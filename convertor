#!/bin/bash
# -*- mode: sh -*-

# convertor - tool for conversion and work DjVu files
#
# Author: Ale≈° Kapica <kapica@fel.cvut.cz>, 2015
#
# Pou≈æit√≠...
# convertor [test] image
#	provede testovac√≠ konverzi pro v≈°echny dostupn√© separaƒçn√≠ algoritmy didjvu
shopt -s extglob

# Changelog
# - o≈°et≈ôena situace, kdy nen√≠ nainstalov√°n ocrodjvu
# - o≈°et≈ôit situaci, kdy soubor neobsahuje ≈æ√°dn√Ω textov√Ω obsah a soubor dsed, ani xml neexistuje
# - mezi kl√≠ƒçov√© operace p≈ôid√°no delete a insert
# - OCR zpracovan√© do samostatn√© funkce
# - v√Ωchoz√≠ algoritmus djvu; testovac√≠ konverze pro v≈°echny algoritmy se
#   provede pouze je-li uveden parametr --test-conversion
# - implementov√°na rotace str√°nky
# - implementov√°ny p≈ôesuny str√°nek (akce fore a back)
# - implementov√°no generov√°n√≠ n√°hled≈Ø do exportu
# - upraveny funkce pro export n√°hled≈Ø a soubor≈Ø textov√© vrstvy
# - implementov√°na akce print pro v√Ωpis metadat

# Otestovat
# - export ze single-page dokumentu
#

# ToDo
# p≈ôepracovat pou≈æit√≠ djvudump na djvm -l (je rychlej≈°√≠..)
# implementovat kontrolu do funkce todjvu, aby nedoch√°zelo k nekontrolovateln√©mu vkl√°d√°n√≠ ji≈æ existuj√≠c√≠ch str√°nek
# - p≈ôidat kontrolu do akce insert na duplicitn√≠ soubory p≈ôi vkl√°d√°n√≠
#   v√≠cestr√°nkov√Ωch DjVu soubor≈Ø. to ov≈°em bude vy≈æadovat samostatnou
#   funkci...
# - dopsat n√°povƒõdu pro akci keywords-unset 
# - dopsat manu√°l pro akci set, argumenty, xmp, atp.
# - implementovat import
# doplnit n√°povƒõdu k rotaci str√°nky (akce rotate)
# opravit volby --algoritmus a --view
NAME="convertor"
[ -d "${HOME}/.config/${NAME}" ] &&	. ${HOME}/.config/${NAME}/* &>>/dev/null

LOG="${LOG=/dev/null}"
XML="${XML=no}"
DPI="${DPI=300}"
DSED="${DSED=no}"
PAGE="${PAGE=no}"
IMG="${IMG=no}"
INDIRECT="${INDIRECT=no}"
FORCE="${FORCE=skip}"
RENAME="no"
EXTENSION=".djvu"
THUMBNAIL="${THUMBNAIL=no}"
INSERTTEXT="${INSERTTEXT=no}"
ALG="${ALG=djvu}"
EXTRACTPAGE="${EXTRACTPAGE=no}"
IMGPAGE="${IMGPAGE=no}"
ALGORITHM="abutaleb bernsen brink djvu niblack otsu sauvola shading-subtraction"

trap '''CHYBA=$? ;
case $CHYBA in
 20) echo "Nen√≠ nainstalov√°n bal√≠k djvu-tools"
 ;;
 21) echo "ERROR: mimetype - tool for detection type of image"
 ;;
 22) echo "ERROR: readlink - tool for detection absolute path of directory"
 ;;
 23) echo "Nen√≠ nainstalov√°n bal√≠k netpbm-sf"
 ;;
 24) "ERROR: imagemagick - tool for image convert is not installed"
 ;;
 31) echo "Nen√≠ nainstalov√°n bal√≠k ocrodjvu, na djvu soubory nelze aplikovat OCR. Buƒèto jej doinstalujte, nebo odstra≈àte z p≈ô√≠kazov√© ≈ô√°dky parametr -o (--ocr)" >> /dev/stderr
 ;;
 32) echo "Pokud m√° p≈ôi operaci zpracovat do DjVu bitmapov√Ω soubor, je t≈ôeba uv√©st na p≈ô√≠kazov√© ≈ô√°dce parametrem -a jak√Ω se m√° pou≈æ√≠t algoritmus. Jak√© parametry lze pou≈æ√≠t se dozv√≠te pokud m√≠sto jm√©na algoritmu nap√≠≈°ete znak ?" >> /dev/stderr
 ;;
 33) NORMDIR=yes
 ;;
esac
[ $NORMDIR ] || rm -rf -- "$TEMPDIR"
exit $CHYBA
''' EXIT

TEMPDIR=$(mktemp -d -p /tmp ${NAME}-XXX) || exit 1

#=== testy z√°vislost√≠ ===
# Dependencies:
#   * feh      ( http://feh.finalrewind.org/ )
#   * exiftool ( http://www.sno.phy.queensu.ca/~phil/exiftool ) in Debian package: libimage-exiftool-perl 
#   * yad      ( http://sourceforge.net/projects/yad-dialog )
REALPATH=$(which realpath)
[ ! ${REALPATH} ] && exit 1
REALPATH="$REALPATH -e "

DIDJVU=$(which didjvu)
[ ! ${DIDJVU} ] && echo 'Nen√≠ nainstalov√°n bal√≠k didjvu, nebude mo≈æn√© aplikovat pokroƒçil√© algoritmy pro separaci pop≈ôed√≠ p≈ôi konverzi do DjVu' >> /dev/stderr && DIDJVU=false
OCRODJVU=$(which ocrodjvu)
[ ! ${OCRODJVU} ] && OCRODJVU=31
DJVIEW=$(which djview)
[ ! ${DJVIEW} ] && echo 'Nen√≠ nainstalov√°n bal√≠k djview, nebude fungovat testovac√≠ zobrazen√≠ djvu.soubor≈Ø' >> /dev/stderr && DJVIEW=false
DDJVU=$(which ddjvu)
[ ! ${DDJVU} ] && exit 20
DJVUTXT=$(which djvutxt)
[ ! ${DJVUTXT} ] && exit 20
DJVUSED=$(which djvused)
[ ! ${DJVUSED} ] && exit 20
DJVUTOXML=$(which djvutoxml)
[ ! ${DJVUTOXML} ] && exit 20
DJVUXMLPARSER=$(which djvuxmlparser)
[ ! ${DJVUXMLPARSER} ] && exit 20
DJVUDUMP=$(which djvudump)
[ ! ${DJVUDUMP} ] && exit 20
DJVMCVT=$(which djvmcvt)
[ ! ${DJVMCVT} ] && exit 20
DJVM=$(which djvm)
[ ! ${DJVM} ] && exit 20
CJB2=$(which cjb2)
[ ! ${CJB2} ] && exit 20
DJVUMAKE=$(which djvumake)
[ ! ${DJVUMAKE} ] && exit 20
#YAD=$(which yad)
#[ ! ${YAD} ] && echo 'Nen√≠ nainstalov√°n bal√≠k yad' && exit 1
MIME=$(which mimetype)
[ ! -x "${MIME}" ] && exit 21
STAT=$(which readlink)
[ ! -x "${STAT}" ] && exit 22
EXIFTOOL=$(which exiftool)
[ ! -x "${EXIFTOOL}" ] && exit 23
TESSERACT=$(which tesseract)
[ ! -x "${TESSERACT}" ] && exit 31


NETPBM=0
PNMSCALE=$(which pnmscale)
[ ! -x "${PNMSCALE}" ] && NETPBM=1
if (( $NETPBM == 0 )); then
    VERSION=($(${PNMSCALE} -version 2>&1 | head -1))
    case ${VERSION[$((${#VERSION[@]} - 1))]} in
	10.0*|9*) echo "WARNING: Version Netpbm pnmacele don't support filters. I must use imagemagick convert" >> /dev/stderr
	    NETPBM=1
	    ;;
	*)  NETPBM=0
	    BMPTOPNM=$(which bmptopnm)
	    [ ! -x "${BMPTOPNM}" ] && exit 23
	    JPEGTOPNM=$(which jpegtopnm)
	    [ ! -x "${JPEGTOPNM}" ] && exit 23
	    GIFTOPNM=$(which giftopnm)
	    [ ! -x "${GIFTOPNM}" ] && exit 23
	    PNGTOPNM=$(which pngtopnm)
	    [ ! -x "${PNGTOPNM}" ] && exit 23
	    PNMTOJPEG=$(which pnmtojpeg)
	    [ ! -x "${PNMTOJPEG}" ] && exit 23
	    TIFFTOPNM=$(which tifftopnm)
	    [ ! -x "${TIFFTOPNM}" ] && exit 23
	    PNMTOPNG=$(which pnmtopng)
	    [ ! -x "${PNMTOPNG}" ] && exit 23
	    PNMTOPLAINPNM=$(which pnmtoplainpnm)
	    [ ! -x "${PNMTOPLAINPNM}" ] && exit 23
	    PPMTOPGM=$(which ppmtopgm)
	    [ ! -x "${PPMTOPGM}" ] && exit 23
	    PGMTOPBM=$(which pgmtopbm)
	    [ ! -x "${PGMTOPBM}" ] && exit 23
	    ;;
    esac
fi
if (( $NETPBM == 1 )) ; then
    CONVERT=$(which convert)
    [ ! -x "${CONVERT}" ] && echo exit 24
fi
#=== konec testu z√°vislost√≠ ===

## Pomocn√© funkce...


function escape_path {
# Zat√≠m nepou≈æit√°
	echo "escape_path $*" >> /dev/stderr
	echo "$*" | sed \
  -e 's/\ /\\\ /g'
}

function log {
	# $1 - z√°va≈ænost hl√°≈°ky
	# $2 - textov√Ω ≈ôetƒõzec..
	# $DEBUG √∫rove≈à logov√°n√≠
	# $LOG - v√Ωstup (default - /dev/null
	case "${1}" in
		1) # Hl√°≈°ky up≈ôes≈àuj√≠c√≠ m√≠sto ve skriptu
		echo "${@:2}" >> ${LOG}
		;;
		0) # Bƒõ≈æn√© hl√°≈°ky
		echo "${1}" >> ${LOG}
		;;
		*)
		;;
	esac
}

function pushd {
    command pushd "$@" > /dev/null
}

function popd {
    command popd "$@" > /dev/null
}

function potvrdit {
    read -r -p "${1:-Opravdu chcete akci prov√©st? [y/N]} " response
    case $response in
        [yY][eE][sS]|[yY]) 
            true
            ;;
        [aA][nN][oO]|[aA]) 
            true
            ;;
        *)
            false
            ;;
    esac
}

function rozvazat {
	# $1 - soubor
	# $2 - adres√°≈ô
	# $3 - indexov√Ω soubor
	echo "rozvazat - $1 - $2 - $3" >> /dev/stderr
	if [ -d "${2}" ] ; then
		if [ -z "${3}" ] ; then
			${DJVMCVT} -i ${1} ${2} index.djvu
		else
			${DJVMCVT} -i ${1} ${2} ${3}
		fi
	fi
}

function setmeta {
	# Funkce pro nastaven√≠ meta atrinut≈Ø
	# $1 - svazek
	# $2 - identifik√°tor, kl√≠ƒçov√© slovo nebo soubor
	# $3 - key
	# $4 - obsah kl√≠ƒçe
	if [ -f ${2} ] ; then
		echo "Importuji atributy ze souboru ${2}" >> /dev/stderr
		${DJVUSED} ${1} -e "set-meta ${2}; save"
	else
		identifypage ${1} ${2}
		local NAMEPAGE=$(identifyname ${1} $?)
		if [ "${NAMEPAGE}" == "" ] ; then
			echo "Neplatn√Ω identifik√°tor str√°nky ${2}" >> /dev/stderr
			exit 12
		fi
		if [ "${3}" == "" ] ; then
			if [ -f ${NAMEPAGE/.djvu/.meta} ] ; then
				echo "Nastavuji kl√≠ƒç $3 do str√°nky $PAGE v souboru $1 s obsahem ${@:4}" >> /dev/stderr
				${DJVUSED} ${1} -e "select ${NAMEPAGE}; set-meta ${NAMEPAGE/.djvu/.meta}; save"
			fi
		else
			${DJVUSED} ${1} -e "select ${NAMEPAGE}; print-meta" > $TEMPDIR/${NAMEPAGE/.djvu/.meta}
			echo "${@:3}" >> $TEMPDIR/${NAMEPAGE/.djvu/.meta}
			${DJVUSED} ${1} -e "select ${NAMEPAGE}; set-meta $TEMPDIR/${NAMEPAGE/.djvu/.meta}; save"
		fi
	fi
}

function printmeta {
	# Funkce pro v√Ωpis meta atribut≈Ø
	# $1 - svazek
	# $2 - identifik√°tor, kl√≠ƒçov√© slovo 'all' nebo atribut
	# $3 - atribut, nebo kl√≠ƒçov√© slovo 'all' (default)
	# nen√≠-li urƒçena str√°nka ani key vyp√≠≈°e pro cel√Ω dokument

	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"

	local CHARSTRING="$2"
	local CHARCOUNT=$((${#CHARSTRING} + 1))
	local CHARPOS=0
	local STRPOS=0
	while [ "${CHARCOUNT}" -gt "0" ] ; do
		case "${CHARSTRING:0:$((${CHARPOS} - ${STRPOS}))}" in
			*.[dD][jJ][vV][uU]) local PAGENAME="${CHARSTRING:0:$((${CHARPOS} - ${STRPOS}))}"
				log 1 "printmeta: Soubor... -${PAGENAME}-"
				local STRPOS="${CHARPOS}"
				local CHARSTRING="${CHARSTRING#${PAGENAME}}"
				log 1 "printmeta: CHARSTRING.. ${CHARSTRING}"
				local CHARCOUNT=$((${#CHARSTRING} + 1))
				log 1 "printmeta: CHARCOUNT.. ${CHARCOUNT}"
			;;
		esac
		local CHARPOS=$((CHARPOS + 1))
		local CHARCOUNT=$((CHARCOUNT - 1))
	done
	if [ -z "${PAGENAME}" ] ; then
		local TEMP=${CHARSTRING##+([[:blank:]])}
		local IDPAGE=${TEMP%%+([[:blank:]])*}
		local CHARSTRING=${TEMP#${IDPAGE}}
		local ATTR=${CHARSTRING##+([[:blank:]])}
		log 1 "printmeta: Meta atrinuty pro str√°nku IDPAGE -${IDPAGE}- parametr ATTR -${ATTR}-"
	else
		local NAMEPAGE=${PAGENAME##+([[:blank:]])}
		local TARGETDIR=${CHARSTRING##+([[:blank:]])}
		log 1 "printmeta: Meta atributy str√°nky NAMEPAGE -${NAMEPAGE}- parametr ATTR -${ATTR}-"
	fi


echo "SOURCE -${SOURCE}- IDPAGE -${IDPAGE}- NAMEPAGE -${NAMEPAGE}- parametr ATTR ${ATTR}" >> /dev/stderr
if [ -z "${NAMEPAGE}" ] ; then
	local PAGE=$(identifyname "${SOURCE}" "${IDPAGE}")
else
	local PAGE=$(identifyname "${SOURCE}" "${NAMEPAGE}")
fi

if [ "${PAGE}" == "" ] ; then
	if [ -z "${IDPAGE}" ] ; then
	echo "Glob√°ln√≠ meta atributy svazku ${FILE} :" >> /dev/stderr
	else
	local ATTR="${IDPAGE}"
	echo "Glob√°n√≠ atribut ${ATTR} svazku ${FILE} :" >> /dev/stderr
	fi
	local METAKEYS=$(${DJVUSED} "${SOURCE}" -e print-meta)
else
	if [ -z "${ATTR}" ] ; then
	echo "Meta atributy str√°nky ${PAGE} ze svazku ${FILE}:" >> /dev/stderr
	else
	local ATTR="${IDPAGE}"
	echo "Meta atribut ${ATTR} str√°nky ${PAGE} ze svazku ${FILE}:" >> /dev/stderr
	fi
	local METAKEYS=$(${DJVUSED} ${SOURCE} -e "select '${PAGE}'; print-meta")
fi

# Zpracov√°n√≠...
	local IFS_BAK=$IFS
	local IFS=$'\n'
	for i in ${METAKEYS} ; do
		if [ "${ATTR}" == "" ] || [ "${ATTR}" == "all" ] ; then
			echo -e "$(echo $i | sed 's/\\/\\0/g')"
		else
			local KEY=$(echo $i | grep "^${ATTR}[[:blank:]]" | sed 's/\\/\\0/g')
			if [ "$KEY" == "" ] ; then
				continue
			else
				echo -e "xxx ${KEY}"
			fi
		fi
	done
	local IFS=$IFS_BAK

exit 0
	if [ "${2}" = "" ] ; then
		echo "Glob√°ln√≠ metadata souboru ${1##*/} :" >> /dev/stderr
		METAKEYS=$(${DJVUSED} ${1} -e print-meta)
		IFS_BAK=$IFS
		IFS=$'\n'
		for i in $METAKEYS ; do
			echo -e $(echo $i | sed 's/\\/\\0/g')
		done
		IFS=$IFS_BAK
	else
		PAGE=$(identifypage "${1}" "${2}")
		local NAMEPAGE=$(identifyname ${1} ${PAGE})
		if [ "${NAMEPAGE}" == "" ] ; then
			if [ "${2}" == "all" ] ; then
				echo "Glob√°ln√≠ metadata souboru ${1##*/} :" >> /dev/stderr
			else
				if [ "${2/[0-9]/}" == "" ] ; then
					lastpage ${1}
					LASTPAGE=$?
					if [ ${2} -gt ${LASTPAGE} ] ; then
						echo "Po≈æadovan√° str√°nka je mimo rozsah souboru ${1##*/}, kter√Ω m√° ${LASTPAGE} a po≈æadovan√° str√°nka se v nƒõm nevyskytuje" >> /dev/stderr
					else
						echo "Glob√°ln√≠ metadata souboru ${1##*/} - atribut ${2}:" >> /dev/stderr
					fi
				else
					echo "Str√°nka ${2} se v souboru ${1##*/} nevyskytuje" >> /dev/stderr
					exit 1
				fi
			fi
			METAKEYS=$(${DJVUSED} ${1} -e "print-meta")
			IFS_BAK=$IFS
			IFS=$'\n'
			for i in $METAKEYS ; do
				if [ "${2}" == "all" ] ; then
					echo -e $(echo $i | sed 's/\\/\\0/g')
				else
					KEY=$(echo $i | grep "^${2}[[:blank:]]" | sed 's/\\/\\0/g')
					if [ "$KEY" == "" ] ; then
						continue
					else
						echo -e $KEY
					fi
				fi
			done
			IFS=$IFS_BAK
		else
			if [ "${3}" == "" ] || [ "${3}" == "all" ] ; then
				echo "Metadata str√°nky ${NAMEPAGE} ( $PAGE ) ze souboru ${1##*/} :" >> /dev/stderr
			else
				echo "Metadata str√°nky ${NAMEPAGE} ( $PAGE ) ze souboru ${1##*/} - atribut ${3}:" >> /dev/stderr
			fi
			METAKEYS=$(${DJVUSED} ${1} -e "select ${NAMEPAGE}; print-meta")
			IFS_BAK=$IFS
			IFS=$'\n'
			for i in $METAKEYS ; do
				if [ "${3}" == "" ] || [ "${3}" == "all" ] ; then
					echo -e $(echo $i | sed 's/\\/\\0/g')
				else
					KEY=$(echo $i | grep "^${3}[[:blank:]]" | sed 's/\\/\\0/g')
					if [ "$KEY" == "" ] ; then
						continue
					else
						echo -e $KEY
					fi
				fi
			done
			IFS=$IFS_BAK
		fi
	fi
}

function unsetmeta {
	# Funkce pro odstranƒõn√≠ meta atributu
	# $1 - svazek
	# $2 - identifik√°tor, kl√≠ƒçov√© slovo nebo soubor
	# $3 - key
	identifypage ${1} ${2}
	local NAMEPAGE=$(identifyname ${1} $?)
	if [ "${NAMEPAGE}" == "" ] ; then
		echo "Odstra≈àuji glob√°ln√≠ atribut.."
		${DJVUSED} ${1} -e "print-meta" > ${TEMPDIR}/${1/.djvu/.temp}
		grep -v "^$2[[:blank:]]" ${TEMPDIR}/${1/.djvu/.temp} >> $TEMPDIR/${1/.djvu/.meta}
		potvrdit && ${DJVUSED} ${1} -e "set-meta $TEMPDIR/${1/.djvu/.meta}; save"
	elif [ "${3}" == "" ] ; then
		echo "Odstra≈àuji v≈°echny meta informace ze str√°nky.."
		potvrdit && ${DJVUSED} ${1} -e "select ${NAMEPAGE}; remove-meta; save"
	elif [ "${2}" == "global" ] ; then
		echo "Odstra≈àuji v≈°echny glob√°ln√≠ meta informace.."
		potvrdit && ${DJVUSED} ${1} -e "remove-meta; save"
	else
		echo "Odstra≈àuji atribut ${3} z meta informac√≠ str√°nky ${NAMEPAGE}"
		echo "$1 - $2 - $3 - $NAMEPAGE"
		${DJVUSED} ${1} -e "select ${NAMEPAGE}; print-meta" > ${TEMPDIR}/${NAMEPAGE/.djvu/.temp}
		grep -v "^$3[[:blank:]]" ${TEMPDIR}/${NAMEPAGE/.djvu/.temp} >> ${TEMPDIR}/${NAMEPAGE/.djvu/.meta}
		potvrdit && ${DJVUSED} ${1} -e "select ${NAMEPAGE}; set-meta $TEMPDIR/${NAMEPAGE/.djvu/.meta}; save"
	fi
	exit 33
}

function export {
	# $1 - DjVu file
	# $2 - identifik√°tor + c√≠lov√Ω adres√°≈ô
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"

	# Parsing $2
	local CHARSTRING="$2"
	local CHARCOUNT=$((${#CHARSTRING} + 1))
	local CHARPOS=0
	local STRPOS=0
	while [ "${CHARCOUNT}" -gt "0" ] ; do
		case "${CHARSTRING:0:$((${CHARPOS} - ${STRPOS}))}" in
			*.[dD][jJ][vV][uU]) local PAGENAME="${CHARSTRING:0:$((${CHARPOS} - ${STRPOS}))}"
				local STRPOS="${CHARPOS}"
				local CHARSTRING="${CHARSTRING#${PAGENAME}}"
				local CHARCOUNT=$((${#CHARSTRING} + 1))
			;;
		esac
		local CHARPOS=$((CHARPOS + 1))
		local CHARCOUNT=$((CHARCOUNT - 1))
	done

	if [  -z "${CHARSTRING}" ] ; then
		if [ -z "${PAGENAME}" ] ; then
			log 1 "export: Export all pages from ${FILE} into aktual directory - do set TARGETDIR"
			local TARGETDIR=$(targetdir $(pwd))
			exportdjvuall "${SOURCE}" "${TARGETDIR}"
			return 0
		else
			log 1 "export: Export page identificated by ${PAGENAME} from ${FILE} into aktual directory - do set TARGETDIR"
			local IDPAGE=$(identifypage "${SOURCE}" "${PAGENAME}")
			[ -z "${IDPAGE}" ] && echo "export: In ${FILE} is not any page identificated by ${PAGENAME}"  >> /dev/stderr &&  exit 1
			local NAMEPAGE=$(identifyname "${SOURCE}" "${PAGENAME}")
			local TARGETDIR=$(targetdir $(pwd))
		fi
	else
		if [ -z "${PAGENAME}" ] ; then
			local TEMP=${CHARSTRING##+([[:blank:]])}
			local IDPAGE=${TEMP%%+([[:blank:]])*}
			local CHARSTRING=${TEMP#${IDPAGE}}
			local TARGETDIR=${CHARSTRING##+([[:blank:]])}
			# Tady m≈Ø≈æe b√Ωt nƒõjak√Ω jin√Ω parametr, ne≈æ po≈ôadov√© ƒç√≠slo, a tak√© TARGETDIR m≈Ø≈æe b√Ωt pr√°zdn√Ω.
			if [ "${IDPAGE}" == "all" ] ; then
				if [ -z "${TARGETDIR}" ] ; then
					log 1 "export: Export all pages from ${FILE} into actual directory - do set TARGETDIR"
					local TARGETDIR=$(targetdir $(pwd))
					exportdjvuall "${SOURCE}" "${TARGETDIR}"
					return 0
				else
					log 1 "export: Export all pages from ${FILE} into ${TARGETDIR}"
					local TARGETDIR=$(targetdir "${TARGETDIR}")
					exportdjvuall "${SOURCE}" "${TARGETDIR}"
					return 0
				fi
			else
				log 1 "export: Export page identificated by order -${IDPAGE}- from ${FILE} into -${TARGETDIR}-"
				local NAMEPAGE=$(identifyname "${SOURCE}" "${IDPAGE}")
				[ -z "${NAMEPAGE}" ] && echo "export: In ${FILE} is not any page on position ${IDPAGE}"  >> /dev/stderr &&  exit 1
				local TARGETDIR=$(targetdir "${TARGETDIR}")
			fi
		else
			local NAMEPAGE=${PAGENAME##+([[:blank:]])}
			local TARGETDIR=${CHARSTRING##+([[:blank:]])}
			log 1 "export: Export page identificated by name -${NAMEPAGE}- from ${FILE} into -${TARGETDIR}-"
			local IDPAGE=$(identifypage "${SOURCE}" "${NAMEPAGE}")
			[ -z "${IDPAGE}" ] && echo "export: In ${FILE} is not any page with name ${NAMEPAGE}" >> /dev/stderr &&  exit 1
			local TARGETDIR=$(targetdir "${TARGETDIR}")
		fi
	fi

#	echo "export: SOURCE ${SOURCE}">> /dev/stderr
#	echo "export: FILE ${FILE}">> /dev/stderr
#	echo "export: IDPAGE ${ODPAGE}">> /dev/stderr
#	echo "export: NAMEPAGE ${NAMEPAGE}">> /dev/stderr
#	echo "export: TARGETDIR ${TARGETDIR}">> /dev/stderr
#	echo "export: FORCE ${FORCE}">> /dev/stderr
	[ "${PAGE}" != "no" ] && exportdjvupage "${SOURCE}" "${NAMEPAGE}" "${TARGETDIR}" || echo "export: For export page in DjVu format we must use option -p" >> /dev/stderr
	[ "${DSED}" != "no" ] && exportdsedpage "${SOURCE}" "${NAMEPAGE}" "${TARGETDIR}" || echo "export: For export text content from DjVu page in dsed format we must use option -d" >> /dev/stderr
	[ "${XML}" != "no" ] && exportxmlpage "${SOURCE}" "${NAMEPAGE}" "${TARGETDIR}" || echo "export: For export hidden text layer of pages from DjVu bundle in XML format we must use option -x" >> /dev/stderr
	[ "${IMG}" != "no" ] && exportimgpage "${SOURCE}" "${NAMEPAGE}" "${TARGETDIR}" || echo "export: For export image of page from DjVu bundle we must use option -i" >> /dev/stderr
}

function exportdjvuall {
	# $1 - DjVu file - full path
	# $2 - targetdir - full path
	[ "${PAGE}" != "no" ] || echo "exportdjvuall: For export pages in DjVu format we must use option -p" >> /dev/stderr
	[ "${DSED}" != "no" ] || echo "exportdjvuall: For export hidden text layer of pages from DjVu bundle in dsed format we must use option -d" >> /dev/stderr
	[ "${XML}" != "no" ] || echo "exportdjvuall: For export hidden text layer of pages from DjVu bundle in XML format we must use option -x" >> /dev/stderr
	[ "${IMG}" != "no" ] || echo "exportdjvuall: For export image of page from DjVu bundle we must use option -i" >> /dev/stderr
	local PAGES=$(lastpage "${SOURCE}")
	local NUMPAGE=1
	while [ ${PAGES} -gt "0" ] ; do
		local NAMEPAGE=$(identifyname "${SOURCE}" "${NUMPAGE}")
		log 1 "exportdjvuall: Exportuji str√°nku ${NAMEPAGE}"
		exportdjvupage "${1}" "${NAMEPAGE}" "${2}"
		exportdsedpage "${1}" "${NAMEPAGE}" "${2}"
		exportxmlpage "${1}" "${NAMEPAGE}" "${2}"
		exportimgpage "${1}" "${NAMEPAGE}" "${2}"
		local NUMPAGE=$((NUMPAGE + 1))
		local PAGES=$((PAGES - 1))
	done
	exportdsedbundle "${1}" "${2}"
	exportxmlbundle "${1}" "${2}"
}

function exportdsedbundle {
	# $1 - DjVu file - full path
	# $2 - targetdir - full path
	local FILE="${1##*/}"
	pushd "${2}"
	case "${DSED}" in
		yes|all) local EXPORT="output-all"
		;;
		txt) local EXPORT="output-txt"
		;;
		ant) local EXPORT="output-ant"
		;;
		no) return 0
		;;
	esac
	if [ "${DSED}" != "no" ] ; then
		local TARGET="${FILE/.djvu/.dsed}"
		if [ -f "${TARGET}" ] ; then
			if [ "${FORCE}" == "yes" ] ; then
				${DJVUSED} "${1}" -e "${EXPORT}" > "${TARGET}"
			elif [ "${FORCE}" == "skip" ] ; then
				log 1 "exportdsedbundle: Soubor ${TARGET} ji≈æ v adres√°≈ôi ${3} existuje."
			else
				echo "exportdsedbundle: Soubor ${TARGET} ji≈æ v adres√°≈ôi ${3} existuje.." >> /dev/stderr
				potvrdit && ${DJVUSED} "${1}" -e "${EXPORT}" > "${TARGET}"
			fi
		else
			${DJVUSED} "${1}" -e "${EXPORT}" > "${TARGET}"
		fi
	fi
	popd
}

function exportxmlbundle {
	# $1 - DjVu file - full path
	# $2 - targetdir - full path
	local FILE="${1##*/}"
	pushd "${2}"
	case "${XML}" in
		yes|all) local EXPORT="--with-text --with-anno"
		;;
		txt) local EXPORT="--with-text --without-anno"
		;;
		ant) local EXPORT="--without-text --with-anno"
		;;
		no) return 0
		;;
	esac
	if [ "${XML}" != "no" ] ; then
		local TARGET="${FILE/.djvu/.xml}"
		if [ -f "${TARGET}" ] ; then
			if [ "${FORCE}" == "yes" ] ; then
				${DJVUTOXML} "${1}" "${TARGET}"
			elif [ "${FORCE}" == "skip" ] ; then
				log 1 "exportxmlbundle: Soubor ${TARGET} ji≈æ v adres√°≈ôi ${3} existuje."
			else
				echo "exportxmlbundle: Soubor ${TARGET} ji≈æ v adres√°≈ôi ${3} existuje.." >> /dev/stderr
				potvrdit && ${DJVUTOXML} "${1}" "${TARGET}"
			fi
		else
			${DJVUTOXML} "${1}" "${TARGET}"
		fi
	fi
	popd
}

function exportimgpage {
	# $1 - DjVu file - full path
	# $2 - identificator - page name
	# $3 - targetdir - full path
	pushd "${3}"
	case "${IMG}" in
		yes) local EXPORT="-mode=color"
		;;
		color|black|foreground|background|mask) local EXPORT="-mode=${IMG}"
		;;
		no) return 0
		;;
	esac
	if [ "${IMG}" != "no" ] ; then
		local PAGE=$(identifypage "${1}" "${2}")
		local TARGET="${2/.djvu/.png}"
		if [ -f "${TARGET}" ] ; then
			if [ "${FORCE}" == "yes" ] ; then
				${DDJVU} -format=pnm "${EXPORT}" -page="${PAGE}" "${1}" | ${PNMTOPNG} > "${TARGET}"
			elif [ "${FORCE}" == "skip" ] ; then
				log 1 "exportimgpage: Soubor ${TARGET} ji≈æ v adres√°≈ôi ${3} existuje."
			else
				echo "exportimgpage: Soubor ${TARGET} ji≈æ v adres√°≈ôi ${3} existuje.." >> /dev/stderr
				potvrdit && ${DDJVU} -format=pnm "${EXPORT}" -page="${PAGE}" "${1}" | ${PNMTOPNG} > "${TARGET}"
			fi
		else
			${DDJVU} -format=pnm "${EXPORT}" -page="${PAGE}" "${1}" | ${PNMTOPNG} > "${TARGET}"
		fi
	fi
	popd
}

function exportxmlpage {
	# $1 - DjVu file - full path
	# $2 - identificator - page name
	# $3 - targetdir - full path
	pushd "${3}"
	case "${XML}" in
		yes|all) local EXPORT="--with-text --with-anno"
		;;
		txt) local EXPORT="--with-text --without-anno"
		;;
		ant) local EXPORT="--without-text --with-anno"
		;;
		no) return 0
		;;
	esac
	if [ "${XML}" != "no" ] ; then
		local PAGE=$(identifypage "${1}" "${2}")
		local TARGET="${2/.djvu/.xml}"
		if [ -f "${TARGET}" ] ; then
			if [ "${FORCE}" == "yes" ] ; then
				${DJVUTOXML} --page "${PAGE}" ${EXPORT} "${1}" "${TARGET}"
			elif [ "${FORCE}" == "skip" ] ; then
				log 1 "Soubor ${TARGET} ji≈æ v adres√°≈ôi ${3} existuje."
			else
				echo "Soubor ${TARGET} ji≈æ v adres√°≈ôi ${3} existuje.." >> /dev/stderr
				potvrdit && ${DJVUTOXML} --page "${PAGE}" ${EXPORT} "${1}" "${TARGET}"
			fi
		else
			${DJVUTOXML} --page "${PAGE}" ${EXPORT} "${1}" "${TARGET}"
		fi
	fi
	popd
}

function exportdsedpage {
	# $1 - DjVu file - full path
	# $2 - identificator - page name
	# $3 - targetdir - full path
	pushd "${3}"
	case "${DSED}" in
		yes|all) local EXPORT="output-all"
		;;
		txt) local EXPORT="output-txt"
		;;
		ant) local EXPORT="output-ant"
		;;
		no) return 0
		;;
	esac
	if [ "${DSED}" != "no" ] ; then
		local TARGET="${2/.djvu/.dsed}"
		if [ -f "${TARGET}" ] ; then
			if [ "${FORCE}" == "yes" ] ; then
				${DJVUSED} "${1}" -e "select '${2}'; ${EXPORT}" > "${TARGET}"
			elif [ "${FORCE}" == "skip" ] ; then
				log 1 "Soubor ${TARGET} ji≈æ v adres√°≈ôi ${3} existuje."
			else
				echo "Soubor ${TARGET} ji≈æ v adres√°≈ôi ${3} existuje.." >> /dev/stderr
				potvrdit && ${DJVUSED} "${1}" -e "select '${2}'; ${EXPORT}" > "${TARGET}"
			fi
		else
			${DJVUSED} "${1}" -e "select '${2}'; ${EXPORT}" > "${TARGET}"
		fi
	fi
	popd
}

function exportdjvupage {
	# $1 - DjVu file - full path
	# $2 - identificator - page name
	# $3 - targetdir - full path
	pushd "${3}"
	if [ "${PAGE}" == "yes" ] ; then
		if [ -f "${2}" ] ; then
			if [ "${FORCE}" == "yes" ] ; then
				${DJVUSED} -e "select '${2}'; save-page-with '${2}'" "${1}"
			elif [ "${FORCE}" == "skip" ] ; then
				log 1 "Soubor ${2} ji≈æ v adres√°≈ôi ${3} existuje."
			else
				echo "Soubor ${2} ji≈æ v adres√°≈ôi ${3} existuje.." >> /dev/stderr
				potvrdit && ${DJVUSED} -e "select '${2}'; save-page-with '${2}'" "${1}"
			fi
		else
			${DJVUSED} -e "select '${2}'; save-page-with '${2}'" "${1}"
		fi
	fi
	popd
}

function inserttext {
	if [ -f ${1/.djvu/.xml} ] ; then
		${DJVUXMLPARSER} -o ${1} ${1/.djvu/.xml}
	elif [ -f ${1/.djvu/.dsed} ] ; then
		${DJVUSED} ${1} -f ${1/.djvu/.dsed} -s
	fi
}

function insertxmp {
	if [ -f ${1/.djvu/.xmp} ] ; then
		echo "Vkl√°d√°m xmp informace, pokud jsou.."
	fi
}

function konvertor {
	# $1 - vstup
	# $2 - v√Ωstup
	# je-li na vstupu djvu provede pouze operace spojen√© s vyexportov√°n√≠m XML, DSED a n√°hledu v png
	# je-li na vstupu nƒõco jin√©ho ne≈æ png, djvu, dsed, xml, mng, tiff, xcf ƒçi pdf  ovƒõ≈ô√≠ zda-li jde o obr√°zek
	if [ -f "$1" ] ; then
		if [ "${1##*.}" == "djvu" ] ; then
			FROM="$1"
		else
			# konverze a v√Ωsledek bude ve from..
			# SEPARATE - rozdƒõlen√≠ na vrstvy  yes (default) | no
			# DPI - 300 (default)
			# ALG
			todjvu "$1" "$2"
			if [ "$?" !=  "0" ]  ; then
				exit 40
			fi
		fi
		if [ -f "$2" ] && [ "${TEST}" != "yes" ]; then
			if [ ${DSED} == "yes" ] ; then
				if [ -f "${2/.djvu/.dsed}" ] ; then
					if [ ${FORCE} != "no" ] ; then
						rm ${2/.djvu/.dsed}
						exportdsed ${2}
					fi
				else
					exportdsed ${2}
				fi
			fi
			if [ ${XML} == "yes" ] ; then
				if [ -f "${2/.djvu/.xml}" ] ; then
					if [ ${FORCE} != "no" ] ; then
						# exportuji textovou vrstvu v xml, pouze pokud neexistuje, nebo je-li uveden parametr -f (--force)
						# XML ve v√Ωchoz√≠m stavu exportuje jak text tak hyperlinky. Neexportuje v≈°echna metadata!!!
						rm ${2/.djvu/.xml}
						exportxml ${2}
					fi
				else
					exportxml ${2}
				fi
			fi
			if [ ${IMGPAGE} == "yes" ] ; then
				exportimg ${2}
			fi
			if [ ${INSERTTEXT} == "yes" ] && [ ${#OCR} != "3" ] ; then
				inserttext ${2}
			elif [ ! ${OCR} ] ; then
				inserttext ${2}
			fi
		fi
	fi
}

function getocr {
	# $1 - jm√©no djvu souboru 
	if [ "${OCR}" ] ; then
		[ "${OCRODJVU%%+([0-9])}" == "" ] && exit ${OCRODJVU} || ${OCRODJVU} --in-place -l ${OCR} "$1"
	fi
}

function testfile {
	# Function return type file by MIME
	# $1 - file
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	if [ -f "${SOURCE}" ] ; then
		local TYPE=$(${MIME} -dbM "${SOURCE}" | awk '{print $1}')
	else
		log 1 "testfile: File ${1} is NOT valid."
		exit 1
	fi
	echo "${TYPE,,}"
}

function targetdir {
	# Function return path into existing directory
	# $1 - path
	if [ -z "${1}" ] ; then
		log 1 "targetdir: NOT PATH"
		exit 1
	else
		local TARGETDIR=$(${REALPATH} -m -P "${1}")
		if [ -d "${TARGETDIR}" ] ; then
			echo -n "${TARGETDIR}"
		else
			mkdir -p "${TARGETDIR}"
			if [ $? -gt "0" ] ; then
				log 1 "targetdir: Could not create target directory ${TARGETDIR}"
				exit 1
			else
				echo -n "${TARGETDIR}"
			fi
		fi
	fi
}

function identifybundle {
	# Function testing DjVu file if is (0) or not (1) bundle
	# $1 - DjVu file
	# WARNING: Use ${DJVUDUMP} is necessary!
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	if [ -z "${SOURCE}" ] ; then
		log 1 "identifybundle: Path ${1} is not valid."
		exit 1
	else
		if [ $(testfile "${SOURCE}") == "djvu" ] ; then
			local TEST=$(${DJVUDUMP} "${SOURCE}" | grep '^\([[:blank:]]*\)DIRM')
			if [ "${TEST}" == "" ] ; then
				log 1 "identifybundle: ${FILE} is DjVu file"
				return 0
			else
				log 1 "identifybundle: ${FILE} is DjVu bundle"
				return 1
			fi
		else
			log 1 "identifybundle: File ${FILE} is NOT DjVu file."
			exit 1
		fi
	fi
}

function identifyname {
	# Function return NAME of DjVu page in DjVu bundle
	# $1 DjVu Bundle
	# $2 Page identificator (order or name)
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	local IDENTIFICATOR="${2##+([[:blank:]])}"
	if [ "${IDENTIFICATOR//+([[:digit:]])}" == "" ] ; then
		log 1 "identifyname: Is any page on position ${IDENTIFICATOR} in DjVu file ${FILE}?"
		local SEARCH="\[P${IDENTIFICATOR}\]"
	else
		log 1 "identifyname: Is page with name ${IDENTIFICATOR} in DjVu file ${FILE}?"
		local SEARCH="\{${IDENTIFICATOR}\}"
	fi
	local OUTPUT=$(${DJVUSED} "${SOURCE}" -e dump | grep FORM:DJVU | grep "${SEARCH}" | awk -F'[{}]' '{print $2}')
	if [ -z "${OUTPUT}" ] ; then
		log 1 "identifyname: Page identificator ${IDENTIFICATOR} is NOT VALID for DjVu bundle ${FILE}."
		return 0
	else
		echo -n "${OUTPUT}"
	fi
}

function identifypage {
	# Function return DjVu page actual ORDER in DjVu bundle
	# $1 DjVu Bundle
	# $2 Page identificator (order or name)
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	local IDENTIFICATOR="${2##+([[:blank:]])}"
	if [ "${IDENTIFICATOR//+([[:digit:]])}" == "" ] ; then
		log 1 "identifypage: Is any page on position ${IDENTIFICATOR} in DjVu bundle ${FILE}?"
		local SEARCH="\[P${IDENTIFICATOR}\]"
	else
		log 1 "identifypage: Is page with name ${IDENTIFICATOR} in ${FILE} bundle?"
		local SEARCH="\{${IDENTIFICATOR}\}"
	fi
	local OUTPUT=$(${DJVUSED} "${SOURCE}" -e dump | grep FORM:DJVU | grep "${SEARCH}" | awk -F'[{}]' '{print $3}')
	if [ -z "${OUTPUT}" ] ; then
		log 1 "identifypage: Page identificator ${IDENTIFICATOR} is NOT VALID for DjVu bundle ${FILE}."
		return 0
	else
		local ORDER="${OUTPUT//+([\]P\[ ])/}"
		echo -n "${ORDER}"
	fi
}

function lastpage {
	# Function return count of all pages in DjVu bundle
	# $1 DjVu file
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	[ "$(testfile ${SOURCE})" == "djvu" ] || exit 1
	log 1 "lastpage: Count of all pages in ${FILE}"
	local OUTPUT=$(${DJVUSED} "${SOURCE}" -e dump | grep FORM:DJVU | wc -l)
	echo -n "${OUTPUT}"
}

function insertpage {
	# $1 - soubor se kter√Ωm se pracuje
	# $2 - djvu soubor co se m√° vlo≈æit
	# $3 - identifik√°tor str√°nky p≈ôed kterou se m√° vlo≈æit
	log 1 "insertpage: ${@}"
	[ "$(testfile ${1})" == "djvu" ] || exit 1
	case "${#@}" in
		3) # soubor str√°nka a pozice
			log 1 "insertpage: M√°m soubor $1 str√°nku $2 i c√≠lovou pozici.. $3"
			if [ "$(testfile ${2})" == "djvu" ] ; then
				local P=$(identifypage ${1} ${3})
				log 1 "insertpage: P $P"
				if [ -z  "${P}" ] ; then
					echo "insertpage: Identifik√°tor $3 je neplatn√Ω" >> /dev/stderr
					exit 1
				else
					log 1 "insertpage: Vkl√°d√°m ${1} ${2} ${P}"
					${DJVM} -i ${1} ${2} ${P}
				fi
			else
				echo "insertpage: Parametr $2 nen√≠ platn√Ω soubor"
				exit 1
			fi
		;;
		2) # soubor a str√°nka
			if [ "$(testfile ${2})" == "djvu" ] ; then
				log 1 "insertpage: Vkl√°d√°m ${1} ${2}"
				local BMAX=$(lastpage ${2})
				if [ -z "${BMAX}" ] ; then
					log 1 "insertpage: Soubor ${2} nen√≠ svazek"
					local AMAX=$(lastpage ${1})
					if [ -z "${AMAX}" ] ; then
						echo "Soubor $1 zat√≠m nen√≠ DjVU svazek" >> /dev/stderr
						exit 0
					else
						log 1 "insertpage: Soubor $1 je DjVU svazek a m√° ${AMAX} stran"
						while [ "${AMAX}" -gt "0" ] ; do
							log 1 "Zpracov√°v√°m stranu ${AMAX} - ${2##*/}"
							local NAMEPAGE=$(identifypage ${1} ${2##*/})
							if [ -z "${NAMEPAGE}" ] ; then
								log 1 "Str√°nka ${2##*/} v souboru ${1} je≈°tƒõ nen√≠"
							else
								echo "Jedna str√°nka s n√°zvem ${NAMEPAGE} se ji≈æ v souboru ${1} nal√©z√°. P≈ôi vlo≈æen√≠ se ke jm√©nu vkl√°dan√© str√°nky p≈ôid√° po≈ôadov√© ƒç√≠slo. Chcete pokraƒçovat ve vkl√°d√°n√≠?" >> /dev/stderr
								potvrdit && break || exit 0
							fi
							AMAX=$((AMAX -1 ))
						done
						${DJVM} -i ${1} ${2}
					fi
				else
					local AMAX=$(lastpage ${1})
					if [ -z "${AMAX}" ] ; then
						echo "Soubor ${1} nem√° ≈æ√°dn√© str√°nky." >> /dev/stderr
#xxxxxxxx vytvo≈ôen√≠ svazku ze souboru 
# 1, ≈†oupnout str√°nku do doƒçasn√©ho adres√°≈ôe
# 2, A na jej√≠m m√≠stƒõ vytvo≈ôit stejnojmenn√Ω svazek
# 3, Pak ≈°oupnout ty dal≈°√≠ str√°nky
						potvrdit || exit 0
					else
						while [ "${BMAX}" -gt "0" ] ; do
							local NAMEPAGE=$(identifyname ${1} ${BMAX})
							if [ ! -z "${NAMEPAGE}" ] ; then
								if [ ! $(identifyname ${2} ${NAMEPAGE}) ] ; then
									echo "Str√°nka s n√°zvem ${NAMEPAGE}, kter√° je souƒç√°st√≠ souboru ${2} se ji≈æ v souboru ${1} nal√©z√°. Chcete pokraƒçovat ve vkl√°d√°n√≠?" >> /dev/stderr
									potvrdit && break || exit 0
								fi
							fi
							BMAX=$((BMAX -1 ))
						done
							echo "Soubor $2, kter√Ω se chyst√°te vlo≈æit do souboru $1 je v√≠cestr√°nkov√Ω DjVu soubor." >> /dev/stderr
							potvrdit && ${DJVM} -i ${1} ${2}
					fi
				fi
			fi
		;;
	esac
}

function deletepage {
	# REVIZE NUTN√Å!!!
	# $1 - soubor se kter√Ωm se pracuje
	# $2 - ƒç√≠slo, nebo n√°zev strany co se m√° odstranit
	local P=$(identifypage ${1} ${2})
	PAGE=$P
#	echo "deletepage: Str√°nka m√° aktu√°lnƒõ po≈ôadov√© ƒç√≠slo $PAGE" >> /dev/stderr
	if [ ! -z "${PAGE}" ] ; then
#		echo "deletepage: Odstra≈àuji str√°nku $2 - $PAGE ze souboru ${1}"  >> /dev/stderr
		${DJVM} -d ${1} ${PAGE}
#		echo "deletepage: Odstranƒõna str√°nka $2 - $PAGE - $?"  >> /dev/stderr
	else
		echo "Str√°nka $2 v souboru nen√≠. Nezapome≈àte, ≈æe konvertovan√©mu souboru se mƒõn√≠ p≈ô√≠pona!!"
		exit 1
	fi
}

function rotatepage {
	# $1 - soubor se kter√Ωm se pracuje
	# $2 - ƒç√≠slo, nebo n√°zev strany kter√° se m√° rotovat
	# $3 - hodnota rotace
#	echo "$*" >> /dev/stderr
	local INFO="""
Uvedenou hodnotu rotace nelze akceptovat. Rotaci lze nastavit buƒè 
absolutnƒõ, a nebo relativnƒõ (pootoƒçit o 90¬∞). AKceptovan√© hodnoty:

      0 - v√Ωchoz√≠ pozice
      1 - natoƒçen√≠ vpravo
      2 - otoƒçen√≠  vzh≈Øru nohama
      3 - natoƒçen√≠ vlevo
   left - rotace smƒõrem doleva
  right - rotace smƒõrem doprava).
    180 - p≈ôetoƒçen√≠ o 180¬∞

Ka≈æd√° jin√° hodnota parametru je ignorov√°na."""
	local PARAMS=($2)
	if [ "${#PARAMS[@]}" -gt "1" ] ; then
		case "${PARAMS[$((${#PARAMS[@]} -1))]}" in
			0|1|2|3|180|left|right) # echo "Jak m√°m ot√°ƒçet $1" >> /dev/stderr
				local ROTATE="${PARAMS[$((${#PARAMS[@]} -1))]}"
#				echo "rotatepage: p≈ôed o≈ôez√°n√≠m -$2-"
				local TEMP="${2% ${ROTATE}}"
				local IDPAGE=${TEMP##+([[:blank:]])}
#				echo "rotatepage: po o≈ôez√°n√≠ -${IDPAGE}-"
			;;
			*) echo "Neplatn√Ω parametr rotace - ${2}" >> /dev/stderr
				exit 1
			;;
		esac
	else
#		echo "Rotuji dokument glob√°lnƒõ.. ${PARAMS}" >> /dev/stderr
		case "${PARAMS}" in
			0|1|2|3|180|left|right) #  echo "Jak m√°m ot√°ƒçet $1" >> /dev/stderr
				local ROTATE="${PARAMS}"
			;;
			*) echo "Neplatn√Ω parametr rotace - ${PARAMS}" >> /dev/stderr
				exit 1
			;;
		esac
	fi
#	echo "rotatepage: ${IDPAGE} - ${ROTATE}" >> /dev/stderr

	local BUNDLE=$(djvuinfo "${1}")
	if [ "${BUNDLE}" == "none" ] ; then
		if [ -z "${IDPAGE}" ] ; then
			case "${ROTATE}" in
				0|1|2|3)  ${DJVUSED} -e "set-rotation ${ROTATE}; save" "${1}"
				;;
				left) ${DJVUSED} -e "set-rotation +1; save" "${1}"
				;;
				right) ${DJVUSED} -e "set-rotation -1; save" "${1}"
				;;
				180) ${DJVUSED} -e "set-rotation +2; save" "${1}"
				;;
				*) echo "${INFO}" >> /dev/stderr
				;;
			esac
		else
			echo "Dokument je typu DjVu single page. Parametr ${IDPAGE} nem√° v√Ωznam, chcete pokraƒçovat v rotaci?" >> /dev/stderr
			if $(potvrdit) ; then
				case "${ROTATE}" in
					0|1|2|3)  ${DJVUSED} -e "set-rotation ${ROTATE}; save" "${1}"
					;;
					left) ${DJVUSED} -e "set-rotation +1; save" "${1}"
					;;
					right) ${DJVUSED} -e "set-rotation -1; save" "${1}"
					;;
					180) ${DJVUSED} -e "set-rotation +2; save" "${1}"
					;;
					*) echo "${INFO}" >> /dev/stderr
					;;
				esac
			else
				exit 0
			fi
		fi
	else
		if [ -z "${IDPAGE}" ] ; then
			echo "P≈ôi glob√°ln√≠m natoƒçen√≠ str√°nek dokumentu d√°vejte pozor, zda-li nastavujete absolutn√≠ hodnotu natoƒçen√≠, nebo, zda-li ot√°ƒç√≠te str√°nky relativnƒõ (left/right). P≈ôi toƒçen√≠ se upravuje natoƒçen√≠ v≈°ech str√°nek. Buƒète tedy p≈ôi t√©to operaci opatrn√≠ a radƒõji si p≈ôedem zkontrolujte, zda-li t√≠m neovlivn√≠te i nƒõkterou ze str√°nek. Pokud ano, pak zvolte bu≈• relativn√≠ parametr natoƒçen√≠, nebo ji pak otoƒçte do spr√°vn√© pozice dodateƒçnƒõ."
			if $(potvrdit) ; then
				case "${ROTATE}" in
					0|1|2|3)  ${DJVUSED} -e "set-rotation ${ROTATE}; save" "${1}"
					;;
					left) ${DJVUSED} -e "set-rotation +1; save" "${1}"
					;;
					right) ${DJVUSED} -e "set-rotation -1; save" "${1}"
					;;
					180) ${DJVUSED} -e "set-rotation +2; save" "${1}"
					;;
					*) echo "${INFO}" >> /dev/stderr
					;;
				esac
			else
				exit 0
			fi
		else
#			echo "Je t≈ôeba prov√©st identifikaci str√°nky ${IDPAGE}"
			local NAMEPAGE=$(identifyname "${1}" "${IDPAGE}")
			if [ -z "${NAMEPAGE}" ] ; then
				echo "Str√°nka ${IDPAGE} ve svazku ${1} nen√≠" >> /dev/stderr
				exit 1
			else
				log 1 "Ot√°ƒç√≠m str√°nku ${NAMEPAGE}"
				case "${ROTATE}" in
					0|1|2|3)  ${DJVUSED} -e "select '${NAMEPAGE}'; set-rotation ${ROTATE}; save" "${1}"
					;;
					left) ${DJVUSED} -e "select '${NAMEPAGE}'; set-rotation +1; save" "${1}"
					;;
					right) ${DJVUSED} -e "select '${NAMEPAGE}'; set-rotation -1; save" "${1}"
					;;
					180) ${DJVUSED} -e "select '${NAMEPAGE}'; set-rotation +2; save" "${1}"
					;;
					*) echo "${INFO}" >> /dev/stderr
					;;
			esac
			fi
		fi
	fi
}

function forwardpage {
	# $1 - soubor
	# $2 - str√°nka k p≈ôesunu
	# $3 - pozice k p≈ôesunu
	local BORDER=$(identifypage $1 $3)
	if [ -z "${BORDER}" ] ; then
#		echo "Pouze se posouv√°, pokud nejde o kl√≠ƒçov√© slovo.."
		case "${3}" in
			end) # P≈ôesun na p≈ôedposledn√≠ pozici
				echo "ToDo" >> /dev/stderr && exit 0
			;;
			begin) # P≈ôesun na zaƒç√°tek souboru
				echo "ToDo" >> /dev/stderr && exit 0
			;;
			*) local AORDER=$(identifypage $1 $2)
				if [ -z "${AORDER}" ] ; then
					echo "Str√°nka $2 v souboru $1 nen√≠" >> /dev/stderr
					exit 1
				else
					echo "Nen√≠ jin√° pozice, bude se posouvat vp≈ôed" >> /dev/stderr
					if [ "${AORDER}" -gt "1" ] ; then
						local B=$(identifyname ${1} $((${AORDER} - 1)))
						local A=$(identifyname ${1} ${AORDER})
						echo "Strana $A se bude se p≈ôesouvat p≈ôed $B, mohu p≈ôikroƒçit k rozebr√°n√≠ a vyjmut√≠ str√°nky" >> /dev/stderr
						rozvazat ${1} ${TEMPDIR}
						deletepage ${1} ${A}
					else
						echo "Str√°nka $AORDER se ji≈æ nach√°z√≠ na prvn√≠ pozici" >> /dev/stderr
						exit 1
					fi
				fi
			;;
		esac
	else
		echo "pln√° - c√≠lov√° pozice, ƒçi str√°nka existuje. Je t≈ôeba zjistit, zda identifik√°tor nen√≠ v kolizi"
		local AORDER=$(identifypage $1 $2)
		if [ -z "${AORDER}" ] ; then
			echo "Str√°nka s identifik√°torem $2 v souboru $1 nen√≠" >> /dev/stderr
			exit 1
		else
			echo "Str√°nka vy se mohla p≈ôesouvat tak√© na sebe samu" >> /dev/stderr
			local B=$(identifyname $1 ${BORDER})
			local A=$(identifyname $1 ${AORDER})
			if [ "${B}" == "${A}" ] ; then
				echo "Identifik√°tor c√≠lov√© pozice odpov√≠d√° aktu√°ln√≠ pozici" >> /dev/stderr
				exit 1
			else
				echo "Mohu p≈ôikroƒçit k rozebr√°n√≠ a vyjmut√≠ str√°nky"
				rozvazat ${1} ${TEMPDIR}
				deletepage ${1} ${A}
			fi
		fi
	fi
	local BORDER=$(identifypage $1 $B)
	echo "Vkl√°d√°m str√°nku ${A} na pozici $BORDER"
	insertpage ${1} "${TEMPDIR}/${A}" ${BORDER}
}

function backpage {
	# REVIZE NUTN√Å!!!
	# $1 - soubor
	# $2 - str√°nka k p≈ôesunu
	# $3 - pozice k p≈ôesunu
	local P=$(identifypage $1 $2)
	AORDER=$P
	A=$(identifyname $1 $AORDER)
	local P=$(identifypage $1 $3)
	BORDER=$P
	if [ -z "${BORDER}" ] ; then
		if [ -z "${AORDER}" ] ; then
			echo "Str√°nka $2 v souboru nen√≠.."
			exit 1
		else
			B=$(identifyname $1 $((${AORDER} + 1)))
		fi
	else
		B=$(identifyname $1 ${BORDER})
	fi
	echo "forwardpage: P≈ôesouv√°m A -> $A p≈ôed B -> $B" >>/dev/stderr
	${DJVMCVT} -i ${1} ${TEMPDIR} index.djvu
	deletepage ${1} ${A}
	local P=$(identifypage $1 $B)
	insertpage ${1} "${TEMPDIR}/${A}" $(($P + 1))
}

function djvuinfo {
	# $1 - soubor
	# $2 - parametry
#	echo "djvuinfo: ${#@}" >> /dev/stderr
#	echo "djvuinfo: Soubor ${1}" >> /dev/stderr
#	echo "djvuinfo: Parametry ${2}" >> /dev/stderr
	# Ovƒõ≈ôuji, je-li soubor typu svazek..
	if $(identifybundle "${1}") ; then
		local PAGES="none"
	else
		local PAGES=$(lastpage "${1}")
	fi
	if [ -z "${2}" ] ; then
		echo "${PAGES}"
	elif [ "${2}" == "all" ] ; then
		echo "Info pro cel√Ω soubor.."
		local INFO="DjVu pages"
		echo -n "${INFO}" && printf "%$((31 - ${#INFO}))s : ${PAGES}\n" >> /dev/stderr
		${EXIFTOOL} "${1}"
	else
		# extrakce str√°nky do doƒçasn√©ho adres√°≈ôe..
		local NAMEPAGE=$(identifyname "${1}" "${2}")
		echo "djvuinfo: ${NAMEPAGE}" >> /dev/stderr
		exportpage "${1}" "${NAMEPAGE} ${TEMPDIR}"
		local INFO="DjVu pages"
		echo -n "${INFO}" && printf "%$((31 - ${#INFO}))s : ${PAGES}\n" >> /dev/stderr
		${EXIFTOOL} "${TEMPDIR}/${NAMEPAGE}"
	fi
}

function djvubundle {
	# REVIZE NUTN√Å!!!
	# Funkce pro vytvo≈ôen√≠ svazku..
	# $1 - vzorek podle kter√©ho se maj√≠ vybrat soubory
	# $2 - c√≠lov√Ω DjVu soubor
	# $FORCE - ovliv≈àuje jestli se m√° p≈ôepsat c√≠lov√Ω soubor, nebo ne
	# $INDIRECT - ovliv≈àuje typ svazku
	# $EXTENSION - je p≈ô√≠pona v√Ωchoz√≠ch soubor≈Ø
	echo $@
	if [ -f "$1" ] ; then
		if [ -f "$2" ] ; then 
			if [ ${FORCE} == "no" ] ; then
				echo "pou≈æiju djvmcvt"
				help existed "$2"
				exit 0
			else
				${DJVMCVT} -${INDIRECT} "$1" "$2"
			fi
		fi
	else
		if [ -f "$2" ] ; then 
			if [ ${FORCE} == "no" ] ; then
				help existed "$2"
				exit 0
			else
				rm -rf "$2"
			fi
		fi
		if [ ${RENAME} == "no" ] ; then
			echo "V√Ωchoz√≠ soubory jsou identifikov√°ny vzorkem a nep≈ôejmenuj√≠ se"
			for i in $(ls -1 | grep -E "([0-9])\1?$EXTENSION\$" | sed "s/$1//" | sort -n) ; do
				#echo "$2 $1$i"
				ORIGSOUBOR="$1$i"
				DJVUSOUBOR=${ORIGSOUBOR/$EXTENSION/.djvu}
				if [ -f "$ORIGSOUBOR" ] ; then
					if [ ! -f "$DJVUSOUBOR" ] ; then
						todjvu "$ORIGSOUBOR"
					fi
				fi
				if [ -f "$2" ] ; then
					${DJVM} -i "$2" "$DJVUSOUBOR"
				else
					${DJVM} -c "$2" "$DJVUSOUBOR"
				fi
			done 
		else
#		RENAME
			if [ "${RENAME}" == "0" ] ; then
				#echo "numerick√© ƒç√≠slov√°n√≠, n√°zev soubor≈Ø se - a≈æ na ƒç√≠slo zachov√° "
				INPUT=""
					for i in $(ls -1 $1*${EXTENSION} ) ; do
						if [ "$INPUT" == "" ] ; then
							INPUT="${i%%+([0-9${EXTENSION}.])}"
						elif [ "$INPUT" != "${i%%+([0-9${EXTENSION}.])}" ] ; then
							continue
						else
							echo "zpracuji $i" > /dev/null
						fi
						STRING="${i#${INPUT}}"
						RAWNUMBER="${STRING%${EXTENSION}}"
						NUMBER="${RAWNUMBER##+(0)}"
						if [ "${NUMBER}" == "" ] ; then
							TARGET="${INPUT}0${EXTENSION}"
						else
							TARGET="${INPUT}${NUMBER}${EXTENSION}"
						fi
						if [ "$3" ] ; then
							if [ "$TARGET" == "${VZOR}$3${EXTENSION}" ] ; then
								konvertor "$i" "${TARGET/${EXTENSION}/.djvu}"
							fi
						else
							konvertor "$i" "${TARGET/${EXTENSION}/.djvu}"
						fi
					done
#					echo "NUMERIC - soubor stejn√Ω"
			elif [ ! "${RENAME//0/}" ] ; then
				MAX="0"
					for i in $(ls -1 $1*${EXTENSION} ) ; do
						if [ "$INPUT" == "" ] ; then
							INPUT="${i%%+([0-9${EXTENSION}.])}"
						elif [ "$INPUT" != "${i%%+([0-9${EXTENSION}.])}" ] ; then
							continue
						else
							echo "zpracuji $i" > /dev/null
						fi
						STRING="${i#${INPUT}}"
						RAWNUMBER="${STRING%${EXTENSION}}"
						if [ "${#RAWNUMBER}" -gt  "${#MAX}" ] ; then
							MAX="${RAWNUMBER}"
						fi
					done
				if [ "${#MAX}" -gt "${#RENAME}" ] ; then
					BASE="${MAX//[0-9]/0}"
				else
					BASE="${RENAME}"
				fi
				INPUT=""
					for i in $(ls -1 $1*${EXTENSION} ) ; do
						if [ "$INPUT" == "" ] ; then
							INPUT="${i%%+([0-9${EXTENSION}.])}"
						elif [ "$INPUT" != "${i%%+([0-9${EXTENSION}.])}" ] ; then
							continue
						else
							echo "zpracuji $i" > /dev/null
						fi
						STRING="${i#${INPUT}}"
						RAWNUMBER="${STRING%${EXTENSION}}"
						NUMBER="${RAWNUMBER##+(0)}"
						if [ "${NUMBER}" == "" ] ; then
							TARGET="${INPUT}${BASE}${EXTENSION}"
						else
							TARGET="${INPUT}${BASE:0:$((${#BASE} - ${#NUMBER}))}${NUMBER}${EXTENSION}"
						fi
						if [ "$3" ] ; then
							if [ "$TARGET" == "${VZOR}$3${EXTENSION}" ] ; then
								konvertor "$i" "${TARGET/${EXTENSION}/.djvu}"
							fi
						else
							konvertor "$i" "${TARGET/${EXTENSION}/.djvu}"
						fi
					done
#				echo "BASE - soubor stejn√Ω"
			else
				# VZOR + BASE z RENAME
				VZOR="${RENAME%%+(0)}"
				BASE="${RENAME#$VZOR}"
				if [ "${#BASE}" == "1" ] ; then
					INPUT=""
					for i in $(ls -1 $1*${EXTENSION} ) ; do
						if [ "$INPUT" == "" ] ; then
							INPUT="${i%%+([0-9${EXTENSION}.])}"
						elif [ "$INPUT" != "${i%%+([0-9${EXTENSION}.])}" ] ; then
							continue
						else
							echo "zpracuji $i" > /dev/null
						fi
						STRING="${i#${INPUT}}"
						RAWNUMBER="${STRING%${EXTENSION}}"
						NUMBER="${RAWNUMBER##+(0)}"
						if [ "${NUMBER}" == "" ] ; then
							TARGET="${VZOR}0${EXTENSION}"
						else
							TARGET="${VZOR}${NUMBER}${EXTENSION}"
						fi
						if [ "$3" ] ; then
							if [ "$TARGET" == "${VZOR}$3${EXTENSION}" ] ; then
								konvertor "$i" "${TARGET/${EXTENSION}/.djvu}"
							fi
						else
							konvertor "$i" "${TARGET/${EXTENSION}/.djvu}"
						fi
					done
#					echo "NUMERIC - vzor"
				else
					INPUT=""
					MAX="0"
					for i in $(ls -1 $1*${EXTENSION} ) ; do
						if [ "$INPUT" == "" ] ; then
							INPUT="${i%%+([0-9${EXTENSION}.])}"
						elif [ "$INPUT" != "${i%%+([0-9${EXTENSION}.])}" ] ; then
							echo "Soubor $i nevyhovuje zvolen√©mu vzoru $1 p≈ôeskakuji jej" >> /dev/stderr
							continue
						else
							echo "zpracuji $i" > /dev/null
						fi
						STRING="${i#${INPUT}}"
						RAWNUMBER="${STRING%${EXTENSION}}"
						if [ "${#RAWNUMBER}" -gt  "${#MAX}" ] ; then
							MAX="${RAWNUMBER}"
						fi
					done
					ORIGBASE="${MAX//[0-9]/0}"
					if [ "${#ORIGBASE}" -gt "${#BASE}" ] ; then
						BASE="$ORIGBASE"
						echo "ORIGBASE - vzor"
					fi
					#	Seznam set≈ô√≠dƒõn√Ω podle d√©lky ≈ôetƒõzc≈Ø $(ls -1 $1* | grep -E "([0-9])\1?$EXTENSION\$" | sed "s/$1//" | sort -n)
					# for i in $(ls -1 | grep -E "([0-9])\1?$EXTENSION\$" | awk '{ print length, $0 }' | sort -n ) ; do
					INPUT=""
					for i in $(ls -1 $1*${EXTENSION} ) ; do
						if [ "$INPUT" == "" ] ; then
							INPUT="${i%%+([0-9${EXTENSION}.])}"
						elif [ "$INPUT" != "${i%%+([0-9${EXTENSION}.])}" ] ; then
							continue
						else
							echo "zpracuji $i" > /dev/null
						fi
						STRING="${i#${INPUT}}"
						RAWNUMBER="${STRING%${EXTENSION}}"
						NUMBER="${RAWNUMBER##+(0)}"
						if [ "${NUMBER}" == "" ] ; then
							TARGET="${VZOR}${BASE}${EXTENSION}"
						else
							TARGET="${VZOR}${BASE:0:$((${#BASE} - ${#NUMBER}))}${NUMBER}${EXTENSION}"
						fi
						if [ "$3" ] ; then
							if [ "$TARGET" == "${VZOR}$3${EXTENSION}" ] ; then
								konvertor "$i" "${TARGET/${EXTENSION}/.djvu}"
							fi
						else
							konvertor "$i" "${TARGET/${EXTENSION}/.djvu}"
						fi
					done
#					echo "VZOR BASE"
				fi
			fi
		fi
	fi
}

function fromxcf {
	if [ "${1##*.}" == "xcf" ] ; then
		TEMPORARY="/tmp/$WINDOWID$BASHPID"
		mkdir $TEMPORARY
		convert ${1} ${TEMPORARY}/test.png
		pushd $TEMPORARY
			BUNDLE=" "
			for i in $(ls -cr -1) ; do
				todjvu $i
				BUNDLE="$BUNDLE ${i/.png/.djvu}"
			done
			djvm -c out.djvu $BUNDLE
		popd
		mv $TEMPORARY/out.djvu ./
		rm -rf $TEMPORARY
	fi
}

function help {
	echo -n """[1mN√°povƒõda pro [1m[2m${0##*/}[0m : """
	case "$1" in
		page) echo """volba [1m-p[0m ([1m--page[0m)

  Extrakce DjVu str√°nky ze svazku p≈ôi akci [2mexport[22m

  [1m${0##*/}[0m ... {-p|--page} [yes|no] ...
  
[4mPozn√°mka:[24m
  * Pokud za volbou nen√≠ uveden ≈æ√°dn√Ω dal≈°√≠ parametr, tak se automaticky
    p≈ôedpokl√°d√° - yes.
  * V√Ωchoz√≠ parametr - no - lze implicitnƒõ zmƒõnit nastaven√≠m promƒõnn√©
    PAGE do souboru v adres√°≈ôi ${HOME}/.config/${NAME}/
  * Exportovan√© str√°nky se ukl√°daj√≠ pod sv√Ωm p≈Øvodn√≠m n√°zvem.
"""
		;;
		image) echo """volba [1m-i[0m ([1m--img[0m)

  [4mExtrakce obrazov√© vrstvy[24m DjVu str√°nky do bitmapov√©ho souboru

  [1m${0##*/}[0m ... {-i|--img} [yes|no|<layer>] ...

  Je-li parametrem volby [3myes[23m, tak se bude p≈ôi akci [2mexport[22m generovat z DjVu
  str√°nky plnobarevn√Ω bitmapov√Ω obr√°zek ve form√°tu PNG.
  V ostatn√≠ch p≈ô√≠padech bude ve form√°tu PNM.

      [1m${0##*/}[0m --img background svazek.djvu export stranka.djvu
 
Pou≈æiteln√© parametry:
                 color - plnobarevn√° str√°nka
                 black - ƒçernob√≠l√° kresba
            foreground - vrstva pop≈ôed√≠
            background - vrstva pozad√≠
                  mask - maska
  Je-li m√≠sto [3m'yes'[23m uvedeno [3m'background'[23m, bude p≈ôi exportu str√°nky
  strana.djvu ulo≈æen obr√°zek pozad√≠ pod jm√©nem strana.background.pnm
  V√Ωchoz√≠ nastaven√≠ lze implicitnƒõ zmƒõnit nastaven√≠m promƒõnn√© IMGPAGE
"""
		;;
		dsed) echo """volba [1m-d[0m ([1m--dsed[0m)

  Extrakce skryt√© textov√© vrstvy DjVu str√°nky ve form√°tu pro djvused.
  Parametrem lze zvolit, co se m√° p≈ôi akci [2mexport[22m ulo≈æit.

  [1m${0##*/}[0m ... {-d|--dsed} [yes|no|all|txt|ant] ...
  
         yes - stejn√Ω efekt jako volba all
         no  - textov√° vrstva se neexportuje (default)
         all - exportuje se cel√Ω obsah skryt√© textov√© vrstvy
         txt - exportuje se pouze obsah str√°nky
         ant - exportuj√≠ se meta atributy str√°nky, hyperlinky, atp.

[4mPozn√°mka:[24m
  * Pokud za volbou nen√≠ uveden ≈æ√°dn√Ω dal≈°√≠ parametr, tak se automaticky
    p≈ôedpokl√°d√° - yes.
  * V√Ωchoz√≠ parametr - no - lze implicitnƒõ zmƒõnit nastaven√≠m promƒõnn√©
    DSED do souboru v adres√°≈ôi ${HOME}/.config/${NAME}/
  * Exportovan√° data se ukl√°daj√≠ do soubor≈Ø s p≈ô√≠ponou [3m.dsed[23m.
"""
		;;
		force) echo """volba [1m-f[0m ([1m--force[0m)

  Nastaven√≠m t√©to volby si lze vynutit v√Ωchoz√≠ chov√°n√≠ k soubor≈Øm p≈ôi
  akci [2mexport[22m. Nen√≠-li uvedena, tak se skript p≈ôed ka≈æd√Ωm
  p≈ôeps√°n√≠m ji≈æ existuj√≠c√≠ho souboru zept√°, zda-li m√°, nebo nem√°
  pokraƒçovat.

  [1m${0##*/}[0m ... {-f|--force} [yes|no|skip] ...
  
         yes  - v≈°echny soubory se budou bez kec≈Ø p≈ôepisovat.
         no   - skript se p≈ôed p≈ôeps√°n√≠m souboru bude dotazovat, zda-li
                m√° soubor p≈ôepsat.
         skip - pokud bude c√≠lov√Ω soubor existovat, tak se akce p≈ôeskoƒç√≠.

[4mPozn√°mka:[24m
  * Pokud za volbou nen√≠ uveden ≈æ√°dn√Ω dal≈°√≠ parametr, tak se automaticky
    p≈ôedpokl√°d√° - skip.
  * V√Ωchoz√≠ parametr hodnotu parametru  (skip) - lze implicitnƒõ zmƒõnit
    nastaven√≠m promƒõnn√© FORCE v u≈æivatelsk√©m konfiguraƒçn√≠m souboru.
"""
		;;
		verbose) echo """volba [1m-v[0m ([1m--verbose[0m)

  Prost≈ôednictv√≠m t√©to volby si lze p≈ôesmƒõrovat v√Ωstup dopl≈àuj√≠c√≠ch
  informaƒçn√≠ch v√Ωpis≈Ø na konzoli. D√≠ky nim pak lze podrobnƒõ sledovat
  postup skriptu p≈ôi zpracov√°n√≠ souboru

  [1m${0##*/}[0m ... {-v|--verbose} ...
"""
		;;
		xml) echo """volba [1m-x[0m ([1m--xml[0m)

  Extrakce skryt√© textov√© vrstvy DjVu str√°nky ve form√°tu XML.
  Parametrem lze zvolit, co se m√° p≈ôi akci [2mexport[22m ulo≈æit.

  [1m${0##*/}[0m ... {-d|--dsed} [yes|no|all|txt|ant] ...
  
         yes - stejn√Ω efekt jako volba all
         no  - textov√° vrstva se neexportuje (default)
         all - exportuje se cel√Ω obsah skryt√© textov√© vrstvy
         txt - exportuje se pouze obsah str√°nky
         ant - exportuj√≠ se meta atributy str√°nky

[4mPozn√°mka:[24m
  * Pokud za volbou nen√≠ uveden ≈æ√°dn√Ω dal≈°√≠ parametr, tak se automaticky
    p≈ôedpokl√°d√° - yes.
  * V√Ωchoz√≠ parametr - no - lze implicitnƒõ zmƒõnit nastaven√≠m promƒõnn√©
    XML do souboru v adres√°≈ôi ${HOME}/.config/${NAME}/
  * Exportovan√° data se ukl√°daj√≠ do soubor≈Ø s p≈ô√≠ponou [3m.xml[23m.

[1mPozor:[0m  P≈ôi exportu do XML nelze podchytit v≈°echny meta atributy!!!
"""
		;;
		exporttometa) echo """volba [1m-m[0m ([1m--meta[0m)

  Extrakce DjVu str√°nky ze svazku

  [1m${0##*/}[0m ... {-x|--xml} [yes|no] ...
  
  Prost≈ôednictv√≠m t√©to volby lze zvolit zda se m√°, nebo nem√° p≈ôi akci
  [3mexport[23m z DjVu svazku exportovat i cel√° DjVu str√°nka. Pokud za volbou
  nen√°sleduje parametr, pak se automaticky p≈ôedpokl√°d√° ≈æe ano (yes).
  V√Ωchoz√≠ nastaven√≠ (no), lze implicitnƒõ zmƒõnit prost≈ôednictv√≠m
  u≈æivatelsk√©ho konfiguraƒçn√≠ho souboru um√≠stƒõn√©ho v v adres√°≈ôi:

    ${HOME}/.config/${NAME}/
"""
		;;
		exporttothumb) echo """volba [1m-t[0m ([1m--thumb[0m)

  Extrakce DjVu str√°nky ze svazku

  [1m${0##*/}[0m ... {-t|--thumb} [yes|no] ...
  
  Prost≈ôednictv√≠m t√©to volby lze zvolit zda se m√°, nebo nem√° p≈ôi akci
  [3mexport[23m z DjVu svazku exportovat i cel√° DjVu str√°nka. Pokud za volbou
  nen√°sleduje parametr, pak se automaticky p≈ôedpokl√°d√° ≈æe ano (yes).
  V√Ωchoz√≠ nastaven√≠ (no), lze implicitnƒõ zmƒõnit prost≈ôednictv√≠m
  u≈æivatelsk√©ho konfiguraƒçn√≠ho souboru um√≠stƒõn√©ho v v adres√°≈ôi:

    ${HOME}/.config/${NAME}/
"""
		;;
		indirect) echo"""
[1mVolba[0m
         --indirect Volba, kterou lze zmƒõnit v√Ωchoz√≠ typ v√≠cestr√°nkov√©ho 
                    DjVu svazku (bundeled)

  Volbu je t≈ôeba aplikovat pokud chcete rozbalit stv√°vaj√≠c√≠ DjVu svazek 
  do podoby voln√©ho svazku, nebo pokud chcete p≈ôi konverzi bitmapov√Ωch
  soubor≈Ø rovnou sestavit DjVu svazek jako voln√Ω

  V√Ωhodou voln√©ho svazku je, ≈æe lze dodateƒçnƒõ upravovat jednotliv√© str√°nky
  jako samostatn√© DjVu soubory, ani≈æ by je bylo nutn√© exportovat.

  Pro finalizaci DjVu svazku je pak lep≈°√≠ svazek p≈ôekonvertovat na typ
  bundled, kdy je v≈°e zabaleno v jednom souboru
"""
		;;
		existed) echo """
  Soubor $2 existuje. Pokud se m√° p≈ôepsat, mus√≠ b√Ωt
  uveden parametr -f (--force)
"""
		;;
		dpi) echo"""
[1mParametr[0m
         --dpi  <[2mƒç√≠slo[22m> Hodnota DPI, kter√° se m√° pou≈æ√≠t p≈ôi zpracov√°n√≠ obr√°zku.
                               p≈ôi konverzi. Optim√°ln√≠ je zjistit hodnotu p≈ô√≠mo ze vstupn√≠ho
                               obr√°zku. P≈ôed nastaven√≠m t√©to hodnoty pro fin√°ln√≠ konverzi. lze vyzkou≈°et
                               optim√°ln√≠ nastaven√≠ na nƒõkter√©m ze soubor≈Ø s vyu≈æit√≠m parametru
                               --test

  Rozsah ƒç√≠seln√© hodnoty je od 72 do 6000 dpi. V√Ωchoz√≠ hodnota 300 se pou≈æije 
  v p≈ô√≠padƒõ, ≈æe parametr --dpi nen√≠ v≈Øbec uveden.
  Vliv dpi na zpracov√°n√≠ obrazu..
"""
		;;
		level) echo """
[1mParametr[0m
         -l|--level  <[2mƒç√≠slo[22m> Hodnota akceptovateln√Ωch ztr√°t u ƒçernob√≠l√© kresby
                               p≈ôi konverzi. P≈ôed nastaven√≠m t√©to hodnoty vyzkou≈°ejte
                               optim√°ln√≠ nastaven√≠ na nƒõkter√©m ze soubor≈Ø a s parametrem
                               --test

  Kromƒõ ƒç√≠seln√© hodnoty, kter√° mus√≠ b√Ωt men≈°√≠ ne≈æ 200 lze √∫rove≈à ztr√°t
  nastavit i pomoc√≠ nƒõkter√©ho z n√°sleduj√≠c√≠ch parametr≈Ø - v p≈ô√≠padƒõ ≈æe 
  jich bude uvedeno v√≠c, m√° prioritu posledn√≠ z nich.

        --lossless     0 - ≈æ√°dn√© ztr√°ty (default)
        --clean        1 - ignoruj√≠ se body o velikosti 1 pixelu
        --lossy        100 - ignoruj√≠ se plochy
"""
		;;
		keywords-export) echo """akce [1mexport[0m

  Export z DjVu svazku. O tom co bude p≈ôedmƒõtem exportu rozhoduj√≠ dal≈°√≠ 
  volby. Export textov√© vrstvy zajist√≠ volby [3m-x[23m a [3m-d[23m, n√°hled obrazov√© vrstvy
  se generuje p≈ôi volbƒõ [3m-i[23m, a cel√° str√°nka v DjVu form√°tu se exportuje
  p≈ôi volbƒõ [3m-p[23m.

  [1m${0##*/}[0m [volby] <svazek> export {<num>|<name>|all} [<dir>]

         num  - po≈ôadov√© ƒç√≠slo str√°nky v DjVu svazku
         name - jm√©no str√°nky v DjVu svazku
         dir  - adres√°≈ô do kter√©ho m√° b√Ωt v√Ωstup ulo≈æen

[4mPozn√°mka:[24m
  * Je-li m√≠sto po≈ôadov√©ho ƒç√≠sla str√°nky, nebo jej√≠ho n√°zvu, uvedeno [3mall[23m
    tak se bude exportovat v≈°e z cel√©ho DjVu svazku.
  * Pro zpracov√°n√≠ single-page DjVu str√°nek je parametr [3mall[23m doporuƒçen√Ω
  * Nen√≠-li uveden c√≠lov√Ω adres√°≈ô, budou soubory exporovan√© do adres√°≈ôe,
    kde byl [1m${0##*/}[0m spu≈°tƒõn.
  * P≈ôeps√°n√≠ ji≈æ existuj√≠c√≠ch soubor≈Ø si lze vynutit volbou [3m--force yes[23m
    V√Ωchoz√≠ chov√°n√≠ je - [3mskip[23m (existuj√≠c√≠ soubory se znovu neexportuj√≠)
"""
		;;
		keywords-import) echo """
  Import textov√©ho obsahu DjVu souboru z extern√≠ch soubor≈Ø

[1mSyntaxe[0m

  [1m${0##*/}[0m [volby] <svazek> import <file> [<num>|<name>]

         num  - po≈ôadov√© ƒç√≠slo str√°nky v DjVu svazku
         name - jm√©no str√°nky v DjVu svazku
         file - soubor s obsahem skryt√© textov√© vrstvy

[3mPozn√°mka:[23m
  Nen√≠-li uvedeno po≈ôadov√© ƒç√≠slo str√°nky, nebo jej√≠ n√°zev, tak se p≈ôedpokl√°d√°
  ≈æe jde o obsah textov√© vrstvy cel√©ho DjVu svazku.
  Soubor je rozli≈°en√Ω podle p≈ô√≠pony a m≈Ø≈æe to b√Ωt buƒè v .dsed nebo .xml
  form√°tu.
  Touto cestou lze importovat tak√© XMP informace z .xmp souboru
"""
		;;
		keywords-delete) echo """akce [1mdelete[0m

  [4mOdstranƒõn√≠ str√°nky[24m identifikovan√© jm√©nem, nebo pozic√≠ v DjVu svazku

  [1m${0##*/}[0m [volby] <svazek> delete {<num>|<name>}

         num  - po≈ôadov√© ƒç√≠slo str√°nky v DjVu svazku
         name - jm√©no str√°nky v DjVu svazku

[1mD√°vejte pozor[0m - akce je nevratn√° !
  Je doporuƒçeno p≈ôi odstra≈àov√°n√≠ str√°nek pou≈æ√≠t jako identifik√°tor jm√©no
  str√°nky. A to z toho d≈Øvodu, ≈æe se pozice str√°nky m≈Ø≈æe v pr≈Øbƒõhu
  zpracov√°n√≠ DjVu svazku zmƒõnit, kde≈æto jej√≠ jm√©no z≈Øst√°v√° v≈ædy v r√°mci
  svazku jedineƒçn√©.
"""
		;;
		keywords-info) echo """akce [1minfo[0m

  [4mV√Ωpis informac√≠ o DjVu souboru[24m.

  [1m${0##*/}[0m [volby] <file> info [<num>|<name>]

         num  - po≈ôadov√© ƒç√≠slo str√°nky v DjVu svazku
         name - jm√©no str√°nky v DjVu svazku
         file - jm√©no DjVu souboru
"""
		;;
		keywords-insert) echo """akce [1minsert[0m
  [4mVlo≈æen√≠ DjVu souboru do Djvu svazku[24m. Je-li na vstupu nekonvertovovan√Ω
  obr√°zek, dojde ke konverzi. Nen√≠-li uvedena pozice, ƒçi jm√©no str√°nky p≈ôed 
  kterou se m√° obsah vlo≈æit, p≈ôipoj√≠ se na konec DjVu svazku. P≈ôedt√≠m, je ale vy≈æadov√°no potvrzen√≠ akce, kter√© lze obej√≠t pouze pou≈æit√≠m volby -f (--force)

  [1m${0##*/}[0m [volby] <svazek> insert <file> [<num>|<name>]

         num  - po≈ôadov√© ƒç√≠slo str√°nky v DjVu svazku
         name - jm√©no str√°nky v DjVu svazku
         file - jm√©no DjVu souboru, nebo skenu

[3mPozn√°mka:[23m
  Pokud se ji≈æ v DjVu souboru str√°nka se stejn√Ωm n√°zvem vyskytuje, dojde
  p≈ôi vlo≈æen√≠ k p≈ôejmenov√°n√≠ souboru - za n√°zev se p≈ôid√° podtr≈æ√≠tko
  a po≈ôadov√© ƒç√≠slo v√Ωskytu. K takov√© situaci m≈Ø≈æe doj√≠t tak√© v p≈ô√≠padƒõ,
  ≈æe je operace [2minsert[22m zopakov√°na se stejn√Ωmi parametry. Pak se
  automaticky p≈ôid√°van√© ƒç√≠slo postupnƒõ navy≈°uje.

              insert test01.jpg => test01.djvu
              insert test01.jpg => test01_1.djvu
              insert test01.jpg => test01_2.djvu
              ...
"""
		;;
		keywords-forward) echo """akce [1mforward[0m

  P≈ôesun str√°nky v r√°mci DjVu svazku o pozici vp≈ôed. [4mP≈ôed str√°nku, kter√°[24m
  [4mji m√° n√°sledovat[24m. V p≈ô√≠padƒõ, u≈æ p≈ôesouvan√° str√°nka je na prvn√≠ pozici,
  se nestane nic.

  [1m${0##*/}[0m [volby] <svazek> fore {<num>|<name>} [<num>|<name>]

         num  - po≈ôadov√© ƒç√≠slo str√°nky v DjVu svazku
         name - jm√©no str√°nky v DjVu svazku

  Je doporuƒçeno pou≈æ√≠t jako identifik√°tor jm√©na str√°nek, m√≠sto jejich 
  aktu√°ln√≠ pozice. A to z toho d≈Øvodu, ≈æe se pozice str√°nek mohou v pr≈Øbƒõhu
  zpracov√°n√≠ DjVu svazku mƒõnit, kde≈æto jej√≠ jm√©no str√°nky je v≈ædy v r√°mci
  svazku jedineƒçn√©.
"""
		;;
		keywords-back) echo """akce [1mback[0m

  P≈ôesun str√°nky v r√°mci DjVu svazku o pozici zpƒõt. [4mZa str√°nku, kter√°[24m
  [4mji m√° n√°sledovat[24m. V p≈ô√≠padƒõ, u≈æ je p≈ôesouvan√° str√°nka na posledn√≠ pozici,
  se nestane nic.

  [1m${0##*/}[0m [volby] <svazek> back {<num>|<name>} [<num>|<name>]

         num  - po≈ôadov√© ƒç√≠slo str√°nky v DjVu svazku
         name - jm√©no str√°nky v DjVu svazku

  Je doporuƒçeno pou≈æ√≠t jako identifik√°tor jm√©na str√°nek, m√≠sto jejich 
  aktu√°ln√≠ pozice. A to z toho d≈Øvodu, ≈æe se pozice str√°nek mohou v pr≈Øbƒõhu
  zpracov√°n√≠ DjVu svazku mƒõnit, kde≈æto jej√≠ jm√©no str√°nky je v≈ædy v r√°mci
  svazku jedineƒçn√©.
"""
		;;
		keywords-rotate) echo """akce [1mrotate[0m

  √öprava v√Ωchoz√≠ho natoƒçen√≠ DjVu str√°nek.

  [1m${0##*/}[0m [volby] <svazek> rotate {<num>|<name>} <value>

         num   - po≈ôadov√© ƒç√≠slo str√°nky
         name  - jm√©no str√°nky
         value - parametr jak m√° b√Ωt str√°nka natoƒçena

[1mParametry[0m
  O - nastav√≠ str√°nku do v√Ωchoz√≠ pozice
  1 - natoƒç√≠ str√°nku o 90¬∞ vpravo
  2 - natoƒç√≠ str√°nku vz≈Øru nohama 
  3 - natoƒç√≠ str√°nku o 90¬∞ vlevo
  left - pootoƒç√≠ str√°nku o 90¬∞ smƒõrem doleva
  right - pootoƒç√≠ str√°nku o 90¬∞ smƒõrem doprava
  180 - pootoƒç√≠ str√°nku o 180¬∞

[3mPozn√°mka:[23m
          Nen√≠-li uveden identifik√°tor str√°nky, bude parametrem
          nastaveno glob√°ln√≠ natoƒçen√≠ pro v≈°echny str√°nky dokumentu.
"""
		;;
		keywords-set) echo """akce [1mset[0m

  [4mNastaven√≠ meta atribut≈Ø[24m DjVu str√°nky, resp. cel√©ho svazku

  [1m${0##*/}[0m [volby] <svazek> set {<num>|<name>} {<file>|<key> <value>}

  [1m${0##*/}[0m [volby] <svazek> set {<file>|<key> <value>}

         num   - po≈ôadov√© ƒç√≠slo str√°nky
         name  - jm√©no str√°nky
         file  - soubor s meta atributy
         key   - jm√©no meta atributu
         value - hodnota meta atributu

Nejbƒõ≈ænƒõj≈°√≠ atributy (key):
       Title - N√°zev DjVu dikumentu
     Creator - Jm√©no tv≈Ørce DjVu dokumentu
CreationDate - ƒåas vytvo≈ôen√≠ dokumentu
    Keywords - Kl√≠ƒçov√° slova pro indexaci DjVu dokumentu
      annote - Pozn√°mka k dokumentu

[3mPozn√°mka:[23m
  Dal≈°√≠ viz akce [2mprint[22m, [2mexport[22m, [2mimport[22m, [2munset[22m a manu√°l k tomuto skriptu.
"""
		;;
		keywords-unset) echo """akce [1munset[0m

  [4mOdstranƒõn√≠ meta atribut≈Ø[24m DjVu str√°nky, resp. cel√©ho svazku

  [1m${0##*/}[0m [volby] <svazek> unset {<num>|<name>} <key>

  [1m${0##*/}[0m [volby] <svazek> unset <key>

         num   - po≈ôadov√© ƒç√≠slo str√°nky
         name  - jm√©no str√°nky
         key   - jm√©no meta atributu

[1mD√°vejte pozor[0m - akce je nevratn√° !
  Akce dovoluje odstranit nejenom vybran√Ω atribut, ale tak√© v≈°echny dal≈°√≠,
  proto ji vyu≈æ√≠vejte nanejv√Ω≈° opatrnƒõ. S meta atributy pracujte radƒõji
  prost≈ôednictv√≠m soubor≈Ø zpracov√°van√Ωch p≈ôi akc√≠ch [2mexport[22m a [2mimport[22m.
  Pro ovƒõ≈ôen√≠ kl√≠ƒçe, p≈ôed jeho zru≈°en√≠m vyu≈æijte akci [2mprint[22m. Nov√Ω obsah
  kl√≠ƒçe lze nastavit p≈ôes akci [2mset[22m.
"""
		;;
		keywords-print) echo """akce [1mprint[0m

  [4mV√Ωpis kl√≠ƒç≈Ø a jejich obsahu[24m z metainformac√≠ ulo≈æen√Ωch v Djvu svazku.

  [1m${0##*/}[0m <svazek> print [all]
  [1m${0##*/}[0m <svazek> print <attr>
  [1m${0##*/}[0m <svazek> print {<num>|<name>} [all]
  [1m${0##*/}[0m <svazek> print {<num>|<name>} <attr>

         num  - po≈ôadov√© ƒç√≠slo str√°nky v DjVu svazku
         name - jm√©no str√°nky v DjVu svazku
         attr - jm√©no atributu
         all  - kl√≠ƒçov√© slovo (vypsat v≈°e)

[3mPozn√°mka:[23m
  Jednotliv√© atributy lze nastavovat p≈ôes [2mset[22m, v√≠ce atribut≈Ø najednou
  lze do DjVu str√°nky ƒçi svazku importovat z extern√≠ho souboru p≈ôi
  akci [2mimport[22m. Metadata lze z DjVu soubor≈Ø tak√© exportovat ([2mexport[22m).
"""
		;;
		keywords) echo """
  [1m${0##*/}[0m [volby] {DjVu svazek} <keyword> [-h|...]

  [1m      keyword - popis akce[0m

         delete - odstran√≠ str√°nku ze svazku
         insert - vlo≈æ√≠ novou str√°nku do svazku
     fore, back - p≈ôesune str√°nku v r√°mci svazku
         rotate - mƒõn√≠ orientaci vybran√© str√°nky
            set - nastavuje metainformace DjVu str√°nek a svazku
          print - vypisuje metainformace z DjVu str√°nek a svazku
          unset - odstra≈àuje metainformace DjVu str√°nek i svazku
         export - exportuje djvu str√°nku, dsed nebo xml soubor s obsahem
                  textov√© vrstvy, n√°hled str√°nky v png, atp.
         import - importuje do DjVu str√°nky ƒçi svazku obsah skryt√© textov√©
                  vrstvy z xml str√°nky
         rename - p≈ôejmenov√°n√≠ str√°nek v DjVu souboru dle nastaven√©ho vzoru

[3mPozn√°mka:[23m
          Pro podrobnƒõj≈°√≠ n√°povƒõdu pou≈æijte volbu -h za kl√≠ƒçov√Ωm slovem
"""
		;;
		rename) echo """
[1mParametr[0m
         -r|--rename  <[2mvzor[22m>  Vzor, podle jak√©ho se maj√≠ p≈ôejmenovat
                              d√≠lƒç√≠ DjVu soubory, ze kter√Ωch se pak bude
                              sestavovat DjVu svazek.
[4mPopis:[24m
  Pomoc√≠ [2mvzoru[22m lze upravit n√°zvy zkonvertovan√Ωch DjVu soubor≈Ø
  p≈ôed jejich sestaven√≠m do DjVu svazku. [2mVzor[22m m≈Ø≈æe b√Ωt tvo≈ôen:
    1, Pouze jednou, nebo v√≠ce nulami - 000
    2, Nebo ≈ôetƒõzcem, n√°sledovan√Ωm nulami - soubor_00

[3mPozn√°mka:[23m
  Je-li uvedena pouze jedna nula, budou str√°nky oƒç√≠slov√°ny [4mnumericky[24m,
  t.j. od ƒç√≠sla 1 d√°le. Je-li nul v√≠ce, pak bude ƒç√≠slo interpretov√°no
  jako [4m≈ôetƒõzec[24m. tedy 001 a d√°le. Pokud by ƒç√≠slov√°n√≠ str√°nek p≈ôes√°hlo
  nastaven√Ω poƒçet ƒç√≠sel, bude upraven dle maxim√°ln√≠ho ƒç√≠sla.

[3mUk√°zkov√© vzory : a v√Ωsledn√Ω efekt..[23m
   soubor-0000 : soubor-0001.djvu .. soubor-0123.djvu
   soubor_0    : soubor_1.djvu    .. soubor_123.djvu
   soubor000   : soubor0001.djvu  .. soubor1234.djvu
"""
			;;
		suffix) echo """
[1mParametr[0m
         -e|--ext  <[2msuffix[22m>  P≈ô√≠pona soubor≈Ø, ze kter√Ωch se m√° sestavit 
                                DjVu soubor.
[4mPopis:[24m
  [2mSuffix[22m je nutn√© uv√©st pouze v p≈ô√≠padƒõ, ≈æe soubory s n√°zvem odpov√≠daj√≠c√≠m
  vzorku dosud nebyly do DjVu zkonvertov√°ny. Jinak se v≈ædy p≈ôedpokl√°d√°, ≈æe
  se bude pracovat s ji≈æ konvertovan√Ωmi DjVu soubory.

  Je-li [2msuffix[22m uveden, budou konvertov√°ny soubory vyhovuj√≠c√≠ vzorku.
  Pokud nƒõkter√© z nich ji≈æ konvertov√°ny byly, tak se se f√°ze konverze
  p≈ôeskoƒç√≠. Pracuje se pak s ji≈æ existuj√≠c√≠m DjVu souborem.

  Konvertov√°ny jsou pouze soubory, kter√© chyb√≠. Kvalitu konverze lze
  ovlivnit  dal≈°√≠mi parametry. Maj√≠-li b√Ωt soubory p≈ôekonvertov√°ny znovu,
  lze si to vynutit parametrem -f (--force) a st√°vaj√≠c√≠ soubory  p≈ôepsat.

  Akceptovan√© sufixy: 
     djvu (default), jpg, gif, png, bmp, pnm, pbm, pgm.
  V√≠cevrstv√© soubory:
     xcf, tiff, pdf 
"""
			;;
		options) echo """
[1mP≈ôehled akceptovan√Ωch voleb[0m: 
  -h|--help     N√°povƒõda
  -b|--bundle   V√Ωsledekm zpracov√°n√≠ bude kompaktn√≠ svazek ( default)
  -d|--dsed     P≈ôi akci export ukl√°dat obsah textov√© vrstvy do souboru .dsed
  -f|--force    Vynucen√° akce
  -i|--indirect V√Ωsledekm zpracov√°n√≠ bude voln√Ω svazek
  -m|--meta     P≈ôi akci export ukl√°dat meta informace z DjVu str√°nky ƒçi svazku do soubor s p≈ô√≠ponou .meta
  -p|--page     Vyta≈æen√≠ cel√© str√°nky z DjVu svazku
  -x|--xml      P≈ôi akci export ukl√°dat obsah textov√© vrstvy do souboru .xml
  -t|--thumb    Vygenerov√°n√≠ n√°hled≈Ø v DjVu svazku, resp. p≈ôi akci export vyta≈æen√≠ n√°hledu do souboru s p≈ô√≠ponou .thumb (obrazov√° vrstva, k√≥dvan√° v  IW44)

Parametrick√© volby:
   -n|--name    parametr zajist√≠, ≈æe se soubory p≈ôejmenuj√≠
   -r|--rename  ≈ôetƒõzec, kter√Ω se m√° pou≈æ√≠t k pojmenov√°n√≠ soubor≈Ø m√≠sto 
                st√°vaj√≠c√≠ch n√°zv≈Ø soubor≈Ø p≈ôi sestaven√≠ svazku 
                soubor_0000 - soubor_0001.djvu .. soubor_0123.djvu
                soubor_0 -    soubor_1.djvu ,, soubor_123.djvu
"""
		;;
		*) echo """
   Toto je n√°stroj pro pr√°ci s DjVu soubory a svazky.

      [1m${0##*/}[0m [volby] ... <akce>

 N√°povƒõdu k volb√°m a jejich parametr≈Øm vyp√≠≈°e volba -h
 P≈ôehled v≈°ech dostupn√Ωch voleb vyp√≠≈°ete takto...

      [1m${0##*/}[0m -h -h

 P≈ôehled akc√≠ vyp√≠≈°ete takto...

      [1m${0##*/}[0m [volby] <soubor> -h
"""
		;;
	esac
}

function todjvu {
	# $1 - soubor ke konverzi
	# $2 - c√≠lov√Ω DjVu soubor
	echo "todjvu: Konvertuji soubor $1 - do souboru $2" >> /dev/stderr
	echo "$(testfile ${1})" >> /dev/stderr
	if [ $(testfile ${1}) == "djvu" ] ; then
		echo "DjVu soubory nelze znovu konvertovat" >> /dev/stderr
		exit 1
	else
		if [ "${#ALG[@]}" -gt "1" ] ; then
			for i in ${ALG[@]} ; do 
				${DIDJVU} encode -o "${2/.djvu/.$i.djvu}" -d "${DPI-300}" ${LEVEL} -m "$i" "$1"
				getocr ${2/.djvu/.$i.djvu}
			done
		else
			if [ -f "${2}" ] ; then
				if [ "${FORCE}" == "yes" ] ; then
				log 1 "todjvu: C√≠lov√Ω soubor ${2} existuje, bude se p≈ôepisovat"
					${DIDJVU} encode -o "${2}" -d "${DPI-300}" ${LEVEL} -m "${ALG}" "${1}"
					getocr ${2}
				else
					echo "M√°m p≈ôepsat c√≠lov√Ω soubor ${2}?"
					potvrdit && ${DIDJVU} encode -o "${2}" -d "${DPI-300}" ${LEVEL} -m "${ALG}" "${1}"
					getocr ${2}
				fi
			else
				if [ ! -d "${2%/*}" ] ; then
					log 1 "todjvu: neexistuje adres√°≈ô pro c√≠lov√Ω soubor, mus√≠m ho vytvo≈ôit"
					mkdir -p "${2%/*}"
				fi
				log 1 "todjvu: konvertuji soubor ${1} do c√≠lov√©ho souboru $2"
				echo "${DIDJVU} encode -o ${2} -d ${DPI-300} ${LEVEL} -m ${ALG} ${1}" >> /dev/stderr
				${DIDJVU} encode -o "${2}" -d "${DPI-300}" ${LEVEL} -m "${ALG}" "${1}"
				getocr ${2}
			fi
		fi
	fi
}

function todotest {
	for i in ${ALG[@]} ; do 
		${DIDJVU} encode -o "${1%.*}-$i.djvu" -d 300 -m "$i" "$1"
	done
}

function todoview {
	for i in ${ALG[@]} ; do 
		(${DJVIEW} ${1%.*}-$i.djvu &)
	done
}

function todjvuclassic {
    RANDOMKEY=$[ 8000 + $[ RANDOM % 1000 ]]
    TEMP_DIR="${TEMPDIR}/$WINDOWID$BASHPID$RANDOMKEY"
    mkdir $TEMP_DIR
    TEMP_IMG="$TEMP_DIR/temp.ppm"
    TEMP_MASK="$TEMP_DIR/mask.pbm"
    DJVU_MASK="$TEMP_DIR/mask.djvu"

    case ${1##*.} in
        tiff|tif) KONVERT="${TIFFTOPNM}";;
        png) KONVERT="${PNGTOPNM}";;
        jpg) KONVERT="${JPEGTOPNM}" ;;
    esac

    $KONVERT $1 | tee $TEMP_IMG | ${PPMTOPGM} | ${PGMTOPBM} -threshold -value 0.${3-5} | ${PNMTOPLAINPNM} > $TEMP_MASK;
    ${CJB2} -lossy -clean $TEMP_MASK $DJVU_MASK;
    ${DJVUMAKE} ${1/.png/.djvu} Sjbz=$DJVU_MASK PPM=$TEMP_IMG;
    getocr ${1/.png/.djvu}
    rm -rf $TEMP_DIR
}

# Zpracov√°n√≠ parametr≈Ø p≈ôedan√Ωch p≈ôi startu skriptu
function main {
#	echo "$@" >> /dev/stderr
#	echo "$*" >> /dev/stderr

local VSTUP="$*"
local COUNT=${#VSTUP}
local POS=0
local START=0
while [ $POS -lt $COUNT ]
do local POS=$((POS+1))
	case "${VSTUP:$START:$POS}" in
		-a|--algorithm) # Volba pro akci insert
			local POS=$((POS+1))
			local TEMP=${VSTUP:$POS}
			case "$TEMP" in
				-h*|--help*) help algorithm && exit 0
				;;
			esac
			local NEXT="${TEMP#* }"
			local VALUE="${TEMP%${NEXT}}"
#			echo "$VALUE" >> /dev/stderr
			if [ "${VALUE:0:1}" == "-" ] ; then
				local VSTUP="${TEMP}"
				local POS=0
				local COUNT=${#VSTUP}
				log 1 "Nebyl uveden ≈æ√°dn√Ω kompresn√≠ algoritmus, aplikuji v√Ωchoz√≠ - $ALG"
			else
				for i in ${VALUE//,/ } ; do
#					echo "$i" >> /dev/stderr
					local TEST="no"
					for y in ${ALGORITHM[@]} ; do
						[ "$i" == "$y" ] && local TEST="yes"
					done
					[ "${TEST}" == "no" ] && echo "Algoritmus $i nelze pou≈æ√≠t" >> /dev/stderr && exit 0
				done
				ALG=(${VALUE//,/ })
				local VSTUP="${NEXT}"
				local POS=0
				local COUNT=${#VSTUP}
				log 1 "main: Kompresn√≠ algoritmy jsou ovƒõ≈ôeny, pou≈æiji - ${ALG[@]}"
			fi
		;;
		-d|--dsed) # Volba pro akci export
			local POS=$((POS+1))
			local TEMP=${VSTUP:$POS}
			case "$TEMP" in
				-h*|--help*) help dsed && exit 0
				;;
			esac
			local NEXT="${TEMP#* }"
			local VALUE="${TEMP%${NEXT}}"
			case "${VALUE%%+([[:blank:]])}" in
				yes|no|txt|ant|all) DSED="${VALUE%%+([[:blank:]])}"
				local VSTUP="${NEXT}"
				local POS=0
				local COUNT=${#VSTUP}
				log 1 "main: Aplikuji pro DSED parametr - ${DSED}"
				;;
				*) log 1 "Nebyl uveden ≈æ√°dn√Ω parametr, aplikuji pro DSED parametr - yes"
				DSED="yes"
				local VSTUP="${TEMP}"
				local POS=0
				local COUNT=${#VSTUP}
			esac
		;;
		--dpi) # Volba pro akci insert
			local POS=$((POS+1))
			local TEMP=${VSTUP:$POS}
			case "$TEMP" in
				-h*|--help*) help dpi && exit 0
				;;
			esac
			local NEXT="${TEMP#* }"
			local VALUE="${TEMP% ${NEXT}}"
#			echo "${VALUE//+([[:digit:]])}" >> /dev/stderr
			if [ "${VALUE//+([[:digit:]])}" == "" ] ; then
				if [ "${VALUE}" -ge "72" ] && [ "${VALUE}" -le "6000" ] ; then
					DPI="${VALUE%%+([[:blank:]])}"
					local VSTUP="${NEXT}"
					local POS=0
					local COUNT=${#VSTUP}
					log 1 "main: Aplikuji pro DPI parametr - ${DPI}"
				else
					echo "Hodnota u volby --dpi se mus√≠ pohybovat v rozmez√≠ od 72 do 6000" >> /dev/stderr
					exit 1
				fi
			else
				echo "Nebyla uvedena hodnota dpi. Pokud chcete volbou --dpi zmƒõnit v√Ωchoz√≠ hodnotu (300), mus√≠te ji uv√©st jako ƒç√≠seln√Ω parametr" >> /dev/stderr
				exit 1
			fi
		;;
		-f|--force) local POS=$((POS+1))
			local TEMP=${VSTUP:$POS}
			case "$TEMP" in
				-h*|--help*) help force && exit 0
				;;
			esac
			local NEXT="${TEMP#* }"
			local VALUE="${TEMP%${NEXT}}"
			case "${VALUE%%+([[:blank:]])}" in
				yes|no|skip) FORCE="${VALUE%%+([[:blank:]])}"
				local VSTUP="${NEXT}"
				local POS=0
				local COUNT=${#VSTUP}
				log 1 "main: Aplikuji pro FORCE parametr - ${FORCE}"
				;;
				*) log 1 "Nebyl uveden ≈æ√°dn√Ω parametr, aplikuji pro FORCE parametr - skip"
				FORCE="skip"
				local VSTUP="${TEMP}"
				local POS=0
				local COUNT=${#VSTUP}
			esac
		;;
		--clean|--lossy|--lossless|--level) # Volba pro akci insert
			local PARAM=${VSTUP:0:$POS}
			local POS=$((POS+1))
			local TEMP=${VSTUP:$POS}
			case "$TEMP" in
				-h*|--help*) help force && exit 0
				;;
			esac
			case "${PARAM}" in
				--lossy) LEVEL="--loss-level=100"
					local VSTUP="${TEMP}"
					local POS=0
				;;
				--lossless) LEVEL="--loss-level=0"
					local VSTUP="${TEMP}"
					local POS=0
				;;
				--clean) LEVEL="--loss-level=1"
					local VSTUP="${TEMP}"
					local POS=0
				;;
				--level)
							local NEXT="${TEMP#* }"
						local VALUE="${TEMP%${NEXT}}"
						local XXX=${VALUE%%+([[:blank:]])}
						if [ "${XXX//+([[:digit:]])}" == "" ] ; then
						local VSTUP="${NEXT}"
						local POS=0
						local COUNT=${#VSTUP}
						if [ "${XXX}" -ge "0" ] && [ "${XXX}" -lt "200" ] ; then
							LEVEL="--loss-level=${XXX}"
							log 1 "main: Aplikuji pro LEVEL hodnotu - ${LEVEL}"
						else
							help level && exit 0
						fi
					else
						echo "main: Volba --loss-level mus√≠ m√≠t v≈ædy uvedenou ƒç√≠selnou hodnotu v rozmez√≠ 0-199" >> /dev/stderr
						exit 1
					fi
				;;
				*) echo "Sem se nikdy nemƒõl dostat"
				;;
			esac
			log 1 "√örove≈à ztr√°tovosti p≈ôi kompresi ${LEVEL}"
		;;
		-i|--image) # Volba pro akci export
			local POS=$((POS+1))
			local TEMP=${VSTUP:$POS}
			case "$TEMP" in
				-h*|--help*) help image && exit 0
				;;
			esac
			local NEXT="${TEMP#* }"
			local VALUE="${TEMP%${NEXT}}"
			case "${VALUE%%+([[:blank:]])}" in
				yes|no|color|black|foreground|background|mask) IMG="${VALUE%%+([[:blank:]])}"
				local VSTUP="${NEXT}"
				local POS=0
				local COUNT=${#VSTUP}
				log 1 "main: Aplikuji pro IMG parametr - ${IMG}"
				;;
				*) log 1 "Nebyl uveden ≈æ√°dn√Ω parametr, aplikuji pro IMG parametr - yes"
				IMG="yes"
				local VSTUP="${TEMP}"
				local POS=0
				local COUNT=${#VSTUP}
			esac
		;;
		-m|--meta) # Volba pro akci export
			local POS=$((POS+1))
			local TEMP=${VSTUP:$POS}
			case "$TEMP" in
				-h*|--help*) help meta && exit 0
				;;
			esac
			local NEXT="${TEMP#* }"
			local VALUE="${TEMP%${NEXT}}"
			if [ "${VALUE%%+([[:blank:]])}" == "yes" ] || [ "${VALUE%%+([[:blank:]])}" == "no" ] ; then
				META="${VALUE%%+([[:blank:]])}"
				local VSTUP="${NEXT}"
				local POS=0
				local COUNT=${#VSTUP}
				log 1 "main: Aplikuji pro META parametr - ${META}"
			else
				META="yes"
				local VSTUP="${TEMP}"
				local POS=0
				local COUNT=${#VSTUP}
				log 1 "Nebyl uveden ≈æ√°dn√Ω parametr, aplikuji pro META parametr - yes"
			fi
		;;
		-o|--ocr) # Volba pro akci insert
			local POS=$((POS+1))
			local TEMP=${VSTUP:$POS}
			case "$TEMP" in
				-h*|--help*) ${TESSERACT} --list-langs 2>&1 | sed -n '1!p'
				exit 0
				;;
			esac
			local NEXT="${TEMP#* }"
			local VALUE="${TEMP% ${NEXT}}"
#			echo "$VALUE" >> /dev/stderr
#			echo $(${TESSERACT} --list-langs 2>&1 | sed '1d;x') >> /dev/stderr
			for i in ${VALUE//+/ } ; do
				local TEST="no"
				for y in $(${TESSERACT} --list-langs 2>&1 | sed -n '1!p') ; do
					[ "$i" == "$y" ] && local TEST="yes"
#					echo "$i - $y" >> /dev/stderr
				done
				[ "${TEST}" == "no" ] && echo "Pro jazyk $i nem√° tesseract nainstalovanou jazykovou podporu" >> /dev/stderr && exit 0
			done
			if [ "${TEST}" == "yes" ] ; then
				OCR="${VALUE%%+([[:blank:]])}"
				local VSTUP="${NEXT}"
				local POS=0
				local COUNT=${#VSTUP}
				log 1 "main: Aplikuji pro OCR parametr - ${OCR}"
			else
				OCR="${OCR=ces}"
				local VSTUP="${TEMP}"
				local POS=0
				local COUNT=${#VSTUP}
				echo "Nebyl uveden ≈æ√°dn√Ω parametr, pro OCR pou≈æiji v√Ωchoz√≠ jazyk - ${OCR}" >> /dev/stderr
			fi
		;;
		-p|--page) # Volba pro akci export
			local POS=$((POS+1))
			local TEMP=${VSTUP:$POS}
			case "$TEMP" in
				-h*|--help*) help page && exit 0
				;;
			esac
			local NEXT="${TEMP#* }"
			local VALUE="${TEMP%${NEXT}}"
			if [ "${VALUE%%+([[:blank:]])}" == "yes" ] || [ "${VALUE%%+([[:blank:]])}" == "no" ] ; then
				PAGE="${VALUE%%+([[:blank:]])}"
				local VSTUP="${NEXT}"
				local POS=0
				local COUNT=${#VSTUP}
				log 1 "main: Aplikuji pro PAGE parametr - ${PAGE}"
			else
				log 1 "Nebyl uveden ≈æ√°dn√Ω parametr, aplikuji pro PAGE parametr - yes"
				PAGE="yes"
				local VSTUP="${TEMP}"
				local POS=0
				local COUNT=${#VSTUP}
			fi
		;;
		-t|--thumb) # Volba pro akci insert
			local POS=$((POS+1))
			local TEMP=${VSTUP:$POS}
			case "$TEMP" in
				-h*|--help*) help thumb && exit 0
				;;
			esac
			local NEXT="${TEMP#* }"
			local VALUE="${TEMP% ${NEXT}}"
#			echo "${VALUE//+([[:digit:]])}" >> /dev/stderr
			if [ "${VALUE//+([[:digit:]])}" == "" ] ; then
				if [ "${VALUE}" -ge "32" ] && [ "${VALUE}" -le "256" ] ; then
					THUMB="${VALUE%%+([[:blank:]])}"
					local VSTUP="${NEXT}"
					local POS=0
					local COUNT=${#VSTUP}
					log 1 "main: Aplikuji pro THUMB parametr - ${DPI}"
				else
					echo "Hodnota u volby --thumb se mus√≠ pohybovat v rozmez√≠ od 32 do 256" >> /dev/stderr
					exit 1
				fi
			else
				echo "Nebyla uvedena hodnota velikosti n√°hledu. Pokud chcete volbou --thumb nastavit v√Ωchoz√≠ hodnotu, mus√≠te ji uv√©st jako ƒç√≠seln√Ω parametr" >> /dev/stderr
				exit 1
			fi
		;;
		-v|--verbose) # Volba pro ukecan√Ω v√Ωstup
			local PARAM=${VSTUP:0:$POS}
			local POS=$((POS+1))
			local TEMP=${VSTUP:$POS}
			case "$TEMP" in
				-h*|--help*) help verbose && exit 0
				;;
			esac
			case "${PARAM}" in
				-v|--verbose) LOG="/dev/stderr"
					local VSTUP="${TEMP}"
					local POS=0
				;;
			esac
			log 1 "Nastavuji ukecan√Ω v√Ωstup"
		;;
		-x|--xml) # Volba pro akci export
			local POS=$((POS+1))
			local TEMP=${VSTUP:$POS}
			case "$TEMP" in
				-h*|--help*) help xml && exit 0
				;;
			esac
			local NEXT="${TEMP#* }"
			local VALUE="${TEMP%${NEXT}}"
			case "${VALUE%%+([[:blank:]])}" in
				yes|no|txt|ant|all) XML="${VALUE%%+([[:blank:]])}"
				local VSTUP="${NEXT}"
				local POS=0
				local COUNT=${#VSTUP}
				log 1 "main: Aplikuji pro XML parametr - ${XML}"
				;;
				*) log 1 "Nebyl uveden ≈æ√°dn√Ω parametr, aplikuji pro XML parametr - yes"
				XML="yes"
				local VSTUP="${TEMP}"
				local POS=0
				local COUNT=${#VSTUP}
			esac
		;;
		*.[dD][jJ][vV][uU]|*.[gG][iI][fF]|*.[jJ][pP][gG]|*.[mM][nN][gG]|*.[pP][dD][fF]|*.[pP][nN][gG]|*.[pP][nN][mM]|*.[tT][iI][fF][fF]|*.[xX][cC][fF]) 
# tady vznik√° probl√©m, pokud akce nem√° ≈æ√°dn√© dal≈°√≠ parametry...
			local FILE="${VSTUP:0:$POS}"
			local TEMP=${VSTUP#${FILE}}
#			echo "D√©lka ≈ôetƒõzce ${#TEMP} -${TEMP}-" >> /dev/stderr
			local OREZ=${TEMP##+([[:blank:]])}
#			echo "D√©lka ≈ôetƒõzce ${#OREZ} -${OREZ}-" >> /dev/stderr
			local CHARSTRING="${OREZ#* }"
#			echo "CHARSTRING D√©lka ≈ôetƒõzce ${#CHARSTRING} -${CHARSTRING}-" >> /dev/stderr
			if [ "${#CHARSTRING}" -eq "${#OREZ}" ] ; then
				local KEY="${CHARSTRING}"
				local CHARSTRING=""
			else
				local TEMP="${OREZ%${CHARSTRING}}"
				local KEY="${TEMP%%+([[:blank:]])}"
			fi
			log 1 "KEY -${KEY}-"
			log 1 "FILE -${FILE}-"
			log 1 "CHARSTRING -${CHARSTRING}-"
		break
		;;
	esac
done

	case "${CHARSTRING}" in
		*-h|*--help|-h*|--help*) if [ -z "${KEY}" ] ; then
				help
			else
				echo "keywords-${KEY}" >> /dev/stderr
				help "keywords-${KEY}"
			fi
			exit 77
		;;
	esac

	if [ -f "${FILE}" ] ; then
#		log 1 "main: Soubor -${FILE}- existuje.."
#		FILE=${FILE//\ /\\ }
		case $(testfile "${FILE}") in
			djvu)
				#echo "AKCE ${KEY}" >> /dev/stderr
				#echo "Parametry #${CHARSTRING}#" >> /dev/stderr
				case "${KEY}" in
					delete) deletepage "${FILE}" "${CHARSTRING}"
						exit 0
					;;
					insert) # ToDo - zpracovat ${CHARSTRING}
						exit 1
						if [ -f "${3}" ] ; then
							if [ $(testfile ${3}) == "djvu" ] ; then
								log 1 "main - insert: Soubor je typu djvu"
								local INSERTFILE=${3}
							else
								[ "${#ALG[@]}" == "1" ] || exit 32
								local INSERTFILE="$TEMPDIR/${3%.*}.djvu"
								todjvu ${3} ${INSERTFILE}
								if [ $? -gt "0" ] ; then
									echo "main - insert: Soubor ${3} se nepoda≈ôilo zkonvertovat do souboru ${INSERTFILE}" >> /dev/stderr
									exit 1
								fi
							fi
							# Urƒçit pozici...
							local P=$(identifypage ${1} ${4})
							log 1 "main - insert: C√≠lov√° pozice je $P"
							if [ -z "${P}" ] ; then
								if [ -z "${4}" ] ; then
									echo "P≈ôipojen√≠ souboru ${INSERTFILE} na konec souboru ${1}" >> /dev/stderr
									insertpage ${1} ${INSERTFILE}
								else
									echo "Identifik√°tor ${4} je pro soubor ${1} neplatn√Ω" >> /dev/stderr
									exit 1
								fi
							else
								log 1 "main - insert: Vkl√°d√°m ${INSERTFILE} na pozici $P"
								insertpage ${1} ${INSERTFILE} ${P}
							fi
						else
							echo "Akci insert lze pou≈æ√≠t pouze ke vlo≈æen√≠ souboru" >> /dev/stderr
							exit 1
						fi
						exit 0
					;;
					set) setmeta "${FILE}" "${CHARSTRING}"
						exit 0
					;;
					print) printmeta ${FILE} "${CHARSTRING}"
						exit 0
					;;
					unset) unsetmeta ${FILE} "${CHARSTRING}"
						exit 0
					;;
					fore)  # ToDo - zpracovat ${CHARSTRING}
						exit 1
						[ -f ${3} ] && echo "pro vlo≈æen√≠ nov√© str√°nky do souboru je urƒçena akce insert" >> /dev/stderr && exit 1
#						echo "akce forvard ${1} - ${3} - ${4}" >> /dev/stderr
						forwardpage ${1} ${3} ${4}
						exit 0
					;;
					back)  # ToDo - zpracovat ${CHARSTRING}
						exit 1
						[ -f ${3} ] && echo "pro vlo≈æen√≠ nov√© str√°nky do souboru je urƒçena akce insert" >> /dev/stderr && exit 1
						backpage ${1} ${3} ${4}
						exit 0
					;;
					rotate) rotatepage "${FILE}" "${CHARSTRING}"
						exit 0
					;;
					export) export "${FILE}" "${CHARSTRING}"
						exit 0
					;;
					import)   # ToDo - zpracovat ${CHARSTRING}
						exit 1
					;;
					info)	echo "proch√°z√≠m"
						djvuinfo "${FILE}" "${CHARSTRING}"
						exit 0
					;;
					rename)   # ToDo - zpracovat ${CHARSTRING}
						exit 1
					;;
					*) echo "Jsem tu -${KEY}-" >> /dev/stderr
						help keywords && exit 0
					;;
				esac
			;;
			jpeg|png) echo "Bude se zpracov√°vat soubor v bitmapov√©m form√°tu"
				echo "ToDo"
				exit 1
			;;
			xcf|tiff|mng) echo "Jako druh√Ω parametr je soubor ve v√≠cevrstv√©m bitmapov√©m form√°tu. Zpracov√°n√≠ tƒõchto soubor≈Ø nen√≠ zat√≠m implementov√°no" >> /dev/stderr
				exit 1
			;;
			xml|XML) echo "m√°-li prvn√≠ soubor p≈ô√≠ponu xml"
				echo "ToDo"
				exit 1
			;;
			unknown) echo "Pokud je soubor ${1} typu DjVU, m≈Ø≈æe j√≠t o tzv. SecureDjVu form√°t, kter√Ω m√° kryptovan√© vrstvy. S takov√Ωm souborem nelze s opensource n√°stroji pracovat." >> /dev/stderr
				exit 1
			;;
			*) echo "${FILE} : $(testfile ${FILE})" >> /dev/stderr
				echo '''Pokud n√°sleduje djvu soubor'''
				echo '''Pokud n√°sleduje adres√°≈ô'''
				echo '''to je existuj√≠c√≠ soubor typu bundle a:
				- nen√°sleduje ≈æ√°dn√Ω dal≈°√≠ existuj√≠c√≠ soubor typu djvu, nebo adres√°≈ô
				a z√°rove≈à existuje $DIRECTORY, pak to znamen√° ≈æe se m√° rozbalit
				- pokud n√°sleduje dal≈°√≠ soubor, pak to znamen√° ≈æe se m√° nƒõjak√Ωm zp≈Øsobem s t√≠mto dal≈°√≠m souborem nalo≈æit. Je-li to:
				- djvu soubor, m√° se p≈ôipojit
				- xml soubor, m√° se vlo≈æit
				- soubor typu dsed m√° se zpracovat
				- jin√Ω soubor - obr√°zek, kter√Ω se m√° p≈ôev√©st a vlo≈æit
				'''
				echo "Zpracov√°n√≠ soubor≈Ø jako je $2 zat√≠m nen√≠ implementov√°no"
				exit 1
			;;
		esac
	else
		echo "Tady se dostane pokud ${FILE} neexistuje" >> /dev/stderr
	fi
}

main "$*"

exit 0
