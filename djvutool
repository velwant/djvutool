#!/bin/bash
# -*- mode: sh -*-

# https://elpa.gnu.org/packages/djvu.html
# djvutool - tool for conversion and work with DjVu files
#
# Author: Aleš Kapica <kapica@fel.cvut.cz>, 2015-2016
#
# Použití...
# convertor [test] image
#	provede testovací konverzi pro všechny dostupné separační algoritmy didjvu
shopt -s extglob

# Changelog
# - ošetřena situace, kdy není nainstalován ocrodjvu
# - ošetřit situaci, kdy soubor neobsahuje žádný textový obsah a soubor dsed, ani xml neexistuje
# - mezi klíčové operace přidáno delete a insert
# - OCR zpracované do samostatné funkce
# - výchozí algoritmus djvu; testovací konverze pro všechny algoritmy se
#   provede pouze je-li uveden parametr --test-conversion
# - implementována rotace stránky
# - implementovány přesuny stránek (akce fore a back)
# - implementováno generování náhledů do exportu
# - upraveny funkce pro export náhledů a souborů textové vrstvy
# - akce 'delete' odstraňuje stránky
# - akce 'fore' a 'back' přesouvají stránky podle udaných parametrů
# - akce 'unset outline' umožňuje odstraňovat záložky na základě čísla řádky
# - akce 'set outline' dovoluje vložit záložku z příkazové řádky
# - do akce 'export' byla přidána možnost interaktivní volby
# - akce 'print outline', 'edit outline', 'export outline', 'convert outline', 'convert bookmarks'

# Otestovat
# - export ze single-page dokumentu
#

# ToDo
# Doplnit nové funkce do wiki souboru
# Opravit akci edit meta - dočasný soubor je někde v pytli - binec dělá asi realpath nebo co..
# implementovat kontrolu do funkce todjvu, aby nedocházelo k nekontrolovatelnému vkládání již existujících stránek
# - přidat kontrolu do akce insert na duplicitní soubory při vkládání
#   vícestránkových DjVu souborů. to ovšem bude vyžadovat samostatnou
#   funkci...
# - dopsat manuál pro akci set, argumenty, xmp, atp.
# - implementovat import
# doplnit nápovědu k rotaci stránky (akce rotate)
# opravit volby --algoritmus a --view
NAME="djvutool"
[ -d "${HOME}/.config/${NAME}" ] &&	. ${HOME}/.config/${NAME}/* &>>/dev/null

DEBUG="-d0"
LOG="${LOG=/dev/null}"
XML="${XML=no}"
DPI="${DPI=300}"
DSED="${DSED=no}"
PAGE="${PAGE=no}"
META="${META=no}"
IMG="${IMG=no}"
INDIRECT="${INDIRECT=no}"
FORCE="${FORCE=skip}"
RENAME="no"
EXTENSION=".djvu"
THUMBNAIL="${THUMBNAIL=no}"
INSERTTEXT="${INSERTTEXT=no}"
ALG="${ALG=none}"
EXTRACTPAGE="${EXTRACTPAGE=no}"
IMGPAGE="${IMGPAGE=no}"
ALGORITHM=( none abutaleb bernsen brink djvu niblack otsu sauvola shading-subtraction tsai white-rohrer )
TABS="8"

trap '''CHYBA=$? ;
case $CHYBA in
 10) echo "Žádná sdílená metadata"
 ;;
 20) echo "Není nainstalován balík poppler-utils"
 ;;
 19) echo "Není nainstalován balík pdftk"
 ;;
 20) echo "Není nainstalován balík djvu-tools"
 ;;
 21) echo "ERROR: mimetype - tool for detection type of image"
 ;;
 22) echo "ERROR: readlink - tool for detection absolute path of directory"
 ;;
 23) echo "ERROR: netpbm-sf - pack of utilities for image conversions not installed "
 ;;
 24) echo "ERROR: imagemagick - tool for image convert is not installed"
 ;;
 25) echo "ERROR: xmlstarlet - tool for work with xml not installed"
 ;;
 26) echo "ERROR: xcftools - tool for work with xcf file (GIMP) not installed"
 ;;
 27) echo "ERROR: libtiff-tools - tool for work with tiff file not installed"
 ;;
 28) echo "ERROR: libopenjp2-tools - tool for work with jp2 file not installed"
 ;;
 29) echo "ERROR: 7z - tool for work with compressed archives is not installed"
 ;;
 30) echo "ERROR: PDF viewer not installed"
 ;;
 31) echo "Není nainstalován balík ocrodjvu, na djvu soubory nelze aplikovat OCR. Buďto jej doinstalujte, nebo odstraňte z příkazové řádky parametr -o (--ocr)" >> /dev/stderr
 ;;
 32) echo "Pokud má při operaci zpracovat do DjVu bitmapový soubor, je třeba uvést na příkazové řádce parametrem -a jaký se má použít algoritmus. Jaké parametry lze použít se dozvíte pokud místo jména algoritmu napíšete znak ?" >> /dev/stderr
 ;;
 33) NORMDIR=yes
 ;;
 38) echo "ERROR - identifikátor stránky není platný!" >> /dev/stderr
 ;;
esac
[ $NORMDIR ] || rm -rf -- "$TEMPDIR"
exit $CHYBA
''' EXIT

TEMPDIR=$(mktemp -d -p /tmp ${NAME}-XXX) || exit 1

#=== testy závislostí ===
# Dependencies:
#   * feh      ( http://feh.finalrewind.org/ )
#   * exiftool ( http://www.sno.phy.queensu.ca/~phil/exiftool ) in Debian package: libimage-exiftool-perl 
#   * yad      ( http://sourceforge.net/projects/yad-dialog )
REALPATH=$(which realpath)
[ ! ${REALPATH} ] && exit 1
REALPATH="$REALPATH -e "

FEH=$(which feh)
[ ! ${FEH} ] && exit 18
GEEQIE=$(which geeqie)
[ ! ${GEEQIE} ] && exit 18
DIDJVU=$(which didjvu)
[ ! ${DIDJVU} ] && echo 'Není nainstalován balík didjvu, nebude možné aplikovat pokročilé algoritmy pro separaci popředí při konverzi do DjVu' >> /dev/stderr && DIDJVU=false
OCRODJVU=$(which ocrodjvu)
[ ! ${OCRODJVU} ] && OCRODJVU=31
DJVIEW=$(which djview)
[ ! ${DJVIEW} ] && echo 'Není nainstalován balík djview, nebude fungovat testovací zobrazení djvu.souborů' >> /dev/stderr && DJVIEW=false
DDJVU=$(which ddjvu)
[ ! ${DDJVU} ] && exit 20
DJVUTXT=$(which djvutxt)
[ ! ${DJVUTXT} ] && exit 20
DJVUSED=$(which djvused)
[ ! ${DJVUSED} ] && exit 20
DJVUTOXML=$(which djvutoxml)
[ ! ${DJVUTOXML} ] && exit 20
DJVUXMLPARSER=$(which djvuxmlparser)
[ ! ${DJVUXMLPARSER} ] && exit 20
DJVMCVT=$(which djvmcvt)
[ ! ${DJVMCVT} ] && exit 20
DJVUEXTRACT=$(which djvuextract)
[ ! ${DJVUEXTRACT} ] && exit 20
DJVM=$(which djvm)
[ ! ${DJVM} ] && exit 20
CJB2=$(which cjb2)
[ ! ${CJB2} ] && exit 20
DJVUMAKE=$(which djvumake)
[ ! ${DJVUMAKE} ] && exit 20
#YAD=$(which yad)
#[ ! ${YAD} ] && echo 'Není nainstalován balík yad' && exit 1
MIME=$(which mimetype)
[ ! -x "${MIME}" ] && exit 21
STAT=$(which readlink)
[ ! -x "${STAT}" ] && exit 22
EXIFTOOL=$(which exiftool)
[ ! -x "${EXIFTOOL}" ] && exit 23
# Přesunuto do funkce main k volbě -o|--ocr
#TESSERACT=$(which tesseract)
#[ ! -x "${TESSERACT}" ] && exit 31
IDENTIFY=$(which identify)
[ ! -x "${IDENTIFY}" ] && echo exit 24
CONVERT=$(which convert)
[ ! -x "${CONVERT}" ] && echo exit 24
IMGVIEW=$(which display)
[ ! -x "${IMGVIEW}" ] && echo exit 24
XCFINFO=$(which xcfinfo)
[ ! -x "${XCFINFO}" ] && echo exit 26
XCF2PNM=$(which xcf2pnm)
[ ! -x "${XCF2PNM}" ] && echo exit 26
TIFFINFO=$(which tiffinfo)
[ ! -x "${TIFFINFO}" ] && echo exit 27
PDFVIEW=$(which xpdf)
if [ ! -x "${PDFVIEW}" ] ; then
    PDFVIEW=$(which evince)
    if [ ! -x "${PDFVIEW}" ] ; then
        if [ ! -x "${xournal}" ] ; then
            echo exit 30
        fi
    fi
fi
PDFTK=$(which pdftk)
[ ! -x "${PDFTK}" ] && echo exit 19
PDFTOPPM=$(which pdftoppm)
[ ! -x "${PDFTOPPM}" ] && echo exit 18

# Konverze z formátu JPEG2000 (jp2)
JP2TO=$(which opj_decompress)
[ ! ${JP2TO} ] && exit 28
JP2IN=$(which opj_compress)
[ ! ${JP2IN} ] && exit 28
# Nástroje pro konverzi animovaných gifů a png souborů
# apng2gif, gif2apng, 

ZIP=$(which 7z)
[ ! -x "${ZIP}" ] && echo exit 29

# ## Implementované akce
#
ACTIONS=(
    delete
    fore
    back
    rotate
    export
    import
    convert
    edit
    info
    rename
    insert
    print
    set
    unset
    view
    )

# ## Akceptované formáty bitmapových souborů
#
# Neztrátové formáty 
FORMATS_FULL=(
    bmp
    pnm
    png
    tif
)
# Formáty, které mohou mít ztrítovou kompresi
FORMATS_MISS=(
    jpg
    xcf
    jp2
)
# Kontejnerové formáty
FORMATS_CONT=(
    pdf
    zip
    tar
)
FORMATS=(${FORMATS_FULL[@]} ${FORMATS_MISS[@]} ${FORMATS_CONT[@]})

PGMTOPBM=$(which pgmtopbm)
[ ! -x "${PGMTOPBM}" ] && exit 23
BMPTOPNM=$(which bmptopnm)
[ ! -x "${BMPTOPNM}" ] && exit 23
JPEGTOPNM=$(which jpegtopnm)
[ ! -x "${JPEGTOPNM}" ] && exit 23
GIFTOPNM=$(which giftopnm)
[ ! -x "${GIFTOPNM}" ] && exit 23
PNGTOPNM=$(which pngtopnm)
[ ! -x "${PNGTOPNM}" ] && exit 23
PNMTOJPEG=$(which pnmtojpeg)
[ ! -x "${PNMTOJPEG}" ] && exit 23
TIFFTOPNM=$(which tifftopnm)
[ ! -x "${TIFFTOPNM}" ] && exit 23
PNMTOPNG=$(which pnmtopng)
[ ! -x "${PNMTOPNG}" ] && exit 23
PAMTOJPEG2K=$(which pamtojpeg2k)
[ ! -x "${PAMTOJPEG2K}" ] && exit 23
JPEG2KTOPAM=$(which jpeg2ktopam)
[ ! -x "${JPEG2KTOPAM}" ] && exit 23
PNMTOJPEG=$(which pnmtojpeg)
[ ! -x "${PNMTOJPEG}" ] && exit 23
PNMTOPLAINPNM=$(which pnmtoplainpnm)
[ ! -x "${PNMTOPLAINPNM}" ] && exit 23
#/ Konvertuje barvy na stupně šedi
PPMTOPGM=$(which ppmtopgm)
#/ Konvertuje stupně šedi na černobílou mmasku
[ ! -x "${PPMTOPGM}" ] && exit 23
#/ Konvertuje binární formát PAM do PNM
PAMTOPNM=$(which pamtopnm)
[ ! -x "${PAMTOPNM}" ] && exit 23
#/ Vysekne oblast z obrázku dle souřadnic
PAMCUT=$(which pamcut)
[ ! -x "${PAMCUT}" ] && exit 23
#/ Odseparuje masku
PAMARITH=$(which pamarith)
[ ! -x "${PAMARITH}" ] && exit 23
#/ generátor prázdných ploch pro masku
PBMMAKE=$(which pbmmake)
[ ! -x "${PBMMAKE}" ] && exit 23
#/ integruje plochy do masky
PNMPASTE=$(which pnmpaste)
[ ! -x "${PNMPASTE}" ] && exit 23
NETPBMSCALE=$(which pamscale)
if [ -x "${NETPBMSCALE}" ] ; then
    # Akceptované škálovací filtry
    FILTERS=(
    point
    box
    triangle
    quadratic 
    cubic 
    catrom 
    mitchell 
    gauss 
    sinc 
    bessel 
    hanning 
    hamming 
    blackman 
    kaiser 
    normal 
    hermite 
    lanczos
    )
    NETPBM=0
else
    exit 23
fi

#=== konec testu závislostí ===

## Pomocné funkce...
function xtabs {
	# $1 - count of tabs
	# return string of tabs
	local TAB=$1
	while [ ! $TAB -eq 0 ] ; do
		printf '\t'
		TAB=$(( $TAB - 1 ))
	done 
}

function tabs {
	# $1 - file with tabs
	local TAB=$(printf '%.0s\ ' {0..${TABS}})
	sed "s/\t/${TAB}/g" "${1}"
}

# ### <span id="log">log()</span> ([top](#FUNCTIONS))
# Je-li použita volba `-d` nebo `--debug`, nastaví funkce [main](#main)
# do globální proměnné [$DEBUG](#$DEBUG) řetězcovou hodnotu, která určuje
# kam se budou zprávy předané této funkci posílat. Ta je tvořená řetězcem
# `-d` a číslem. Jakž bude mít toto číslo efekt viz
# [Parametry pro debug](#debug-levels).
#
# První položka, předaná této funkci jako parametr __$1__, určuje
# závažnost zprávy. Ostatní předané položky pak jsou již součástí
# vypisované zprávy.
#
#     log info "Zpráva s informativní hodnotou"
# Informační zprávy obsahují kontrolní výpisy, které informují o průběhu
# zpracování akce skriptem
#
#     log warn "Zpráva, co upozorňuje že by něco nemuselo klapnout"
# Upozorňující zprávy se používají při operacích, které mohou představovat
# problém. Kupř. když skript realizuje nevratný krok. Modelovým příkladem
# takové situace je zpracování příkazu [___delete___](#delete-command-config)
# při akci [__config__](#config), při kterém se odstraňují všechny
# konfigurační soubory pro VM, ze všech hostitelů.
#
#     log err "Zpráva, která oznamuje chybu"
# Chybové zprávy popisují stavy, které mají návratový kód __1__
#
# #### <span id="debug-levels">Parametry pro debug</span>
# Výchozí hodnota pro [$DEBUG](#$DEBUG) je __0__ při které se nevypisuje
# nic. Doporučená úroveň pro ladění skriptu je __7__. A pro normální
# použití, v případě že je skript spravován kupř. přes `cron` __5__.
#
# 1. Vypisuje pouze chybové (ERR) zprávy pouze na standardní chybový výstup
# 2. Zapisuje pouze do logu a pouze chybové (ERR) zprávy
# 3. Vypisuje chybové (ERR) zprávy na standardní výstup a zároveň je
#    zapisuje do logu
# 4. Vypisuje chybové (ERR) a varovné (WARN) zprávy pouze na standardní
#    chybový výstup
# 5. Zapisuje chybové (ERR) a varovné (WARN) zprávy pouze do logu
# 6. Zapisuje chybové (ERR) a varovné (WARN) zprávy na standardní výstup
#    a zároveň je zapisuje do logu
# 7. Vypisuje všechny zprávy pouze na standardní chybový výstup
# 8. Zapisuje všechny zprávy pouze do logu
# 9. Vypisuje všechny zprávy na standardní výstup a zároveň je zapisuje do logu
#
# #### Kde se rozhodně nesmí použít parametr $DEBUG
# Parametr $DEBUG rozhodně nepoužívejte tam, kde se musí zavolat akce na
# vzdáleném stroji přes $SSH a navrácený výstup se má dále zpracovávat.
# Problém spočívá v tom, že SSH s parametrem -t, které se používá pro
# interaktivní práci, přetočí chybový výstup na standardní výstup a tím
# pádem se může vrátit neplatný výsledek.
#
# Typickým příkladem budiž volání akce master. Je-li zavoláno s parametrem
# DEBUG, je výsledek pro další zpracování nepoužitelný!
#
#      local MASTER=$($0 ${DEBUG} master ${PROCESS})
#
# Správně:
#
#      local MASTER=$($0 master ${PROCESS})
#
log() {
    local TIMESTAMP="$(date +%T.%N) $(hostname)"
    local LOG="${LOGDIR}/messages"
    if [ -n "${DEBUG}" ] ; then
        case ${DEBUG} in
            -d0) ;;
            -d1) [ "${1^^}" == "ERR" ] && \
                echo -e "${TIMESTAMP} ${ACTION} ${1^^} ${@:2}" >> /dev/stderr
                ;;
            -d2) [ "${1^^}" == "ERR" ] && \
                echo -e "${TIMESTAMP} ${ACTION} ${1^^} ${@:2}" >> ${LOG}
                ;;
            -d3) [ "${1^^}" == "ERR" ] && \
                echo -e "${TIMESTAMP} ${ACTION} ${1^^} ${@:2}" | \
                tee ${LOG} >> /dev/stderr
                ;;
            -d4) [ "${1^^}" == "ERR" ] || [ "${1^^}" == "WARN" ] && \
                echo -e "${TIMESTAMP} ${ACTION} ${1^^} ${@:2}" >> /dev/stderr
                ;;
            -d5) [ "${1^^}" == "ERR" ] || [ "${1^^}" == "WARN" ] && \
                echo -e "${TIMESTAMP} ${ACTION} ${1^^} ${@:2}" >> ${LOG}
                ;;
            -d6) [ "${1^^}" == "ERR" ] || [ "${1^^}" == "WARN" ] && \
                echo -e "${TIMESTAMP} ${ACTION} ${1^^} ${@:2}" | \
                tee ${LOG} >> /dev/stderr
                ;;
            -d7) echo -e "${TIMESTAMP} ${ACTION} ${1^^} ${@:2}" >> /dev/stderr
                ;;
            -d8) echo -e "${TIMESTAMP} ${ACTION} ${1^^} ${@:2}" >> ${LOG}
                ;;
            -d9) echo -e "${TIMESTAMP} ${ACTION} ${1^^} ${@:2}" | \
                tee ${LOG} >> /dev/stderr
                ;;
            *) help_debug && exit 1
                ;;
        esac
    fi
}
# <span id="help_debug" /> ([top](#FUNCTIONS))
help_debug() {
    echo """Chybné nastavení pro debug –> $1

Pro debug lze použít pouze čísla od 1 do 9. Nastavení lze provést těmito způsoby:

    … -d2 …
    … -d 2 …
    … -d=2 …
    … --debug 2 …
    … --debug=2 …

  0 Je výchozí stav, při kterém se logovací zprávy nevypisují nikam.
  1 Vypisuje pouze chybové (ERR) zprávy pouze na standardní chybový
    výstup.
  2 Zapisuje pouze do logu a pouze chybové (ERR) zprávy.
  3 Vypisuje chybové (ERR) zprávy na standardní výstup a zároveň je
    zapisuje do logu.
  4 Vypisuje chybové (ERR) a varovné (WARN) zprávy pouze na standardní
    chybový výstup.
  5 Zapisuje chybové (ERR) a varovné (WARN) zprávy pouze do logu.
  6 Zapisuje chybové (ERR) a varovné (WARN) zprávy na standardní výstup
    a zároveň je zapisuje do logu.
  7 Vypisuje všechny zprávy pouze na standardní chybový výstup.
  8 Zapisuje všechny zprávy pouze do logu.
  9 Vypisuje všechny zprávy na standardní výstup a zároveň je zapisuje
    do logu.
"""
}

function pushd {
    command pushd "$@" > /dev/null
}

function popd {
    command popd "$@" > /dev/null
}

# ### <span id="filepath">filepath()</span> ([top](#FUNCTIONS))
# Funkce na základě předaného jména (parametr __$1__) zjišťuje skutečnou
# cestu k souboru.
# V případě že cílový soubor neexistuje, je návratový kód __1__
filepath() {
    local SOURCE=$(${REALPATH} -m -P "${1}")
    if [ -n "${SOURCE}" ] ; then
        FILEFULL="${SOURCE}"
        FILEPATH="${SOURCE%/*}"
        FILENAME="${SOURCE##*/}"
        FILESUFFIX="${FILENAME##*\.}"
        return 0
    else
        return 1
    fi
}

# ### <span id="anone">anone()</span> ([top](#FUNCTIONS))
# Ověřovací funkce.
# V případě, že se lze pokračovat v realizaci akce vrací __0__,
# v opačném případě __1__.
anone() {
    if [ -n "${1}" ] ; then
        if [ "${FORCE}" != "yes" ] ; then
            echo "$1"
            while true ; do
#                read -p "(ANO/NE) : " yn
                read -er yn
                case $yn in
                    [AaYy]*) break;;
                    [Nn]*) return 1;;
                    *) echo "Napište ANO či NE:";;
                esac
            done
        fi
        return 0
    else
        log warn "anone() Not value"
        return 1
    fi
}

function potvrdit {
    read -r -p "${1:-Opravdu chcete akci provést? [y/N]} " response
    case $response in
        [yY][eE][sS]|[yY]) 
            true
            ;;
        [aA][nN][oO]|[aA]) 
            true
            ;;
        *)
            false
            ;;
    esac
}

function printtext {
	echo "${#1}" >> /dev/stderr
	echo -e "${@}"
}

function escape_path {
# Zatím nepoužitá
	echo "escape_path $*" >> /dev/stderr
	echo "$*" | sed \
  -e 's/\ /\\\ /g'
}

function extractmaparea {
	if [ $1 == "(maparea" ] ; then
		if [ $2 == "(url" ] ; then
			echo "URL ($3 $4"
			shift && shift && shift && shift
		else
			echo "NOTE $2"
			shift && shift
		fi
		echo -e $@ | sed 's/ (/\n(/g' | sed 's/^/\t/' | sed 's/))/)/'
	fi
}

function createant {
	# $1 - na vstupu je obsah souboru formátu .ant
	# na výstupu je obsah v .dsed formátu
	local IFS_BAK=$IFS
	local IFS=$'\n'
	local TEMP
	local META
	while read line ; do
		if [[ "${line:0:1}" == $'\t' ]] ; then
			TEMP="$TEMP ${line:1}"
			#TEMP="$TEMP${line}"
		elif [[ "${line:0:1}" == $';' ]] ; then
			echo "Komentář - Ignoruji" >> ${LOG}
		elif [[ "${line:0:1}" == $'#' ]] ; then
			local PAGE="${line#* }"
			if [[ "${PAGE%.*}" == "shared_anno" ]] ; then
				printf "select \"%s.iff\"\nset-ant\n" "${PAGE%.*}" >> ${LOG}
			else
				printf "select \"%s.djvu\"\nset-ant\n" "${PAGE%.*}" >> ${LOG}
			fi
		else
			if [[ "${line:0:4}" == $'NOTE' ]] ; then
				[ "${#TEMP}" != "0" ] && echo "$TEMP )"
				TEMP="(maparea ${line//NOTE /}"
			elif [[ "${line:0:4}" == $'URL ' ]] ; then
				[ "${#TEMP}" != "0" ] &&  echo "$TEMP )"
				TEMP="(maparea ${line//URL (/(url }"
			else
				META="$META ( $line )"
			fi
		fi
	done < $1
	[ "${#TEMP}" != "0" ] && echo "$TEMP )"
	echo "(metadata $META )"
	local IFS=$IFS_BAK
	return 0
}

# ### <span id="anttodsed">anttodsed()</span> ([top](#FUNCTIONS))
# Funkce převádí obsah .ant souboru na formát .dsed, který lze naimportovat
# do DjVu souboru.
# Výstup funkce se zapisuje rovnou do souborů s příponou .dsed, umístěných
# v cílovém adresáři
#
# Používá se úpravách textové vrstvy DjVu souborů
anttodsed() {
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	if [ ! -z "${SOURCE}" ] ; then
		local OBSAH=($(wc -l ${SOURCE}))
		local ITEMS=($(grep -n '^#' ${SOURCE} | awk -F\: '{print $1}'))
		local index=0
		for i in ${ITEMS[@]} ; do
			index=$(( $index + 1 ))
			# soubor...
			local SOUBOR=($(sed -n "${i}p" ${SOURCE}))
			local TEMPFILE="${TEMPDIR}/${SOUBOR['1']%.*}.bak"
			if [ "${SOUBOR['1']%.*}" == "shared_anno" ] ; then
				printf "create-shared-ant; select '%s'\nset-ant\n" "${SOUBOR['1']%.*}.iff" >> ${TEMPFILE//.bak/.dsed}
			else
				printf "select '%s'\nset-ant\n" "${SOUBOR['1']%.*}.djvu" >>  ${TEMPFILE//.bak/.dsed}
			fi
			if [ -z ${ITEMS["$index"]} ] ; then
				sed -n "${i},${OBSAH['0']}p" ${SOURCE} >> ${TEMPFILE}
				createant ${TEMPFILE} | encode >> ${TEMPFILE//.bak/.dsed}
			else
				sed -n "${i},$((${ITEMS["$index"]} - 1))p" ${SOURCE} >> ${TEMPFILE}
				createant ${TEMPFILE} | encode >> ${TEMPFILE//.bak/.dsed}
			fi
			printf "\n\n.\n" >> ${TEMPFILE//.bak/.dsed}
		done
		echo "Soubory jsou uloženy v adresáři ${TEMPDIR}"
	fi
}

# ### 
# $1 - DjVu
# $2 - .ant file
# $3 - select parameters
important() {
    if [ "$(head -1 -c1 ${2})" == "#" ] ; then
        # jdu importovat položky...
        local OBSAH=($(wc -l ${2}))
        local ITEMS=($(grep -n '^#' ${2} | awk -F\: '{print $1}'))
        local index=0
        for i in ${ITEMS[@]} ; do
            index=$(( $index + 1 ))
            # soubor...
            local SOUBOR=($(sed -n "${i}p" ${2}))
            local ANTFILE=$(tempfile -d ${TEMPDIR} -s .dsed)
            local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .dsed)
            echo "${SOUBOR[@]}" >> /dev/stderr
            if [ "${SOUBOR['1']%.*}" == "shared_anno" ] ; then
                printf "create-shared-ant; select '%s'\nset-ant\n" "${SOUBOR['1']%.*}.iff" >> ${ANTFILE}
            else
                printf "select '%s'\nset-ant\n" "${SOUBOR['1']%.*}.djvu" >>  ${ANTFILE}
            fi
            if [ -z ${ITEMS["$index"]} ] ; then
                sed -n "${i},${OBSAH['0']}p" ${2} >> ${ANTFILE}
                createant ${ANTFILE} | encode >> ${TEMPFILE}
            else
                sed -n "${i},$((${ITEMS["$index"]} - 1))p" ${2} >> ${ANTFILE}
                createant ${ANTFILE} | encode >> ${TEMPFILE}
            fi
            printf "\n\n.\n" >> ${TEMPFILE}
            printf "Při importu budou stávající hyperlinky i meta atributy stránky ${SOUBOR['1']} v souboru '%s' přepsány. Mám pokračovat?\n" "${SOURCE}" >> /dev/stderr
            echo "Importuji soubor ${TEMPFILE}" >> /dev/stderr
        done
    else
        echo "File ${2} isn't not in .ant format!" >> /dev/stderr
        return 1
    fi
}

function important1 {
	# $1 - DjVu
	# $2 - .ant file
	# $3 - select parameters
	echo ${1} >> /dev/stderr
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	if [ ! -z "${SOURCE}" ] ; then
		local ANT=$(${REALPATH} -m -P "${2}")
		if [ "$(head -1 -c1 ${ANT})" == "#" ] ; then
			# jdu importovat položky...
			local OBSAH=($(wc -l ${ANT}))
			local ITEMS=($(grep -n '^#' ${ANT} | awk -F\: '{print $1}'))
			local index=0
			for i in ${ITEMS[@]} ; do
				index=$(( $index + 1 ))
				# soubor...
				local SOUBOR=($(sed -n "${i}p" ${ANT}))
				local TEMPFILE="${TEMPDIR}/${SOUBOR['1']%.*}.bak"
				if [ "${SOUBOR['1']%.*}" == "shared_anno" ] ; then
					printf "create-shared-ant; select '%s'\nset-ant\n" "${SOUBOR['1']%.*}.iff" >> ${TEMPFILE//.bak/.dsed}
				else
					printf "select '%s'\nset-ant\n" "${SOUBOR['1']%.*}.djvu" >>  ${TEMPFILE//.bak/.dsed}
				fi
				if [ -z ${ITEMS["$index"]} ] ; then
					sed -n "${i},${OBSAH['0']}p" ${ANT} >> ${TEMPFILE}
					createant ${TEMPFILE} | encode >> ${TEMPFILE//.bak/.dsed}
				else
					sed -n "${i},$((${ITEMS["$index"]} - 1))p" ${ANT} >> ${TEMPFILE}
					createant ${TEMPFILE} | encode >> ${TEMPFILE//.bak/.dsed}
				fi
				printf "\n\n.\n" >> ${TEMPFILE//.bak/.dsed}
				if [ "${FORCE}" == "skip" ] ; then
					printf "Při importu budou stávající hyperlinky i meta atributy stránky ${SOUBOR['1']} v souboru '%s' přepsány. Mám pokračovat?\n" "${SOURCE}" >> /dev/stderr
					potvrdit
					echo "${FORCE}" >> /dev/stderr
				else
					echo "${FORCE}" >> /dev/stderr
				fi
			done
		else
			printf "File ${ANT} isn't not in .ant format!" >> /dev/stderr
			exit 1
		fi
	fi
}

testsyntaxant() {
    while read -r line ; do
        local OK="OK –> ${line}"
        local ERR="ERR –> Chybí typ datového bloku"
        local INVALID="INVALID –> Neplatný typ datového bloku"
        case "${line}" in
            \#+([[:blank:]])+([[:digit:]])) echo "Adresa" >> /dev/stderr
                printf "select; remove-ant\n"
                printf "# ------------------------- \n"
                printf "select '%d'\n" "${line##\#+([[:blank:]])}"
                printf "set-ant\n"
            ;;
            \#+([[:blank:]])*) echo "Adresa" >> /dev/stderr
                printf "select; remove-ant\n"
                printf "# ------------------------- \n"
                printf "select '%s'\n" "${line##\#+([[:blank:]])}"
                printf "set-ant\n"
            ;;
            metadata) local META='metadata'
            ;;
            maparea) local META='maparea'
            ;;
            +([[:digit:]])+([[:blank:]])*)
                [ -n "${META}" ] || echo "${ERR}" >> /dev/stderr
                echo "Klíč ${line%% *} tvořený pouze číslem sice DjVu sežere, ale prohlížeč nezobrazí" >> /dev/stderr
            ;;
            +([[:alnum:]])+([[:blank:]])\"+([[:alpha:]])*\") #/ klíč začínající číslem sice sežere, ale nezobrazí
                [ -n "${META}" ] || echo "${ERR}" >> /dev/stderr
                KEYS="${KEYS} (${line})"
            ;;
            url+([[:blank:]])\"*\"+([[:blank:]])\"*\")
                [ -n "${META}" ] || echo "${ERR}" >> /dev/stderr
                [ -n "${URL}" ] && echo "URL už je nastaveno!" >> /dev/stderr && return 1
                local TEMPORAR=(${line})
                if [ ${#TEMPORAR[@]} -eq 4 ] ; then
                    URL="(${line[0]} ${line[1]} ${line[2]}) ${line[3]}"
                else
                    echo "Neplatné nastavení URL –> ${line}"
                    return 1
                fi
            ;;
            \"*\"+([[:blank:]])\"*\") #maparea bez URL
                [ -n "${META}" ] || echo "${ERR}" >> /dev/stderr
                [ -n "${URL}" ] && echo "URL už je nastaveno!" >> /dev/stderr && return 1
                URL="${line}"
            ;;
            rect|oval|poly|line|text)
                [ -n "${META}" ] || echo "${ERR}" >> /dev/stderr
                BORDER="${line}"
            ;;
            shadow_*) # stínování - číslem uvedená tloušťka
            ;;
            hilite+([[:blank:]])\#+([[:digit:]])) # barva vysvícení
            ;;
            pushpin) # špendlík
            ;;
            arrow) # šipka
            ;;
            border_avis)
            ;;
            xor|none)
                [ -n "${META}" ] || echo "${ERR}" >> /dev/stderr
                [ "${META}" == "maparea" ] || echo "${INVALID}" >> /dev/stderr
                [ ! -n "${BORDER}" ] && echo "Nejprve musí být nastavea oblast!" >> /dev/stderr
                TEMPORAR="(${BORDER} ) (${line} )" && unset BORDER
            ;;
            border+([[:blank:]])+([[:digit:]]))
                [ -n "${META}" ] || echo "${ERR}" >> /dev/stderr
                [ "${META}" == "maparea" ] || echo "${INVALID}" >> /dev/stderr
                [ ! -n "${BORDER}" ] && echo "Nejprve musí být nastavena oblast!" >> /dev/stderr
                TEMPORAR="(${BORDER} ) (${line} )" && unset BORDER
            ;;
            '') #echo "Prázdný řádek - vypíše položku a vypne přechozí volbu"
                if [ "${META}" == "metadata" ] ; then
                    printf "(${META} ${KEYS}) "
                    unset META
                    unset KEYS
                elif [ "${META}" == "maparea" ] ; then
                    printf "(${META} ${URL} ${KEYS}) "
                    unset META
                    unset URL
                    unset KEYS
                fi
            ;;
            *) echo "Na řádku je chyba –> ${line}" >> /dev/stderr
                return 1
            ;;
        esac
    done < $1
    printf "\n.\n"
}

# ###
# Funkce pro zpracování výstupu příkazu output-ant
testsyntaxdsed() {
    local ANTFILE=$(tempfile -d ${TEMPDIR} -s .ant)
    local TXTFILE=$(tempfile -d ${TEMPDIR} -s .txt)
    while read -r line ; do
        case "${line}" in
            select\;*) # Následuje výstup příkazu output-ant
                local ALL="yes"
            ;;
            select+([[:blank:]])\"*) # Následuje výstup příkazu output-ant
                local PAGE="# ${line#select+([[:blank:]])}"
                echo "${PAGE}"
            ;;
            set-ant) local ANT="yes"
            ;;
            set-txt) local TXT="yes"
            ;;
            \.) if [ -n "${ANT}" ] ; then
                    cat ${ANTFILE} | formatdsed
                    unset ANT
                elif [ -n "${TXT}" ] ; then
                    cat ${TXTFILE} | formatdsed
                    unset TXT
                fi
            ;;
            \#+([[:blank:]])+(-)) # echo "Konec stránky" >> /dev/stderr
                unset PAGE
            ;;
            *) if [ -n "${ANT}" ] ; then
                    echo "${line}" >> ${ANTFILE}
                elif [ -n "${TXT}" ] ; then
                    echo "${line}" >> ${TXTFILE}
                fi
            ;;
        esac
    done < $1
}

# ###
# Konvertuje stream v .dsed formátu do formátu .ant
#
#/ # ------------------------- 
#/ select "shared_anno.iff"
#/ set-ant
#/ (background #000000 ) (zoom d50 ) 
#/ .
# 
formatdsed() {
    sed 's/\t/\n/g ; s/(/\n(/g ; s/("/\n\t"/g ; ' | grep -v ^$ | \
    sed '/^(m[ea][tp]a[dr][ae][ta]/! s/^(/\t(/ ; /^\t($/d ; s/) ) )/) )/ ; s/\\/\\\\0/g' | \
    while read line ; do
        #echo "zpracovávám ${line}" >> /dev/stderr
        case ${line} in
            \(metadata) echo -e "metadata"
                local TAB=""
            ;;
            \(maparea+([[:blank:]])\") echo -e "\n"
                local TAB="\t"
            ;;
            \(note+([[:blank:]])\"*) local TEMPORAR="${line#(}"
                echo -e "${TEMPORAR%\)}"
                unset TEMPORAR
                unset TAB
            ;;
            *) if [ "${TAB}" == "\t" ] ; then
                    case "${line:0:2}" in
                        "(u") local TEMPORAR="${line#(}"
                            echo "maparea"
                            echo -e "${TAB}${TEMPORAR//\) /}"
                            unset TEMPORAR
                        ;;
                        *)
                            local TEMPORAR="${line#(}"
                            echo -e "${TAB}${TEMPORAR// \)/}"
                            unset TEMPORAR
                        ;;
                    esac
                else
                    local TEMPORAR="${line//[)(]/}"
                    case "${TEMPORAR}" in
                        maparea*) echo -e "${TEMPORAR/ /\\\n\\\t}"
                            unset TEMPORAR
                        ;;
                        background*|zoom*) local TEMPORAR="${line#(}"
                            echo -e "${TEMPORAR// \)/}"
                            unset TEMPORAR
                        ;;
                        *) echo -e "\t${TEMPORAR}"
                            unset TEMPORAR
                        ;;
                    esac
                fi
            ;;
        esac
    done  | sed 's/) )/)/ ; /^$/d '
}

function formatdsed1 {
	# .dsed to .ant
	sed 's/\t/\n/g ; s/(/\n(/g ; s/("/\n\t"/g ; ' | grep -v ^$ | \
	sed '/^(m[ea][tp]a[dr][ae][ta]/! s/^(/\t(/ ; /^\t($/d ; s/) ) )/) )/ ; s/\\/\\\\0/g' | \
	while read line ; do
		case ${line} in
			\(metadata) local TAB=""
				;;
			\(maparea) echo -e "\n"
				local TAB="\t"
			 ;;
			\"*) echo -e "NOTE ${line}"
			;;
			*) if [ "${TAB}" == "\t" ] ; then
					case "${line:0:2}" in
						"(u") echo -e "URL (${line#(url }"
						;;
						*) echo -e "${TAB}${line}"
						;;
					esac
				else
					echo -e "${line//[)(]/}"
				fi
			;;
		esac
	done  | sed 's/) )/)/ ; /^$/d '
}

# ### <span id="printant">printant()</span> ([top](#FUNCTIONS))
# Nahrazeno přímo ve funkci fromdjvu
function printant1 {
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	TEMPFILE=$(tempfile -d ${TEMPDIR} -s .txt)
	local CHARSET="${2}"
	local RANGE="${CHARSET%%\ *}"
	if identifybundle ${SOURCE} ; then
		if [ "${RANGE}" == "all" ] ; then
			if ${DJVM} -l ${SOURCE} 2>/dev/null | grep SHARED_ANNO &>/dev/null ; then
				printf "# 'shared_anno.iff'\n"
				${DJVUSED} ${SOURCE} -e "select 'shared_anno.iff'; print-ant" | formatdsed
			fi
			for i in $(${DJVM} -l ${SOURCE} | grep PAGE\ # | awk '{print $4}') ; do
				printf "# '%s'\n" "$i"
				${DJVUSED} ${SOURCE} -e "select '$i'; print-ant" | formatdsed
			done
		elif [ "${RANGE//+([[:alpha:]])/}" == "" ] ; then
			if ${DJVM} -l ${SOURCE} 2>/dev/null | grep SHARED_ANNO &>/dev/null ; then
				printf "# 'shared_anno.iff'\n"
				${DJVUSED} ${SOURCE} -e "select 'shared_anno.iff'; print-ant" | formatdsed
			fi
		elif [ "${RANGE}" != "${RANGE/[a-Z]/}" ] ; then
			# zkontrolovat jestli range není seznam stránek
			# tj. obsahuje písmena
			for i in ${RANGE//,/ } ; do
				local PAGE=$(identifypage name "${SOURCE}" ${i})
				if  [ ! -z "${PAGE}" ] ; then
					printf "# '%s'\n" "${PAGE#*:}"
					${DJVUSED} ${SOURCE} -e "select '${PAGE#*:}'; print-ant" 2>/dev/null | formatdsed
				fi
			done
		else
			local IDPAGES=($(range "${RANGE}" | sort -n))
			local PAGES=($(${DJVM} -l ${SOURCE} | grep PAGE\ # | awk '{print $4}'))
			local ITEM="${CHARSET#* }"
			local KEY=(${ITEM})
			for i in ${IDPAGES[@]} ; do
				local PAGE="${PAGES[$((${i} -1))]}"
				if [ ! -z "${PAGE}" ] ; then
					printf "# '%s'\n" "${PAGE}"
					${DJVUSED} ${SOURCE} -e "select '${PAGE}'; print-ant" | formatdsed
				fi
			done
		fi
	else
		# Single page
		local PAGE=$(identifypage name "${SOURCE}" 1)
		printf "# '%s'\n" "${PAGE}"
		${DJVUSED} ${SOURCE} -e "select 1; print-ant" | formatdsed
	fi
}

# ### <span id="printmeta">printmeta()</span> ([top](#FUNCTIONS))
# Odstraňuje z DjVu Bundle svazku stránky
#
# $1 - svazek
# $2 - identifikátor, klíčové slovo 'all' nebo atribut
printmeta() {
    log goto "printmeta() ${1} –> ${2}"
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	case "${2}" in
		all) log info "printmeta() All meta attributes for %s\n" "${FILE}"
			local META=$(${DJVUSED} "${SOURCE}" -e "select; print-meta" | sed 's/\\/\\0/g')
			if [ -n "${META}" ] ; then
				echo "#"
				echo -e "${META}" | tr '\000' '\\'
				echo -e "\n."
			fi
			for i in $(seq $(lastpage ${SOURCE})) ; do
				local PAGENAME=$(identifypage name "${SOURCE}" "${i}")
				local META=$(${DJVUSED} "${SOURCE}" -e "select '${PAGENAME}'; print-meta" | sed 's/\\/\\0/g')
				if [ -n "${META}" ] ; then
					echo "#$i '${PAGENAME}'"
					echo -e "${META}" | tr '\000' '\\'
					echo -e "\n."
				fi
			done
		;;
		global) printf "printmeta: Global meta attributes from %s\n" "${FILE}" >> ${LOG}
			local META=$(${DJVUSED} "${SOURCE}" -e "select; print-meta" | sed 's/\\/\\0/g')
			if [ ! -z "${META}" ] ; then
				echo "#"
				echo -e "${META}" | tr '\000' '\\'
				echo -e "\n."
			fi
		;;
		+([[:digit:]])|*.djvu) printf "printmeta: Meta attributes for page %s from %s\n" "${2}" "${FILE}" >> ${LOG}
			local PAGENAME=$(identifypage name "${SOURCE}" "${2}")
			if [ ! -z "${PAGENAME}" ] ; then
				local IDPAGE=$(identifypage order "${SOURCE}" "${PAGENAME}")
				local META=$(${DJVUSED} "${SOURCE}" -e "select '${PAGENAME}'; print-meta" | sed 's/\\/\\0/g')
				if [ ! -z "${META}" ] ; then
					echo "#${IDPAGE} '${PAGENAME}'"
					echo -e "${META}" | tr '\000' '\\'
					echo -e "\n."
				fi
			fi
		;;
		*) printmeta "${SOURCE}" all
		;;
	esac
}

# ### <span id="printoutline">printoutline()</span> ([top](#FUNCTIONS))
# V původní podobě byl výsledek zapsán do souboru s příponou .outline
# V tomto příoa
printoutline() {
    log goto "printoutline() $1 –> $2"
	# $1 - DjVu file
	# $2 - cíl
    bookmarktooutline "${1}"
    return 0
    # bookmarktooutline "${1}" | awk '{print i++ "\t|" $0}'
}

function printoutline1 {
    log goto "fromcontainer() ${PGMTOPBM} ${FILETYPE} $1 –> $2"
	# $1 - DjVu file
	# $2 - cíl
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	if [ -z "${2}" ] ; then
		bookmarktooutline "${SOURCE}" | awk '{print i++ "\t|" $0}'
	elif [ -f "${2}" ] ; then
		bookmarktooutline "${SOURCE}" >> "${2}"
	elif [ -d "${2}" ] ; then
		if [ -f "${2}/${FILE//.djvu/.outline}" ] ; then
			echo "Overwrite file ${2}/${FILE//.djvu/.outline}?" >> /dev/stderr
			potvrdit
			bookmarktooutline "${SOURCE}" > "${2}/${FILE//.djvu/.outline}"
		else
			bookmarktooutline "${SOURCE}" > "${2}/${FILE//.djvu/.outline}"
		fi
	else
		bookmarktooutline "${SOURCE}"
	fi
	return 0
}

function djvuimport {
	# Import nevkládá nové stránky, ale importuje soubory textové vrstvy
	# $1 - DjVu file
	# $2 - soubor identifikátor + cílový adresář
	#echo "1- ${1}" >> /dev/stderr
	#echo "2- ${2}" >> /dev/stderr
	#echo "3- ${3}" >> /dev/stderr
	local SOURCE=$(${REALPATH} -m -P "${1}")
	echo "djvuimport: SOURCE ${SOURCE}" >> /dev/stderr
	local FILE="${SOURCE##*/}"
	if [ -z "${2}" ] ; then
		local FROM=$(${REALPATH} -m -P "$(pwd)")
		echo "djvuimport: FROM ${FROM}" >> /dev/stderr
	else
		local FROM=$(${REALPATH} -m -P "${2}")
		echo "djvuimport: FROM ${FROM}" >> /dev/stderr
	fi

	if [ -d "${FROM}" ] ; then
		local LIST=$(djvuinfo "${SOURCE}" list)
		local IFS_BAK=$IFS
		local IFS=$'\n'
		for i in  ${LIST} ; do

			local PAGENAME="${i##*:}"
			log info "djvuimport() Hledám soubory pro import dat do stránky ${PAGENAME} v souboru ${FILE}"
			if [ -f "${FROM}/${PAGENAME/.djvu/.dsed}" ] ; then
				importdsedpage "${SOURCE}" "${PAGENAME}" "${FROM}/${PAGENAME/.djvu/.dsed}"
			fi
			if [ -f "${FROM}/${PAGENAME/.djvu/.xml}" ] ; then
				importxmlpage "${SOURCE}" "${FROM}/${PAGENAME/.djvu/.xml}"
			fi
			if [ -f "${FROM}/${PAGENAME/.djvu/.meta}" ] ; then
				importmetapage "${SOURCE}" "${PAGENAME}" "${FROM}/${PAGENAME/.djvu/.meta}"
			fi

		done
		local IFS=$IFS_BAK
		log info "djvuimport() Importuji meta atributy a obsah pro celý soubor ${FILE}"
		# Import obsahu souboru..
		if [ -f "${FROM}/${FILE/.djvu/.meta}" ] ; then
			importmetaall "${SOURCE}" "${FROM}/${FILE/.djvu/.meta}"
		fi
		if [ -f "${FROM}/${FILE/.djvu/.outline}" ] ; then
			importoutline "${SOURCE}" "${FROM}/${FILE/.djvu/.outline}"
		fi
	elif [ -f "${FROM}" ] ; then
		case "$(head -c 1 ${FROM})" in
			\<) echo "import: import XML file" >> /dev/stderr
				XML="yes"
				importxmlpage "${SOURCE}" "${FROM}"
				return 0
			;;
			s) echo "import: import file in dsed format" >> /dev/stderr
				DSED="yes"
				importdsedall "${SOURCE}" "${FROM}"
				return 0
			;;
			\") echo "import: import outline file" >> /dev/stderr
				local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .outline)
				outlinetodsed "${FROM}" | encode > "${TEMPFILE}"
				importoutline "${SOURCE}" "${TEMPFILE}"
				return 0
			;;
			\() echo "import: import outline in dsed format" >> /dev/stderr
				"${SOURCE}" 
				importoutline "${SOURCE}" "${FROM}"
				return 0
			;;
			\#) echo "import: import meta atribute file" >> /dev/stderr
				META="yes"
				importmeta "${SOURCE}" "${FROM}"
				return 0
			;;
			[[:alpha:]]) echo "import: meta TODO atribute file for one page - not implemented" >> /dev/stderr
				echo "může jít i o seznam stránek k importu do souboru.." >> /dev/stderr
				local FROMFILE="${FROM##*/}"
				#echo  "${FILE%.*} ${FROMFILE%.*}" >> /dev/stderr
				log info "djvuimport() Importuji data do stránky ${FROMFILE}"
				local LIST=$(djvuinfo "${SOURCE}" list)
				local IFS_BAK=$IFS
				local IFS=$'\n'
				for i in  ${LIST} ; do
					local PAGENAME="${i##*:}"
					if [ "${PAGENAME%.*}" == "${FROMFILE%.*}" ] ; then
						echo "Importuji data ze souboru ${FROM} do stránky ${PAGENAME} v souboru ${FILE}" >> /dev/stderr
						case "${FROMFILE}" in
							*.dsed) DSED="yes"
								importdsedpage "${SOURCE}" "${PAGENAME}" "${FROM}"
							;;
							*.meta) META="yes"
								importmeta "${SOURCE}" "${PAGENAME}" "${FROM}"
							;;
							*.xml) XML="yes"
								importxmlpage "${SOURCE}" "${FROM}"
							;;
							*) echo "import: Při importu textových dat do stránky jsou akceptovány pouze soubory s příponou .dsed, .xml a .meta" >> /dev/stderr
							;;
						esac
					fi
				done
				local IFS=$IFS_BAK
				return 0
			;;
			*) echo "import: FAIL - unknown file" >> /dev/stderr
				exit 1
			;;
		esac
	else
		echo "import: Parametrem akce import může být buď adresář se soubory, nebo soubor s daty k importu" >> /dev/stderr
		exit 1
	fi
}

function djvuexport {
	# $1 - DjVu file
	# $2 - identifikátor + cílový adresář
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"

	# Parsing $2
	local CHARSTRING="$2"
	if [ "${CHARSTRING}" == "" ] ; then
		help keywords-export
		exit 0
	fi

#	echo "${PAGE} ${DSED} ${XML} ${IMG} ${META} ${FORCE} option" >> /dev/stderr
	export EXPORTVALUE=0
	[ "${PAGE}" != "no" ] && export EXPORTVALUE=$(( $EXPORTVALUE + 1 )) && echo "actual $EXPORTVALUE" >> /dev/stderr
	[ "${IMG}" != "no" ] && export EXPORTVALUE=$(( $EXPORTVALUE + 2 )) && echo "actual $EXPORTVALUE" >> /dev/stderr
	[ "${XML}" != "no" ] && export EXPORTVALUE=$(( $EXPORTVALUE + 4 )) && echo "actual $EXPORTVALUE" >> /dev/stderr
	[ "${META}" != "no" ] && export EXPORTVALUE=$(( $EXPORTVALUE + 8 )) && echo "actual $EXPORTVALUE" >> /dev/stderr
	[ "${DSED}" != "no" ] && export EXPORTVALUE=$(( $EXPORTVALUE + 16 )) && echo "actual $EXPORTVALUE" >> /dev/stderr
#	if [ "${PAGE}" == "no" ] && [ "${DSED}" == "no" ] && [ "${XML}" == "no" ] && [ "${IMG}" == "no" ] && [ "${META}" == "no" ] ; then

	if  [ "${FORCE}" == "skip" ] ; then
		# Interaktivní mód
		printf "export: For export from DjVu bundle we must use any option\n" >> /dev/stderr
		# Co mám vyexportovat ze svazku?
		# 1) pouze stránky ve formátu DjVu
		# 2) pouze náhledy stránek ve formátu PNG
		# 3) 0+P
		# 4) pouze xml soubory textové vrstvy
		# 5) X+P
		# 6) X+O
		# 7) X+O+P
		# 8) pouze metainformace
		# 9) M+P
		# 10) M+O
		# 11) M+O+P
		# 12) M+X
		# 13) M+X+P
		# 14) M+X+O
		# 15) M+X+O+P
		# 16) pouze dsed soubory
		# 17) D+P
		# 18) D+O
		# 19) D+O+P
		# 20) D+X
		# 21) D+X+P
		# 22) D+X+O
		# 23) D+X+O+P
		# 24) D+M
		# 25) D+M+P
		# 26) D+M+O
		# 27) D+M+O+P
		# 28) D+M+X
		# 29) D+M+X+P
		# 30) D+M+X+O
		# 31) D+M+X+O+P
		printf "Export of DjVu pages from bundle?\n" >> /dev/stderr
		potvrdit && export EXPORTVALUE=$(( $EXPORTVALUE + 1 ))
		printf "Export pages as PNG too?\n" >> /dev/stderr
		potvrdit && export EXPORTVALUE=$(( $EXPORTVALUE + 2 ))
		printf "Export text layer as XML file?\n" >> /dev/stderr
		potvrdit && export EXPORTVALUE=$(( $EXPORTVALUE + 4 ))
		printf "Export meta and outline from bundle?\n" >> /dev/stderr
		potvrdit && export EXPORTVALUE=$(( $EXPORTVALUE + 8 ))
		printf "Export text from bundle in DSED format?\n" >> /dev/stderr
		potvrdit && export EXPORTVALUE=$(( $EXPORTVALUE + 16 ))
#		echo "Budu zpracovávat $EXPORTVALUE"
	fi

	if [ $EXPORTVALUE == 0 ] ; then
		printf "export: Options are necessary for specify of content for export from DjVu bundle.\n" >> /dev/stderr
		return 1
	fi

	local CHARCOUNT=$((${#CHARSTRING} + 1))
	local CHARPOS=0
	local STRPOS=0
	while [ "${CHARCOUNT}" -gt "0" ] ; do
		case "${CHARSTRING:0:$((${CHARPOS} - ${STRPOS}))}" in
			*.[dD][jJ][vV][uU]) local PAGENAME="${CHARSTRING:0:$((${CHARPOS} - ${STRPOS}))}"
				local STRPOS="${CHARPOS}"
				local CHARSTRING="${CHARSTRING#${PAGENAME}}"
				local CHARCOUNT=$((${#CHARSTRING} + 1))
			;;
		esac
		local CHARPOS=$((CHARPOS + 1))
		local CHARCOUNT=$((CHARCOUNT - 1))
	done

	if [  -z "${CHARSTRING}" ] ; then
		if [ -z "${PAGENAME}" ] ; then
			log info "djvuexport() Export all pages from ${FILE} into aktual directory - do set TARGETDIR"
			local TARGETDIR=$(targetdir $(pwd))
			exportdjvuall "${SOURCE}" "${TARGETDIR}"
			return 0
		else
			log info "djvuexport() Export page identificated by ${PAGENAME} from ${FILE} into aktual directory - do set TARGETDIR"
			local IDPAGE=$(identifypage order "${SOURCE}" "${PAGENAME}")
			if [ -z "${IDPAGE}" ] ; then
				case "${PAGENAME%%\ *}" in
					meta) printmeta "${SOURCE}" "${PAGENAME#* }"
						return 0
					;;
					*) echo "export: In ${FILE} is not any page identificated by ${PAGENAME}"  >> /dev/stderr &&  exit 1
					;;
				esac
			else
				local NAMEPAGE=$(identifypage name "${SOURCE}" "${PAGENAME}")
				local TARGETDIR=$(targetdir $(pwd))
			fi
		fi
	else
		if [ -z "${PAGENAME}" ] ; then
			local TEMP=${CHARSTRING##+([[:blank:]])}
			local IDPAGE=${TEMP%%+([[:blank:]])*}
			local CHARSTRING=${TEMP#${IDPAGE}}
			local TARGETDIR=${CHARSTRING##+([[:blank:]])}
			# Tady může být nějaký jiný parametr, než pořadové číslo, a také TARGETDIR může být prázdný.
			case "${IDPAGE}" in
				all) if [ -z "${TARGETDIR}" ] ; then
						log info "djvuexport() Export all pages from ${FILE} into actual directory - do set TARGETDIR"
						local TARGETDIR=$(targetdir $(pwd))
						exportdjvuall "${SOURCE}" "${TARGETDIR}"
						return 0
					else
						log info "djvuexport() Export all pages from ${FILE} into ${TARGETDIR}"
						local TARGETDIR=$(targetdir "${TARGETDIR}")
						exportdjvuall "${SOURCE}" "${TARGETDIR}"
						return 0
					fi
				;;
				meta) printmeta "${SOURCE}" "${TARGETDIR}"
					return 0
				;;
				outline) bookmarktooutline "${SOURCE}"
					return 0
				;;
				*) log info "djvuexport() Export page identificated by order -${IDPAGE}- from ${FILE} into -${TARGETDIR}-"
					local NAMEPAGE=$(identifypage name "${SOURCE}" "${IDPAGE}")
					if [ -z "${NAMEPAGE}" ] ; then
						# djvutool bundle.djvu export
						if [ -e "${IDPAGE}" ] ; then
							if [ -d "${IDPAGE}" ] ; then
								djvuexport "${SOURCE}" "all ${IDPAGE}"
							else
								echo "export: In ${FILE} is not any page on position ${IDPAGE}"  >> /dev/stderr &&  exit 1
							fi
						else
							djvuexport "${SOURCE}" "all ${IDPAGE}"
						fi
					else
						local TARGETDIR=$(targetdir "${TARGETDIR}")
					fi
				;;
			esac
		else
			local NAMEPAGE=${PAGENAME##+([[:blank:]])}
			local TARGETDIR=${CHARSTRING##+([[:blank:]])}
			log info "djvuexport() Export page identificated by name -${NAMEPAGE}- from ${FILE} into -${TARGETDIR}-"
			local IDPAGE=$(identifypage order "${SOURCE}" "${NAMEPAGE}")
			[ -z "${IDPAGE}" ] && echo "export: In ${FILE} is not any page with name ${NAMEPAGE}" >> /dev/stderr &&  exit 1
			local TARGETDIR=$(targetdir "${TARGETDIR}")
		fi
	fi

#	echo "export: SOURCE ${SOURCE}">> /dev/stderr
#	echo "export: FILE ${FILE}">> /dev/stderr
#	echo "export: IDPAGE ${ODPAGE}">> /dev/stderr
#	echo "export: NAMEPAGE ${NAMEPAGE}">> /dev/stderr
#	echo "export: TARGETDIR ${TARGETDIR}">> /dev/stderr
#	echo "export: FORCE ${FORCE}">> /dev/stderr

	exportdjvupage "${SOURCE}" "${NAMEPAGE}" "${TARGETDIR}"
	exportdsedpage "${SOURCE}" "${NAMEPAGE}" "${TARGETDIR}"
	#echo "export: For export text content from DjVu page in dsed format we must use option -d" >> /dev/stderr
	exportxmlpage "${SOURCE}" "${NAMEPAGE}" "${TARGETDIR}"
	#echo "export: For export hidden text layer of pages from DjVu bundle in XML format we must use option -x" >> /dev/stderr
	exportpage2img "${SOURCE}" "${NAMEPAGE}" "${TARGETDIR}"
	#echo "export: For export image of page from DjVu bundle we must use option -i" >> /dev/stderr
	exportmetapage "${SOURCE}" "${NAMEPAGE}" "${TARGETDIR}"
	# echo "export: For export meta attributes from pages DjVu bundle in we must use option -m" >> /dev/stderr
}

function exportdjvuall {
	# $1 - DjVu file - full path
	# $2 - targetdir - full path
	echo "$EXPORTVALUE" >> /dev/stderr
	local EXPORTDJVU="1|3|5|9|11|13|15|17|19|21|23|25|27|29|31"
	local EXPORTIMG="2|3|6|7|10|11|14|15|18|19|22|23|26|27|30|31"
	local EXPORTXML="4|5|6|7|12|13|14|15|20|21|22|23|28|29|30|31"
	local EXPORTMETA="8|9|10|11|12|13|14|15|24|25|26|27|28|29|30|31"
	local EXPORTDSED="16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31"
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	[ "${PAGE}" != "no" ] || echo "exportdjvuall: For export pages in DjVu format we must use option -p" >> /dev/stderr
	[ "${DSED}" != "no" ] || echo "exportdjvuall: For export hidden text layer of pages from DjVu bundle in dsed format we must use option -d" >> /dev/stderr
	[ "${XML}" != "no" ] || echo "exportdjvuall: For export hidden text layer of pages from DjVu bundle in XML format we must use option -x" >> /dev/stderr
	[ "${IMG}" != "no" ] || echo "exportdjvuall: For export image of page from DjVu bundle we must use option -i" >> /dev/stderr
	[ "${META}" != "no" ] || echo "exportdjvuall: For export meta attributes from pages DjVu bundle in we must use option -m" >> /dev/stderr
	local PAGES=$(lastpage "${SOURCE}")
	local NUMPAGE=1
	while [ ${PAGES} -gt "0" ] ; do
		local NAMEPAGE=$(identifypage name "${SOURCE}" "${NUMPAGE}")
		log info "exportdjvuall() Exportuji stránku ${NAMEPAGE}"

		[[ $EXPORTDJVU =~ $EXPORTVALUE ]] && exportdjvupage "${1}" "${NAMEPAGE}" "${2}"
		[[ $EXPORTIMG =~ $EXPORTVALUE ]] && exportpage2img "${1}" "${NAMEPAGE}" "${2}"
		[[ $EXPORTXML =~ $EXPORTVALUE ]] && exportxmlpage "${1}" "${NAMEPAGE}" "${2}"
		[[ $EXPORTMETA =~ $EXPORTVALUE ]] && exportmetapage "${1}" "${NAMEPAGE}" "${2}"
		[[ $EXPORTDSED =~ $EXPORTVALUE ]] && exportdsedpage "${1}" "${NAMEPAGE}" "${2}"

		local NUMPAGE=$((NUMPAGE + 1))
		local PAGES=$((PAGES - 1))
	done
	[[ $EXPORTXML =~ $EXPORTVALUE ]] && exportxmlbundle "${1}" "${2}"
	[[ $EXPORTMETA =~ $EXPORTVALUE ]] && exportmetabundle "${1}" "${2}"
	[[ $EXPORTMETA =~ $EXPORTVALUE ]] && bookmarktooutline "${1}" > "${2}/${FILE/.djvu/.outline}"
	[[ $EXPORTDSED =~ $EXPORTVALUE ]] && exportdsedbundle "${1}" "${2}"
}

function exportdsedbundle {
	# $1 - DjVu file - full path
	# $2 - targetdir - full path
	local FILE="${1##*/}"
	pushd "${2}"
	case "${DSED}" in
		yes|all) local EXPORT="output-all"
		;;
		txt) local EXPORT="output-txt"
		;;
		ant) local EXPORT="output-ant"
		;;
		no) return 0
		;;
	esac
	if [ "${DSED}" != "no" ] ; then
		local TARGET="${FILE/.djvu/.dsed}"
		if [ -f "${TARGET}" ] ; then
			if [ "${FORCE}" == "yes" ] ; then
				${DJVUSED} "${1}" -e "${EXPORT}" > "${TARGET}"
			elif [ "${FORCE}" == "skip" ] ; then
				log warn "exportdsedbundle() Soubor ${TARGET} již v adresáři ${3} existuje."
			else
				echo "exportdsedbundle: Soubor ${TARGET} již v adresáři ${3} existuje.." >> /dev/stderr
				potvrdit && ${DJVUSED} "${1}" -e "${EXPORT}" > "${TARGET}"
			fi
		else
			${DJVUSED} "${1}" -e "${EXPORT}" > "${TARGET}"
		fi
	fi
	popd
}

function exportxmlbundle {
	# $1 - DjVu file - full path
	# $2 - targetdir - full path
	local FILE="${1##*/}"
	pushd "${2}"
	case "${XML}" in
		yes|all) local EXPORT="--with-text --with-anno"
		;;
		txt) local EXPORT="--with-text --without-anno"
		;;
		ant) local EXPORT="--without-text --with-anno"
		;;
		no) return 0
		;;
	esac
	if [ "${XML}" != "no" ] ; then
		local TARGET="${FILE/.djvu/.xml}"
		if [ -f "${TARGET}" ] ; then
			if [ "${FORCE}" == "yes" ] ; then
				${DJVUTOXML} "${1}" "${TARGET}"
			elif [ "${FORCE}" == "skip" ] ; then
				log warn "exportxmlbundle() Soubor ${TARGET} již v adresáři ${3} existuje."
			else
				echo "exportxmlbundle: Soubor ${TARGET} již v adresáři ${3} existuje.." >> /dev/stderr
				potvrdit && ${DJVUTOXML} "${1}" "${TARGET}"
			fi
		else
			${DJVUTOXML} "${1}" "${TARGET}"
		fi
	fi
	popd
}

#/ OBSOLETE
#/ nahrazeno funkcí fromdjvu
function exportpage2img {
	# $1 - DjVu file - full path
	# $2 - identificator - page name
	# $3 - targetdir - full path
	pushd "${3}"
	case "${IMG}" in
		yes) local EXPORT="-mode=color"
		;;
		color|black|foreground|background|mask) local EXPORT="-mode=${IMG}"
		;;
		no) return 0
		;;
	esac
	echo "$EXPORT" >> /dev/stderr
	echo "$PNMTOPNG" >> /dev/stderr
	if [ "${IMG}" != "no" ] ; then
		local PAGE=$(identifypage order "${1}" "${2}")
		local TARGET="${2/.djvu/.png}"
		if [ -f "${TARGET}" ] ; then
			if [ "${FORCE}" == "yes" ] ; then
				${DDJVU} -format=pnm "${EXPORT}" -page="${PAGE%%(*}" "${1}" | ${PNMTOPNG} > "${TARGET}"
			elif [ "${FORCE}" == "skip" ] ; then
				log warn "exportpage2img() Soubor ${TARGET} již v adresáři ${3} existuje."
			else
				echo "exportpage2img: Soubor ${TARGET} již v adresáři ${3} existuje.." >> /dev/stderr
				potvrdit && ${DDJVU} -format=pnm "${EXPORT}" -page="${PAGE%%(*}" "${1}" | ${PNMTOPNG} > "${TARGET}"
			fi
		else
			echo "${DDJVU} -format=pnm ${EXPORT} -page=${PAGE%%(*} ${1} | ${PNMTOPNG} > ${TARGET}"
			${DDJVU} -format=pnm "${EXPORT}" -page="${PAGE%%(*}" "${1}" | ${PNMTOPNG} > "${TARGET}"
		fi
	fi
	popd
}

function exportxmlpage {
	# $1 - DjVu file - full path
	# $2 - identificator - page name
	# $3 - targetdir - full path
	pushd "${3}"
	case "${XML}" in
		yes|all) local EXPORT="--with-text --with-anno"
		;;
		txt) local EXPORT="--with-text --without-anno"
		;;
		ant) local EXPORT="--without-text --with-anno"
		;;
		no) return 0
		;;
	esac
	if [ "${XML}" != "no" ] ; then
		local PAGE=$(identifypage order "${1}" "${2}")
		local TARGET="${2/.djvu/.xml}"
		if [ -f "${TARGET}" ] ; then
			if [ "${FORCE}" == "yes" ] ; then
				${DJVUTOXML} --page "${PAGE}" ${EXPORT} "${1}" "${TARGET}"
			elif [ "${FORCE}" == "skip" ] ; then
				log warn "exportxmlpage() Soubor ${TARGET} již v adresáři ${3} existuje."
			else
				echo "Soubor ${TARGET} již v adresáři ${3} existuje.." >> /dev/stderr
				potvrdit && ${DJVUTOXML} --page "${PAGE}" ${EXPORT} "${1}" "${TARGET}"
			fi
		else
			${DJVUTOXML} --page "${PAGE}" ${EXPORT} "${1}" "${TARGET}"
		fi
	fi
	popd
}

function importmetapage {
	# $1 - soubor se stránkou
	# $2 - identifikátor stránky
	# $3 - soubor s meta atributy
	echo "importmetapage: Importuji meta atributy do jedné stránky" >> /dev/stderr
	${DJVUSED} "${1}" -e "select '${2}'; set-meta ${3}; save"
}

function importmetaall {
	# $1 - soubor se stránkou
	# $2 - soubor s meta atributy
	echo "importmetaall: Importuji meta atributy pro celý svazek" >> /dev/stderr
	${DJVUSED} "${1}" -e "select; set-meta ${2}; save"
}

# ### <span id="writefile">writefile()</span> ([top](#FUNCTIONS))
# Funkce průběžně konvertuje stream unicode znaků do jejich číselné podoby
# Velmi důležitá funkce!!!
writefile() {
    if [ -t 0 ]; then
        log info "writefile() Empty stdin"
        return 1
    else
        tee $1 >> /dev/null
        return 0
    fi
}

# ### <span id="encode">encode()</span> ([top](#FUNCTIONS))
# Funkce průběžně konvertuje stream unicode znaků do jejich číselné podoby
# Velmi důležitá funkce!!!
encode() {
    while read -n 1 a
    do
    CHAR=($( echo "$a" | od -A n -t c ))
    if [ "${#CHAR[@]}" -gt "2" ] ; then 
        echo -n "\\${CHAR[0]}\\${CHAR[1]}"
    elif [ "${#CHAR[@]}" == "1" ] ; then 
        echo -n " "
    else
        if [ "${#CHAR[0]}" == "0" ] ; then
            echo -n " "
        else
            echo -n "${CHAR[0]}"
        fi
    fi
    done
}

# ### <span id="encodefile">encodefile()</span> ([top](#FUNCTIONS))
# Konvertuje bitmapový soubor v PAM formátu, předaný jako __$1__ do
# DjVu souboru __$2__
# Základním předpokladem je, že pro tento PAM soubor (s příponou `.pam`)
# existuje minimálně jeden soubor ve formátu PBM pro vygenerování masky.
#
# Přednost má přitom soubor s příponou `.text`, který (pokud existuje)
# obsahuje vyseparované textové bloky.
#
# V případě že neexistuje, je automaticky vyžadován soubor s příponou
# `.fore`, který byl vygenerován funkcí [separatemask](#separatemask)
encodefile() {
    log goto "encodefile() Use $1 –> $2"
    if [ -f "${1/.pam/.text}" ] ; then
        ${CJB2} -lossy -clean "${1/.pam/.text}" "${1}.mask";
    else
        ${CJB2} -lossy -clean "${1/.pam/.fore}" "${1}.mask";
    fi
    ${DJVUMAKE} "${2}" Sjbz="${1}.mask" PPM="${1}";
}

# ### <span id="separatemask">separatemask()</span> ([top](#FUNCTIONS))
# Z bitmapového souboru ve formátu PAM, který je předán jako __$1__
# generuje černobílou masku __$2__ ve formátu PBM.
# Jako parametr __$3__ se předává buď algoritmus s parametry, nebo hodnota
# `none` s nastavením prahové hodnoty
#
# shading-subtraction - k od 3 (málo šumu) do 12 (hodně šumu),
# šum lze odstranit nastavením prahu (hodnota float)
# Výsledek je přesně opačný než při nastavení prahu - čím vyšší hodnota,
# tím míň toho proleze
separatemask() {
    log goto "separatemask() Use $3 for $1 –> $2"
    case "${3%:*}" in
        none) if [ "${3#*:}" == "none" ] ; then
                log info "${PAMTOPNM} ${1} | ${PPMTOPGM} | ${PGMTOPBM} -threshold -value 0.5 | ${PNMTOPLAINPNM} > ${2}"
                ${PAMTOPNM} ${1} | ${PPMTOPGM} | ${PGMTOPBM} -threshold -value 0.5 | ${PNMTOPLAINPNM} > ${2}
            else
                log info "${PAMTOPNM} ${1} | ${PPMTOPGM} | ${PGMTOPBM} -threshold -value 0.${3#*:} | ${PNMTOPLAINPNM} > ${2}"
                ${PAMTOPNM} ${1} | ${PPMTOPGM} | ${PGMTOPBM} -threshold -value 0.${3#*:} | ${PNMTOPLAINPNM} > ${2}
            fi
            while [ ! -f "${2}" ] ; do
                sleep 0.1
            done
        ;;
        *) if [ -f "${HOME}/.config/${NAME}/${3}.conf" ] ; then
                local PARAMS=$(grep -v '^#' "${HOME}/.config/${NAME}/${3}.conf" | awk '{print "--param", $1}' | tr '\n' ' ')
            fi
            if [[ "${3}" =~ ":" ]] ; then
                local TEMPORAR="${3#*:}"
                local PARAMS=$(printf "xxx %s" ${TEMPORAR//,/ })
            fi
            ${DIDJVU} separate -o "${2}.png" ${LEVEL} -m "${3%:*}" ${PARAMS//xxx/ -x} "${1}"
            while [ ! -f "${2}.png" ] ; do
                sleep 0.1
            done
            pngtopam "${2}.png" > "${2}"
        ;;
    esac
    return $?
}

# ### <span id="bookmarktooutline">bookmarktooutline()</span> ([top](#FUNCTIONS))
# Funkce zpracovává záložky z DjVu souboru do formátu s odsazením
bookmarktooutline() {
    local TARGET="$1"
    local BEGIN=""
    local TAB=0
    ${DJVUSED} "${1}" -e 'print-outline' | sed -n '
    s|(|\n(\n|g
    s|)|\n)\n|g
    s|\\|\\\\0|g
    p
    ' |	while read y
    do
        case "$y" in
            \)) local TAB=$((TAB - 1))
            ;;
            \() local TAB=$((TAB + 1))
            ;;
            \"*) if [ "${BEGIN}" == "" ] ; then
                    local TEXT="$y"
                    local BEGIN="yes"
                else
                    for i in $(seq $((TAB-2))) ; do echo -en '\t' ; done
                    echo -e "${TEXT} ${y}"
                    local BEGIN=""
                fi
            ;;
        esac
    done
}

function outlineunset {
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .outline)
	local CHARSET="$(( $2 + 1 ))"
	bookmarktooutline "${SOURCE}" >> "${TEMPFILE}"
	if [ "${CHARSET//+([[:digit:]])}" == "" ] ; then
		ed ${TEMPFILE} 2>/dev/null <<-EOF
${CHARSET}d
w
q
EOF
		outlinetodsed "${TEMPFILE}" | encode > "${TEMPFILE/.outline/.temp}"
		${DJVUSED}  "${SOURCE}" -e "set-outline ${TEMPFILE/.outline/.temp}; save"
	fi
}

function outlineset {
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .outline)
	local CHARSET="${2}"
	bookmarktooutline "${SOURCE}" >> "${TEMPFILE}"
	local ORDER="${CHARSET%% *}"
	local BOOKMARKTARGET="${CHARSET##* }"
	local TEMP="${CHARSET#${ORDER} *}"
	local BOOKMARKITEM="${TEMP%* ${BOOKMARKTARGET}}"
	case ${ORDER:$((${#ORDER}-1))} in
		+) if [ -z ${ORDER%:+} ] ; then
				local TEMP=$(tail -1 ${TEMPFILE})
				local TABS="${TEMP%%\"*}"
				local ITEM="$(xtabs $((${#TABS} + 1)))\"${BOOKMARKITEM}\" \"#${BOOKMARKTARGET}\""
				ed ${TEMPFILE} 2>/dev/null <<-EOF
a
${ITEM}
.
w
q
EOF
			else
				local TEMP=$(head -$((${ORDER%:+*}+1)) ${TEMPFILE} | tail -1)
				local TABS="${TEMP%%\"*}"
				local ITEM="$(xtabs $((${#TABS} + 1)))\"${BOOKMARKITEM}\" \"#${BOOKMARKTARGET}\""
				ed ${TEMPFILE} 2>/dev/null <<-EOF
${ORDER%:+}a
${ITEM}
.
w
q
EOF
			fi
			;;
		-) if [ -z ${ORDER%:-*} ] ; then
				local TEMP=$(tail -1 ${TEMPFILE})
				local TABS="${TEMP%%\"*}"
				local MINUS="${ORDER#:}"
				if [ ${#TABS} -ge ${#MINUS} ] ; then
					local ITEM="$(xtabs $((${#TABS} - ${#MINUS})))\"${BOOKMARKITEM}\" \"#${BOOKMARKTARGET}\""
				else
					local ITEM="\"${BOOKMARKITEM}\" \"#${BOOKMARKTARGET}\""
				fi
				ed ${TEMPFILE} 2>/dev/null <<-EOF
a
${ITEM}
.
w
q
EOF
			else
				local TEMP=$(head -$((${ORDER%:-*}+1)) ${TEMPFILE} | tail -1)
				local TABS="${TEMP%%\"*}"
				local MINUS="${ORDER#*:}"
				if [ ${#TABS} -ge ${#MINUS} ] ; then
					local ITEM="$(xtabs $((${#TABS} - ${#MINUS})))\"${BOOKMARKITEM}\" \"#${BOOKMARKTARGET}\""
				else
					local ITEM="\"${BOOKMARKITEM}\" \"#${BOOKMARKTARGET}\""
				fi
				ed ${TEMPFILE} 2>/dev/null <<-EOF
${ORDER%:-*}a
${ITEM}
.
w
q
EOF
			fi
			;;
		:) if [ -z ${ORDER%:} ] ; then
				local TEMP=$(tail -1 ${TEMPFILE})
				local TABS="${TEMP%%\"*}"
				local ITEM="$(xtabs ${#TABS})\"${BOOKMARKITEM}\" \"#${BOOKMARKTARGET}\""
				ed ${TEMPFILE} 2>/dev/null <<-EOF
a
${ITEM}
.
w
q
EOF
			else
				local TEMP=$(head -$((${ORDER%:}+1)) ${TEMPFILE} | tail -1)
				local TABS="${TEMP%%\"*}"
				local ITEM="$(xtabs ${#TABS})\"${BOOKMARKITEM}\" \"#${BOOKMARKTARGET}\""
				ed ${TEMPFILE} 2>/dev/null <<-EOF
${ORDER%:}a
${ITEM}
.
w
q
EOF
			fi
			;;
		[[:digit:]]) local TEMP=$(head -$((${ORDER}+1)) ${TEMPFILE} | tail -1)
			local TABS="${TEMP%%\"*}"
			local ITEM="$(xtabs ${#TABS})\"${BOOKMARKITEM}\" \"#${BOOKMARKTARGET}\""
				ed ${TEMPFILE} 2>/dev/null <<-EOF
${ORDER}a
${ITEM}
.
w
q
EOF
			;;
		*) echo "outlineset: Sem bys nikdy neměl dojít" && exit 1
			;;
	esac
	outlinetodsed "${TEMPFILE}" | encode > "${TEMPFILE/.outline/.temp}"
	${DJVUSED}  "${SOURCE}" -e "set-outline ${TEMPFILE/.outline/.temp}; save"
}

# ### <span id="outlinetodjvu">outlinetodjvu()</span> ([top](#FUNCTIONS))
# Funkce převádí obsah .outline souboru na formát .dsed
# a výsledek zapisuje do djvu souboru
# $1 - DjVu file
# $2 - soubor ve formátu .outline
outlinetodjvu() {
    log goto "outlinetodjvu() From $2 into $1"
    local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .bookmarks)
    if [ -f "${2}" ] ; then
        outlinetodsed "${2}" | encode > "${TEMPFILE}"
        ${DJVUSED}  "${1}" -e "set-outline ${TEMPFILE}; save"
    else
        log err "outlinetodjvu() Not any outline file"
        return 1
    fi
    return $?
}

# ### <span id="outlinetodjvu">outlinetodjvu()</span> ([top](#FUNCTIONS))
# Funkce převádí obsah ve formátu .outline na formát .dsed
# $1 - .outline file with TAB syntax
# Output is txt stream
function outlinetodsed {
    local TARGET="$1"
    # Remove comment from .outline file
    sed --in-place '/^#/d ; /^;/d' "${TARGET}"
    [ $(grep -c ^ "${TARGET}") -eq "0" ] && return 1
    local LEVEL="1"
    IFS=''
    echo -n "(bookmarks "
    CONTENT=$(sed '
        s/\ \ \ \ /\t/g
        s/^/\t/
        ' "${TARGET}" | while read line ; do
        local SPACE="${line%%\"*}"
        if [ "${#SPACE}" -gt "${LEVEL}" ] ; then
            local PREV="${PREV%)} ( ${line} )"
            local LEVEL=$((${LEVEL} + 1))
        elif [ "${#SPACE}" -eq "${LEVEL}" ] ; then
            local PREV="${PREV} ( ${line} )"
        elif [ "${#SPACE}" -lt "${LEVEL}" ] ; then
            local ROZDIL=$((${LEVEL} - ${#SPACE}))
            local ZAV=$(seq  -f "%1.0f" -s '' ${ROZDIL})
            local PREV="${PREV} ${ZAV//[[:digit:]]/)} ( $line )"
            local LEVEL=$((${LEVEL} - ${ROZDIL}))
        fi
        echo "${PREV}"
        echo "-----${LEVEL}"
    done | sed 's/\t/\ /g' | tail -2)
    TEST="${CONTENT##*-----}"
    echo -n "${CONTENT%-----*}"
    local ZAV=$(seq  -f "%1.0f" -s '' ${TEST})
    echo "${ZAV//[[:digit:]]/)}"
    return 0
}


function importdsedall {
	case "${DSED}" in
		# Vytvořit dočasný soubor s následující hlavičkou...
		# -e "select '${2}'; remove-ant; remove-txt"
		# -------------------------
		# time awk '/^set-ant$/{flag=1;next} ; /^.$/{flag=0}; flag' vysledek.dsed 
		all|yes) # nejprve ant, pak text..
		${DJVUSED} "${1}" -f "${2}" -s
		;;
		no)
		;;
	esac
}

function importdsedpage {
	# $1 - DjVu file - full path
	# $2 - identificator - page name
	# $3 - source DSED file - full path
	case "${DSED}" in
		# Vytvořit dočasný soubor s následující hlavičkou...
		# -e "select '${2}'; remove-ant; remove-txt"
		# -------------------------
		# time awk '/^set-ant$/{flag=1;next} ; /^.$/{flag=0}; flag' vysledek.dsed 
		all|yes) awk '/^set-ant$/{flag=1;next} ; /^.$/{flag=0}; flag' "${3}" > ${TEMPDIR}/${2}.ant
			${DJVUSED} "${1}" -e "select '${2}'; set-ant ${TEMPDIR}/${2}.ant ; save"
			awk '/^set-txt$/{flag=1;next} ; /^.$/{flag=0}; flag' "${3}" > ${TEMPDIR}/${2}.txt
			${DJVUSED} "${1}" -e "select '${2}'; set-txt ${TEMPDIR}/${2}.txt ; save"
		;;
		ant) awk '/^set-ant$/{flag=1;next} ; /^.$/{flag=0}; flag' "${3}" > ${TEMPDIR}/${2}.ant
			${DJVUSED} "${1}" -e "select '${2}'; set-ant ${TEMPDIR}/${2}.ant ; save"
		;;
		txt) awk '/^set-txt$/{flag=1;next} ; /^.$/{flag=0}; flag' "${3}" > ${TEMPDIR}/${2}.txt
			${DJVUSED} "${1}" -e "select '${2}'; set-txt ${TEMPDIR}/${2}.txt ; save"
		;;
		no) echo "K importu textových dat ze souboru ${3} se přistoupí pouze bude-li uvedena volba -d" >> /dev/stderr
		;;
	esac
}

function importmeta {
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .meta)
	local FROM=$(${REALPATH} -m -P "${2}")
	local FROMFILE="${FROM##*/}"
	grep '^#' "${FROM}" | while read line ; do
		echo "$line" >> /dev/stderr
		local NAMEPAGE=( $line )
		case "${#NAMEPAGE[@]}" in
			2) local PAGENAME=$(identifypage name "${SOURCE}" "${NAMEPAGE[1]//\'/}")
				if [ -z "${PAGENAME}" ] ; then
					echo "importmeta: FAIL - for ${FILE} is identificator ${NAMEPAGE[1]} not valid" >> /dev/stderr
				else
					awk "/.\ '${PAGENAME}'$/{flag=1;next} ; /^.$/{flag=0}; flag" "${FROM}" > ${TEMPFILE}
					${DJVUSED} "${1}" -e "select ${PAGENAME}; set-meta ${TEMPFILE}" -s
				fi
			;;
			1) if [ "${NAMEPAGE[0]}" == "#" ] ; then
					awk "/^#$/{flag=1;next} ; /^.$/{flag=0}; flag" "${FROM}" > ${TEMPFILE}
					${DJVUSED} "${1}" -e "select ; set-meta ${TEMPFILE}" -s
				else
					local PAGENAME=$(identifypage name "${SOURCE}" "${NAMEPAGE[0]:1}")
					if [ -z "${PAGENAME}" ] ; then
						echo "importmeta: FAIL - for ${FILE} is identificator ${NAMEPAGE[0]:1} not valid" >> /dev/stderr
					else
						awk "/^#${NAMEPAGE[0]:1}$/{flag=1;next} ; /^.$/{flag=0}; flag" "${FROM}" > ${TEMPFILE}
						${DJVUSED} "${1}" -e "select ${PAGENAME}; set-meta ${TEMPFILE}" -s
					fi
				fi
			;;
		esac
	done
}

function importmeta1 {
	# $1 - DjVu file - full path
	# $2 - identificator - page name
	# $3 - source DSED file - full path
	if [ -f "${2}" ] ; then
		if [ "${3}" ] ; then
			local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .meta)
			# Zpracování gobálních metadat
			awk '/^# select '${i}'$/{flag=1;next} ; /^.$/{flag=0}; flag' "${2}" > ${TEMPFILE}
			${DJVUSED} "${1}" -e "select ${3}; set-meta ${TEMPFILE}" -s
		else
			for i in $(seq $(lastpage ${1})) ; do
				awk '/^# select '${i}'$/{flag=1;next} ; /^.$/{flag=0}; flag' "${2}" > ${TEMPFILE}
				if [ "${TEMPFILE}" ] ; then
					${DJVUSED} "${1}" -e "select ${i}; set-meta ${TEMPFILE}" -s
				fi
			done
		fi
	else
		importmeta "${1}" "${3}" 
	fi
}

function importoutline {
	# Import outline in dsed format
	${DJVUSED}  "${1}" -e "set-outline ${2}" -s
}

function importxmlpage {
	# $1 - DjVu file - full path
	# $2 - source XML file - full path
	# INFO: XML file has name of target page in self.
	case "${XML}" in
		no) echo "K importu textových dat ze souboru ${2} se přistoupí pouze bude-li uvedena volba -x" >> /dev/stderr
		;;
		*) ${DJVUXMLPARSER} -o "${1}" "${2}"
		;;
	esac
}

# TODO - meta - Nepoužitá funkce
function exportmetabundle {
	# $1 - DjVu file - full path
	# $2 - targetdir - full path
	local FILE="${1##*/}"
	pushd "${2}"
	if [ "${META}" != "no" ] ; then
		local TARGET="${FILE/.djvu/.meta}"
		if [ -f "${TARGET}" ] ; then
			if [ "${FORCE}" == "yes" ] ; then
				${DJVUSED} "${1}" -e "print-meta" > "${TARGET}"
			elif [ "${FORCE}" == "skip" ] ; then
				log warn "exportmetabundle() Soubor ${TARGET} již v adresáři ${2} existuje."
			else
				echo "Soubor ${TARGET} již v adresáři ${2} existuje.." >> /dev/stderr
				potvrdit && ${DJVUSED} "${1}" -e "print-meta" > "${TARGET}"
			fi
		else
			${DJVUSED} "${1}" -e "print-meta" > "${TARGET}"
		fi
	fi
	popd
}

# OBSOLETE
# TODO - meta - Nepoužitá funkce
function exportmetapage {
	# $1 - DjVu file - full path
	# $2 - identificator - page name
	# $3 - targetdir - full path
	pushd "${3}"
	if [ "${META}" != "no" ] ; then
		local TARGET="${2/.djvu/.meta}"
		if [ -f "${TARGET}" ] ; then
			if [ "${FORCE}" == "yes" ] ; then
				${DJVUSED} "${1}" -e "select '${2}'; print-meta" > "${TARGET}"
			elif [ "${FORCE}" == "skip" ] ; then
				log warn "exportmetapage() Soubor ${TARGET} již v adresáři ${3} existuje."
			else
				echo "Soubor ${TARGET} již v adresáři ${3} existuje.." >> /dev/stderr
				potvrdit && ${DJVUSED} "${1}" -e "select '${2}'; print-meta" > "${TARGET}"
			fi
		else
			${DJVUSED} "${1}" -e "select '${2}'; print-meta" > "${TARGET}"
		fi
	fi
	popd
}

function exportdsedpage {
	# $1 - DjVu file - full path
	# $2 - identificator - page name
	# $3 - targetdir - full path into dir for file
	pushd "${3}"
	case "${DSED}" in
		yes|all) local EXPORT="output-all"
		;;
		txt) local EXPORT="output-txt"
		;;
		ant) local EXPORT="output-ant"
		;;
		no) return 0
		;;
	esac
	if [ "${DSED}" != "no" ] ; then
		local TARGET="${2/.djvu/.dsed}"
		if [ -f "${TARGET}" ] ; then
			if [ "${FORCE}" == "yes" ] ; then
				${DJVUSED} "${1}" -e "select '${2}'; ${EXPORT}" > "${TARGET}"
			elif [ "${FORCE}" == "skip" ] ; then
				log warn "exportdsedpage() Soubor ${TARGET} již v adresáři ${3} existuje."
			else
				echo "Soubor ${TARGET} již v adresáři ${3} existuje.." >> /dev/stderr
				potvrdit && ${DJVUSED} "${1}" -e "select '${2}'; ${EXPORT}" > "${TARGET}" 2>${LOG}
			fi
		else
#			echo "select '${2}'; ${EXPORT} > ${TARGET}" >> /dev/stderr
#			echo $(pwd) >> /dev/stderr
			${DJVUSED} "${1}" -e "select '${2}'; ${EXPORT}" > "${TARGET}" 2>${LOG}
			return $?
		fi
	fi
	popd
}

function exportdjvupage {
	# $1 - DjVu file - full path
	# $2 - identificator - page name
	# $3 - targetdir - full path
	log info "exportdjvupage() -${1}- -${2}- ${3}"
	pushd "${3}"
	if [ "${PAGE}" == "yes" ] ; then
		if [ -f "${2}" ] ; then
			if [ "${FORCE}" == "yes" ] ; then
				${DJVUSED} -e "select '${2}'; save-page-with '${2}'" "${1}"
			elif [ "${FORCE}" == "skip" ] ; then
				log warn "exportdjvupage() Soubor ${2} již v adresáři ${3} existuje."
			else
				echo "Soubor ${2} již v adresáři ${3} existuje.." >> /dev/stderr
				potvrdit && ${DJVUSED} -e "select '${2}'; save-page-with '${2}'" "${1}"
			fi
		else
			${DJVUSED} -e "select '${2}'; save-page-with '${2}'" "${1}"
		fi
	fi
	popd
}

function getocr {
    log goto "getocr() OCR ${OCR} –> ${1}"
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	if [ "${OCR}" ] ; then
		${OCRODJVU} --in-place -l "${OCR}" "${SOURCE}"
		[ "$?" ] && log info "getocr() OCR was applicated on ${FILE}" 
	fi
}

# ### <span id="testfile">testfile()</span> ([top](#FUNCTIONS))
# Function return type file by MIME
#
# $1 - jméno testovaného souboru se kterým se pracuje
testfile () {
    log goto "testfile() –> ${1}"
    local SOURCE=$(${REALPATH} -m -P "${1}")
    local FILE="${SOURCE##*/}"
    if [ -f "${SOURCE}" ] ; then
        local TYPE=$(${MIME} -dbM "${SOURCE}" | awk '{print $1}')
    else
        log err "testfile() File ${1} is NOT valid."
        return 1
    fi
    log info "testfile() ${1} –> ${TYPE,,}"
    echo "${TYPE,,}"
    return 0
}

function targetdir {
	# Function return path into existing directory
	# $1 - path
	if [ -z "${1}" ] ; then
		log err "targetdir() NOT PATH"
		exit 1
	else
		local TARGETDIR=$(${REALPATH} -m -P "${1}")
		if [ -d "${TARGETDIR}" ] ; then
			echo -n "${TARGETDIR}"
		else
			mkdir -p "${TARGETDIR}"
			if [ $? -gt "0" ] ; then
				log err "targetdir() Could not create target directory ${TARGETDIR}"
				exit 1
			else
				echo -n "${TARGETDIR}"
			fi
		fi
	fi
}

# ### <span id="identifybundle">identifybundle()</span> ([top](#FUNCTIONS))
# Function for test type file. For DjVu bundle (0), single (1), or another (1)
# $1 - file path
identifybundle() {
    log goto "identifybundle() $1"
    if [ $(testfile "${1}") == "djvu" ] ; then
        ${DJVM} -l "${1}" &>/dev/null
        [ $? -eq 1 ] && return 2
    else
        log err "identifybundle() ${1} –> NOT DjVu file"
        return 1
    fi
    return 0
}

function comparedjvu {
	#  Function do test two DjVu files and return (0) if is not any page in conflict or (1)
	# $1 - Djvu full path
	# $2 - Djvu full path
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	local FROMPATH=$(${REALPATH} -m -P "${2}")
	local FROM="${FROMPATH##*/}"
	if identifybundle ${SOURCE} ; then
		${DJVM} -l "${SOURCE}" | grep PAGE\ # | awk '{print $4}' | while read x ; do
		if identifybundle ${FROMPATH} ; then
			${DJVM} -l "${FROMPATH}" | grep PAGE\ # | awk '{print $4}' | while read y ; do
				if [ "${x}" == "${y}" ] ; then
					echo "comparedjvu: WARNING Page with name ${x} from file ${FILE} is in ${FROM} too." >> /dev/stderr
					break
				fi
			done
		else
			${DJVUSED} "${FROMPATH}" -e dump | grep FORM:DJVU | awk -F'[{}]' '{print $2}' | while read y ; do
				if [ "${x}" == "${y}" ] ; then
					echo "comparedjvu: WARNING Page with name ${x} from file ${FILE} is in ${FROM} too." >> /dev/stderr
					break
				fi
			done
		fi
		done
	else
		${DJVUSED} "${SOURCE}" -e dump | grep FORM:DJVU | awk -F'[{}]' '{print $2}' | while read x ; do
		if identifybundle ${FROMPATH} ; then
			${DJVM} -l "${FROMPATH}" | grep PAGE\ # | awk '{print $4}' | while read y ; do
				if [ "${x}" == "${y}" ] ; then
					echo "comparedjvu: WARNING Page with name ${x} from file ${FILE} is in ${FROM} too." >> /dev/stderr
					break
				fi
			done
		else
			${DJVUSED} "${FROMPATH}" -e dump | grep FORM:DJVU | awk -F'[{}]' '{print $2}' | while read y ; do
				if [ "${x}" == "${y}" ] ; then
					echo "comparedjvu: WARNING Page with name ${x} from file ${FILE} is in ${FROM} too." >> /dev/stderr
					break
				fi
			done
		fi
		done
	fi
	potvrdit && return 0 || return 1
}

function splitxcf {
	# vrátí seznam
#	echo ${RANGE[@]} >> /dev/stderr
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	pushd ${TEMPDIR}
		i=0
		${XCFINFO} ${SOURCE} | grep -v Version | cut -d ' ' -f5- | while read line
		do i=$((i+1))
			if [ -z ${RANGE} ] ; then
				${XCF2PNM} ${SOURCE} -o "${line%.pnm}.pnm" "$line"
			else
				for x in ${RANGE[@]}
					do if [ "$x" -eq "$i" ] ; then
						${XCF2PNM} ${SOURCE} -o "${line%.pnm}.pnm" "$line"
					fi
				done
			fi
		done
	popd
}

# ### <span id="istarget">istarget()</span> ([top](#FUNCTIONS))
# Funkce nastavuje TARGETDIR a TARGETSAMPLE
istarget() {
    log goto "istarget() –> $1"
    case "${1:$((${#1}-1)):1}" in
        /) TARGETSAMPLE="ORIGINAL"
            TARGETDIR=$(${REALPATH} -m -P "${1}")
            log info "targets() Export pages with a original names into –> ${TARGETDIR}"
            [ ! -d "${TARGETDIR}" ] && mkdir -p "${TARGETDIR}"
        ;;
        *) if [[ "${1}" =~ "/" ]] ; then
                #/ obsahuje cestu
                local TEMPORARY=$(${REALPATH} -m -P "${1}")
                TARGETDIR="${TEMPORARY%/*}"
                TARGETSAMPLE="${TEMPORARY##*/}"
                log info "targets() Export pages a named by sample ${TARGETSAMPLE} –> ${TARGETDIR}"
                [ ! -d "${TARGETDIR}" ] && mkdir -p "${TARGETDIR}"
            else
                #/ jde o vzorek
                TARGETDIR="$(pwd)/"
                TARGETSAMPLE="${1}"
                log info "targets() Export pages a named by sample ${TARGETSAMPLE} into actual directory"
            fi
        ;;
    esac
    return 0
}

# ### <span id="isrange">isrange()</span> ([top](#FUNCTIONS))
# Nastavuje proměnnou RANGE a vrací ořezaný řetězec
isrange() {
    log goto "isrange() input –> $1"
    local PARAMS=($1)
    case "${PARAMS[0]}" in
        +([0-9\-,]))
            log value "isrange() OK –> ${PARAMS[0]}"
            echo "${PARAMS[0]}"
            ;;
        *) return 1
            ;;
    esac
    return 0
}

# ### <span id="isscale">isscale()</span> ([top](#FUNCTIONS))
# Zjišťuje, zda-li předaný řetězec začíná kódem podporovaného formátu
isformat() {
    log goto "isformat() string –> $1"
    local PARAMS=($1)
    case "${PARAMS[0]}" in
        all)  #/ Volba pro DjVu
            #/ Vyexportuje všechno
            ;;
        ant) #/ Volba pro DjVu
            #/ Poznámky
            ;;
        meta) #/ Volba pro DjVu
            ;;
        outline) #/ Volba pro DjVu
            #/ Obsah
            ;;
        bookmark) #/ Volba pro DjVu
            #/ Záložky
            ;;
        dsed-*) #/ Volba pro DjVu
            #/ Export textové vrstvy v dsed formátu
            #/ dsed-ant
            #/ dsed-all
            #/ dsed-txt
            ;;
        djvu) #/ Bitmapový soubor bude konvertován do djvu
            #/ U DjVu souboru budou vyexportované stránky složené opět
            #/ do DjVu souboru
            ;;
        txt|text) #/ V případě DjVu či PDF souborů bude exportován text
            #/ V ostatních případech se stránka prožene přes OCR
            ;;
        image*) #/ akceptováno u PDF a DjVu
            #/ Výsledkem exporu bude obrázek stránky (u DjVu) nebo extrahované
            #/ obrázky z PDF
            ;;
        orig*) #/ původní formát
            ;;
        jpg|jpeg|jp2)
            ;;
        pnm|pam)
            ;;
        mask|black|background|foreground|color) #/ Typ exportované obrazové vrstvy
            ;;
        xcf|gimp)
            ;;
        xml-*) #/ Volba pro DjVu
            #/ export XML vrstvy
            #/ xml-ant
            #/ xml-all
            #/ xml-txt
            ;;
        *) return 1
            ;;
    esac
    log value "isformat() OK –> ${PARAMS[0]}"
    echo "${PARAMS[0]}"
    return 0
}

# ### <span id="parsecut">parsecut()</span> ([top](#FUNCTIONS))
# Parsuje předaný řetězec, který můře být buď ve formě:
# * LEFT,TOP,SIRKA,VYSKA
# * SIRKAxVYSKA+LEFT+TOP
#
# a vrací hodnoty v daném pořadí: W H X Y
#
# * W - (weight) šířka boxu
# * H - (height) výška boxu
# * X - horizontální vzdálenost od levého okraje
# * Y - vertikální vzdálenost od horního okraje
parsecut() {
    log goto "parsecut() $1"
    case ${1} in
                +([0-9])x+([0-9])|+([0-9])x+([0-9])[+]+([0-9])[+]+([0-9]))
                    local W="${1%%x*}"
                    local TEMPORAR="${1#*x}"
                    local H="${TEMPORAR%%+*}"
                    local TEMPORAR="${1#*+}"
                    local X="${TEMPORAR%+*}"
                    local Y="${1##*+}"
                ;;
                +([0-9]),+([0-9]),+([0-9]),+([0-9]))
                    local TEMPORAR=( ${1//,/ } )
                    local X="${TEMPORAR[0]}"
                    local Y="${TEMPORAR[1]}"
                    local W="${TEMPORAR[2]}"
                    local H="${TEMPORAR[3]}"
                ;;
                *) echo "Neplatné nastavení pro cut –> ${1}" >> /dev/stderr
                    return 1
                ;;
    esac
    echo "$W $H $X $Y"
}

# ### <span id="imgcut">imgcut()</span> ([top](#FUNCTIONS))
# Funkce zpracovává řetězec, kterým je identifikována oblast vyžadující
# speciální ošetření. Ta může být nastavena dvěma možnými způsoby:
# LEFT,TOP,SIRKA,VYSKA nebo SIRKAxVYSKA+LEFT+TOP
# Za tímto řetězcem může následovat dvojtečka, která specifikuje typ rámce
# T - vymezená textová oblast se nakopíruje na prázdnou plochu `.text`
# I - vymezená oblast bude na masce `.fore` začerněná
# M - vymezená oblast bude na masce `.fore` zabílená
# G - grafika (čáry a linky)
# bez specifikace typu rámce se předpokládá že se má "zamaskovat" obrázek
#
# Pro zjištění souřadnic lze použít kupř. geeqie Zobrazit –> Zobrazit informace o pixelech
#
# Pro nastavení oblastí lze použít i nástroj djvusmooth, ale souřadnice se musí přepočítat
# rect 225 0 804 61
#     LEFT,BOTTOM, LEFT+WIDTH,HEIGHT
imgcut() {
    log goto "imgcut() $1 –> $2"
    local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .pam)
    local SIZE=(${1/:/ })
    local W=($(parsecut ${SIZE[0]}))
    [ $? -eq 1 ] && return 1
    if [ "${W[0]}" -eq "0" ] || [ "${W[1]}" -eq "0" ] || [ "${W[0]:0:1}" == "-" ] || [ "${W[1]:0:1}" == "-" ] ; then
        echo "${W[2]},${W[3]},[1m${W[0]}[0m,[1m${W[1]}[0m –> Šířka a výška plochy musí mít nenulovou velikost" >> /dev/stderr
        return 1
    fi
    local Y="${W[3]}"
    local X="${W[2]}"
    local H="${W[1]}"
    local W="${W[0]}"
    log info "imgcut W $W H $H X $X Y $Y"
    local FILENAME="${2%.*}"
    case ${#SIZE[@]} in
        1) #/ Vyjme vybranou oblast za černou plochu
            ${PBMMAKE} -black ${W} ${H} > ${TEMPFILE}
            log info "imgcut() ${FILENAME}.fore –> ${FILENAME}.temp"
            ${PAMTOPNM} "${FILENAME}.fore" | ${PNMPASTE} ${TEMPFILE} "${X}" "${Y}" > "${FILENAME}.temp"
            mv -f "${FILENAME}.temp" "${FILENAME}.fore"
            rm -f ${TEMPFILE}
            log info "imgcut() Plocha $1 byla zamaskována"
        ;;
        2) case ${SIZE[1]} in
            M) #/ Nahradí oblast za bílou plochu (ve výsledku dojde k rozmazání
                ${PBMMAKE} -white ${W} ${H} > ${TEMPFILE}
                ${PAMTOPNM} "${FILENAME}.fore" | ${PNMPASTE} ${TEMPFILE} "${X}" "${Y}" > "${FILENAME}.temp"
                mv -f "${FILENAME}.temp" "${FILENAME}.fore"
                log info "imgcut() Plocha $1 byla odmaskována"
            ;;
            T) #/ Text - vybraná plocha z fore je naklíčovaná na bílou plochu
                #/ maska bude mít příponu text
                ${PAMTOPNM} "${FILENAME}.fore" | ${PAMCUT} -left ${X} -top ${Y} -width ${W} -height ${H} > ${TEMPFILE}
                [ ! -f "${FILENAME}.text" ] && \
                    ${PBMMAKE} -white $(head -2 "${FILENAME}.fore" |tail -1) > "${FILENAME}.text"
                ${PAMTOPNM} "${FILENAME}.text" | ${PNMPASTE} ${TEMPFILE} "${X}" "${Y}" > "${FILENAME}.temp"
                mv -f "${FILENAME}.temp" "${FILENAME}.text"
                log info "imgcut() Plocha textu $1 byla vyseparovaná"
            ;;
            I) #/ Obrázek - vybraná plocha je na masce začerněná
                ${PBMMAKE} -black ${W} ${H} > ${TEMPFILE}
                ${PAMTOPNM} "${FILENAME}.fore" | ${PNMPASTE} ${TEMPFILE} "${X}" "${Y}" > "${FILENAME}.temp"
                mv -f "${FILENAME}.temp" "${FILENAME}.fore"
                log info "imgcut() Plocha $1 byla zamaskována"
            ;;
            G) #/ Grafika - v rámci vybrané plochy zredukuje barvy a pak ji naklíčuje do barevného pozadí
            ;;
            *) echo "Neimplemnetováno {SIZE[1]}" >> /dev/stderr
                return 1
            ;;
            esac
        ;;
        *) echo "Neplatné nastavení pro cut –> $1" >> /dev/stderr
        ;;
    esac
}

# ### <span id="iscut">iscut()</span> ([top](#FUNCTIONS))
# Ověřuje, zda-li následuje řetězec pro specifikaci oblastí pro zvláštní
# zacházení. Těchto oblastí může být specifikováno více, v takovém případě
# však musí být odděleny středníkem a uzavřeny v uvozovkách
iscut() {
    log goto "iscut() string –> $1"
    local PARAMS=($1)
    log info "vysledek ${PARAMS[0]}"
    case "${PARAMS[0]}" in
        -cut) echo "${PARAMS[1]}"
        ;;
    esac
}

# ### <span id="isscale">isscale()</span> ([top](#FUNCTIONS))
# Nastavuje proměnnou SCALE a vrací ořezaný řetězec
isscale() {
    log goto "isscale() string –> $1"
    local PARAMS=($1)
    log info "vysledek ${PARAMS[0]}"
    case "${PARAMS[0]}" in
        [1-9]+([0-9])x[1-9]+([0-9]))
            case "${PARAMS[1]}" in
                -xyfit|-xyfill|-xysize)
                    SCALE="${PARAMS[1]} ${PARAMS[0]/x/ }"
                    local TEMPORAR=${1#*${PARAMS[1]}}
                ;;
                *) echo """Při škálování na fixní rozmět musí být nastaven jeden z následujících parametrů: 
  -xyfit
  -xyfill
  -xysize
                """
                    echo false
                ;;
            esac
        ;;
        0.|0.0|0.00) echo "Chybně nastavena hodnota škálování: ${PARAMS[0]}" >> /dev/stderr
            echo false
        ;;
        [1-9]+([0-9])x|x[1-9]+([0-9])) echo "Chybně nastavený škálovací box: ${PARAMS[0]}" >> /dev/stderr
            echo false
        ;;
        [0-9].[0-9]?([0-9])|+([0-9]))
            SCALE="${PARAMS[0]}"
            local TEMPORAR=${1#*${PARAMS[0]}}
        ;;
        *) return 1
            ;;
    esac
    if [[ "${TEMPORAR}" =~ "-filter=" ]] ; then
        local PARAMS=(${TEMPORAR#*-filter=})
        if [[ "${FILTERS[@]}" =~ "${PARAMS[0]}" ]] ; then
            echo "${SCALE} -filter=${PARAMS[0]}"
        else
            echo "Neplatný škálovací filtr: ${PARAMS[0]}" >> /dev/stderr
            echo false
        fi
    else
        echo "${SCALE}"
    fi
}

# ### <span id="fromdjvu">fromdjvu()</span> ([top](#FUNCTIONS))
# Na rozdíl od funkce exportimg, se zde zpracovávají předané parametry
# __$1__ je cesta ke kontejneru ze kterého se exportuje stránka
# __$2__ obsahuje parametry
#
# Rozdíl oproti podobné funkci fromfile je ve zpracování výstupu
# Cílem téhle funkce je nahradit funkce fromfile() a extractionpage() a filters()
# ant - Exportuje hyperlinky a meta atributy ve formátu .ant
# meta
# mask|background|foreground|color|black - oxportuje obrázek pozadí
fromdjvu() {
    log goto "fromdjvu() ${FILETYPE} $1 –> $2"
    local INTO=$(isformat "${2}")
    if [ -n "${INTO}" ] ; then
        local TEMPORAR="${2#*${INTO}}"
    else
        echo "Cílový formát musí být vždy uveden!" >> /dev/stderr
        return 1
    fi

    local RANGE=$(isrange "${TEMPORAR}")
    if [ -n "${RANGE}" ] ; then
        local TEMPORAR="${TEMPORAR#*${RANGE}}"
    fi

    case "${TEMPORAR:$((${#TEMPORAR}-1)):1}" in
        /) TARGETDIR=$(${REALPATH} -m -P "${TEMPORAR## }")
            log info "targets() Export pages with a original names into –> ${TARGETDIR}"
            [ ! -d "${TARGETDIR}" ] && mkdir -p "${TARGETDIR}"
        ;;
        *) if [[ "${TEMPORAR}" =~ "/" ]] ; then
                #/ obsahuje cestu
                local TEMPORARY=$(${REALPATH} -m -P "${TEMPORAR## }")
                TARGETDIR="${TEMPORARY%/*}"
                TARGETSAMPLE="${TEMPORARY##*/}"
                log info "targets() Export pages a named by sample ${TARGETSAMPLE} –> ${TARGETDIR}"
                [ ! -d "${TARGETDIR}" ] && mkdir -p "${TARGETDIR}"
            else
                #/ jde o vzorek
                TARGETDIR="$(pwd)"
                TARGETSAMPLE="${TEMPORAR## }"
                log info "targets() Export pages a named by sample ${TARGETSAMPLE} into actual directory"
            fi
        ;;
    esac
    echo '''
    echo "RANGE ${RANGE}"
    echo "INTO ${INTO}"
    echo "TARGETDIR ${TARGETDIR}"
    echo "TARGETSAMPLE ${TARGETSAMPLE}"
    echo "TEMPORAR ${TEMPORAR}"
    echo "Můžeme přikročit k akci"
    ''' >> /dev/null
    mapfile -t LISTPAGES <<< $($0 "${1}" info list)
    case "${INTO}" in
        djvu|ant|meta|mask|background|foreground|color|black|dsed-*|xml-*)
            if [ -n "${RANGE}" ] ; then
                local PAGES=($(range "${RANGE}"))
            else
                case "${TEMPORAR//+([[:blank:]])/}" in
                    '') # jenom příkaz
                        local PAGES=($(range "0-${#LISTPAGES[@]}"))
                    ;;
                    *) # seznam stránek oddělených čárkou
                        local IFS_BAK=$IFS
                        local IFS=$','
                        local SEZNAM=($TEMPORAR)
                        local IFS=$IFS_BAK
                        for i in "${LISTPAGES[@]}" ; do
                            if [[ "${SEZNAM[@]}" =~ "${i#+([[:digit:]]) }" ]] ; then
                                local TEMP="$TEMP${i%% *} "
                            fi
                            x=$((x + 1))
                        done
                        local PAGES=($TEMP)
                    ;;
                esac
            fi
            for i in ${PAGES[@]} ; do
                case "${LISTPAGES[$i]%% *}" in
                    0) #/ echo "${LISTPAGES[$i]#+([[:digit:]]) }"
                        case ${INTO} in
                            ant) printf "# 'shared_anno.iff' # [S]\n"
                                ${DJVUSED} "${1}" -e "select 'shared_anno.iff'; print-ant" | formatdsed
                            ;;
                            meta)
                            ;;
                            dsed-*) local EXPORT="output-ant"
                                local TEMPORAR="${LISTPAGES[$i]#+([[:digit:]]) }"
                                local TARGET=$(${REALPATH} -m -P "${TARGETDIR}/${TEMPORAR}.dsed")
                                if [ -f "${TARGET}" ] ; then
                                    anone "Soubor ${TARGET##*/} již existuje a může obsahovat změny. Mám ho přepsat?"
                                    [ $? -eq 1 ]&& return 1
                                fi
                                printf "select '${LISTPAGES[$i]#+([[:digit:]]) }' ; remove-ant\n" > "${TARGET}"
                                ${DJVUSED} "${1}" -e "select 'shared_anno.iff'; ${EXPORT}" >> "${TARGET}"
                                [ $? -eq 1 ] && return 1
                                echo "Soubor ${TARGET} byl zapsán" >> /dev/stderr
                            ;;
                        esac
                    ;;
                    '') echo ""
                    ;;
                    *) #/ echo "${LISTPAGES[$i]#+([[:digit:]]) }"
                        local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .ant)
                        case ${INTO} in
                            ant) printf "# '${LISTPAGES[$i]#+([[:digit:]]) }' # [P${LISTPAGES[$i]%% *}]\n"
                                ${DJVUSED} "${1}" -e "select ${LISTPAGES[$i]%% *}; print-ant" | formatdsed
                            ;;
                            meta)
                            ;;
                            djvu) local TEMPORAR="${LISTPAGES[$i]#+([[:digit:]]) }"
                                local TARGET=$(${REALPATH} -m -P "${TARGETDIR}/${TEMPORAR}")
                                if [ -f "${TARGET}" ] ; then
                                    anone "Soubor ${TEMPORAR} již existuje. Mám ho přepsat?"
                                    [ $? -eq 1 ]&& return 1
                                fi
                                ${DJVUSED} "${1}" -e "select ${LISTPAGES[$i]%% *}; save-page-with '${TARGET}'"
                                echo "Exportuji stránku Zapisuji do souboru ${TARGET}" >> /dev/stderr
                            ;;
                            mask|background|foreground|color|black)
                                local TEMPORAR="${LISTPAGES[$i]#+([[:digit:]]) }"
                                local TARGET=$(${REALPATH} -m -P "${TARGETDIR}/${TEMPORAR/.djvu/.png}")
                                ${DDJVU} -format=pnm -mode=${INTO} -page="${LISTPAGES[$i]%% *}" "${1}" | ${PNMTOPNG} > "${TARGET}"
                                [ $? -eq 1 ] && return 1
                                echo "Soubor ${TARGET} byl zapsán" >> /dev/stderr
                            ;;
                            dsed-*)
                                case ${INTO} in
                                    dsed-all) local EXPORT="output-all"
                                        local IMPORT="remove-ant; remove-txt"
                                        local TEMPORAR="${LISTPAGES[$i]#+([[:digit:]]) }"
                                        local TARGET=$(${REALPATH} -m -P "${TARGETDIR}/${TEMPORAR/.djvu/.dsed}")
                                    ;;
                                    dsed-txt) local EXPORT="output-txt"
                                        local IMPORT="remove-txt"
                                        local TEMPORAR="${LISTPAGES[$i]#+([[:digit:]]) }"
                                        local TARGET=$(${REALPATH} -m -P "${TARGETDIR}/${TEMPORAR/.djvu/.txt.dsed}")
                                    ;;
                                    dsed-ant) local EXPORT="output-ant"
                                        local IMPORT="remove-ant"
                                        local TEMPORAR="${LISTPAGES[$i]#+([[:digit:]]) }"
                                        local TARGET=$(${REALPATH} -m -P "${TARGETDIR}/${TEMPORAR/.djvu/.ant.dsed}")
                                    ;;
                                    *) return 1
                                    ;;
                                esac
                                if [ -f "${TARGET}" ] ; then
                                    anone "Soubor ${TARGET##*/} již existuje a může obsahovat změny. Mám ho přepsat?"
                                    [ $? -eq 1 ]&& return 1
                                fi
                                printf "select '${LISTPAGES[$i]#+([[:digit:]]) }' ; ${IMPORT}\n" > "${TARGET}"
                                ${DJVUSED} "${1}" -e "select ${LISTPAGES[$i]%% *}; ${EXPORT}" >> "${TARGET}"
                                [ $? -eq 1 ] && return 1
                                echo "Soubor ${TARGET} byl zapsán" >> /dev/stderr
                            ;;
                            xml-*) local TEMPORAR="${LISTPAGES[$i]#+([[:digit:]]) }"
                                local TARGET=$(${REALPATH} -m -P "${TARGETDIR}/${TEMPORAR/.djvu/.xml}")
                                case ${INTO} in
                                    xml-all) local EXPORT="--with-text --with-anno"
                                    ;;
                                    xml-txt) local EXPORT="--with-text --without-anno"
                                    ;;
                                    xml-ant) local EXPORT="--without-text --with-anno"
                                    ;;
                                    *) return 1
                                    ;;
                                esac
                                if [ -f "${TARGET}" ] ; then
                                    anone "Soubor ${TEMPORAR/.djvu/.xml} již existuje a může obsahovat změny. Mám ho přepsat?"
                                    [ $? -eq 1 ]&& return 1
                                fi
                                ${DJVUTOXML} --page "${LISTPAGES[$i]%% *}" ${EXPORT} "${1}" "${TARGET}"
                                [ $? -eq 1 ] && return 1
                                echo "Soubor ${TARGET} byl zapsán" >> /dev/stderr
                            ;;
                        esac
                    ;;
                esac
            done
            ;;
        outline) # Export obsahu ve formátu .outline
            printoutline "${1}"
            ;;
        bookmark) # Export obsahu ve formátu .bookmarks
            local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .outline)
            printoutline "${1}" > ${TEMPFILE}
            outlinetodsed ${TEMPFILE} | encode
            printf "\n"
            ;;
#        meta) #/ printmeta "${FILE}" global
#            # může být vše, ale také jen kus..
#            testsyntaxdsed ${TEMPFILE}
#            ;;
        *) echo "Nedělám nic ${INTO}" >> /dev/stderr
            ;;
    esac
}

# ### <span id="fromcontainer">fromcontainer()</span> ([top](#FUNCTIONS))
# Na rozdíl od funkce exportimg, se zde zpracovávají předané parametry
# __$1__ je cesta ke kontejneru ze kterého se exportuje stránka
# __$2__ obsahuje parametry
#
# Rozdíl oproti podobné funkci fromfile je ve zpracování výstupu
# Cílem téhle funkce je nahradit funkce fromfile() a extractionpage() a filters()
fromcontainer() {
    log goto "fromcontainer() $1 –> $2"

    local INTO=$(isformat "${2}")
    if [ -n "${INTO}" ] ; then
        local TEMPORAR="${2#*${INTO}}"
    else
        echo "Cílový formát musí být vždy uveden!" >> /dev/stderr
        return 1
    fi

    local RANGE=$(isrange "${TEMPORAR}")
    if [ -n "${RANGE}" ] ; then
        local TEMPORAR="${TEMPORAR#*${RANGE}}"
    fi

    local CUT=$(iscut "${TEMPORAR}")
    if [ -n "${CUT}" ] ; then
        local TEMPORAR="${TEMPORAR#*${CUT}}"
    fi

    local SCALE=$(isscale "${TEMPORAR}")
    if [ -n "${SCALE}" ] ; then
        [ "${SCALE}" == "false" ] && return 1
        local PARAM=(${SCALE})
        case "${PARAM[$((${#PARAM[@]}-1))]}" in
            -filter=*)
                log info "fromcontainer()" \
                "Scale use any resize filter –> ${PARAM[$((${#PARAM[@]}-1))]}"
                local TEMPORAR="${TEMPORAR#*${PARAM[$((${#PARAM[@]}-1))]}}"
            ;;
            [0-9]*)
                case ${#PARAM[@]} in
                1) log info "fromcontainer()" \
                    "Only resize scale –> ${PARAM[$((${#PARAM[@]}-1))]}"
                    local TEMPORAR="${TEMPORAR#*${PARAM[$((${#PARAM[@]}-1))]}}"
                ;;
                2) echo \
                    "Někde je chyba v nastavení škálování –> ${SCALE}" >> /dev/stderr
                    return 1
                ;;
                *) #/ 3 a více položek
                    case "${PARAM[0]}" in
                        -xy*) local TEMPORAR="${TEMPORAR#*${PARAM[0]}}"
                        ;;
                        *) echo \
                            "Někde je chyba v nastavení škálování –> ${SCALE}" >> /dev/stderr
                            return 1
                        ;;
                    esac
                ;;
            esac
            ;;
            *) echo "${PARAM[$((${#PARAM[@]}-1))]}"
            ;;
        esac
    fi
    case "${TEMPORAR:$((${#TEMPORAR}-1)):1}" in
        /) TARGETDIR=$(${REALPATH} -m -P "${TEMPORAR## }")
            log info "targets() Export pages with a original names into –> ${TARGETDIR}"
            [ ! -d "${TARGETDIR}" ] && mkdir -p "${TARGETDIR}"
        ;;
        *) if [[ "${TEMPORAR}" =~ "/" ]] ; then
                #/ obsahuje cestu
                local TEMPORARY=$(${REALPATH} -m -P "${TEMPORAR## }")
                TARGETDIR="${TEMPORARY%/*}"
                TARGETSAMPLE="${TEMPORARY##*/}"
                log info "targets() Export pages a named by sample ${TARGETSAMPLE} –> ${TARGETDIR}"
                [ ! -d "${TARGETDIR}" ] && mkdir -p "${TARGETDIR}"
            else
                #/ jde o vzorek
                TARGETDIR="$(pwd)"
                TARGETSAMPLE="${TEMPORAR## }"
                log info "targets() Export pages a named by sample ${TARGETSAMPLE} into actual directory"
            fi
        ;;
    esac
    echo "RANGE ${RANGE}"
    echo "INTO ${INTO}"
    echo "CUT ${CUT}"
    echo "SCALE ${SCALE}"
    echo "TARGETDIR ${TARGETDIR}"
    echo "TARGETSAMPLE ${TARGETSAMPLE}"
    echo "TEMPORAR ${TEMPORAR}"
    echo "Můžeme přikročit k akci ${FILETYPE}"
    echo "DPI ${DPI}"
    echo "ALG ${ALG[@]}"
    # exit 33
    case ${FILETYPE} in
        pbm|pgm|ppm) log info "fromcontainer() Export from ${FILETYPE^^}"
            if [ -n "${RANGE}" ] && [ ! ${RANGE} -eq 1 ] ; then
                echo "Formát ${FILETYPE} podporuje pouze jednu stránku" >> /dev/stderr
                return 1
            fi
            local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .pam)
            #/ Nejdřív je třeba obrázek nakopírovat do pracovního prostoru
            cp "${FILE}" "${TEMPFILE}"
            #/ Pak je třeba vyseparovat výchozí masku
            if [ ${#ALG[@]} -gt 1 ] ; then
                cp "${TEMPFILE}" "${TEMPFILE}.in"
                COUNT=1
                for i in ${ALG[@]} ; do
                    separatemask "${TEMPFILE}.in" "${TEMPFILE}.${COUNT}" "$i"
                    while [ ! -f "${TEMPFILE}.${COUNT}" ] ; do
                        sleep 0.1
                    done
                    ${PAMARITH} -divide "${TEMPFILE}" "${TEMPFILE}.${COUNT}" > "${TEMPFILE}.in"
                    COUNT=$((COUNT + 1))
                done
                echo "Je třeba složit ${COUNT} masek"
                case ${COUNT} in
                    1) #/ Pouze jedna maska 
                        echo "Došlo k nějaké chybě při zpracování cyklu!" >> /dev/stderr
                        return 1 
                    ;;
                    *) #/ Více masek
                        #cp "${TEMPFILE}.1" "${TEMPFILE}.in"
                        while [ ! ${COUNT} -eq 2 ] ; do
                            log info "Slučuji ${TEMPFILE}.$((COUNT - 1)) ${TEMPFILE}.$((COUNT - 2))"
                            ${PAMARITH} -and "${TEMPFILE}.$((COUNT - 1))" "${TEMPFILE}.$((COUNT - 2))" > "${TEMPFILE/.pam/.fore}"
                            COUNT=$((COUNT - 1))
                        done
                    ;;
                esac
                log ok "Masky sloučeny"
            else
                separatemask "${TEMPFILE}" "${TEMPFILE/.pam/.fore}" "${ALG}"
            fi
            if [ -n "${CUT}" ] ; then
                #/ Na masku se aplikují vybrané rámečky
                local BOX=( "${CUT//;/ }" )
                echo "${CUT}" >> /dev/stderr
                for i in ${BOX[@]} ; do
                    imgcut "${i}" "${TEMPFILE}"
                done
            fi
            #exit 33
            if [ -n "${TARGETSAMPLE}" ] ; then
                # jedu podle vzorku
                local TARGET="${TARGETDIR}/${TARGETSAMPLE}.${INTO}"
            else
                local TARGET="${TARGETDIR}/${FILE##*/}.${INTO}"
            fi
            case "${INTO}" in
                djvu) #/ V tomto bodě se v případě DjVu provede konverze
                    encodefile ${TEMPFILE} "${TARGET}"
                    # na anglicke texty dává lepší výsledky cuneiform
                ;;
                mask|pbm) #/ Výsledkem je soubor s cílovým názvem, ale příponou pbm
                    if [ -f "${TEMPFILE/.pam/.text}" ] ; then
                        cp "${TEMPFILE/.pam/.text}" "${TARGET/.mask/.pbm}"
                    else
                        cp "${TEMPFILE/.pam/.fore}" "${TARGET/.mask/.pbm}"
                    fi
                ;;
                back) #/ Výsledkem je PNG soubor pozadí s cílovým názvem, a příponou back.png
                    if [ -f "${TEMPFILE/.pam/.text}" ] ; then
                        ${PAMTOPNG} -alpha="${TEMPFILE/.pam/.text}" "${TEMPFILE}" > "${TARGET}.png"
                    else
                        ${PAMTOPNG} -alpha="${TEMPFILE/.pam/.fore}" "${TEMPFILE}" > "${TARGET}.png"
                    fi
                ;;
                png) #/ konvertuji pozadí
                    if [ -n "${SCALE}" ] ; then
                        ${PAMTOPNM} ${TEMPFILE} | ${PAMSCALE} ${SCALE} | ${PAMTOPNG} > "${TARGET}"
                    else
                        ${PAMTOPNG} ${TEMPFILE} > "${TARGET}"
                    fi
                ;;
                jpg|jpeg)
                    if [ -n "${SCALE}" ] ; then
                        ${PAMTOPNM} ${TEMPFILE} | ${PAMSCALE} ${SCALE} | ${PNMTOJPEG} > "${TARGET}"
                    else
                        ${PNMTOJPEG} ${TEMPFILE} > "${TARGET}"
                    fi
                ;;
                jp2)
                    if [ -n "${SCALE}" ] ; then
                        ${PAMTOPNM} ${TEMPFILE} | ${PAMSCALE} ${SCALE} | ${PAMTOJPEG2K} > "${TARGET}"
                    else
                        ${PAMTOJPEG2K} ${TEMPFILE} > "${TARGET}"
                    fi
                ;;
                *) log info "Konverze do výchozího formátu ${FILETYPE} není nutná"
                    cp "${TEMPFILE}" "${TARGET%.}.pam"
                ;;
            esac
        ;;
        jpeg) log info "fromcontainer() Export from JPEG into ${INTO}"
            #exit 33
            local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .pam)
            if [ -n "${TARGETSAMPLE}" ] ; then
                # jedu podle vzorku
                local TARGET="${TARGETDIR}/${TARGETSAMPLE}.${INTO}"
            else
                local TARGET="${TARGETDIR}/${FILE##*/}.${INTO}"
            fi
            case "${INTO}" in
                djvu) #/ V tomto bodě se v případě DjVu provede konverze
                    encodefile ${TEMPFILE} "${TARGET}"
                    # na anglicke texty dává lepší výsledky cuneiform
                ;;
                mask|pbm) #/ Výsledkem je soubor s cílovým názvem, ale příponou pbm
                    $0 ${FILE} export 1 mask ${TEMPFILE}
                    #if [ -f "${TEMPFILE/.pam/.text}" ] ; then
                    #    cp "${TEMPFILE/.pam/.text}" "${TARGET/.mask/.pbm}"
                    #else
                    #    cp "${TEMPFILE/.pam/.fore}" "${TARGET/.mask/.pbm}"
                    #fi
                ;;
                back) #/ Výsledkem je PNG soubor pozadí s cílovým názvem, a příponou back.png
                    $0 ${FILE} export 1 back ${TEMPFILE}
                ;;
                pnm) echo "POZOR! Při konverzi do PNM formátu dojde ke ztrátě meta informací a tím i k anonymizaci obrázku" >> /dev/stderr
                    ${JPEGTOPNM} -dct float -dumpexif -exif="${TEMPFILE/.pam/.exif}" -repair "${FILE}" > ${TEMPFILE}
                    if [ -n "${SCALE}" ] ; then
                        ${PAMTOPNM} ${TEMPFILE} | ${PAMSCALE} ${SCALE} > "${TARGET}"
                    else
                        cp ${TEMPFILE} "${TARGET}"
                    fi
                ;;
                png) log info "export do PNG"
                    if [ -n "${SCALE}" ] ; then
                        $0 ${FILE} export 1 png ${TEMPFILE}
                    else
                        $0 ${FILE} export 1 png ${TEMPFILE}
                    fi
                ;;
                jpg|jpeg) 
                    if [ -n "${SCALE}" ] ; then
                        $0 ${FILE} export 1 pnm ${TEMPFILE}
                        ${PAMTOPNM} ${TEMPFILE} | ${PAMSCALE} ${SCALE} | ${PNMTOJPEG} > "${TARGET}"
                    else
                        log info "export do výchozího formátu ${FILETYPE} má smysl pouze při přeškálování"
                    fi
                ;;
                jp2)
                    if [ -n "${SCALE}" ] ; then
                        ${PAMTOPNM} ${TEMPFILE} | ${PAMSCALE} ${SCALE} | ${PAMTOJPEG2K} > "${TARGET}"
                    else
                        ${PAMTOJPEG2K} ${TEMPFILE} > "${TARGET}"
                    fi
                ;;
                *) log info "Konverze do výchozího formátu ${FILETYPE} má smysl pouze při škálování"
                    return 1
                ;;
            esac
        ;;
        png)   log info "fromcontainer() Export from PNG"
            case "${INTO}" in
                images) echo "Parametr použitelný pouze u PDF - exportují se obrázky místo stránek" >> /dev/stderr
                    return 1
                ;;
                ocr) echo "TODO Aplikace OCR na konverovaný originální soubor" >> /dev/stderr
                ;;
                txt|text) echo "Parametr použitelný pouze u PDF - exportují se text místo stránky" >> /dev/stderr
                    return 1
                ;;
                *)
                    log info "fromcontainer() Original file is exported from container without conversion"
                    local PAGES=($(range "${RANGE}"))
                    local LISTPAGES=($(listpng "${FILE}"))
                    #/ echo "${LISTPAGES[-1]}"
                    #/ echo "${PAGES[@]}"
                    for i in ${PAGES[@]} ; do
                        local PAGE="${LISTPAGES[$((i-1))]}"
                        case "${INTO}" in
                            png|orig*)
                                if [ -n "${TARGETSAMPLE}" ] ; then
                                    # jedu podle vzorku
                                    local TEMPORAR=$(printf "${TARGETSAMPLE}" $i)
                                    local TARGET="${TARGETDIR}/${TEMPORAR// /0}.png"
                                else
                                    local TARGET="${TARGETDIR}/${PAGE}.png"
                                fi
                                local TEMPFILE=$(tempfile)
                                if [ -n "${SCALE}" ] ; then
                                    local FORSCALE=$(tempfile)
                                    $(itempng "${FILE}" "${PAGE}" > "${FORSCALE}")
                                    pamscale ${SCALE} ${FORSCALE} > ${TEMPFILE}
                                    rm ${FORSCALE}
                                else
                                    $(itempng "${FILE}" "${PAGE}" > "${TEMPFILE}")
                                fi
                                convertovergimp png "${TEMPFILE}"
                                mv -i "${TEMPFILE}.png" "${TARGET}"
                                [ -f "${TEMPFILE}" ] && rm "${TEMPFILE}"
                            ;;
                                pnm|pam)
                                    if [ -n "${TARGETSAMPLE}" ] ; then
                                        # jedu podle vzorku
                                        local TEMPORAR=$(printf "${TARGETSAMPLE}" $i)
                                        local TARGET="${TARGETDIR}/${TEMPORAR// /0}.${INTO}"
                                    else
                                        local TARGET="${TARGETDIR}/${PAGE}.${INTO}"
                                    fi
                                    local TEMPFILE=$(tempfile)
                                    if [ -n "${SCALE}" ] ; then
                                        local FORSCALE=$(tempfile)
                                        $(itempng "${FILE}" "${PAGE}" > "${FORSCALE}")
                                        pamscale ${SCALE} ${FORSCALE} > ${TEMPFILE}
                                        rm ${FORSCALE}
                                    else
                                        $(itempng "${FILE}" "${PAGE}" > "${TEMPFILE}")
                                    fi
                                    case "${INTO}" in
                                        pnm|pam)
                                            mv -i "${TEMPFILE}" "${TARGET}"
                                        ;;
                                        *) echo "Unsupported format –> ${INTO}" >> /dev/stderr
                                            return 1
                                        ;;
                                    esac
                                    [ -f "${TEMPFILE}" ] && rm "${TEMPFILE}"
                                ;;
                                *) echo "U XCF souborů je třeba uvést typ cílového souboru" >> /dev/stderr
                                    return 1
                                ;;
                            esac
                        done
                ;;
            esac
        ;;
        pdf)  log info "fromcontainer() Export from PDF"
            case "${INTO}" in
                images) log info "exportuji pouze obrázky z ředaného rozsahu"
                ;;
                ocr) log info "exportuji stránku jako obrázek a aplikuji OCR"
                ;;
                txt|text) log info "exportuji stránku jako text"
                ;;
                pdf) 
                    if [ -n "${TARGETSAMPLE}" ] ; then
                        # jedu podle vzorku
                        local TEMPORAR=$(printf "${TARGETSAMPLE}" $i)
                        local TARGET="${TARGETDIR}/${TARGETSAMPLE}_${RANGE}.pdf"
                    else
                        local TARGET="${TARGETDIR}/${FILE##*/}"
                        pdftopdf "${FILE}" "${TARGET/.pdf/${RANGE}}.pdf"
                    fi
                ;;
                *) if [ "${INTO}" == "" ] ; then
                        echo "Neuvedený formát. " >> /dev/stderr
                        if [ -n "${TARGETSAMPLE}" ] ; then
                            # jedu podle vzorku
                            local TEMPORAR=$(printf "${TARGETSAMPLE}" $i)
                            local TARGET="${TARGETDIR}/${TEMPORAR// /0}.${INTO}"
                        else
                            local TARGET="${TARGETDIR}/${FILE##*/}"
                            pdftopdf "${FILE}" "${TARGET/.pdf/_${RANGE}}.pdf"
                        fi
                    else
                        echo "Unsupported format –> ${INTO}" >> /dev/stderr
                        return 1
                    fi
                ;;
            esac
        ;;
        gimp|xcf) log info "fromcontainer() Export from XCF"
            case "${INTO}" in
                images) echo "Parametr použitelný pouze u PDF - exportují se obrázky místo stránek" >> /dev/stderr
                    return 1
                ;;
                ocr) echo "TODO Aplikace OCR na konverovaný originální soubor" >> /dev/stderr
                ;;
                txt|text) echo "Parametr použitelný pouze u PDF - exportují se text místo stránky" >> /dev/stderr
                    return 1
                ;;
                *)
                    log info "fromcontainer() Original file is exported from container without conversion"
                    local PAGES=($(range "${RANGE}"))
                    local LISTPAGES=($(listxcf "${FILE}"))
                    #/ echo "${LISTPAGES[-1]}"
                    #/ echo "${PAGES[@]}"
                    for i in ${PAGES[@]} ; do
                        local PAGE="${LISTPAGES[$((i-1))]}"
                        case "${INTO}" in
                            xcf|orig*)
                                if [ -n "${TARGETSAMPLE}" ] ; then
                                    # jedu podle vzorku
                                    local TEMPORAR=$(printf "${TARGETSAMPLE}" $i)
                                    local TARGET="${TARGETDIR}/${TEMPORAR// /0}.xcf"
                                else
                                    local TARGET="${TARGETDIR}/${PAGE}.xcf"
                                fi
                                local TEMPFILE=$(tempfile)
                                if [ -n "${SCALE}" ] ; then
                                    local FORSCALE=$(tempfile)
                                    $(itemxcf "${FILE}" "${PAGE}" > "${FORSCALE}")
                                    pamscale ${SCALE} ${FORSCALE} > ${TEMPFILE}
                                    rm ${FORSCALE}
                                else
                                    $(itemxcf "${FILE}" "${PAGE}" > "${TEMPFILE}")
                                fi
                                convertovergimp xcf "${TEMPFILE}"
                                mv -i "${TEMPFILE}.xcf" "${TARGET}"
                                [ -f "${TEMPFILE}" ] && rm "${TEMPFILE}"
                            ;;
                                pnm|pam)
                                    if [ -n "${TARGETSAMPLE}" ] ; then
                                        # jedu podle vzorku
                                        local TEMPORAR=$(printf "${TARGETSAMPLE}" $i)
                                        local TARGET="${TARGETDIR}/${TEMPORAR// /0}.${INTO}"
                                    else
                                        local TARGET="${TARGETDIR}/${PAGE}.${INTO}"
                                    fi
                                    local TEMPFILE=$(tempfile)
                                    if [ -n "${SCALE}" ] ; then
                                        local FORSCALE=$(tempfile)
                                        $(itemxcf "${FILE}" "${PAGE}" > "${FORSCALE}")
                                        pamscale ${SCALE} ${FORSCALE} > ${TEMPFILE}
                                        rm ${FORSCALE}
                                    else
                                        $(itemxcf "${FILE}" "${PAGE}" > "${TEMPFILE}")
                                    fi
                                    case "${INTO}" in
                                        pnm|pam)
                                            mv -i "${TEMPFILE}" "${TARGET}"
                                        ;;
                                        *) echo "Unsupported format –> ${INTO}" >> /dev/stderr
                                            return 1
                                        ;;
                                    esac
                                    [ -f "${TEMPFILE}" ] && rm "${TEMPFILE}"
                                ;;
                                *) echo "U XCF souborů je třeba uvést typ cílového souboru" >> /dev/stderr
                                    return 1
                                ;;
                            esac
                        done
                ;;
            esac
        ;;
        zip|tar) log info "fromcontainer() Export from archive"
            case "${INTO}" in
                images) echo "Parametr použitelný pouze u PDF - exportují se obrázky místo stránek" >> /dev/stderr
                    return 1
                ;;
                ocr) echo "TODO Aplikace OCR na konverovaný originální soubor" >> /dev/stderr
                ;;
                txt|text) echo "Parametr použitelný pouze u PDF - exportují se text místo stránky" >> /dev/stderr
                    return 1
                ;;
                *) local PAGES=($(range "${RANGE}"))
                    local LISTPAGES=($(listzip "${FILE}"))
                    #echo "${LISTPAGES[-1]}"
                    #echo "${PAGES[@]}"
                    for i in ${PAGES[@]} ; do
                        local PAGE="${LISTPAGES[$((i-1))]}"
                        case "${INTO}" in
                            pnm|pam|png|jpg|tiff|jp2) local SUFFIX="${PAGE##*.}"
                                case ${SUFFIX} in
                                    jp2) $(itemzip "${FILE}" "${PAGE}" |\
                                        ${JPEG2KTOPAM} > "${TEMPFILE}")
                                    ;;
                                    jpg) $(itemzip "${FILE}" "${PAGE}" |\
                                        ${JPEGTOPNM} > "${TEMPFILE}")
                                    ;;
                                    png) $(itemzip "${FILE}" "${PAGE}" |\
                                        ${PNGTOPNM} > "${TEMPFILE}")
                                    ;;
                                    tiff) $(itemzip "${FILE}" "${PAGE}" |\
                                        ${TIFFTOPNM} > "${TEMPFILE}")
                                    ;;
                                    *) echo "Nepodporovaný formát ${SUFFIX}"
                                        return 1
                                    ;;
                                esac
                                if [ -n "${TARGETSAMPLE}" ] ; then
                                    # jedu podle vzorku
                                    local TEMPORAR=$(printf "${TARGETSAMPLE}" $i)
                                    local TARGET="${TARGETDIR}/${TEMPORAR// /0}.${INTO}"
                                else
                                    local TEMPORAR="${PAGE#*/}"
                                    local TARGET="${TARGETDIR}/${TEMPORAR%.*}.${INTO}"
                                fi
                                case ${INTO} in
                                    jp2) if [ -n "${SCALE}" ] ; then
                                            $(${PAMTOPNM} ${TEMPFILE} |\
                                                ${PAMSCALE} ${SCALE} |\
                                                ${PAMTOJPEG2K} > "${TARGET}")
                                        else
                                            $(${PAMTOPNM} ${TEMPFILE} |\
                                                ${PAMTOJPEG2K} > "${TARGET}")
                                        fi
                                    ;;
                                    jpg)if [ -n "${SCALE}" ] ; then
                                            $(${PAMTOPNM} ${TEMPFILE} |\
                                                ${PAMSCALE} ${SCALE} |\
                                                ${PNMTOJPEG} > "${TARGET}")
                                        else
                                            $(${PAMTOPNM} ${TEMPFILE} |\
                                                ${PNMTOJPEG} > "${TARGET}")
                                        fi
                                    ;;
                                    tiff) if [ -n "${SCALE}" ] ; then
                                            $(${PAMTOPNM} ${TEMPFILE} |\
                                                ${PAMSCALE} ${SCALE} |\
                                                ${PAMTOTIFF} > "${TARGET}")
                                        else
                                            $(${PAMTOPNM} ${TEMPFILE} |\
                                                ${PAMTOTIFF} > "${TARGET}")
                                        fi
                                    ;;
                                    png) if [ -n "${SCALE}" ] ; then
                                            $(${PAMTOPNM} ${TEMPFILE} |\
                                                ${PAMSCALE} ${SCALE} |\
                                                ${PAMTOPNG} > "${TARGET}")
                                        else
                                            $(${PAMTOPNM} ${TEMPFILE} |\
                                                ${PAMTOPNG} > "${TARGET}")
                                        fi
                                    ;;
                                    pnm|pam) if [ -n "${SCALE}" ] ; then
                                            $(${PAMTOPNM} ${TEMPFILE} |\
                                                ${PAMSCALE} ${SCALE} > "${TARGET}")
                                        else
                                            $(${PAMTOPNM} ${TEMPFILE} > "${TARGET}")
                                        fi
                                    ;;
                                esac
                                echo "Page $i saved as ${TARGET}" >> /dev/stderr
                                ;;
                            *) local SUFFIX="${PAGE##*.}"
                                if [ -n "${TARGETSAMPLE}" ] ; then
                                    # jedu podle vzorku
                                    local TEMPORAR=$(printf "${TARGETSAMPLE}" $i)
                                    local TARGET="${TARGETDIR}/${TEMPORAR// /0}.${SUFFIX}"
                                else
                                    local TARGET="${TARGETDIR}/${PAGE#*/}"
                                fi
                                if [ -n "${SCALE}" ] ; then
                                    anone "Při přeškálování do původního formátu dojde k degradaci kvality obrazu mám pokračovat?"
                                    [ $? -eq 1 ] && return 1
                                    case ${SUFFIX} in
                                        jp2) $(itemzip "${FILE}" "${PAGE}" |\
                                                ${JPEG2KTOPAM} |\
                                                ${PAMSCALE} ${SCALE} |\
                                            ${PAMTOJPEG2K} > "${TARGET}")
                                        ;;
                                        jpg) $(itemzip "${FILE}" "${PAGE}" |\
                                            ${JPEGTOPNM} |\
                                            ${PAMSCALE} ${SCALE} |\
                                            ${PNMTOJPEG} > "${TARGET}")
                                        ;;
                                        png) $(itemzip "${FILE}" "${PAGE}" |\
                                            ${PNGTOPNM} |\
                                            ${PAMSCALE} ${SCALE} |\
                                            ${PAMTOPNG} > "${TARGET}")
                                        ;;
                                        tiff) $(itemzip "${FILE}" "${PAGE}" |\
                                            ${TIFFTOPNM} |\
                                            ${PAMSCALE} ${SCALE} |\
                                            ${PAMTOTIFF} > "${TARGET}")
                                        ;;
                                    esac
                            else
                                log info "fromcontainer() Original file ${PAGE} is exported from container without conversion"
                                $(itemzip "${FILE}" "${PAGE}" > "${TARGET}")
                            fi
                            echo "Page $i saved as ${TARGET}" >> /dev/stderr
                            ;;
                        esac
                    done
                ;;
            esac
        ;;
    esac
    return 0
}

# ### <span id="exportimg">exportimg()</span> ([top](#FUNCTIONS))
# Funkce exportuje ze souboru stránky jako obrázky.
# Vstupními parametry jsou globální proměnné:
# * FILE - Soubor ze kterého se stránka exportuje.
# * CHARSTRING - Proměnná, která obsahuje další parametry:
# ** Rozsah exportovaných stránek. Není-li uveden, budou exportovány
#    všechny stránky ze souboru.
# ** Formát cílového souboru
# ** Velikost cílového souboru, nastavená buď formou XxY, nebo procetuálně Z%
#
# Místo parametrů může být také předána také cesta k souboru, ve kterém
# mohou být parametry nastaveny specificky pro každou stránku (rozsah)
# zvlášť. Tento soubor __musí__ mít příponu `.list`
#
# Za parametry, nebo cestou k souboru s příponou `.list` může následovat
# cílový adresář, resp. vzor pro pojmenování stránek
#
#     example/example
#
# Při exportu jpeg souborů z archívu uloží do podadresáře example
# exportované stránky pod názvy: example_00001.jpg, example_00002.jpg, …
#
exportimg() {
    log goto "exportimg() ${FILE} –> ${CHARSTRING}"
    if [[ "${CHARSTRING}" =~ "?" ]] ||\
        [[ "${CHARSTRING}" =~ "-h" ]] ||\
        [[ "${CHARSTRING}" =~ "help" ]] ; then
        help bitmap-export
    elif [[ "${CHARSTRING}" =~ ".list" ]] ; then
        local SOURCE=$(${REALPATH} -m -P "${CHARSTRING%.list*}.list" 2>/dev/null)
        if [ -f "${SOURCE}" ] ; then
            log info "exportimg() Read params from –> ${SOURCE}"
            local TARGET="${CHARSTRING#*.list}"
            while read line ; do
                CHARSTRING="$line ${TARGET}"
                fromcontainer "${FILE}" "${CHARSTRING}"
            done < "${SOURCE}"
        else
            return 1
        fi
    else
        fromcontainer "${FILE}" "${CHARSTRING}"
    fi
    return $?
}

# ### <span id="viewimg">viewimg()</span> ([top](#FUNCTIONS))
#
viewimg() {
    log info "viewimg() open –> ${FILE}"
    case ${FILETYPE} in
        pnm|ppm|pgm|pbm|pam|\
        png|jpg|jpeg|bmp|gif|tiff) if [ -n "${FEH}" ] ; then
                local TEMPORARY=($(parsecut $(xrandr | grep '[ ]connected' | head -1 | cut -d' ' -f3)))
                echo "${TEMPORARY[@]}" >> /dev/stderr
                local W=$(( ${TEMPORARY[0]} / 2 ))
                local H=$(( ${TEMPORARY[1]} / 2 ))
                local X=50
                local Y=50
                echo "${W}x${H}+${X}+${Y}" >> /dev/stderr
                ${FEH} --scale-down --auto-zoom --geometry "${W}x${H}+${X}+${Y}" "${FILE}"
            else
                ${GEEQIE} "${FILE}"
            fi
        ;;
        plain|jpeg-2000) local TEMPFILE="${TEMPDIR}/${FILE##*/}"
            ${JPEG2KTOPAM} ${FILE} > ${TEMPFILE}
            #opj_decompress -i ${FILE} -o ${TEMPFILE} -l 1
            ls -alh ${TEMPFILE}
            exiftool ${TEMPFILE}
            $0 ${TEMPFILE} view
        ;;
#        gimp|pdf|xcf|eps|psd|tga|ps)
#            ${GIMP} "${FILE}"
#        ;;
        gimp) isrange ${CHARSTRING}
            if [ $? -eq 0 ] ; then
                local PAGES=($(range "${CHARSTRING}"))
                local LISTPAGES=($(listxcf "${FILE}"))
                #echo "${LISTPAGES[-1]}"
                #echo "${PAGES[@]}"
                for i in ${PAGES[0]} ; do
                    local PAGE="${LISTPAGES[$((i-1))]}"
                    $(itemxcf "${FILE}" "${PAGE}" > "${TEMPDIR}/${PAGE##*/}.pam")
#                    exit 33
                    $0 view "${TEMPDIR}/${PAGE##*/}.pam"
                done
            else
                echo "V případě xcf souboru musí být uvedeno číslo stránky" >> /dev/stderr
                return 1
            fi
        ;;
        zip) isrange ${CHARSTRING}
            if [ $? -eq 0 ] ; then
                local PAGES=($(range "${CHARSTRING}"))
                local LISTPAGES=($(listzip "${FILE}"))
                #echo "${LISTPAGES[-1]}"
                #echo "${PAGES[@]}"
                for i in ${PAGES[0]} ; do
                    local PAGE="${LISTPAGES[$((i-1))]}"
                    $(itemzip "${FILE}" "${PAGE}" > "${TEMPDIR}/${PAGE##*/}")
                    $0 view "${TEMPDIR}/${PAGE##*/}"
                done
            else
                echo "V případě kontejneru musí být uvedeno číslo stránky" >> /dev/stderr
                return 1
            fi
        ;;
        *) echo "Nepodporovaný formát ${FILETYPE}" >> /dev/stderr
            return 1
        ;;
    esac
}

# ### <span id="infoimg">infoimg()</span> ([top](#FUNCTIONS))
# Funkce vypisuje info o bitmapových souborech a případně vicestránkových
# formátů i jejich stránkách.
# Vstupními parametry jsou globální proměnné:
# * FILE - Soubor ze kterého se stránka exportuje.
# * CHARSTRING - Proměnná, která obsahuje další parametry:
# ** typ zobrazované informace
# ** a případně číslo konkrétní stránky (vrstvy)
infoimg() {
    log goto "infoimg() ${FILE} –> ${CHARSTRING}"
    if [[ "${CHARSTRING}" =~ "?" ]] ||\
        [[ "${CHARSTRING}" =~ "-h" ]] ||\
        [[ "${CHARSTRING}" =~ "help" ]] ; then
        help bitmap-info
    else
        case ${FILETYPE} in
            gif) # GIF je grafický formát, s bezztrátovou kompresí, který
                # má podporu pro animace.
                # Je omezený především v tom, že má k dispozici pouze 256
                # barev. Za určitých okolností může fungovat i jako
                # kontejner pro více stránkové dokumenty (co vrstva, to stránka).
                #
                # Výhodou GIF formátu oproti MNG či (AP)NG je především
                # to, že má širokou podporu u webových prohlížečů. Proto
                # se vyžívá především pro náhledy vícestránkových dokumentů.
                # Kdy se náhledy vybraných stránek, uložené jako jednotlivé
                # snímky přehrávají v nekonečné smyčce.
                # Počet snímků (stránek) udává exif tag 'Animation frames'
                #
                # .gif
                case ${CHARSTRING} in
                    meta*) ${EXIFTOOL} "${FILE}"
                    ;;
                    pages) echo "Zjistit počet vrstev"
                    ;;
                    *) local INFO=($(cat "${FILE}"|infoitem))
                        echo "${INFO[@]}"
                    ;;
                esac
            ;;
            jpg|jpeg) # JPEG je grafický formát se ztrátovou kompresí, který
                # podporuje pouze jednu vrstvu
                #
                # .jpg, .jpeg, .jpe, .jif, .jfif, .jfi
                case ${CHARSTRING} in
                    meta*) ${EXIFTOOL} "${FILE}"
                    ;;
                    pages) echo "1"
                    ;;
                    *) local INFO=($(cat "${FILE}"|infoitem))
                        echo "${INFO[@]}"
                    ;;
                esac
            ;;
            jpeg-2000) # JPEG 2000 je grafický formát, který pracuje se
                # ztrátovou, ale i bezeztrátovou wavelet kompresí. To je
                # klíčovým rozdílem oproti DjVu, protože u DjVu z principu
                # vždy dojde k částečné ztrátě grafické informace.
                # Oproti bezeztrátovému PNG má lepší kompresní poměr. A
                # při ztrátové kompresi je výsledek po dekompresi vždy
                # lepší než u JPEG formátu.
                # Nevýhodou je zdlouhavá dekomprese a tím i pomalejší
                # zobrazování v prohlížeči. Proto se využívá především
                # pro archivaci původního skenu.
                #
                # Nepodporuje více vrstev! Proto se naskenované soubory
                # obvykle zabalí do `.zip` kontejneru
                #
                # .jp2, .j2k, .jpf, .jpx, .jpm, .mj2
                case ${CHARSTRING} in
                    meta*) ${EXIFTOOL} "${FILE}"
                    ;;
                    pages) echo "1"
                    ;;
                    *) local INFO=($(cat "${FILE}"|infoitem))
                        echo "${INFO[@]}"
                    ;;
                esac
            ;;
            pnm|pgm|pbm|ppm) # Formát se kterým přišel projekt Netpbm.
                # Nepodporuje více vrstev!!!
                # PNM formát (portable anymap) zastupuje následující formáty:
                # * PBM - portable bitmap (černobílé obrázky)
                #   V hlavičce má P1 (P4 - binární formát)
                # * PGM - portable graymap (obrázky ve stupních šedi)
                #   V hlavičce má P2 (P5 - binární formát)
                # * PPM - portable pixmap (RGB obrázky)
                #   V hlavičce má P3 (P6 - binární formát)
                # * PAM - portable anymap, zastupuje podobně jako PNM
                #   všechny formáty a v má hlavičce P7. Je schopen zachytit
                #   barvy stejně jako CMYK
                #
                # Rozdíly jsou především v popdpoře bitové hloubky barev:
                # 48-bitů podporuje pouze PPM (rgb48be)
                # 32-bitů podporuje plain PNM a plain PAM - binární verze nikoliv!!!
                # 24-bitová podopora je u všech formátů
                # 16-bitů PGM a PAM bez průhlednosti (grap16be)
                #
                # https://en.wikipedia.org/wiki/Netpbm_format
                case ${CHARSTRING} in
                    meta*) ${EXIFTOOL} "${FILE}"
                    ;;
                    pages) echo "1"
                    ;;
                    *) local INFO=($(cat "${FILE}"|infoitem))
                        echo "${INFO[@]}"
                    ;;
                esac
            ;;
            mng) # MNG je formát pro animace, založený na PNG, podobně
                # jako (A)PNG. Není moc rozšířený.
                # Počet vrstev udává v exifu 'Animation frames'
                #
                # .mng
                case ${CHARSTRING} in
                    meta*) ${EXIFTOOL} "${FILE}"
                    ;;
                    pages) local SUMPAGES=$(${IDENTIFY} "${FILE}" | wc -l)
                        echo "${SUMPAGES}"
                    ;;
                    *) local INFO=($(cat "${FILE}"|infoitem))
                        local SUMPAGES=$(${IDENTIFY} "${FILE}" | wc -l)
                        echo "${INFO[@]} ${SUMPAGES}"
                    ;;
                esac
            ;;
            png) # PNG je formát, u kterého se původně vůbec nepočítalo,
                # že by mohl mít více než jednu vrstvu. Protože ale formát
                # GIF, který animace podporuje, má svá omezení (nepodporuje
                # průhlednost a má k dispozici pouze 256 barev), vzniklo
                # jako alternativa APNG – což je svým způsobem video
                # kontejner, který obsahuje řadu po sobě jdoucích PNG obrázků.
                #
                # Oproti podobnému MNG formátu však umožňuje zpětnou
                # kompatibilitu, kdy se v prohlížečích co animace nepodporují,
                # zobrazuje pouze první snímek. Soubory mají stejnou příponu
                # .png, jako klasické PNG
                #
                # Počet vrstev udává exif tag 'Animation frames'
                #
                # .png
                case ${CHARSTRING} in
                    meta*) ${EXIFTOOL} "${FILE}"
                    ;;
                    pages) echo "Zjistit počet vrstev"
                    ;;
                    *) local INFO=($(cat "${FILE}"|infoitem))
                        echo "${INFO[@]}"
                    ;;
                esac
            ;;
            gimp|xcf) # Nativní formát Gimpu může mít více vrstev
                case ${CHARSTRING} in
                    meta*)  ${EXIFTOOL} "${FILE}"
                    ;;
                    pages\ +([0-9])|pages\ all|pages)
                        local TEMPORAR=(${CHARSTRING})
                        case ${TEMPORAR[1]} in
                            all) ${XCFINFO} -u "${FILE}"
                            ;;
                            +([0-9])) ${XCFINFO} -u "${FILE}" | \
                                grep -m ${TEMPORAR[1]} '^+.*RGB.*Normal' | \
                                tail -1
                            ;;
                            *) local SUMPAGES=$(${XCFINFO} "${FILE}" | wc -l)
                                echo "${SUMPAGES}"
                            ;;
                        esac
                    ;;
                    *) local INFO=($(cat "${FILE}"|infoitem))
                        local SUMPAGES=$(${XCFINFO} "${FILE}" | wc -l)
                        echo "${INFO[@]} ${SUMPAGES}"
                    ;;
                esac
            ;;
            tiff) # Formát TIFF může mít více stránek
                case ${CHARSTRING} in
                    meta*) ${EXIFTOOL} "${FILE}"
                    ;;
                    pages) local SUMPAGES=$(${TIFFINFO} "${FILE}" | grep "TIFF Directory" | wc -l)
                        echo "${SUMPAGES}"
                    ;;
                    *) local INFO=($(cat "${FILE}"|infoitem))
                        local SUMPAGES=$(${TIFFINFO} "${FILE}" | grep "TIFF Directory" | wc -l)
                        echo "${INFO[@]} ${SUMPAGES}"
                    ;;
                esac
            ;;
            stl|pcd) # PCD je rastrový formát fy. Kodak
                # Starší formát, pro jehož konverzi lze použít ImageMagick,
                # ale lepší výsledky dává již delší dobu neudržovaná konverzní
                # utilita pcdtojpeg.
                # http://pcdtojpeg.sourceforge.net/Download.html
                #
                # Formát je podobný formátu Tiled Multi-Resolution TIFF
                # …
                # Obrázek je v kontejneru uložen v 6
                # velikostech:
                # Suffix [1] produces an image 192 by 128 ("Base/16")
                # Suffix [2] produces an image 384 by 256 ("Base/4")
                # Suffix [3] produces an image 768 by 512 ("Base")
                # Suffix [4] produces an image 1536 by 1024 ("4 Base")
                # Suffix [5] produces an image 3072 by 2048 ("16 Base")
                # Suffix [6] produces an image 6144 by 4096 ("64 Base")
                #
                # Poznámka: Když použijete číslo 7 a vyšší tak to má stejný
                # efekt jako když se použije 6
                #
                # Při konverzi vychází obrázek moc tmavý to lze pořešit buď
                # nastavením barevného profilu, nebo gammy
                # Resolutin
                # Contrast
                # Saturation
                # Red
                # Green
                # Nepodporuje více stránek
                #
                # https://en.wikipedia.org/wiki/Photo_CD
                case ${CHARSTRING} in
                    meta*) ${EXIFTOOL} "${FILE}"
                    ;;
                    pages) echo "1"
                    ;;
                    *) local INFO=($(cat "${FILE}"|infoitem))
                        echo "${INFO[@]}"
                    ;;
                esac
            ;;
            psd|psb) # Proprietární formát Photoshopu
                # PSB je PSD rozšířené na podporu obrázků o velikosti
                # 300 tis. pixelů. Standardní PSD podporuje max. 30 tis.
                # pixelů. Pracuje s vrstvami
                # .psd .psb
            ;;
            pdf) # PDF - portable document format, je do učité míry
                # alternativou k DjVu. Nebyl ale navržen pro rychlé
                # prohlížení (jako DjVu) ale pro lepší přenositelnost mezi
                # operačními systémy. Z toho plynou i jeho nevýhody.
                # Především zdlouhavá dekomprese.
                #
                # Z principu má podporu pro více stránek
                case ${CHARSTRING} in
                    meta*) pdfinfo -box "${FILE}"
                    ;;
                    *) local INFO=($(cat "${FILE}"|infoitem))
                        local SUMPAGES=$(${EXIFTOOL} -s3 -PageCount "${FILE}")
                        echo "${INFO[@]} ${SUMPAGES}"
                    ;;
                esac
            ;;
            sgi) #
                # https://en.wikipedia.org/wiki/Silicon_Graphics_Image
            ;;
            tga) # 
                # https://en.wikipedia.org/wiki/Truevision_TGA
            ;;
            webp) #
                # https://en.wikipedia.org/wiki/WebP
            ;;
            xbm) #
                # https://en.wikipedia.org/wiki/X_BitMap
            ;;
            xpm) #
                # https://en.wikipedia.org/wiki/X_PixMap
            ;;
            xwd) # Formát do kterého ukládá screenshoty obrazovky X Windows systems
                # https://en.wikipedia.org/wiki/Xwd
            ;;
            tar|zip) # Nejde o grafické formáty, ale kontejnery, co můžou
                # obsahovat různé typy souborů. Na serveru archive.org se
                # využívají pro zabalení souborů skenů ve formátu jp2, jpeg aj.
                case ${CHARSTRING} in
                    list) listzip "${FILE}"
                    ;;
                    meta*) #/ může být archiv s obrázky
                        local LISTPAGES=($(listzip "${FILE}"))
                        local PAGE="${CHARSTRING#meta }"
                        case ${PAGE} in
                            meta) log info "main() Exif info for first file ${LISTPAGES[0]} from archive ${FILE}"
                                echo $(itemzip "${FILE}" "${LISTPAGES[0]}" | infoitem)
                            ;;
                            *) if [ "${PAGE}" -ge "0" ] && [ "${PAGE}" -lt "${#LISTPAGES[@]}" ] ; then
                                    log info "main() Exif info for ${PAGE} file: ${LISTPAGES[${PAGE}]} from archive ${FILE}"
                                    itemzip "${FILE}" "${LISTPAGES[${PAGE}]}" | ${EXIFTOOL} -
                                else
                                    echo "Ivalid value ${PAGE}" >> /dev/stderr
                                    return 1
                                fi
                            ;;
                        esac
                    ;;
                    pages\ +([0-9])|pages\ all|pages) local TEMPORAR=(${CHARSTRING})
                        case ${TEMPORAR[1]} in
                            all) local LISTPAGES=($(listzip "${FILE}"))
                                printf "%s\n" ${LISTPAGES[@]}
                            ;;
                            +([0-9])) local LISTPAGES=($(listzip "${FILE}"))
                                printf "%s\n" ${LISTPAGES[@]} | \
                                grep -m ${TEMPORAR[1]} -v /$ | tail -1
                            ;;
                            *) local SUMPAGES=$(listzip "${FILE}" | wc -l)
                                echo "${SUMPAGES}"
                            ;;
                        esac
                    ;;
                    *) # zjistit jakého typu jsou obrázky v archivu
                        local SUMPAGES=$(listzip "${FILE}" | wc -l)
                        echo "${FILETYPE^^} ${SUMPAGES}"
                    ;;
                esac
            ;;
        esac
    fi
    return $?
}

# ### <span id="jp2to">jp2to()</span> ([top](#FUNCTIONS))
# Konvertuje obrázky z formátu JPEG-2000 do bitmapových formátů:
# `.bmp`, `.pgm`, `.pgx`, `.png`, `.pnm`, `.ppm`, `.raw`, `.tga`, `.tif`.
# Využívá se při tom nástroj libopenjp2-tools
# Při konverzi do PNG je vyžadována knihovna libpng a při konverzi do
# formátu TIFF zase knihovna libtiff.
#
# Srovnání: Cca 4,1M jp2 ve stupních šedi, mizerné kvality má po konverzi
# do DjVu při použití výchozího algoritmu (`djvu`) 1,1M. O něco lepší výsledek
# jak z hlediska vizuálního, tak velikosti souboru nabídnul algoritmus
# `otsu` – 0.7MB
# Stejný soubor nekomprimovaný zabral 33M a v PNG 21M
jp2to() {
    log goto "jp2to() $1 –> $2"
    ${PAMTO} -i "${1}" -o "${2}"
    return $?
}

# ### <span id="jp2in">jp2in()</span> ([top](#FUNCTIONS))
# Konvertuje obrázky do formátu JPEG-2000
# `.bmp`, `.pgm`, `.pgx`, `.png`, `.pnm`, `.ppm`, `.raw`, `.tga`, `.tif`.
# Využívá se při tom nástroj libopenjp2-tools.
# Při konverzi z PNG je vyžadována knihovna libpng a při konverzi z
# formátu TIFF zase knihovna libtiff.
#
# Konverze již zpracovaného obrázku už není tak dobrá jako z originálu 8-/
jp2in() {
    log goto "jp2in() $1 –> $2"
    
    ${JP2IN} -i "${1}" -o "${2}"
    return $?
}


# ### <span id="listpdf">listpdf()</span> ([top](#FUNCTIONS))
# Funkce vrací seznam stránek v PDF souboru.
#
# pdftk soubor.pdf dump_data | grep PageMedia
#
# PageMediaNumber: 5
# PageMediaRotation: 0
# PageMediaRect: 0 0 533 838
# PageMediaDimensions: 533 838
#
# Důležité jsou rozměry, rotace a číslo
#     + 2451x3363+0+0 RGB-alpha Normal 46
#
# 1, položka viditelnost vrstvy (+|-)
# 2, položka rozměry vrstvy
# 3, 
# 4, typ vrstvy - by měly být typu Normal 
# 5, jméno vrstvy
#
# Pokud se u některé z viditelných vrstev vyskytuje jiný typ, než Normal,
# pak se vrací upozornění, že jde o rozpracovaný soubor a výsledek nemusí
# odpovídat požadovku
#
# Pořadové číslo souboru tak odpovídá číslu stránky
listpdf() {
    log goto "listpdf() From "
    ${PDFTK} "${1}" dump_data | awk '/^PageMediaNumber/ {print $2}'
}

# ### <span id="pdftopdf">pdftopds()</span> ([top](#FUNCTIONS))
# Export rozsahu ${RANGE} stránek z pdf souboru $1 do nového pdf souboru $2
pdftopdf() {
    log goto "pdftopdf() From pdf $1 range ${RANGE}"
    local TEMPORAR=(${RANGE//,/ })
    local RANGE=$(printf "A%s " ${TEMPORAR[@]})
    ${PDFTK} A="${1}" cat ${RANGE} output "${2}"
}

# ### <span id="itemxcf">itemxcf()</span> ([top](#FUNCTIONS))
# Funkce vyblije na standardní výstup stránku __$2__ z PDF souboru __$1__
itempdf() {
    ${PDFTOPPM} -f ${2} -l ${2} < "${1}"
}

# ### <span id="listxcf">listxcf()</span> ([top](#FUNCTIONS))
# Funkce vrací seznam vrstev v XCF souboru.
#
# Ovšem tento vstupní XCF soubor musí být připraven ke konverzi a to tak,
# že vrstvy, které mají být považovány za stránky, musí být typu Normal a
# viditelné. 
#
#     + 2451x3363+0+0 RGB-alpha Normal 46
#
# 1, položka viditelnost vrstvy (+|-)
# 2, položka rozměry vrstvy
# 3, 
# 4, typ vrstvy - by měly být typu Normal 
# 5, jméno vrstvy
#
# Pokud se u některé z viditelných vrstev vyskytuje jiný typ, než Normal,
# pak se vrací upozornění, že jde o rozpracovaný soubor a výsledek nemusí
# odpovídat požadovku
#
# Pořadové číslo souboru tak odpovídá číslu stránky
listxcf() {
    local TEST=$( ${XCFINFO} "${1}" | grep ^+ | awk '{print $4}' | grep -v Normal )
    ${XCFINFO} -u "${1}" | while read line ; do
        case "${line:0:1}" in
            +) echo "${line#*RGB* Normal }"
            ;;
        esac
    done
    [ -n "${TEST}" ] && return 1 || return 0
}

# ### <span id="itemxcf">itemxcf()</span> ([top](#FUNCTIONS))
# Funkce vyblije na standardní výstup z XCF __$1__ vrstvu __$2__
itemxcf() {
    log goto "itemxcf() From $1 flush –> $2"
    ${XCF2PNM} "${1}" "${2}"
}

# ### <span id="itempng">itempng()</span> ([top](#FUNCTIONS))
# Funkce vyblije na standardní výstup z XCF __$1__ vrstvu __$2__
itempng() {
    log goto "itempng() From $1 flush –> $2"
    # ${XCF2PNM} "${1}" "${2}"
}

# ### <span id="listpng">listpng()</span> ([top](#FUNCTIONS))
# Vrací pořadové číslo vrstvy, které odpovídá číslu stránky
listpng() {
    local TEMPORARY="${1##*/}"
    mkdir ${TEMPORARY}
    # ${ZIP} l -so "${1}" | awk '{print $6}' | grep '/' | sort -t _
}

# ### <span id="listdjvu">listdjvu()</span> ([top](#FUNCTIONS))
# Vrací seznam stránek v DjVu souboru
listdjvu() {
    #${ZIP} l -so "${1}" | awk '{print $6}' | grep '/' | sort -t _
    echo nil
}

# ### <span id="listzip">listzip()</span> ([top](#FUNCTIONS))
# Vrací setříděný seznam souborů v ZIP archivu - je založen na syntaxi
# používané u souborů archive.org, kdy číslování stránek je před příponou
# souboru, oddělené od jména adresáře podtržítkem
#
#         pg35600_jp2/pg35600_0158.jp2
#
# Pořadové číslo souboru tak odpovídá číslu stránky
listzip() {
    ${ZIP} l -so "${1}" | awk '{print $6}' | grep '/' | sort -t _
}

# ### <span id="itemzip">itemzip()</span> ([top](#FUNCTIONS))
# Funkce vyblije na standardní výstup ze zazipovaného archívu __$1__
# soubor __$2__
itemzip() {
    log goto "itemzip() From $1 flush –> $2"
    ${ZIP} e -so "${1}" "${2}"
}

# ### <span id="infoitem">infoitem()</span> ([top](#FUNCTIONS))
# Na vstupu je stream a výstupem je sada hodnot
infoitem() {
    ${EXIFTOOL} -s3 -FileType -ImageSize -Compression -AnimationFrames -FrameCount -
}

# ### <span id="infoitem">infoitem()</span> ([top](#FUNCTIONS))
# Na vstupu je soubor $1, a případně identifikátor stránky $2
rotateinfo() {
    local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .bin)
    case ${2} in
        +([[:digit:]])) #/ pořadí stránky
            ${DJVUEXTRACT} "${1}" -page=${2} INFO=${TEMPFILE} 2>/dev/null
        ;;
        '') #/ globální
            ${DJVUEXTRACT} "${1}" INFO=${TEMPFILE} 2>/dev/null
        ;;
        *) #/ jméno stránky
            ${DJVUEXTRACT} "${1}" -page="${2}" INFO=${TEMPFILE} 2>/dev/null
        ;;
    esac
    [ $? -eq 1 ] && return 1
    local ROTATION=$(dd if=${TEMPFILE} bs=1 skip=9 2>/dev/null | od -A none -b)
    case ${ROTATION} in
        001) # 0°
            echo "0"
        ;;
        005) # 270°
            echo "3"
        ;;
        002) # 180°
            echo "2"
        ;;
        006) # 90°
            echo "1"
        ;;
        *) return 1
        ;;
    esac
    return 0
}

# ### <span id="convertovergimp">convertovergimp()</span> ([top](#FUNCTIONS))
# Bitmapový editor gimp lze rovněž využívat ke konverzi bitmapových souborů
#
# $1 - výstupní formát
convertovergimp() {
    # Start gimp with python-fu batch-interpreter
    gimp -i --batch-interpreter=python-fu-eval -b - << EOF
import gimpfu

def convert(filename):
    img = pdb.gimp_file_load(filename, filename)
    new_name = filename.rsplit(".",1)[0] + ".$1"
    layer = pdb.gimp_image_merge_visible_layers(img, 1)

    pdb.gimp_file_save(img, layer, new_name, new_name)
    pdb.gimp_image_delete(img)

convert('${2}')

pdb.gimp_quit(1)
EOF
}

# ### <span id="identifypage">identifypage()</span> ([top](#FUNCTIONS))
# Function return DjVu page actual ORDER in DjVu bundle
# $1 type (order|name)
# $2 DjVu file
# $3 Page identificator (order or name)
identifypage() {
    log goto "identifypage() ${1} page ${3} from ${2}"
    case "${3}" in
        +([[:digit:]])) #/ Identifikace podle čísla stránky
            local PAGE=$(${DJVUSED} "${2}" -e dump | grep "\[P${3}\]")
        ;;
        *) #/ Identifikace podle názvu stránky
            local PAGE=$(${DJVUSED} "${2}" -e dump | grep "\{${3}\}")
        ;;
    esac
    [ ! -n "${PAGE}" ] && \
        log err "identifypage() Invalid identificator ${1} for ${2}" && \
        return 1
    case "${1}" in
        name) local TEMPORAR="${PAGE##*\{}"
            echo "${TEMPORAR%%\}*}"
        ;;
        order) local TEMPORAR="${PAGE##*\[P}"
            echo "${TEMPORAR%%\]*}"
        ;;
        *) log err "identifypage() Invalid type –> ${1}"
            return 1
        ;;
    esac
    return 0
}

# ### <span id="lastpage">lastpage()</span> ([top](#FUNCTIONS))
# Function return count of all pages in DjVu bundle
# $1 DjVu file
lastpage() {
    log goto "lastpage() –> ${1}"
    local SOURCE=$(${REALPATH} -m -P "${1}")
    local FILE="${SOURCE##*/}"
    [ "$(testfile ${SOURCE})" == "djvu" ] || return 1
    local OUTPUT=$(${DJVUSED} "${SOURCE}" -e n)
    log info "lastpage() Count of all pages in ${FILE} –> ${OUTPUT}"
    echo -n "${OUTPUT}"
    return 0
}

# ### <span id="deletepage">deletepage()</span> ([top](#FUNCTIONS))
# Odstraňuje z DjVu svazku stránky, pokud jejich celkový počet je > 1
#
# $1 - jméno DjVu svazku se kterým se pracuje
# $2 - číslo, nebo název strany co se má odstranit
#
# Pokud je stránka úspěšně odstraněna, vrací __0__
# Pokud se stránka ve svazku nevyskytuje, vrací __1__
# Pokud není DjVu soubor typu bundle, vrací __2__
deletepage() {
    log goto "deletepage() From ${1} –> ${2}"
    [ -z ${2} ] && return 1
    local SUMPAGE=$(${DJVUSED} "${1}" -e 'n')
    [ $? -eq 1 ] && return 1
    case $SUMPAGE in
        1) echo "Single page DjVu file –> ${FILE}" >> /dev/stderr
            return 0
            ;;
        *) local PAGE=$(identifypage order "${1}" "${2}")
            if [ ! -z "${PAGE}" ] ; then
                ${DJVM} -d "${1}" "${PAGE}"
                echo "Page ${2} from ${1} was removed" >> /dev/stderr
            else
                return 1
            fi
            ;;
    esac
    return $?
}

function djvurotate {
	# $1 - soubor se kterým se pracuje
	# $2 - číslo, nebo název strany která se má rotovat
	# $3 - hodnota rotace
#	echo "$*" >> /dev/stderr
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	local INFO="""
Uvedenou hodnotu rotace nelze akceptovat. Rotaci lze nastavit buď 
absolutně, a nebo relativně (pootočit o 90°). AKceptované hodnoty:

      0 - výchozí pozice
      1 - natočení vpravo
      2 - otočení  vzhůru nohama
      3 - natočení vlevo
   left - rotace směrem doleva
  right - rotace směrem doprava).
    180 - přetočení o 180°

Každá jiná hodnota parametru je ignorována."""
	local PARAMS=($2)
	if [ "${#PARAMS[@]}" -gt "1" ] ; then
		case "${PARAMS[$((${#PARAMS[@]} -1))]}" in
			0|1|2|3|180|left|right) # echo "Jak mám otáčet $1" >> /dev/stderr
				local ROTATE="${PARAMS[$((${#PARAMS[@]} -1))]}"
#				echo "rotate: před ořezáním -$2-"
				local TEMP="${2% ${ROTATE}}"
				local IDPAGE=${TEMP##+([[:blank:]])}
#				echo "rotate: po ořezání -${IDPAGE}-"
			;;
			*) printf "%s - is not valid rotate VALUE" "${2}" >> /dev/stderr
				exit 1
			;;
		esac
	else
		case "${PARAMS}" in
			0|1|2|3|180|left|right) local ROTATE="${PARAMS}"
			;;
			*) printf "%s - is not valid rotate VALUE" "${PARAMS}" >> /dev/stderr
				exit 1
			;;
		esac
	fi

	if $(identifybundle "${1}") ; then
		if [ -z "${IDPAGE}" ] ; then
			case "${ROTATE}" in
				0|1|2|3)  ${DJVUSED} -e "set-rotation ${ROTATE}; save" "${SOURCE}"
				;;
				left) ${DJVUSED} -e "set-rotation +1; save" "${SOURCE}"
				;;
				right) ${DJVUSED} -e "set-rotation -1; save" "${SOURCE}"
				;;
				180) ${DJVUSED} -e "set-rotation +2; save" "${SOURCE}"
				;;
				*) echo "${INFO}" >> /dev/stderr
				;;
			esac
		else
			printf "DjVu file is single page. Param %s is non sense, continue in rotate?" "${IDPAGE}" >> /dev/stderr
			if $(potvrdit) ; then
				case "${ROTATE}" in
					0|1|2|3)  ${DJVUSED} -e "set-rotation ${ROTATE}; save" "${SOURCE}"
					;;
					left) ${DJVUSED} -e "set-rotation +1; save" "${SOURCE}"
					;;
					right) ${DJVUSED} -e "set-rotation -1; save" "${SOURCE}"
					;;
					180) ${DJVUSED} -e "set-rotation +2; save" "${SOURCE}"
					;;
					*) echo "${INFO}" >> /dev/stderr
					;;
				esac
			else
				exit 0
			fi
		fi
	else
		if [ -z "${IDPAGE}" ] ; then
			echo "Warning: If you want c a global orientation of pages Při globálním natočení stránek dokumentu dávejte pozor, zda-li nastavujete absolutní hodnotu natočení, nebo, zda-li otáčíte stránky relativně (left/right). Při točení se upravuje natočení všech stránek. Buďte tedy při této operaci opatrní a raději si předem zkontrolujte, zda-li tím neovlivníte i některou ze stránek. Pokud ano, pak zvolte buť relativní parametr natočení, nebo ji pak otočte do správné pozice dodatečně."
			if $(potvrdit) ; then
				case "${ROTATE}" in
					0|1|2|3)  ${DJVUSED} -e "set-rotation ${ROTATE}; save" "${SOURCE}"
					;;
					left) ${DJVUSED} -e "set-rotation +1; save" "${SOURCE}"
					;;
					right) ${DJVUSED} -e "set-rotation -1; save" "${SOURCE}"
					;;
					180) ${DJVUSED} -e "set-rotation +2; save" "${SOURCE}"
					;;
					*) echo "${INFO}" >> /dev/stderr
					;;
				esac
			else
				exit 0
			fi
		else
#			echo "Je třeba provést identifikaci stránky ${IDPAGE}"
			local NAMEPAGE=$(identifypage name "${1}" "${IDPAGE}")
			if [ -z "${NAMEPAGE}" ] ; then
				printf "Page %s is not valid for file %s" "${IDPAGE}" "${FILE}" >> /dev/stderr
				exit 1
			else
				printf "Change orientation page %s in %s by %s" "${NAMEPAGE}" "${FILE}" "${ROTATE}" >> ${LOG}
				case "${ROTATE}" in
					0|1|2|3)  ${DJVUSED} -e "select '${NAMEPAGE}'; set-rotation ${ROTATE}; save" "${SOURCE}"
					;;
					left) ${DJVUSED} -e "select '${NAMEPAGE}'; set-rotation +1; save" "${SOURCE}"
					;;
					right) ${DJVUSED} -e "select '${NAMEPAGE}'; set-rotation -1; save" "${SOURCE}"
					;;
					180) ${DJVUSED} -e "select '${NAMEPAGE}'; set-rotation +2; save" "${SOURCE}"
					;;
					*) echo "${INFO}" >> /dev/stderr
					;;
			esac
			fi
		fi
	fi
}

function djvumove {
	# $1 - DjVu file
	# $2 - Parametry
	#	zdroj : identifikátor pozice
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"

	local VSTUP="${2}"
	local COUNT=${#VSTUP}
	local POS=0
	local START=0
	while [ $POS -lt $COUNT ]
	do local POS=$((POS+1))
#		echo "${VSTUP:$START:$POS}" >> /dev/stderr
		case "${VSTUP:$START:$POS}" in
			*.[dD][jJ][vV][uU]|*.[gG][iI][fF]|*.[jJ][pP][gG]|*.[mM][nN][gG]|*.[pP][dD][fF]|*.[pP][nN][gG]|*.[pP][nN][mM]|*.[tT][iI][fF][fF]|*.[xX][cC][fF]) 
				local SOUBOR="${VSTUP:0:$POS}"
				log info "move() Zachycen soubor $SOUBOR - ${SOUBOR:$((${#SOUBOR} - 4)):4}"
				if [ "${SOUBOR:$((${#SOUBOR} - 4)):4}" == "djvu" ] ; then
#					echo "Před testem.. '${SOUBOR##+([[:blank:]])}'" >> /dev/stderr
					local TESTORDER=$(identifypage order "${SOURCE}" "${SOUBOR##+([[:blank:]])}")
#					echo "Po testu.." >> /dev/stderr
					if [ -z "${TESTORDER}" ] ; then
						if [ -f "${SOUBOR}" ] ; then
							local FROM="${SOUBOR}"
							local VSTUP="${VSTUP#${SOUBOR} }"
							local COUNT=${#VSTUP}
							local POS=0
							echo "move: OK - jde o DjVu soubor ${SOUBOR} co se má vložit" >> /dev/stderr
							local ANAME="${SOUBOR}"
							##### Ve zbytku musí být identifikátor
							# ....
#							echo "Insert djvu file yet not implemented!!!" >> /dev/stderr
#							return 0
						else
							local TEST=( ${SOUBOR} )
							if [ "${#TEST}" -gt "0" ] ; then
								local A="${TEST[0]}"
								if [ "${A%%+([[:digit:]])}" == "" ] ; then
									local BTEST="${SOUBOR##${A}+([[:blank:]])}"
									local B=$(identifypage order "${SOURCE}" "${BTEST}")
									if [ -z "${B}" ] ; then
										echo "move: FAIL - for DjVu file ${FILE} identificator target page ${BTEST} is not valid." >> /dev/stderr
										exit 1
									else
										#FINITO### tady budu realizovat přesun...?
										local ANAME=$(identifypage name "${SOURCE}" "${A}")
										local BNAME=$(identifypage name "${SOURCE}" "${B}")
										if [ "${ANAME}" == "${BNAME}" ] ; then
											echo "move: FAIL - If you want move page on position ${A}, which is the same page as target. If you want moved page from position ${2} before actual position, use command without identification of target position." >> /dev/stderr
											exit 1
										fi
										if [ "${MOVE}" == "fore" ] ; then
											if [ "$A" == "1" ] ; then
												echo "move: INFO - page ${ANAME} is on first position in ${FILE}." >> /dev/stderr
												return 1
											elif [ "$A" == "$((${B} - 1))" ] ; then
												echo "move: INFO - page ${ANAME} is on previous position (${A}) in ${FILE} before page ${BNAME} (position ${B})." >> /dev/stderr
												return 1
											else
												PAGE="yes"
												exportdjvupage "${SOURCE}" "${ANAME}" "${TEMPDIR}"
												deletepage "${SOURCE}" "${ANAME}"
												if [ "${A}" -gt "${B}" ] ; then
													${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "${B}"
												else
													${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "$((${B} - 1))"
												fi
												return 0
											fi
										elif [ "${MOVE}" == "back" ] ; then
											local TEST=$(lastpage "${1}")
											if [ "$A" == "${TEST}" ] ; then
												echo "move: INFO - page ${ANAME} is on last position in ${FILE}." >> /dev/stderr
												return 1
											elif [ "$A" == "$((${B} + 1))" ] ; then
												echo "move: INFO - page ${ANAME} is on next position in ${FILE} after page ${BNAME}." >> /dev/stderr
												return 0
											else
												PAGE="yes"
												exportdjvupage "${SOURCE}" "${ANAME}" "${TEMPDIR}"
												deletepage "${SOURCE}" "${ANAME}"
												if [ "${A}" -lt "${B}" ] ; then
													${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "${B}"
												else
													${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "$((${B} - 1))"
												fi
												return 0
											fi
										else
											echo "move: Nedělám nic" >> /dev/stderr
										fi
									fi
								else
									echo "move: FAIL - identificator '${SOUBOR##+([[:blank:]])}' for file ${FILE} is not valid. Pay attention to the gap - are treacherous!" >> /dev/stderr
									exit 1
								fi
							else
								echo "move: S názvem souboru není něco v pořádku" >> /dev/stderr
							fi
						fi
					else
						if [ -z "${ANAME}" ] ; then
							# Nenastavené ANAME 
							local ANAME="${SOUBOR}"
							local A="${TESTORDER}"
							local VSTUP="${VSTUP#${SOUBOR}}"
							if [ "${VSTUP##+([[:blank:]])}" == "" ] ; then
								#FINITO### tady budu realizovat přesun...?
								if [ "${MOVE}" == "fore" ] ; then
									if [ "$A" == "1" ] ; then
										echo "move: INFO - page ${ANAME} is on first position in ${FILE}." >> /dev/stderr
										return 1
									else
										PAGE="yes"
										exportdjvupage "${SOURCE}" "${ANAME}" "${TEMPDIR}"
										deletepage "${SOURCE}" "${ANAME}"
										${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "$((${A} - 1))"
										return 0
									fi
								elif [ "${MOVE}" == "back" ] ; then
									local TEST=$(lastpage "${1}")
									if [ "$A" == "${TEST}" ] ; then
										echo "move: INFO - page ${ANAME} is on last position in ${FILE}." >> /dev/stderr
										return 1
									else
										PAGE="yes"
										exportdjvupage "${SOURCE}" "${ANAME}" "${TEMPDIR}"
										deletepage "${SOURCE}" "${ANAME}"
										${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "$((${A}+1))"
										return 0
									fi
								else
									echo "move: Nedělám nic" >> /dev/stderr
								fi
							else
								local TEST="${VSTUP##+([[:blank:]])}"
								if [ "${TEST##+([[:digit:]])}" == "" ] ; then
#									# Pořadové číslo - budu přesouvat..
									local B=$(identifypage order "${SOURCE}" "${TEST}")
									if [ -z "${B}" ] ; then
										echo "move: ERROR - target position is not valid for file ${FILE}" >> /dev/stderr
										exit 1
									else
										#FINITO## Budu přesouvat
										if [ "${A}" == "${B}" ] ; then
											echo "move: FAIL - If you want move page on position ${A}, which is the same page as target. If you want moved page from position ${2} before actual position, use command without identification of target position." >> /dev/stderr
											exit 1
										fi
										if [ "${MOVE}" == "fore" ] ; then
											if [ "${A}" == "$((${B} - 1))" ] ; then
												echo "move: INFO - page ${ANAME} is on previous position (${A}) in ${FILE} before page with position ${B}." >> /dev/stderr
												return 1
											else
												PAGE="yes"
												exportdjvupage "${SOURCE}" "${ANAME}" "${TEMPDIR}"
												deletepage "${SOURCE}" "${ANAME}"
												if [ "${A}" -gt "${B}" ] ; then
													${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "${B}"
												else
													${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "$((${B} - 1))"
												fi
												return 0
											fi
										elif [ "${MOVE}" == "back" ] ; then
											local TEST=$(lastpage "${SOURCE}")
											if [ "$A" == "${TEST}" ] ; then
												echo "move: INFO - page ${ANAME} is on last position in ${FILE}." >> /dev/stderr
												return 1
											elif [ "$A" == "$((${B} + 1))" ] ; then
												echo "move: INFO - page ${ANAME} is on next position in ${FILE} after page which is target (${B})." >> /dev/stderr
												return 0
											else
												PAGE="yes"
												exportdjvupage "${SOURCE}" "${ANAME}" "${TEMPDIR}"
												deletepage "${SOURCE}" "${ANAME}"
												if [ "${A}" -lt "${B}" ] ; then
													${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "${B}"
												else
													${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "$((${B} - 1))"
												fi
												return 0
											fi
										else
											echo "move: Nedělám nic" >> /dev/stderr
										fi
										return 0
									fi
								else
									local COUNT=${#VSTUP}
									local POS=0
									log warn "move() INFO - page ${ANAME} has order ${A}. What is the identificator of target page from bundle -$VSTUP-?"
								fi
							fi
						elif [ "${ANAME}" == "none" ] ; then
#							# ANAME je none
							local B=$(identifypage order "${1}" "${SOUBOR}")
							if [ -z "${B}" ] ; then
								echo "move: ERROR - Chybné jméno stránky před kterou se má stránka přesunout" >> /dev/stderr
								exit 1
							else
								local A=""
								local BNAME="${SOUBOR}"
								log warn "move() Vkládá se konvertovaná stránka ${FROM} před stránu -${BNAME}- na pozici ${B}"
								break
							fi
						else
#							#FINITO### Budu přesouvat..
#							echo "move: ${A} ${TESTORDER}" >> /dev/stderr
							if [ "${A}" == "${TESTORDER}" ] ; then
								echo "move: FAIL - If yu want move page ${ANAME} in ${FILE} about one position. You must for it use action ${MOVE} only with identificator of page to move." >> /dev/stderr
								exit 1
							else
								local B=$(identifypage order "${1}" "${SOUBOR}")
								if [ -z "${B}" ] ; then
									echo "move: FAIL - Chybné jméno stránky před kterou se má stránka přesunout" >> /dev/stderr
									exit 1
								else
									local A=$(identifypage order "${1}" "${ANAME}")
									if [ -z "${A}" ] ; then
										echo "move: file ${ANAME} je djvu soubor?" >> /dev/stderr
#										exit 1
									else
										echo "move: ANAME je soubor ${ANAME}.." >> /dev/stderr
									local BNAME="${SOUBOR}"
#									#FINITO## Budu přesouvat ####
									if [ "${ANAME}" == "${BNAME}" ] ; then
										echo "move: FAIL - If you want move page on position ${A}, which is the same page as target. If you want moved page from position ${2} before actual position, use command without identification of target position." >> /dev/stderr
										exit 1
									fi
									if [ "${MOVE}" == "fore" ] ; then
										if [ "$A" == "1" ] ; then
											echo "move: INFO - page ${ANAME} is on first position in ${FILE}." >> /dev/stderr
											return 1
										elif [ "$A" == "$((${B} - 1))" ] ; then
											echo "move: INFO - page ${ANAME} is on previous position (${A}) in ${FILE} before page ${BNAME} (position ${B})." >> /dev/stderr
											return 1
										else
											PAGE="yes"
											exportdjvupage "${SOURCE}" "${ANAME}" "${TEMPDIR}"
											deletepage "${SOURCE}" "${ANAME}"
											if [ "${A}" -gt "${B}" ] ; then
												${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "${B}"
											else
												${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "$((${B} - 1))"
											fi
											return 0
										fi
									elif [ "${MOVE}" == "back" ] ; then
										local TEST=$(lastpage "${1}")
										if [ "$A" == "${TEST}" ] ; then
											echo "move: INFO - page ${ANAME} is on last position in ${FILE}." >> /dev/stderr
											return 1
										elif [ "$A" == "$((${B} + 1))" ] ; then
											echo "move: INFO - page ${ANAME} is on next position in ${FILE} after page ${BNAME}." >> /dev/stderr
											return 0
										else
											PAGE="yes"
											exportdjvupage "${SOURCE}" "${ANAME}" "${TEMPDIR}"
											deletepage "${SOURCE}" "${ANAME}"
											if [ "${A}" -lt "${B}" ] ; then
												${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "${B}"
											else
												${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "$((${B} - 1))"
											fi
											return 0
										fi
									else
										echo "move: Nedělám nic" >> /dev/stderr
									fi
									fi
								fi
							fi
						fi
					fi
				else
					if [ -f "${SOUBOR}" ] ; then
						local FROM="${SOUBOR}"
						##### KONVERZE #######
						local ANAME="none"
						local VSTUP="${VSTUP#${SOUBOR}}"
						local COUNT=${#VSTUP}
						local POS=0
						echo "move: INFO file ${SOUBOR} id not DjVu; must be converted" >> /dev/stderr
						local ANAME="${TEMPDIR}/${SOUBOR%.*}.djvu"
						filetodjvu "${SOUBOR}" "${ANAME}"
						if [ ! -f "${ANAME}" ] ; then
							echo "move: ERROR - file ${ANAME} not exists. Probably any problem with conversion." >> /dev/stderr
							exit 1
						fi
					else
						echo "move: ERROR - Soubor ${SOUBOR} neexistuje" >> /dev/stderr
						exit 1
					fi
				fi
			;;
		esac
	done

	if [ -f "${ANAME}" ] ; then
		echo "Sem to propadne je-li ANAME -${ANAME}- již existující soubor" >> /dev/stderr
		if [ -z "${BNAME}" ] ; then
			echo "move: Musím získat pozici ze zbytku ${VSTUP}" >> /dev/stderr
			local TEST="${VSTUP##+([[:blank:]])}"
			if [ "${TEST##+([[:blank:]])}" == "" ] ; then
				## Budu soubor připojovat na konec DjVu svazku...
				# Není třeba nic víc řešit...
				echo "Budu soubor připojovat na konec DjVu svazku. Není třeba řešit nic víc, nežli to zda není nějaká stránka v konfliktu.."
				if comparedjvu "${SOURCE}" "${ANAME}" ; then
					echo "move: APPEND - content of file ${ANAME} to ${MOVE} ${SOURCE}" >> /dev/stderr
					if [ "${MOVE}" == "fore" ] ; then
						${DJVM} -i "${SOURCE}" "${ANAME}" 1
					elif [ "${MOVE}" == "back" ] ; then
						${DJVM} -i "${SOURCE}" "${ANAME}"
					else
						echo "Nedělám nic" >> /dev/stderr
					fi
					return 0
				else
					echo "Stránka je v konfliktu" >> /dev/stderr
					exit 1
				fi
			else
				local B=$(identifypage order "${SOURCE}" "${TEST}")
				if [ -z "${B}" ] ; then
					echo "move: identificator -${TEST} is not valid." >> /dev/stderr
					exit 1
				else
					echo "move: APPEND - content of file ${ANAME} to ${SOURCE} ${MOVE} page ${B}" >> /dev/stderr
					if comparedjvu "${SOURCE}" "${ANAME}" ; then
						if [ "${MOVE}" == "fore" ] ; then
							${DJVM} -i "${SOURCE}" "${ANAME}" "${B}"
						elif [ "${MOVE}" == "back" ] ; then
							${DJVM} -i "${SOURCE}" "${ANAME}" "$((${B} + 1))"
						else
							echo "Nedělám nic" >> /dev/stderr
						fi
						return 0
					else
						echo "Stránka je v konfliktu" >> /dev/stderr
						exit 1
					fi
				fi 
			fi
		fi
	else
		if [ -z "${ANAME}" ] ; then
			local TEST=( ${VSTUP} )
			if [ "${#TEST}" -gt "0" ] ; then
				local ANAME=$(identifypage name "${SOURCE}" "${TEST[0]}")
				if [ -z "${ANAME}" ] ; then
					echo "move: FAIL - for DjVu file ${FILE} identificator ${TEST[0]} is not valid." >> /dev/stderr
					exit 1
				else
					if [ "${TEST[1]##+([[:blank:]])}" != "" ] ; then
						local BNAME=$(identifypage name "${SOURCE}" "${TEST[1]}")
						if [ -z "${BNAME}" ] ; then
							echo "move: FAIL - for DjVu file ${FILE} identificator ${TEST[1]} is not validxxx." >> /dev/stderr
							exit 1
						else
							echo "move: INFO - page ${ANAME} has order ${A}. Do move ${MOVE} ${BNAME}." >> /dev/stderr
							### budu přesouvat stránku na pozici..
						fi
					else
						echo "move: page ${ANAME} move ${MOVE}" >> /dev/stderr
						### budu přesouvat stránku o jednu pozici..
					fi

				fi
			fi 
		fi
	fi

	echo "move - jsem za tim" >> /dev/stderr

	if [ -z "${BNAME}" ] ; then
		if [ -z "{ANAME}" ] ; then
			echo "move: Neplatná cílová stránka ${BNAME}, i stránka ${ANAME} která se má přesouvat" >> /dev/stderr
			exit 1
		else
			local TEST=( ${VSTUP} )
			if [ "${#TEST}" -gt "0" ] ; then
				local BNAME=$(identifypage name "${SOURCE}" "${TEST[0]}")
				if [ -z "${BNAME}" ] ; then
					echo "move: FAIL - identificator ${TEST[0]} is not valid for DjVu file ${FILE}" >> /dev/stderr
					exit 1
				else
#					#FINITO## Zpracovávám přesun..
					if [ "${ANAME}" == "${BNAME}" ] ; then
						local A=$(identifypage order "${SOURCE}" "${ANAME}")
						if [ "${MOVE}" == "fore" ] ; then
							if [ "$A" == "1" ] ; then
								echo "move: INFO - page ${ANAME} is on first position in ${FILE}." >> /dev/stderr
								return 1
							else
								PAGE="yes"
								exportdjvupage "${SOURCE}" "${ANAME}" "${TEMPDIR}"
								deletepage "${SOURCE}" "${ANAME}"
								${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "$((${A} - 1))"
								return 0
							fi
						elif [ "${MOVE}" == "back" ] ; then
							local TEST=$(lastpage "${1}")
							if [ "$A" == "${TEST}" ] ; then
								echo "move: INFO - page ${ANAME} is on last position in ${FILE}." >> /dev/stderr
								return 1
							else
								PAGE="yes"
								exportdjvupage "${SOURCE}" "${ANAME}" "${TEMPDIR}"
								deletepage "${SOURCE}" "${ANAME}"
								${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "$((${A}+1))"
								return 0
							fi
						else
							echo "move: Nedělám nic" >> /dev/stderr
						fi
					else
#						echo "move: INFO - move page -${ANAME}- -${A}- ${MORE} page -${BNAME}- -${B}-" >> /dev/stderr
#						#FINITO## Zpracovávám přesun..
						local B=$(identifypage order "${SOURCE}" "${BNAME}")
						if [ "${ANAME}" == "${BNAME}" ] ; then
							echo "move: FAIL - If you want move page on position ${A}, which is the same page as target. If you want moved page from position ${2} before actual position, use command without identification of target position." >> /dev/stderr
							exit 1
						fi
						if [ "${MOVE}" == "fore" ] ; then
							if [ "$A" == "1" ] ; then
								echo "move: INFO - page ${ANAME} is on first position in ${FILE}." >> /dev/stderr
								return 1
							elif [ "$A" == "$((${B} - 1))" ] ; then
								echo "move: INFO - page ${ANAME} is on previous position (${A}) in ${FILE} before page ${BNAME} (position ${B})." >> /dev/stderr
								return 1
							else
								PAGE="yes"
								exportdjvupage "${SOURCE}" "${ANAME}" "${TEMPDIR}"
								deletepage "${SOURCE}" "${ANAME}"
								if [ "${A}" -gt "${B}" ] ; then
									${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "${B}"
								else
									${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "$((${B} - 1))"
								fi
								return 0
							fi
						elif [ "${MOVE}" == "back" ] ; then
							local TEST=$(lastpage "${SOURCE}")
							if [ "$A" == "${TEST}" ] ; then
								echo "move: INFO - page ${ANAME} is on last position in ${FILE}." >> /dev/stderr
								return 1
							elif [ "$A" == "$((${B} + 1))" ] ; then
								echo "move: INFO - page ${ANAME} is on next position in ${FILE} after page ${BNAME}." >> /dev/stderr
								return 0
							else
								PAGE="yes"
								exportdjvupage "${SOURCE}" "${ANAME}" "${TEMPDIR}"
								deletepage "${SOURCE}" "${ANAME}"
								if [ "${A}" -lt "${B}" ] ; then
									${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "${B}"
								else
									${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "$((${B} - 1))"
								fi
								return 0
							fi
						else
							echo "move: Nedělám nic" >> /dev/stderr
						fi
					fi
				fi
			else
				echo "move: FAIL ANAME -${ANAME}-, VSTUP -${VSTUP}- je buď prázdný, nebo obsahuje pouze číselnou identifikaci cílové pozice" >> /dev/stderr
				exit 1
			fi 
		fi
	else
		if [ -z "${FROM}" ] && [ -z "${ANAME}" ] ; then
			echo "move: Neplatná identifikace stránky se kterou se má pracovat" >> /dev/stderr
			exit 1
		fi
	fi

	echo "FROM - ${FROM}" >> /dev/stderr
	echo "A - ${A}" >> /dev/stderr
	echo "ANAME - ${ANAME}" >> /dev/stderr
	echo "B - ${B}" >> /dev/stderr
	echo "BNAME - ${BNAME}" >> /dev/stderr
	echo "MOVE - ${MOVE}" >> /dev/stderr

# Do tohoto místa probíhá zpracování stejně pro fore i back
# Následuje další zpracování parametrů - především porovnání ..

# 1, je-li ANAME, stejné jako BNAME, přesun A o jednu pozici vřed či vzad..
#
# 2, je-li FROM stejné jako BNAME, vyhodit dotaz: 
#		Nahradit? nebo akci přerušit?
# Pro MOVE=fore...
# 3f, je-li pozice A o 1 větší než B - skončit 
# 4f, je-li pozice A = 1 skončit 
# 
# Pro MOVE=back...
# 3b, je-li pozice A o 1 menší než B - skončit
# 4b, le-li pozice A = lastpage skončit
#
# Má se přesouvat kupředu
}

# ### <span id="range">range()</span> ([top](#FUNCTIONS))
# Funkce, která zpracuje předaný řetězec do sekvence čísel
# 1,2,3-9,10-20
# Pokud zpracování řetězce proběhne v pořádku je návratový kód __0__,
# v opačném případě __1__.
range() {
    log goto "range() –> ${@}"
    case "${1:0:1}" in
        [[:digit:]]) local INPUTARRAY=( ${1//,/ } )
            for i in ${INPUTARRAY[@]} ; do
                if [[ "$i" =~ "-" ]] ; then
                    seq ${i//-/ }
                else
                    seq ${i} ${i}
                fi
            done | sort -nu
            return 0
        ;;
        *) printf "range: FAIL - range of pages must be set only from order numbers, commas and hyphens.\n" >> /dev/stderr
            return 1
        ;;
    esac
}

function changemeta {
	# Funkce která modifikuje soubor pro vložení meta atributů
	# AUTHOR
	# TITLE
	# SUBJECT
	# NOTE
	# ANNOTATION
	# URL
	# CREATOR
	[ $(grep -c '^CreationDate' ${1}) -eq 0 ] && printf "CreationDate \"%s\"\n" "$(date -u +%FT%T%:z)" >> ${1}
	if [ $(grep -c '^Producer' ${1}) -eq 1 ] ; then
		sed --in-place '/^Producer/,/$/d' ${1}
		printf 'Producer "djvutool 0.1 alpha (http://www.thewoodcraft.org)"\n' >> ${1}
	elif  [ $(grep -c '^Producer' ${1}) -eq 0 ] ; then
		printf 'Producer "djvutool 0.1 alpha (http://www.thewoodcraft.org)"\n' >> ${1}
	fi
	if [ $(grep -c '^ModDate' ${1}) -eq 1 ] ; then
		sed --in-place '/^ModDate/,/$/d' ${1}
		printf "ModDate \"%s\"\n" "$(date -u +%FT%T%:z)" >> ${1}
	elif  [ "$(grep -c ^ModDate $1)" == "0" ] ; then
		printf "ModDate \"%s\"\n" "$(date -u +%FT%T%:z)" >> ${1}
	fi
	printf '##' >> ${1}
	printf '## Toto jsou nejčastěji používané atributy. Budete-li je chtít použít,' >> ${1}
	printf '## stačí zrušit znak # na začátku řádky a doplnit do uvozovek obsah\n' >> ${1}
	printf '## Pokud budete mít nastavenou odpovídající proměnnou, tak se některé doplní.\n' >> ${1}
	[ $(grep -c '^Title' ${1}) -eq 0 ] && printf '#Title "%s"\t# - název zpracovávaného dokumentu\n' "${TITLE}" >> ${1}
	[ $(grep -c '^Author' ${1}) -eq 0 ] && printf '#Author "%s"\t# - jméno autora původního dokumentu, je-li znám\n' "${AUTHOR-unknown}" >> ${1}
	[ $(grep -c '^Subject' ${1}) -eq 0 ] && printf '#Subject "%s"\t# - stručné info o čem to je\n' "${SUBJECT}" >> ${1}
	[ $(grep -c '^Keywords' ${1}) -eq 0 ] && printf '#Keywords " "\t# - klíčová slova, která se vztahují k dokumentu, oddělená čárkou\n' >> ${1}
	[ $(grep -c '^note' ${1}) -eq 0 ] && printf '#note "%s"\t# - poznámka ke stránce\n' "${NOTE}" >> ${1}
	[ $(grep -c '^annote' ${1}) -eq 0 ] && printf '#annote "%s"\t# - stručná anotace obsahu\n' "${ANNOTATION}" >> ${1}
	[ $(grep -c '^url' ${1}) -eq 0 ] && printf '#url "%s"\t# - URL vašeho webu\n' "${URL}" >> ${1}
	[ $(grep -c '^Trapped' ${1}) -eq 0 ] && printf '#Trapped "FALSE"\t# - indikační klíč, který oznamuje zda-li je úprava stránky tímto dokončena (TRUE), nebo ne (FALSE)\n' >> ${1}
	[ $(grep -c '^Creator' ${1}) -eq 0 ] && printf '#Creator "%s"\t# - uvádí se jméno autora, nebo název aplikace ve které vytvořil původní dokument.\n' "${CREATOR}" >> ${1}
	return 0
}

function setmeta {
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .meta)
	local CHARSET="${2}"
	local RANGE="${CHARSET%%\ *}"
	if [ "${RANGE}" == "all" ] ; then
		local ITEM="${CHARSET#* }"
		local KEY=(${ITEM})
		if [ "${#KEY[@]}" -lt "2" ] ; then
			printf "setmeta: FAIL - you must set meta attribute key and any value for it.\n"
			exit 1
		else
			for i in $(seq $(lastpage "${SOURCE}")) ; do
				printf "set meta: Set meta attribute key %s into all pages in DjVu bundle %s\n" "${KEY[0]}" "${FILE}" >> ${LOG}
				printmeta "${SOURCE}" "$i" | grep -v '^[#.]\|^$' > ${TEMPFILE}
				ed ${TEMPFILE} 2>/dev/null <<-EOF
/${KEY}
d
w
q
EOF
				ed ${TEMPFILE} 2>/dev/null <<-EOF
i
${ITEM}
.
w
q
EOF
				${DJVUSED} "${SOURCE}" -e "select $i; set-meta ${TEMPFILE}" -s
			done 1>/dev/null
		fi
	elif [ "${RANGE//+([[:alpha:]])/}" == "" ] ; then
		local ITEM="${CHARSET}"
		printf "set meta: Set global meta attribute key %s into DjVu bundle %s\n" "${RANGE}" "${FILE}" >> ${LOG}
		printmeta "${SOURCE}" global | grep -v '^[#.]\|^$' > ${TEMPFILE}
		ed ${TEMPFILE} 2>/dev/null <<-EOF
/${RANGE}
d
w
q
EOF
		ed ${TEMPFILE} 2>/dev/null <<-EOF
i
${ITEM}
.
w
q
EOF
		${DJVUSED} "${SOURCE}" -e "select; set-meta ${TEMPFILE}" -s
	else
		local IDPAGES=($(range "${RANGE}"))
		local ITEM="${CHARSET#* }"
		local KEY=(${ITEM})
		for i in ${IDPAGES[@]} ; do
			printf "set meta: Set meta attribute key %s into page %s in DjVu bundle %s\n" "${KEY[0]}" "$i" "${FILE}" >> ${LOG}
			printmeta "${SOURCE}" "$i" | grep -v '^[#.]\|^$' > ${TEMPFILE}
			ed ${TEMPFILE} 2>/dev/null <<-EOF
/${KEY}
d
w
q
EOF
			ed ${TEMPFILE} 2>/dev/null <<-EOF
i
${ITEM}
.
w
q
EOF
			${DJVUSED} "${SOURCE}" -e "select $i; set-meta ${TEMPFILE}" -s
		done 1>/dev/null
	fi
	return 0
}


function unsetmeta {
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .meta)
	local CHARSET="${2}"
	local RANGE="${CHARSET%%\ *}"
	if [ "${RANGE}" == "all" ] ; then
		local ITEM="${CHARSET#* }"
		local KEY=(${ITEM})
		printf "unset meta: Remove attribute key %s from all pages DjVu bundle %s\n" "${KEY[0]}" "${FILE}" >> ${LOG}
		for i in $(seq $(lastpage "${SOURCE}")) ; do
			printmeta "${SOURCE}" "$i" | grep -v '^[#.]\|^$' > ${TEMPFILE}
			ed ${TEMPFILE} 2>/dev/null <<-EOF
/${KEY}
d
w
q
EOF
			${DJVUSED} "${SOURCE}" -e "select $i; set-meta ${TEMPFILE}" -s
		done  1>/dev/null
	elif [ "${RANGE//+([[:alpha:]])/}" == "" ] ; then
		printf "unset meta: Remove global attribute key %s from DjVu bundle %s\n" "${RANGE}" "${FILE}" >> ${LOG}
		printmeta "${SOURCE}" global | grep -v '^[#.]\|^$' > ${TEMPFILE}
		ed ${TEMPFILE} 2>/dev/null <<-EOF
/${RANGE}
d
w
q
EOF
		${DJVUSED} "${SOURCE}" -e "select; set-meta ${TEMPFILE}" -s
	else
		local IDPAGES=($(range "${RANGE}"))
		local ITEM="${CHARSET#* }"
		local KEY=(${ITEM})
		for i in ${IDPAGES[@]} ; do
			printf "unset meta: Remove attribute key %s from page %s\n" "${KEY[0]}" "$i" >> ${LOG}
			printmeta "${SOURCE}" "$i" | grep -v '^[#.]\|^$' > ${TEMPFILE}
			ed ${TEMPFILE} 2>/dev/null <<-EOF
/${KEY}
d
w
q
EOF
			${DJVUSED} "${SOURCE}" -e "select $i; set-meta ${TEMPFILE}" -s
		done  1>/dev/null
	fi
	return 0
}

# ###
#
djvuinfo() {
    log goto "djvuinfo() $1 –> $2"
    case ${2} in
        list) 
            ${DJVUSED} "${1}" -e 'dump' | grep '{' | grep -v INCL |\
            awk -F'}' '{print $2,$1}' | \
            sed -E 's/][[:blank:]]+[[:alnum:]:]+[[:blank:]]+\[[[:digit:]]+\][[:blank:]]+\{/ / ; s/ \[// ; s/^P// ; s/^S/0/' | sort -n
        ;;
        exif) ${EXIFTOOL} "${1}"
        ;;
        meta*)
            #/ zpracovat rozsah, nebo jméno předané stránky
            #/ TODO
            ${DJVUSED} "${1}" -e 'dump' | grep '{' | grep -v INCL | awk '{print $4,$3,$2}' | \
            while read line ; do
                case "${line}" in
                    \[S\]*) local TEMPORAR="${line#*\{}"
                            local PAGE="${TEMPORAR%\}*}"
                           echo "# shared_anno.iff # ${line##*+([[:blank:]])}"
                           echo "Tisknu Globální meta informace"
                           echo "select 'shared_anno.iff'; print-meta"
                           ${DJVUSED} "${1}" -e "select 'shared_anno.iff'; print-meta"
                    ;;
                    *) local TEMPORAR="${line#*\{}"
                            local PAGE="${TEMPORAR%\}*}"
                            echo -n "# ${PAGE} # ${line%%+([[:blank:]])*} ${line##*+([[:blank:]])} "
                            ${DJVUSED} "${1}" -e "select ${PAGE}; size"
                            #echo -e "Tisknu Meta informace ke stránce"
                            ${DJVUSED} "${1}" -e "select ${PAGE}; print-meta"
                    ;;
                esac
            done
        ;;
        pages) identifybundle "${1}"
            case $? in
                0) ${DJVM} -l "${1}" | grep PAGE\ # | wc -l
                ;;
                2) echo 1
                ;;
                *) echo error
                ;;
            esac
        ;;
        grep*) ${DJVUSED} "${1}" -e 'dump' | grep '{' | grep -v INCL | awk '{print $4,$3}' | \
            while read line ; do
                case "${line}" in
                    \[S\]*)
                    ;;
                    *) local TEMPORAR="${line#*\{}"
                        local PAGE="${TEMPORAR%\}*}"
                        local TEMPORAR="${line%%\]*}"
                        local ORDER="${TEMPORAR##*\[P}"
                            #echo -n "# ${PAGE} # ${line%%+([[:blank:]])*} ${line##*+([[:blank:]])} "
                            #${DJVUSED} "${1}" -e "select ${PAGE}; size"
                            #echo -e "Tisknu Meta informace ke stránce"
                            #${DJVUSED} "${1}" -e "select ${PAGE}; print-meta" | ${2}
                            local TEMPORAR=$(${DJVUTXT} "${1}" -page=${ORDER} | ${2} 2>1)
                            if [ -n "${TEMPORAR}" ] ; then
                                echo "# ${PAGE} # ${line%%+([[:blank:]])*}"
                                printf "%s\n" "${TEMPORAR}"
                            fi
                    ;;
                esac
            done
        ;;
        '') local INFO=($(cat "${1}"|infoitem))
            identifybundle "${1}"
            case $? in
                0) local SUMPAGES=$(${DJVM} -l "${1}" | grep PAGE\ # | wc -l)
                ;;
                2) local SUMPAGES=1
                ;;
                *) local SUMPAGES=error
                ;;
            esac
            echo "${INFO[@]} ${SUMPAGES}"
        ;;
        *) return 1
        ;;
    esac
    return $?
}

# ### <span id="deletepage">deletepage()</span> ([top](#FUNCTIONS))
# Odstraňuje z DjVu Bundle svazku stránky
#
# $1 - soubor
# $2 - parametry
djvuinfo1() {
    log goto "djvuinfo() $1 –> $2"
    local SOURCE=$(${REALPATH} -m -P "${1}")
    local FILE="${SOURCE##*/}"
    if $(identifybundle "${SOURCE}") ; then
        local PAGES="none"
    else
        local PAGES=$(lastpage "${SOURCE}")
    fi
    if [ -n "${2}" ] ; then
        case "${2}" in
            exif) ${EXIFTOOL} "${SOURCE}"
                ;;
            meta) printmeta "${SOURCE}" all | grep -v '^[#.]\|^$'
                ;;
            pages) if identifybundle ${SOURCE} ; then
                    ${DJVM} -l "${SOURCE}" | grep PAGE\ # | awk '{print " [P"$3"]:"$4}' | sed 's/P#/P/'
                else
                    ${DJVUSED} "${SOURCE}" -e dump | grep FORM:DJVU | awk -F'[{}]' '{print $3":"$2}'
                fi
                return 0
            ;;
            *) case "${2%%\ *}" in
                    meta) if [ "${2#* }" == "all" ] ; then
                            printmeta "${SOURCE}" all | grep -v '^[#.]\|^$'
                            return 0
                        elif [ "${2#* }" == "global" ] ; then
							printmeta "${SOURCE}" global | grep -v '^[#.]\|^$'
							return 0
						else
							printf "Meta atributtes for page %s from %s" "${2#* }" "${FILE}" >> ${LOG}
							local NAMEPAGE=$(identifypage name "${SOURCE}" "${2#* }")
							if [ -z "${NAMEPAGE}" ] ; then
								echo "info: FAIL - identificator page ${2#* } is not valid for DjVu bundle ${FILE}" >> /dev/stderr
								exit 1
							else
								local IDPAGE=$(identifypage order "${SOURCE}" "${NAMEPAGE}")
								printf "Meta attributes from #%s page in DjVu bundle %s" "${IDPAGE}" "${FILE}" >> ${LOG}
								printmeta "${SOURCE}" "${NAMEPAGE}" | grep -v '^[#.]\|^$'
								return 0
							fi
						fi
					;;
					pages) if [ "${2#* }" == "all" ] ; then
							if identifybundle ${SOURCE} ; then
								${DJVM} -l "${SOURCE}" | grep PAGE\ # | awk '{print " [P"$3"]:"$4}' | sed 's/P#/P/'
							else
								${DJVUSED} "${SOURCE}" -e dump | grep FORM:DJVU | awk -F'[{}]' '{print $3":"$2}'
							fi
							return 0
						else
							printf "View %s item from list %s" "${2#* }" "${FILE}" >> ${LOG}
							local NAMEPAGE=$(identifypage name "${SOURCE}" "${2#* }")
							if [ -z "${NAMEPAGE}" ] ; then
								echo "info: FAIL - identificator page ${2#* } is not valid for DjVu bundle ${FILE}" >> /dev/stderr
								exit 1
							else
								local IDPAGE=$(identifypage order "${SOURCE}" "${NAMEPAGE}")
								printf " [P%d]:%s\n" "${IDPAGE}" "${NAMEPAGE}"
								return 0
							fi
						fi
					;;
					exif) if [ "${2#* }" == "all" ] ; then
							${EXIFTOOL} "${SOURCE}"
							return 0
						else
							printf "Exif atributtes for page %s from %s" "${2#* }" "${FILE}" >> ${LOG}
							local NAMEPAGE=$(identifypage name "${SOURCE}" "${2#* }")
							if [ -z "${NAMEPAGE}" ] ; then
								echo "info: FAIL - identificator page ${2#* } is not valid for DjVu bundle ${FILE}" >> /dev/stderr
								exit 1
							else
								local IDPAGE=$(identifypage order "${SOURCE}" "${NAMEPAGE}")
								PAGE="yes"
								djvuexport "${1}" "${NAMEPAGE} ${TEMPDIR}"
								local INFO="Page #${IDPAGE} from DjVu bundle"
								echo -n "${INFO}" && printf "%$((31 - ${#INFO}))s : ${FILE}\n"
								${EXIFTOOL} "${TEMPDIR}/${NAMEPAGE}"
								return 0
							fi
						fi
					;;
				esac
			;;
		esac
    else
        case "${PAGES}" in
            none) local INFO="${FILE}"
                echo -n "${INFO}" && printf "%$((31 - ${#INFO}))s : DjVu single-page\n"
                ;;
            *) local INFO="${FILE}"
                echo -n "${INFO}" && printf "%$((31 - ${#INFO}))s : DjVu bundle - ${PAGES} pages\n"
                ;;
        esac
    fi
}

function help {
	case "$1" in
        actions) echo """Implementované akce: """
        ;;
		algorithm) echo """

Binarizační algoritmy ovliňují vygenerování optimální černobílé masky
Utilita DiDjVu podporuje tyto algoritmy:

abutaleb
bernsen
  - region-size=N (1 .. 50, default: 11)
  - contrast-limit=N (0 .. 255, default: 80)
  - doubt-to-black
brink
djvu (default) (vhodný pro černobílé obrázky)
  - smoothness=X (0.0 .. 1.0, default: 0.2)
  - max-block-size=N (default: 512)
  - min-block-size=N (default: 64)
  - block-factor=N (1 .. 8, default: 2)
global
  - threshold=N
niblack
  - region-size=N (default: 15)
  - sensitivity=X (default: -0.2)
  - lower-bound=N (0 .. 255, default: 20)
  - upper-bound=N (0 .. 255, default: 150)
otsu (vhodný pro černobílé obrázky, lepší komprese než u výchozího djvu)
sauvola
  - region-size=N (default: 15)
  - sensitivity=X (default: 0.5)
  - dynamic-range=N (1 .. 255, default: 128)
  - lower-bound=N (0 .. 255, default: 20)
  - upper-bound=N (0 .. 255, default: 150)
shading-subtraction
  - k=N (default: 7)
  - threshold=N
tsai
white-rohrer
  - x-lookahead=N (default: 8)
  - y-lookahead=N (default: 1)
  - bias-mode=N (default: 0)
  - bias-factor=N (default: 100)
  - f-factor=N (default: 100)
  - g-factor=N (default: 100)

Výchozí nastavení algoritmů lze upravit 
		"""
		;;
        bitmap) echo """
        """
        ;;
		bitmap-export) echo """
U bitmapových souborů, které mají podporu pro více stránek (či vrstev)
lze využít export k jejich extrakci a případně i transformaci na jiný
rozměr či konverzi do jiného formátu – včetně DjVu. Viz příklad:

    ${APP} soubor.jpg export jpg 1 30%

Vygeneruje JPEG obrázek s názvem soubor_30%.jpg jehož obsahem bude původní
obrázek ze souboru soubor.jpg, zmenšený na 30% původní velikosti.

U kontejnerů typu zip či tar, které mohou obsahovat obrázky v různých formátech,
lze provést export pouze s uvedením rozsahu. Cílové soubory se pak budou
jmenovat stejně, jako ty v archívu:

    ${APP} soubor.zip export orig 2-7

U bitmapových formátů s podporou více stránek, které mají v sobě uložen
také název vrstvy či stránky, bude mít vyexportovaný soubor stejné jméno
jako byl název příslušné vrstvy či stránky.

    ${APP} soubor.xcf export 2-7

V tomto případě tedy bude výsledkem série šesti souborů ve formátu .xcf,
vytvořených z druhé až sedmé vrstvy souboru soubor.xcf pojmenovaných podle
jejich názvů.

Pokud se mají soubory jmenovat podle jiného vzoru, musí být uveden výchozí
vzorek. Viz příklad:

    ${APP} soubor.xcf export 2-7 soubor

V takovém případě se budou vyexportované soubory jmenovat soubor_00002.xcf
až soubor_00007.xcf

Akci export lze využít i ke konverzi do jiného formátu:

    ${APP} soubor.pdf export 1 jpg

V případě PDF souborů, které mohou obsahovat mix textu a obrázků bude v tomto
případě výstupem jako bitmapový obrázek celá stránka. Pokud však chcete,
aby výstupem byly pouze vložené obrázky (nebo text), je třeba jako výstupní
formát uvést co chcete:

    ${APP} soubor.pdf export 1 images

Není-li řečeno jinak, jsou výsledné soubory v původním rozlišení. Ovšem
při konverzi lze velikost cílového obrázku rovnou přeškálovat:

    ${APP} soubor.pdf export 1 jpg 0.5 example

Tímto způsobem zvolíte, že cílová velikost bude obrázku bude 50% původní
velikosti.

Velikost výsledného souboru také můžete uvést uvedením rozměru cílového
obrázku. V takovém případě ale musíte použít i jeden z následujících
parametrů, kterým určíte jak se má při škálování postupovat:

-xysize přeškáluje obrázek tím způsebem, že použije kratší rozměr a ten
        co bude přesahovat ořízne tak aby výsledek odpovídal velikosti
        vymezeného prostoru a zároveň zůstal zachován poměr stran výchozího
        obrázku
-xyfit  roztáhne obrázek tak aby vyplnil celý uvedený rozměr, poměr stran
        tedy nebude zachován
-xyfill přeškáluje obrázek podle většího rozměru, tak aby se vešel do
        vymezeného prostoru celý a poměr stran při tom zůstal zachován.

Viz příklad:

    ${APP} soubor.pdf export 1 jpg 250x300 -xysize example

Při škálování se automaticky použije volba -nomix, můžete ji ale zaměnit
za konkrétní škálovací filtr. Viz příklad:

    ${APP} soubor.pdf export 1 jpg 250x300 -filter=box example
"""
        echo "Seznam použitelných škálovacích filtrů:"
        printf "\t%s\n" ${FILTERS[@]}
echo """
Ve všech uvedených příkladech jsou výsledné soubory uloženy do adresáře,
ve kterém se ${APP} spouští. Pokud se mají uložit jinam, je třeba uvést
i cílovou  cestu:

    djvutool soubor.pdf export 1 jpg 0.33 example/

V tomto případě se vyexportované stránky nasypou do podadresáře example.
Pokud neexistuje, tak se vytvoří. Pokud se mají soubory při exportu také
přejmenovat, je třeba za lomítkem uvést také příslušný vzor:

    djvutool soubor.pdf export 1 jpg 0.33 example/example

V tomto případě by se tedy výsledný soubor jmenoval example_30%_00001.jpg

Pokud má být číslování jiné než výchozí pětimístné, vypadá vzorek takto:

    djvutool soubor.pdf export 1 jpg 30% example/example_XX
"""
		;;
        bitmap-info) echo """
  ACTION [1minfo[0m

  If isn't subkey, return basic informations about file: Format, dimensions
  of page and for file in multipage format summary count of pages.

  [1m${0##*/}[0m info <file> [ pages | list | meta <num> ]

         num  - order of page (or layer) in file

  SUBKEYS:
         [3mlist[23m - (only multipage file) return list names, or numbers of
                pages from multipage file, or from container 
         [3mmeta[23m - return exif info about page from container or file
        [3mpages[23m - return only sumary count of pages as number

[3mNotice:[23m
  * For [3m'meta'[23m [2minfo[22m different from [2mexport[22m in that output is purified from syntax chars, whose is required for [2mimport[22m.
  * When is passed subkey [3m'exif'[23m with an identificator of page, be export a page into temporary dir and view info only about this page.
  * Subkey [3m'pages'[23m with an identificator of page return only item for this.
        """
        ;;
		bundle) echo """Nápověda pro volbu typu svazku.. ToDo
		"""
		;;
		page) echo """volba [1m-p[0m ([1m--page[0m)

  Extrakce DjVu stránky ze svazku při akci [2mexport[22m

  [1m${0##*/}[0m ... {-p|--page} [yes|no] ...
  
[4mPoznámka:[24m
  * Pokud za volbou není uveden žádný další parametr, tak se automaticky
    předpokládá - yes.
  * Výchozí parametr - no - lze implicitně změnit nastavením proměnné
    PAGE do souboru v adresáři ${HOME}/.config/${NAME}/
  * Exportované stránky se ukládají pod svým původním názvem.
"""
		;;
		image) echo """volba [1m-i[0m ([1m--img[0m)

  [4mExtrakce obrazové vrstvy[24m DjVu stránky do bitmapového souboru

  [1m${0##*/}[0m ... {-i|--img} [yes|no|<layer>] ...

  Je-li parametrem volby [3myes[23m, tak se bude při akci [2mexport[22m generovat z DjVu
  stránky plnobarevný bitmapový obrázek ve formátu PNG.
  V ostatních případech bude ve formátu PNM.

      [1m${0##*/}[0m --img background svazek.djvu export stranka.djvu
 
Použitelné parametry:
                 color - plnobarevná stránka
                 black - černobílá kresba
            foreground - vrstva popředí
            background - vrstva pozadí
                  mask - maska
  Je-li místo [3m'yes'[23m uvedeno [3m'background'[23m, bude při exportu stránky
  strana.djvu uložen obrázek pozadí pod jménem strana.background.pnm
  Výchozí nastavení lze implicitně změnit nastavením proměnné IMGPAGE
"""
		;;
		dsed) echo """Option [1m-d[0m ([1m--dsed[0m)

  Extrakce skryté textové vrstvy DjVu stránky ve formátu pro djvused.
  Parametrem lze zvolit, co se má při akci [2mexport[22m uložit.

  [1m${0##*/}[0m ... {-d|--dsed} [yes|no|all|txt|ant] ...
  
         yes - stejný efekt jako volba all
         no  - textová vrstva se neexportuje (default)
         all - exportuje se celý obsah skryté textové vrstvy
         txt - exportuje se pouze obsah stránky
         ant - exportují se meta atributy stránky, hyperlinky, atp.

[4mPoznámka:[24m
  * Pokud za volbou není uveden žádný další parametr, tak se automaticky
    předpokládá - yes.
  * Výchozí parametr - no - lze implicitně změnit nastavením proměnné
    DSED do souboru v adresáři ${HOME}/.config/${NAME}/
  * Exportovaná data se ukládají do souborů s příponou [3m.dsed[23m.
"""
		;;
		force) echo """volba [1m-f[0m ([1m--force[0m)

  Nastavením této volby si lze vynutit výchozí chování k souborům při
  akci [2mexport[22m. Není-li uvedena, tak se skript před každým
  přepsáním již existujícího souboru zeptá, zda-li má, nebo nemá
  pokračovat.

  [1m${0##*/}[0m ... {-f|--force} [yes|no|skip] ...
  
         yes  - všechny soubory se budou bez keců přepisovat.
         no   - skript se před přepsáním souboru bude dotazovat, zda-li
                má soubor přepsat.
         skip - pokud bude cílový soubor existovat, tak se akce přeskočí.

[4mPoznámka:[24m
  * Pokud za volbou není uveden žádný další parametr, tak se automaticky
    předpokládá - skip.
  * Výchozí parametr hodnotu parametru  (skip) - lze implicitně změnit
    nastavením proměnné FORCE v uživatelském konfiguračním souboru.
"""
		;;
		verbose) echo """volbu [1m-v[0m ([1m--verbose[0m)
  Prostřednictvím této volby si lze přesměrovat výstup doplňujících
  informačních výpisů na konzoli. Díky nim pak lze podrobně sledovat
  postup skriptu při zpracování souboru

  [1m${0##*/}[0m ... {-v|--verbose} ...
"""
		;;
		xml) echo """volba [1m-x[0m ([1m--xml[0m)

  Extrakce skryté textové vrstvy DjVu stránky ve formátu XML.
  Parametrem lze zvolit, co se má při akci [2mexport[22m uložit.

  [1m${0##*/}[0m ... {-d|--dsed} [yes|no|all|txt|ant] ...
  
         yes - stejný efekt jako volba all
         no  - textová vrstva se neexportuje (default)
         all - exportuje se celý obsah skryté textové vrstvy
         txt - exportuje se pouze obsah stránky
         ant - exportují se meta atributy stránky

[4mPoznámka:[24m
  * Pokud za volbou není uveden žádný další parametr, tak se automaticky
    předpokládá - yes.
  * Výchozí parametr - no - lze implicitně změnit nastavením proměnné
    XML do souboru v adresáři ${HOME}/.config/${NAME}/
  * Exportovaná data se ukládají do souborů s příponou [3m.xml[23m.

[1mPozor:[0m  Při exportu do XML nelze podchytit všechny meta atributy!!!
"""
		;;
		exporttometa) echo """volba [1m-m[0m ([1m--meta[0m)

  Extrakce DjVu stránky ze svazku

  [1m${0##*/}[0m ... {-x|--xml} [yes|no] ...
  
  Prostřednictvím této volby lze zvolit zda se má, nebo nemá při akci
  [3mexport[23m z DjVu svazku exportovat i celá DjVu stránka. Pokud za volbou
  nenásleduje parametr, pak se automaticky předpokládá že ano (yes).
  Výchozí nastavení (no), lze implicitně změnit prostřednictvím
  uživatelského konfiguračního souboru umístěného v v adresáři:

    ${HOME}/.config/${NAME}/
"""
		;;
		exporttothumb) echo """volba [1m-t[0m ([1m--thumb[0m)

  Extrakce DjVu stránky ze svazku

  [1m${0##*/}[0m ... {-t|--thumb} [yes|no] ...
  
  Prostřednictvím této volby lze zvolit zda se má, nebo nemá při akci
  [3mexport[23m z DjVu svazku exportovat i celá DjVu stránka. Pokud za volbou
  nenásleduje parametr, pak se automaticky předpokládá že ano (yes).
  Výchozí nastavení (no), lze implicitně změnit prostřednictvím
  uživatelského konfiguračního souboru umístěného v v adresáři:

    ${HOME}/.config/${NAME}/
"""
		;;
		indirect) echo"""
[1mVolba[0m
         --indirect Volba, kterou lze změnit výchozí typ vícestránkového 
                    DjVu svazku (bundeled)

  Volbu je třeba aplikovat pokud chcete rozbalit stvávající DjVu svazek 
  do podoby volného svazku, nebo pokud chcete při konverzi bitmapových
  souborů rovnou sestavit DjVu svazek jako volný

  Výhodou volného svazku je, že lze dodatečně upravovat jednotlivé stránky
  jako samostatné DjVu soubory, aniž by je bylo nutné exportovat.

  Pro finalizaci DjVu svazku je pak lepší svazek překonvertovat na typ
  bundled, kdy je vše zabaleno v jednom souboru
"""
		;;
		existed) echo """
  Soubor $2 existuje. Pokud se má přepsat, musí být
  uveden parametr -f (--force)
"""
		;;
		dpi) echo """
[1mOption:[0m --dpi  <[2mčíslo[22m> Hodnota DPI, která se má použít při zpracování obrázku.
                               při konverzi. Optimální je zjistit hodnotu přímo ze vstupního
                               obrázku. Před nastavením této hodnoty pro finální konverzi. lze vyzkoušet
                               optimální nastavení na některém ze souborů s využitím parametru
                               --test

  Rozsah číselné hodnoty je od 72 do 6000 dpi. Výchozí hodnota 300 se použije 
  v případě, že parametr --dpi není vůbec uveden.
  Vliv dpi na zpracování obrazu..
"""
		;;
		level) echo """
[1mParametr[0m
         -l|--level  <[2mčíslo[22m> Hodnota akceptovatelných ztrát u černobílé kresby
                               při konverzi. Před nastavením této hodnoty vyzkoušejte
                               optimální nastavení na některém ze souborů a s parametrem
                               --test

  Kromě číselné hodnoty, která musí být menší než 200 lze úroveň ztrát
  nastavit i pomocí některého z následujících parametrů - v případě že 
  jich bude uvedeno víc, má prioritu poslední z nich.

        --lossless     0 - žádné ztráty (default)
        --clean        1 - ignorují se body o velikosti 1 pixelu
        --lossy        100 - ignorují se plochy
"""
		;;
		keywords) echo """

  [1m${0##*/}[0m {ACTIONS} <DjVu file> {-h|--help}

ACTIONS:
    export - export and convert page into another format
      info - view info about file or page
      view - view file, or page from file

ACTIONS for DjVu:

    delete - remove page from bundle
fore, back - move, or insert pages into DjVu bundle
    rotate - change orientation page or all pages DjVu bundle
    export - export from DjVu bundle
    import - import (content, meta attributes, outline) into DjVu bundle 
      edit - edit meta attributes or outline in DjVu bundle
      info - view info about DjVu bundle or selected page
    rename - rename pages in DjVu bundle by pattern

OBSOLETE ACTIONS:
    insert - vložení čehokoliv do DjVu (nahrazuje import)
     print - výpis meta atributů na konzoli (nahrazuje export)
       set - nastavení meta atributu (nahrazuje edit)
     unset - zrušení meta atributu (nahrazuje edit)
      view - otevření DjVu souboru v djview4

[3mNotice:[23m
   For more description about any action or option you set on command line as next parameter option -h (--help)
"""
		;;
		keywords-delete) echo """
  ACTION: [1mdelete[0m    Odstraňuje stránky z DjVu svazku. Pozor, akce je [4mnevratná[24m!

  [1m${0##*/}[0m [volby] <svazek> delete RANGE

  RANGE
    Stránky k odstranění mohou být identifikovány buď jménem nebo aktuální
    pozicí v rámci DjVu svazku. Ostranit lze i několik stránek najednou.
    Použití seznamu jmen:
                        … 'name_1.djvu,name_23.djvu,name_4.djvu'
    Použití rozsahu:
                        … 1,10,4-5
[4mPoznámky:[24m
  * Při odstraňování stránek je uvedený rozsah setříděn tak, aby se stránky
    odstraňovaly postupně odzadu, tak aby se během odstraňování neměnilo
    jejich pořadové číslo.
  * K odstranění stránky dojde pouze v případě že DjVu soubor tvoří víc než
    jedna stránka.
  * Při odstraňování stránek je bezpečnější používat k identifikaci jména
    stránek, neboť pozice stránky se může v průběhu zpracování DjVu svazku
    měnit, kdežto jméno zůstává vždy v rámci svazku jedinečné.
"""
		;;
		keywords-fore) help move
		;;
		keywords-fore1) echo """
  ACTION [1mfore[0m

  Umístění nové stránky, nebo stránky v rámci DjVu svazku již existující před stránku identifikovanou jménem, nebo aktuální pozicí. o pozici vpřed. [4mPřed stránku, která[24m
  [4mji má následovat[24m. V případě, už přesouvaná stránka je na první pozici,
  se nestane nic.

  [1m${0##*/}[0m [volby] <svazek> fore {<num>|<name>|<file>} [<num>|<name>]

         num  - pořadové číslo stránky v DjVu svazku
         name - jméno stránky v DjVu svazku
         file - DjVu soubor nebo naskenovaná stránka v bitmapovém formátu

  Je doporučeno použít jako identifikátor jména stránek, místo jejich 
  aktuální pozice. A to z toho důvodu, že se pozice stránek mohou v průběhu
  zpracování DjVu svazku měnit, kdežto její jméno stránky je vždy v rámci
  svazku jedinečné.
"""
		;;
		keywords-back) echo """
  ACTION [1mback[0m

  Přesun stránky v rámci DjVu svazku o pozici zpět. [4mZa stránku, která[24m
  [4mji má následovat[24m. V případě, už je přesouvaná stránka na poslední pozici,
  se nestane nic.

  [1m${0##*/}[0m [volby] <svazek> back {<num>|<name>} [<num>|<name>]

         num  - pořadové číslo stránky v DjVu svazku
         name - jméno stránky v DjVu svazku

  Je doporučeno použít jako identifikátor jména stránek, místo jejich 
  aktuální pozice. A to z toho důvodu, že se pozice stránek mohou v průběhu
  zpracování DjVu svazku měnit, kdežto její jméno stránky je vždy v rámci
  svazku jedinečné.
"""
		;;
		keywords-rotate) echo """
  ACTION [1mrotate[0m

  For change of default orientation page in DjVu file.

  [1m${0##*/}[0m [option] <DjVu> rotate {<num>|<name>} <VALUE>

         num   - order of page to change in DjVu bundle
         name  - name of page to change in DjVu bundle

Options:
    -f|--force   Force rotate without any questions

  VALUE:
             0 - normal orientation (0°)
             1 - rotate page 90° to right
             2 - rotate page 180°
             3 - rotate page 90° to left (270°)
          left - rotate page 90° in left direction
         right - rotate page 90° in right direction
           180 - turn the page on the contrary

[3mWarning:[23m
  * If is not any identificator of page, do set global orientation for all DjVu bundle.
"""
		;;
		keywords-export) echo """
  ACTION: [1mexport[0m

  [1m${0##*/}[0m [volby] <DjVu svazek> export {FORMAT} [RANGE] [TARGET]

FORMAT
      ant - poznámky
      xml - na výstup bude vypsán XML obsah vybraného rozsahu stránek
     dsed - na výstup bude vypsán obsah vybraného rozsahu stránek v dsed formátu
  outline - na výstup bude vypsán obsah DjVu svazku ve formátu pro import
 ?   meta - na výstup budou vypsány meta atributy svazku ve formátu pro import

     color - plnobarevná stránka
     black - černobílá kresba
foreground - vrstva popředí
background - vrstva pozadí
      mask - maska

RANGE
      num - pořadové číslo stránky v DjVu svazku
     name - jméno stránky v DjVu svazku
TARGET
      dir - adresář do kterého má být výstup uložen
      all - předmětem exportu bude obsah celého DjVu svazku

  O tom co bude předmětem exportu rozhoduje typ vstupního souboru, a další 
  volby.

  Je-li je vstupním souborem jiný formát souboru než DjVu, umožňuje export:
  * u vícestránkových dokumentů extrakci jednotlivých stránek
  * jejich konverzi do jiných bitmapových formátů, včetně přeškálování
  * i konverzi do DjVu
  
  Je-li vstupním souborem DjVu dokument, jsou výsledkem exportu soubory,
  které lze po úpravě importovat zpět a tak provádět kupř. textovou korekturu
  jeho původního obsahu, či doplňovat obsah a další metadata.
  
  Export textové vrstvy zajistí volby [3m-x[23m a [3m-d[23m, náhled obrazové vrstvy
  se generuje při volbě [3m-i[23m, a celá stránka v DjVu formátu se exportuje
  při volbě [3m-p[23m.

[4mPoznámky:[24m
  * Pro zpracování single-page DjVu stránek je parametr [3mall[23m doporučený
  * Není-li uveden cílový adresář, budou soubory exporované do adresáře,
    kde byl [1m${0##*/}[0m spuštěn.
  * Přepsání již existujících souborů si lze vynutit volbou [3m--force yes[23m
    Výchozí chování je - [3mskip[23m (existující soubory se znovu neexportují)
"""
		;;
		keywords-import) echo """
   ACTION: [1mimport[0m
  [4mImport obsahu textové vrstvy[24m do DjVu souboru

  [1m${0##*/}[0m [volby] <svazek> import [<file>|<dir>]

         file - soubor s obsahem skryté textové vrstvy
         dir  - adresář se soubory s obsahem skryté textové vrstvy

[3mPoznámky:[23m
  * Parametrem akce [2mimport[22m může být buď adresář se soubory, nebo soubor s
    daty k importu
  * Název souboru musí odpovídat názvu svazku (pro gobální metadata), nebo
    názvu stránky, kterou obsahuje, s tím rozdílem, že jeho přípona odpovídá
    typu dat které obsahuje:
          [3m.meta[23m - meta atributy
           [3m.xml[23m - skrytý text obsahu
          [3m.dsed[23m - poznámky, meta atributy a skrytý text obsahu
       [3m.outline[23m - obsah svazku; Pozor! Obsah je součást celého svazku, nemá
                  tedy smysl ho vkládat do single-page DjVu dokumentu.
    K formátu těchto souborů více viz manuál
  * Není-li uveden žádný adresář, ani soubor, tak se předpokládá že se budou
    zpracovávat soubory z aktuálního adresáře
"""
		;;
		keywords-edit) echo """
  ACTION [1medit[0m

  Editace textový informací DjVu svazku - meta informace, bookmarks,outline

  [1m${0##*/}[0m <DjVu> edit outline

  [1m${0##*/}[0m <DjVu> edit ant [<num>|<name>|<RANGE>]

         outline - výpis aktuálního obsahu DjVu svazku ve formátu .outline
         meta  - vygenerování šablony pro .outline formát s adresováním
                 stránek podle jejich názvů

         num  - pořadové číslo stránky v DjVu svazku
         name - jméno stránky v DjVu svazku

[3mPoznámka:[23m
  Vygenerovanou šablonu .outline formátu lze upravit editací v libovolném
  textovém editoru. Řádky s nevyužitými položkami je třeba smazat.
  Do dalších úrovní lze položky obsahu zanořit pomocí odsazení řádku
                   1 úroveň = 1 tabulátor = 8 mezer
  Aktuální obsah lze vyexportovat v .outline formátu parametrem print
  Upravený obsah lze do DjVu svazku naimportovat ze souboru přes akci [2mimport[22m,
[1mPozor:[0m Soubor ve formátu .outline musí mít (až na příponu) stejné jméno,
  jako má DjVu svazek do kterého se má vložit, jinak se nenaimportuje!
"""
		help range
		;;
		keywords-info) echo """
  ACTION [1minfo[0m

  Print informations about DjVu bundle. Without parameters return number of pages.
  If is DjVu file 'single-page', return 'none'.

  [1m${0##*/}[0m [volby] <DjVu svazek> info [SUBKEY]

SUBKEY
    exif - vypisuje exif info o DjVu souboru
    meta - vypisuje meta informace stránek DjVu souboru
    pages - vrací celkový počet stran v DjVu svazku
    list - vrací seznam stránek DjVu svazku
    grep - aplikuje příkaz grep s předanými parametry na textový obsah DjVu svazku
"""
		;;
		keywords-print) echo """
   Action [1mprint[0m

   Action [2mprint[22m meta attribute keys or outline into stdout

  [1m${0##*/}[0m <DjVu> print outline

  [1m${0##*/}[0m <DjVu> print meta

  [1m${0##*/}[0m <svazek> print <attr>
  [1m${0##*/}[0m <svazek> print {<num>|<name>} [all]
  [1m${0##*/}[0m <svazek> print {<num>|<name>} <attr>

         num  - pořadové číslo stránky v DjVu svazku
         name - jméno stránky v DjVu svazku
         attr - jméno atributu
         all  - klíčové slovo (vypsat vše)

[3mPoznámka:[23m
  Jednotlivé atributy lze nastavovat přes [2mset[22m, více atributů najednou
  lze do DjVu stránky či svazku importovat z externího souboru při
  akci [2mimport[22m. Metadata lze z DjVu souborů také exportovat ([2mexport[22m).
"""
		;;
		keywords-set) echo """
  ACTION [1mset[0m set meta attribute key or outline item from command line

  [1m${0##*/}[0m <DjVu> set outline {<num>[:[+|-]]} <ITEM> <TARGET>
 
  [1m${0##*/}[0m <DjVu> set meta [all|<RANGE>|<name>] <KEY> <VALUE>

Example for set outline item:

  [1m${0##*/}[0m bundle.djvu set outline : 'To page 12' '#12'

Example for set meta attribute:

  [1m${0##*/}[0m bundle.djvu set meta 1,3,7-12 Creator 'Thomas Jefferson'

[3mNotice:[23m
    * If is value of [3mORDER[23m zero or empty, is append ITEM
      to end outline
    * Plus, separed by colon from order num, signalize next level for
      nesting of the item compare to level of a previous item
    * Count of minus, separed by colon, signalize level for emersion of
      the outline item compare to level of a previous item.
    * First item outline can not be nested.
    * If is not page identificator, is [3mKEY[23m set as shared
      into shared_anno.iff

   ITEM - text value of bookmark item
 TARGET - name or order page which is target of item with hash (#)
    num - item order in outline (see action [2mprint[22m)
    all - attributte is set as meta attribute for every page in DjVu bundle
   name - attributte is set to page specified by name"""
		help key
		help value
		help range
		;;
		keywords-unset) echo """
  ACTION [1munset[0m remove item from outline or meta attributes

  [1m${0##*/}[0m <DjVu> unset outline <num>

  [1m${0##*/}[0m <DjVu> unset meta [all|<RANGE>|<name>] <KEY>

Example for remove bookmark item:

    [1m${0##*/}[0m bundle.djvu unset outline 3

Examle for remove meta attribute:

    [1m${0##*/}[0m bundle.djvu unset meta 1,3,7-12 Creator

    all - item is set as meta attribute for every page in DjVu bundle
    num - item order in outline (see action [2mprint[22m)
   name - name page in DjVu bundle"""
		help range
		help key
		help value
		;;
		range) echo """  RANGE - parameter for selection range pages, specified by order of pages
           in DjVu bundle. Separated by comma. Hyphen is for limits from-to.
           Example range: 1,3,7-12"""
		;;
		key) echo """    KEY - name of meta attribute, single word without diacritical chars
          and spaces. Example commonly used keys:
                 [3mTitle[23m - Title of DjVu page or bundle
               [3mCreator[23m - Creator DjVu bundle or DjVu page from scan
          [3mCreationDate[23m - Creation date of DjVu bundle or page
              [3mKeywords[23m - Keywords for indexation DjVu file
                [3mannote[23m - Notes about origin of document & etc."""
		;;
		value) echo """  VALUE - is normal text string in quotes"""
		;;
		keywords-meta) echo """
  ACTION [1mset[0m or [1munset[0m

  Keywords [2mset[22m or [2munset[22m work only with meta attribute key.
  For view meta attribute use keyword [2minfo[22m and [2mexport[22m for output in
  format which is usable to [2mimport[22m. You may [2medit[22m attribute too.

  [1m${0##*/}[0m <DjVu> unset meta [all|<RANGE>] <KEY>

  [1m${0##*/}[0m <DjVu> set meta [all|<RANGE>] <KEY> <VALUE>

          all - item is set as meta attribute for every
                page in DjVu bundle
        RANGE - range specified pages
          KEY - key name of meta attribute
        VALUE - value of meta attribute key

[3mNotice:[23m
  * If is not given key word [3mall[23m or [3mRANGE[23m of pages, is item KEY accepted
    as global meta attribute of DjVu bundle
  * Range is 

RANGE example:

    [1m${0##*/}[0m bundle.djvu set meta 1,3,7-12 Creator 'Thomas Jefferson'

KEY most common attributes:
        [3mTitle[23m - Title of DjVu page or bundle
      [3mCreator[23m - Creator DjVu bundle or DjVu page from scan
 [3mCreationDate[23m - Creation date of DjVu bundle or page
     [3mKeywords[23m - Keywords for indexation DjVu file
       [3mannote[23m - Notes about origin of document & etc.

[3mNotice:[23m
  * KEY is single word without diacritical chars and spaces
  * VALUE is normal text string
"""
		;;
# ODSTRANIT VVVV
		keywords-outline) echo """akce [1moutline[0m

Zrušeno, nahrazeno akcí edit a export

  Pomocná akce pro výpis a export obsahu (bookmarks,outline) Djvu svazku.

  [1m${0##*/}[0m <svazek> outline {dump|print|<order>|<name}

         dump  - dump aktuálního obsahu DjVu svazku v dsed formátu
         print - výpis aktuálního obsahu DjVu svazku ve formátu .outline
         order - vygenerování šablony pro .outline formát s adresováním
                 stránek dle pořadových čísel
         name  - vygenerování šablony pro .outline formát s adresováním
                 stránek podle jejich názvů
         num  - pořadové číslo stránky v DjVu svazku
         name - jméno stránky v DjVu svazku

[3mPoznámka:[23m
  Vygenerovanou šablonu .outline formátu lze upravit editací v libovolném
  textovém editoru. Řádky s nevyužitými položkami je třeba smazat.
  Do dalších úrovní lze položky obsahu zanořit pomocí odsazení řádku
                   1 úroveň = 1 tabulátor = 8 mezer
  Aktuální obsah lze vyexportovat v .outline formátu parametrem print
  Upravený obsah lze do DjVu svazku naimportovat ze souboru přes akci [2mimport[22m,
[1mPozor:[0m Soubor ve formátu .outline musí mít (až na příponu) stejné jméno,
  jako má DjVu svazek do kterého se má vložit, jinak se nenaimportuje!
"""
		;;
# ODSTRANIT VVVV
		meta) echo """
Export meta atributů

  [1m${0##*/}[0m <svazek> export meta [<num>|<name>|all|global]
  
  global - globální meta atributy DjVu svazku
     all - kompletní výpis atributů ke svazku
         - výpis atributů stránky identifikované pořadovým číslem nebo jménem

Syntaxe meta souboru:

 #<num> '<name>'
 key1 <description>
 key2 ...
 .

Při importu stránky má jméno stránky přednost před pořadovým číslem. To se použije pouze tehdy, pokud identifikační jméno stránky chybí
Pokud stránka žádné meta atributy nemá, vypíše se pouze prázdná šablona
"""
		;;
		move) echo """akce [1mfore[0m a [1mback[0m
  [4mUmožňují přesunout stránku v rámci DjVu svazku [24m na jinou pozici, či
  [4mvložit[24m na tuto pozici  [4mstránku novou [24m, je-li prvním parametrem akce
  místo identifikátoru stránky v DjVu svazku soubor.

  [1m${0##*/}[0m [volby] <svazek> {fore|back} {<num>|<name>|<file>} [<num>|<name>]

         num  - pořadové číslo stránky v DjVu svazku
         name - jméno stránky v DjVu svazku
         file - jméno DjVu souboru, nebo skenu

[3mPoznámka:[23m
  * Je-li souborem nekonvertovaný bitmapový obrázek, určí co vše bude
    obnášet konverze předané volby.
  * Není-li určena indentifikátorem cílová pozice, bude stránka přesunuta
    při akci [2mfore[22m o pozici vpřed, nebo vzad - při akci [2mback[22m.
  * Je-li při akci [2mfore[22m vložena ze souboru nová stránka a není uveden
    identifikátor cílové pozice, bude stránka vložena na první pozici
    DjVu svazku. Při akci [2mback[22m) se připojí na konec.
  * Pokud se již v DjVu svazku nalézá stránka se stejným názvem jako má
    vkládaný soubor, vyskytuje, dojde při jeho vložení automaticky k
    přejmenování - za název se přidá podtržítko a pořadové číslo.
"""
		;;
		rename) echo """ volba [1m-r[0m, [1m--rename[0m
 Nastavení vzorku, podle jakého se mají pojmenovat, nebo přejmenovat DjVu soubory v DjVu svazku.

Lze využít parametr %01d pro nastavení počtu znaků v číslování stránky, při konverzi vícestránkových bitmapových souborů (tiff, png, xcf)

[4mPopis:[24m
  Pomocí [2mvzoru[22m lze upravit názvy zkonvertovaných DjVu souborů
  před jejich sestavením do DjVu svazku. [2mVzor[22m může být tvořen:
    1, Pouze jednou, nebo více nulami - 000
    2, Nebo řetězcem, následovaným nulami - soubor_00

[3mPoznámka:[23m
  Je-li uvedena pouze jedna nula, budou stránky očíslovány [4mnumericky[24m,
  t.j. od čísla 1 dále. Je-li nul více, pak bude číslo interpretováno
  jako [4mřetězec[24m. tedy 001 a dále. Pokud by číslování stránek přesáhlo
  nastavený počet čísel, bude upraven dle maximálního čísla.

[3mUkázkové vzory : a výsledný efekt..[23m
   soubor-0000 : soubor-0001.djvu .. soubor-0123.djvu
   soubor_0    : soubor_1.djvu    .. soubor_123.djvu
   soubor000   : soubor0001.djvu  .. soubor1234.djvu
"""
			;;
		suffix) echo """
[1mParametr[0m
         -e|--ext  <[2msuffix[22m>  Přípona souborů, ze kterých se má sestavit 
                                DjVu soubor.
[4mPopis:[24m
  [2mSuffix[22m je nutné uvést pouze v případě, že soubory s názvem odpovídajícím
  vzorku dosud nebyly do DjVu zkonvertovány. Jinak se vždy předpokládá, že
  se bude pracovat s již konvertovanými DjVu soubory.

  Je-li [2msuffix[22m uveden, budou konvertovány soubory vyhovující vzorku.
  Pokud některé z nich již konvertovány byly, tak se se fáze konverze
  přeskočí. Pracuje se pak s již existujícím DjVu souborem.

  Konvertovány jsou pouze soubory, které chybí. Kvalitu konverze lze
  ovlivnit  dalšími parametry. Mají-li být soubory překonvertovány znovu,
  lze si to vynutit parametrem -f (--force) a stávající soubory  přepsat.

  Akceptované sufixy: 
     djvu (default), jpg, gif, png, bmp, pnm, pbm, pgm.
  Vícevrstvé soubory:
     xcf, tiff, pdf 
"""
			;;
		ocr) echo "Nápověda k OCR - ToDo"
		;;
		options) echo """Options:
    -a|--algorithm Algorithm for separating mask of image (fore or back)
xx  -b|--bundle    Setting type of DjVu bundle
    -d|--dsed      Export hiddent text layer in native code for DjVused
       --dpi       DPI input image for import (actions fore or back)
    -f|--force     Force action
       --clean     Params for convert image to DjVu with separate layers
       --lossy
       --lossless
       --level
    -h|--help      Main options for help about option, or action
    -i|--image     Export .png image of page for use with DjVuWebEd
??  -m|--meta      Export meta attributes from DjVu file
    -o|--ocr       Application OCR
    -p|--page      Export single DjVu page from bundle
    -r|--rename    Pattern for action rename 
xx  -t|--thumb     Creating thumbnails in DjVu bundle
    -v|--verbose   
    -x|--xml       Export hiddent text layer (XML) for use with DjVuWebEd"""
		;;
		*) echo """
DJVUTOOL - tool to work with DjVu files & bundles

Use:  [1m${0##*/}[0m [options] { [-h|--help] | <file> {KEYWORDS} [...] }
""" && help options && help keywords
		;;
	esac
}

# ### <span id="filetodjvu">filetodjvu()</span> ([top](#FUNCTIONS))
# Dublovaná funkce
function filetodjvu {
	echo "filetodjvu: vstupuji sem.." >> /dev/stderr
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	local TARGETPATH=$(${REALPATH} -m -P "${2}")
	local TARGET="${TARGETPATH##*/}"
	case "${FILE##*.}" in
		[jJ][pP][gG]|[pP][nN][gG]|[gG][iI][fF]|[pP][nN][mM]) todjvu "${SOURCE}" "${TARGETPATH}"
			echo "filetodjvu: INFO - DjVu bundle ${TARGETPATH} is prepared" >> /dev/stderr
		;;
		[tT][iI][fF][fF]|[xX][cC][fF]|[nM][nN][gG]|[pP][dD][fF]) if [ "${RENAME}" == "no" ] ; then
				# pojmenování cíle vyjde ze jména souboru
				local COUNT=$(${IDENTIFY} -format "%n" ${SOURCE})
				${CONVERT} "${SOURCE}" "${TEMPDIR}/${FILE%.*}_%0${#COUNT}d.png"
			else
				# pojmenování vyjde ze vzoru
				local COUNT=$(${IDENTIFY} -format "%n" ${SOURCE})
				if [[ ${RENAME} =~ "%" ]] ; then
					echo "Použiju číslování ze vzoru" >> /dev/stderr
					${CONVERT} "${SOURCE}" "${TEMPDIR}/${RENAME}.png"
				else
					echo "Použiju výchozí číslování" >> /dev/stderr
					${CONVERT} "${SOURCE}" "${TEMPDIR}/${RENAME}_%0${#COUNT}d.png"
				fi
			fi
			# Konverze vytažených souborů..
			find "${TEMPDIR}" -type f ! -name '*.djvu' | while read line
			do
				todjvu "${line}" "${line%.*}.djvu"
			done
			# Zabalení vytažených souborů...
			find "${TEMPDIR}" -type f ! -name "${TARGET}" -name "*.djvu" | while read line
			do
				if [ -f "${TARGETPATH}" ] ; then
					${DJVM} -i "${TARGETPATH}" "${line}"
				else
					${DJVM} -c "${TARGETPATH}" "${line}"
				fi
			done
			echo "filetodjvu: INFO - DjVu bundle ${TARGETPATH} is prepared" >> /dev/stderr
		;;
		*) echo "filetodjvu: INFO - Format file ${FILE##*\.} is not supported. Sorry!!" >> /dev/stderr && exit 1
		;;
	esac
}

# ### <span id="todjvu">todjvu()</span> ([top](#FUNCTIONS))
# Funkce která konvertuje soubory do DjVu
todjvu() {
    log goto "todjvu() View ${VIEW} ${1} –> ${2}"
    filepath "${1}"
    [ $? -eq 1 ] && echo "todjvu() Invalid path –> ${1}" && return 1
    case "${FILESUFFIX}" in
        [jJ][pP][gG]|[pP][nN][mM]) #/ Konverze není nutná
            ;;
        [pP][nN][gG]|[gG][iI][fF]) #/ mohou mít více framů
            ;;
        [jJ][2kKpP][2cCtT])
            jp2to "${FILEFULL}" "${TEMPDIR}/${FILENAME/.${FILESUFFIX}/.pnm}"
            filepath "${TEMPDIR}/${FILENAME/.${FILESUFFIX}/.pnm}"
            ;;
        [tT][iI][fF][fF]|[xX][cC][fF]|[nM][nN][gG]|[pP][dD][fF]) echo "todjvu() INFO - Format file ${FILESUFFIX} now is not accepted. Sorry!!" >> /dev/stderr && return 1
            ;;
        [dD][jJ][vV][uU]) echo "todjvu: ERROR - ${FILENAME} is DjVu file" >> /dev/stderr && return 1
            ;;
        *) echo "todjvu() INFO - Format file ${FILESUFFIX} is not supported. Sorry!!" >> /dev/stderr && return 1
            ;;
    esac
    local SOURCE="${FILEFULL}"
    filepath "${2}"
    case "${FILESUFFIX}" in
        [dD][jJ][vV][uU])
            if [ "${#ALG[@]}" -gt "1" ] ; then
                for i in ${ALG[@]} ; do
                    [ -f "${FILEPATH}/${FILENAME/.${FILESUFFIX}/.$i.djvu}" ] && \
                    anone "Soubor ${FILEPATH}/${FILENAME/.${FILESUFFIX}/.$i.djvu}, mám pokračovat a ten soubor přepsat?"
                    [ $? -eq 1 ] && return 1
                    encodefile $i "${SOURCE}" "${FILEPATH}/${FILENAME/.${FILESUFFIX}/.$i.djvu}" && \
                    getocr "${FILEPATH}/${FILENAME/.${FILESUFFIX}/.$i.djvu}"
                    [ -n "${VIEW}" ] && djvuview "${FILEPATH}/${FILENAME/.${FILESUFFIX}/.$i.djvu}"
                done
            else
                [ -f "${FILEPATH}/${FILENAME}" ] && \
                anone "Soubor ${FILEPATH}/${FILENAME}, mám pokračovat a ten soubor přepsat?"
                [ $? -eq 1 ]&& return 1
                encodefile $i "${SOURCE}" "${FILEPATH}/${FILENAME}" && \
                getocr "${FILEPATH}/${FILENAME}"
                [ -n "${VIEW}" ] && djvuview "${FILEPATH}/${FILENAME}"
                log info "todjvu() ${FILE} was converted into ${FILEPATH}/${FILENAME}"
            fi
            return 0
            ;;
        *) echo "todjvu: ERROR - Target must be with suffix .djvu" >> /dev/stderr
            return 1
            ;;
    esac
}

# ### <span id="djvuview">djvuview()</span> ([top](#FUNCTIONS))
# Funkce na základě předaného jména (parametr __$1__) a zvolených
# enkodovacích algoritmů otevře prohlížeč DjVu souborů, aby bylo možné
# provést vizuální srovnání kvality zkonvertovaných souborů
djvuview() {
    log goto "djvuview() Open –> $@"
    while [ $# -gt 0 ] ; do
        local TYPE=$(testfile "${1}")
        case "${TYPE}" in
            djvu) (${DJVIEW} "${1}" &) ;;
            *) echo "File ${1} is not DjVu file" >> /dev/stderr ;;
        esac
        shift
    done
}

# TODO - insert
function todjvuclassic {
    RANDOMKEY=$[ 8000 + $[ RANDOM % 1000 ]]
    TEMP_DIR="${TEMPDIR}/$WINDOWID$BASHPID$RANDOMKEY"
    mkdir $TEMP_DIR
    TEMP_IMG="$TEMP_DIR/temp.ppm"
    TEMP_MASK="$TEMP_DIR/mask.pbm"
    DJVU_MASK="$TEMP_DIR/mask.djvu"

    case ${1##*.} in
        tiff|tif) KONVERT="${TIFFTOPNM}";;
        png) KONVERT="${PNGTOPNM}";;
        jpg) KONVERT="${JPEGTOPNM}" ;;
    esac

    $KONVERT $1 | tee $TEMP_IMG | ${PPMTOPGM} | ${PGMTOPBM} -threshold -value 0.${3-5} | ${PNMTOPLAINPNM} > $TEMP_MASK;
    ${CJB2} -lossy -clean $TEMP_MASK $DJVU_MASK;
    ${DJVUMAKE} ${1/.png/.djvu} Sjbz=$DJVU_MASK PPM=$TEMP_IMG;
    getocr ${1/.png/.djvu}
    rm -rf $TEMP_DIR
}

# Zpracování parametrů předaných při startu skriptu
main() {
while [ $# -gt 0 ]
do
    case ${1} in
        -a|--algorithm) #/ Volba pro akci insert
            #/ Není-li uveden žádný kompresní algoritmus, je aplikováno
            #/ výchozí nastavení proměnné $ALG z konfigurace"
            case ${2} in
                -h|--help) help algorithm
                    exit 0
                    ;;
                *) for i in ${2//;/ } ; do
                    if [[ ${ALGORITHM[@]} =~ (^|[^[:alpha:]])${i%:*}([^[:alpha:]]|$) ]] ; then
                        log info "main() Verify algorithm $i –> OK"
                    else
                        printf "Algorithm %s isn't supported\n" "$i" 1>&2
                        exit 0
                    fi
                    done
                    ALG=(${2//;/ })
                    log set "main() Compression algorithm –> ${ALG[@]}"
                    shift && shift
                    ;;
            esac
            ;;
        -d|--dsed) # Volba pro akci export
            case ${2} in
                -h*|--help*) help dsed && exit 0
                    ;;
                yes|no|txt|ant|all) DSED=${2}
                    log info "main() Aplikuji pro DSED parametr - ${DSED}"
                    shift && shift
                    ;;
                *) log warn "main() Nebyl uveden žádný parametr, aplikuji pro DSED parametr - yes"
                    DSED="yes"
                    shift
                    ;;
            esac
            ;;
        --dpi) # Volba pro akci insert
            case ${2} in
                -h*|--help*) help dpi && exit 0
                    ;;
                [[:digit:]])
                    if [ "${2}" -ge "72" ] && [ "${2}" -le "6000" ] ; then
                        DPI="${2}"
                        log info "main() Aplikuji pro DPI parametr - ${DPI}"
                        shift && shift
                    else
                        echo "Hodnota u volby --dpi se musí pohybovat v rozmezí od 72 do 6000" >> /dev/stderr
                        exit 1
                    fi
                    ;;
                *) echo "Nebyla uvedena hodnota dpi. Pokud chcete volbou --dpi změnit výchozí hodnotu (300), musíte ji uvést jako číselný parametr" >> /dev/stderr
                    exit 1
                    ;;
            esac
            ;;
        -f|--force)
            case ${2} in
                -h*|--help*) help force && exit 0
                    ;;
                yes|no|skip) FORCE=${2}
                    log info "main() Aplikuji pro FORCE parametr - ${FORCE}"
                    shift && shift
                    ;;
                *) log warn "main() Nebyl uveden žádný parametr, aplikuji pro FORCE parametr - skip"
                    FORCE="yes"
                    shift
                    ;;
            esac
            log set "main() FORCE –> ${FORCE}"
            ;;
        --clean) LEVEL="--loss-level=1" && shift
            ;;
        --lossy) LEVEL="--loss-level=100" && shift
            ;;
        --lossless) LEVEL="--loss-level=0" && shift
            ;;
        --level) # Volba pro akci insert
            case ${2} in
                -h*|--help*) help force && exit 0
                    ;;
                [[:digit:]])
                    if [ "${2}" -ge "0" ] && [ "${2}" -lt "200" ] ; then
                        LEVEL="--loss-level=${2}"
                        log info "main() Aplikuji pro LEVEL hodnotu - ${LEVEL}"
                        shift && shift
                    else
                        help level && exit 0
                    fi
                    ;;
                *) echo "main() Volba --loss-level musí mít vždy uvedenou číselnou hodnotu v rozmezí 0-199" >> /dev/stderr
                    exit 1
                    ;;
            esac
            log info "main() Úroveň ztrátovosti při kompresi ${LEVEL}"
            ;;
        -i|--image) # Volba pro akci export
            case "${2}" in
                -h*|--help*) help image && exit 0
                    ;;
                yes|no|color|black|foreground|background|mask)
                    IMG="${2}"
                    log info "main)) Aplikuji pro IMG parametr - ${IMG}"
                    shift && shift
                    ;;
                *) log warn "main() Nebyl uveden žádný parametr, aplikuji pro IMG parametr - yes"
                    IMG="yes"
                    shift
                    ;;
            esac
            ;;
        -m|--meta) # Volba pro akci export
            case "${2}" in
                -h*|--help*) help meta && exit 0
                    ;;
                yes|no) META="${2}"
                    log info "main() Aplikuji pro META parametr - ${META}"
                    shift && shift
                    ;;
                *) META="yes"
                    log warn "main() Nebyl uveden žádný parametr, aplikuji pro META parametr - yes"
                    shift
                    ;;
            esac
            ;;
        -o|--ocr) # Volba pro akci insert
            case "${2}" in
                -h*|--help*) help ocr
                    ${TESSERACT} --list-langs 2>&1 | sed -n '1!p'
                    exit 0
                    ;;
                *)
#			echo $(${TESSERACT} --list-langs 2>&1 | sed '1d;x') >> /dev/stderr
                for i in ${2//+/ } ; do
                    local TEST="no"
                    local OCR=(${i//:/\ })
                    if [ "${#OCR[@]}" -eq 2 ] ; then
                        # ${OCR[0]} engine
                        # ${OCR[1]} jazyk
                        case "${OCR[0]:0:1}" in
                            c) CUNEIFORM=$(which cuneiform)
                                [ ! -x "${CUNEIFORM}" ] && exit 31
                                if [ "${OCR[1]}" == "?" ] ; then
                                    ${CUNEIFORM} -l
                                    exit 0
                                else
                                    local LANGUAGES=($(${CUNEIFORM} -l | grep languages | sed 's/^[a-Z ]*://'))
                                    if [[ ${LANGUAGES[@]} =~ (^|[^[:alpha:]])$y([^[:alpha:]]|$) ]] ; then
                                        OCRLANG=$y && local TEST="yes"
                                        log info "main() OCR lang –> $y"
                                    fi
                                fi
                                ;;
                            t) TESSERACT=$(which tesseract)
                                [ ! -x "${TESSERACT}" ] && exit 31
                                if [ "${OCR[1]}" == "?" ] ; then
                                    ${TESSERACT} --list-langs
                                    exit 0
                                else
                                    local LANGUAGES=($(${TESSERACT} --list-langs 2>&1 | sed -n '1!p'))
                                    if [[ ${LANGUAGES[@]} =~ (^|[^[:alpha:]])$y([^[:alpha:]]|$) ]] ; then
                                        OCRLANG=$y && local TEST="yes"
                                        log info "main() OCR lang –> $y"
                                    fi
                                fi
                                ;;
                            *) help keywords-convert-ocr
                                exit 0
                                ;;
                        esac
                    elif [ "${#OCR[@]}" -eq 1 ] ; then
                        # ${OCR[0]} jazyk
                        # výchozí engine je tesseract
                        TESSERACT=$(which tesseract)
                        [ ! -x "${TESSERACT}" ] && exit 31
                        if [ "${OCR[0]}" == "?" ] ; then
                            ${TESSERACT} --list-langs
                            exit 0
                        else
                            local LANGUAGES=($(${TESSERACT} --list-langs 2>&1 | sed -n '1!p'))
                            if [[ ${LANGUAGES[@]} =~ (^|[^[:alpha:]])$y([^[:alpha:]]|$) ]] ; then
                                OCRLANG=$y && local TEST="yes"
                                log info "main() OCR lang –> $y"
                            fi
                        fi
                    else
                        help keywords-convert-ocr
                        exit 0
                    fi
                    echo "OCR ${#OCR[@]}" >> /dev/stderr
                    echo "OCRLANG ${OCRLANG}" >> /dev/stderr
                    echo "TESSERACT ${TESSERACT}" >> /dev/stderr
                    echo "CUNEIFORM ${CUNEIFORM}" >> /dev/stderr
                    if [ "${TEST}" == "no" ] ; then
                        echo "Pro OCR engine $i není nainstalovanájazyková podpora" >> /dev/stderr
#					exit 1
                    fi
                done

                if [ "${TEST}" == "yes" ] ; then
                    OCR="${2%%+([[:blank:]])}"
                    log info "main() Aplikuji pro OCR parametr - ${OCR}"
                    shift && shift
                else
                    OCR="${OCR=ces}"
                    echo "Nebyl uveden žádný parametr, pro OCR použiji výchozí jazyk - ${OCR}" >> /dev/stderr
#				exit 1
                    shift
                fi
                ;;
            esac
            ;;
        -p|--page) # Volba pro akci export
            case "${2}" in
                -h*|--help*) help page && exit 0
                    ;;
                yes|no) PAGE="${2}"
                    log info "main() Aplikuji pro PAGE parametr - ${PAGE}"
                    shift && shift
                    ;;
                *) log warn "main() Nebyl uveden žádný parametr, aplikuji pro PAGE parametr - yes"
                    PAGE="yes"
                    shift
                    ;;
            esac
            ;;
        -r|--rename) # Nastavení vzoru pro pojmenování stránek při akcích rename, fore a back
            case "${2}" in
                -h*|--help*) help rename && exit 0
                ;;
                *) if [ "${2##+([[:alnum:]%_-])}" == "" ] ; then
                    RENAME="${2}"
                    log info "main() Aplikuji pro RENAME parametr - ${RENAME}"
                    shift && shift
                else
                    echo "main() FAIL - pattern '${VALUE}' for rename is is not acceptable." >> /dev/stderr
                    exit 1
                fi
            ;;
            esac
        ;;
        -t|--thumb) # Volba pro akci insert
            case "${2}" in
                -h*|--help*) help thumb && exit 0
                    ;;
                *) if [ "${2//+([[:digit:]])}" == "" ] ; then
                        if [ "${2}" -ge "32" ] && [ "${2}" -le "256" ] ; then
                            THUMB="${2%%+([[:blank:]])}"
                            log info "main() Aplikuji pro THUMB parametr - ${DPI}"
                            shift && shift
                        else
                            echo "Hodnota u volby --thumb se musí pohybovat v rozmezí od 32 do 256" >> /dev/stderr
                            exit 1
                        fi
                    else
                        echo "Nebyla uvedena hodnota velikosti náhledu. Pokud chcete volbou --thumb nastavit výchozí hodnotu, musíte ji uvést jako číselný parametr" >> /dev/stderr
                        exit 1
                    fi
                    ;;
            esac
            ;;
        -v*|--verbose*) #/ Změna výchozí hodnoty proměnné $DEBUG
            case ${1} in
                -v|--verbose)
                    case ${2} in
                        -h|--help|help|\?)
                            help verbose && exit 0
                            ;;
                        [0-9])
                            DEBUG="-d${2}"
                            shift && shift
                            ;;
                        *) DEBUG="-d1"
                            shift
                            ;;
                    esac
                    ;;
                -v[0-9])
                    DEBUG="-d${1:2}"
                    shift
                    ;;
                *=*)
                    case "${1#*=}" in
                        0) shift
                            ;;
                        [1-9]) DEBUG="-d${1#*=}"
                            shift
                            ;;
                        *) help_debug "${1#*=}" && exit 1
                            ;;
                    esac
                    ;;
            esac
            log set "main() DEBUG –> ${DEBUG}"
            ;;
        -x|--xml) # Volba pro akci export
            case "${2}" in
                -h*|--help*) help xml && exit 0
                    ;;
                yes|no|txt|ant|all) XML="${2%%+([[:blank:]])}"
                    log info "main() Aplikuji pro XML parametr - ${XML}"
                    shift && shift
                    ;;
                *) log warn "main() Nebyl uveden žádný parametr, aplikuji pro XML parametr - yes"
                    XML="yes"
                    shift
                    ;;
            esac
            ;;
            *.[dD][jJ][vV][uU]|\
            *.[gG][iI][fF]|\
            *.[jJ][pP][gG]|\
            *.[jJ][pP]2|\
            *.[zZ][iI][pP]|\
            *.[pP][nN][gG]|\
            *.[pP][nNpPgGaAbB][mM]|\
            *.fore|\
            *.[pP][cC][dD]|\
            *.[mM][nN][gG]|\
            *.[pP][dD][fF]|\
            *.[tT][aA][rR]|\
            *.[tT][iI][fF][fF]|\
            *.[tT][iI][fF]|\
            *.[xX][cC][fF])
                local FILE=$(realpath -P "${1}")
                [ ! -n "${FILE}" ] && echo "Invalid filepath ${1}" && exit 1
                shift
                if [[ ${ACTIONS[@]} =~ (^|[^[:alpha:]])${1}([^[:alpha:]]|$) ]] && [ "?" != "${1}" ]; then
                    ACTION=${1}
                    shift
                    local CHARSTRING="$@"
                    log info "main() ACTION –> ${ACTION}"
                    log info "main() CHARSTRING –> ${CHARSTRING}"
                    break
                else
                    case ${1} in
                        -h|--help|help|?) help actions
                            printf "\t"
                            printf "%s " ${ACTIONS[@]}
                            help keywords
                            return 0
                        ;;
                        *) echo "Neimplementovaný parametr" >> /dev/stderr
                            return 1
                        ;;
                    esac
                fi
                ;;
        *) if [[ ${ACTIONS[@]} =~ (^|[^[:alpha:]])${1}([^[:alpha:]]|$) ]] && [ "?" != "${1}" ]; then
                ACTION=${1}
                shift
                case ${1} in
                    *.[dD][jJ][vV][uU]|\
                    *.[gG][iI][fF]|\
                    *.[jJ][pP][gG]|\
                    *.[jJ][pP]2|\
                    *.[zZ][iI][pP]|\
                    *.[pP][nN][gG]|\
                    *.[pP][nNpPgGaAbB][mM]|\
                    *.fore|\
                    *.[pP][cC][dD]|\
                    *.[mM][nN][gG]|\
                    *.[pP][dD][fF]|\
                    *.[tT][aA][rR]|\
                    *.[tT][iI][fF][fF]|\
                    *.[tT][iI][fF]|\
                    *.[xX][cC][fF])
                        local FILE=$(realpath -P "${1}")
                        [ ! -n "${FILE}" ] && echo "Invalid filepath ${1}" && exit 1
                        shift
                        local CHARSTRING="$@"
                        log info "main() ACTION –> ${ACTION}"
                        log info "main() CHARSTRING –> ${CHARSTRING}"
                        break
                    ;;
                    *) echo "${1} – Nepodporovaný typ souboru" >> /dev/stderr
                        return 1
                    ;;
                esac
            else
# Smyčka se přeruší, pokud není předaná žádná známá akce, ani parametr,
# který by byl ošetřen pomocí voleb. Další paramtery jsou pak již číslovány
# 1, 2, 3 atd..
                case ${1} in
                    -h|--help|help|?) help actions
                        printf "\t"
                        printf "%s " ${ACTIONS[@]}
                        help keywords
                        return 0
                    ;;
                    *) echo "Neimplementovaný parametr ${1}" >> /dev/stderr
                        return 1
                    ;;
                esac
            fi
            ;;
    esac
done


#/ echo "${ACTION}" >> /dev/stderr
#/ echo "$@" >> /dev/stderr

FILETYPE=$(testfile "${FILE}")
case "${CHARSTRING}" in
    *-h|*--help|-h*|--help*)
        if [ -z "${ACTION}" ] ; then
            help
        else
            case ${FILETYPE} in
                djvu) help "keywords-${ACTION}"
                ;;
                *) help "bitmap-${ACTION}"
                ;;
            esac
        fi
        exit 0
    ;;
esac

case ${FILETYPE} in
    djvu) #/ Pracuji se souborem v DjVu formátu
        log info "main() DjVu file ${FILE} –> #${CHARSTRING}#"
        case "${ACTION}" in
            delete) local TEST=$(isrange "${CHARSTRING}")
                if [ -n "${TEST}" ] ; then
                    #/ Rozsah stránek identifikovaných pořadím
                    RANGE=$(range ${TEST})
                else
                    #/ Seznam stránek oddělených čárkami
                    x=0
                    for i in ${CHARSTRING//,/ } ; do
                       RANGE[$x]=$(identifypage order "${FILE}" "${i}")
                    done
                fi
                #/ Setřídění RANGE pozpátku, 
                for i in $(printf "%d\n" ${RANGE[@]} | sort -nr) ; do
                    deletepage "${FILE}" "${i}"
                    [ $? -eq 1 ] && echo "Page isn't in ${FILE} –> $i" >> /dev/stderr && return 1
                done
                return 0
            ;;
            insert) # OBSOLETE - nahrazuje akce import
                #/ Vkládám soubor předaný jako parametr 
                # ToDo - zpracovat ${CHARSTRING}
                exit 1
                        if [ -f "${3}" ] ; then
                            if [ $(testfile ${3}) == "djvu" ] ; then
                                log info "main() - insert: Soubor je typu djvu"
                                local INSERTFILE=${3}
                            else
                                [ "${#ALG[@]}" == "1" ] || exit 32
                                local INSERTFILE="$TEMPDIR/${3%.*}.djvu"
                                todjvu ${3} ${INSERTFILE}
                                if [ $? -gt "0" ] ; then
                                    echo "main - insert: Soubor ${3} se nepodařilo zkonvertovat do souboru ${INSERTFILE}" >> /dev/stderr
                                    return 1
                                fi
                            fi
                            # Určit pozici...
                            local P=$(identifypage order ${1} ${4})
                            log info "main() - insert: Cílová pozice je $P"
                            if [ -z "${P}" ] ; then
                                if [ -z "${4}" ] ; then
                                    echo "Připojení souboru ${INSERTFILE} na konec souboru ${1}" >> /dev/stderr
                                    insertpage ${1} ${INSERTFILE}
                                else
                                    echo "Identifikátor ${4} je pro soubor ${1} neplatný" >> /dev/stderr
                                    return 1
                                fi
                            else
                                log info "main() - insert: Vkládám ${INSERTFILE} na pozici $P"
                                insertpage ${1} ${INSERTFILE} ${P}
                            fi
                        else
                            echo "Akci insert lze použít pouze ke vložení souboru" >> /dev/stderr
                            return 1
                        fi
                        return 0
            ;;
            fore) #/ Přesouvám stránku kupředu
                MOVE="fore"
                djvumove "${FILE}" "${CHARSTRING}"
                return 0
            ;;
            back) #/ Přesouvám stránku dozadu
                MOVE="back"
                djvumove "${FILE}" "${CHARSTRING}"
                return 0
            ;;
            rotate) #/ Otáčím stránku
                djvurotate "${FILE}" "${CHARSTRING}"
                return 0
            ;;
            export) #/ Exportuji stránku
                log info "main() export from page ${CHARSTRING}"
                fromdjvu "${FILE}" "${CHARSTRING}"
                return 0
            ;;
            #/ Akce convert byla vyřazena..
            convert) # Konvertuje obsah předhozeného souboru
                case "${CHARSTRING%% *}" in
                    ant) # Převede obsah .ant souboru do formátu pro dsed
                        anttodsed "${CHARSTRING#* }"
                    ;;
                    outline) # Převede obsah .outline souboru do formátu pro dsed
                        #outlinetodsed "${CHARSTRING#* }" | encode >> "${TARGET/.djvu/.outline}"
                        local OUTLINE="${CHARSTRING#* }"
                        outlinetodjvu "${FILE}" "${OUTLINE%%.outline*}.outline" "${OUTLINE#*outline}"
                    ;;
                    bookmark) # Převede obsah .outline souboru do formátu pro import
                        outlinetodsed "${CHARSTRING#* }" | encode > "${TARGET/.djvu/.outline}"
                    ;;
                    dsed) # Převede obsah .dsed souboru podle obsahu na soubor typu .outline a soubor typu .ant
                        echo nil
                    ;;
                    -h) help keyword-import
                    ;;
                    *) djvuimport "${FILE}" "${CHARSTRING}"
                    ;;
                esac
                return 0
            ;;
            import|edit) #/ Import předhozeného souboru a případná editace jeho obsahu
                case "${CHARSTRING}" in
                    ant*) #/ Importuji obsah .ant souboru
                        local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .ant)
                        writefile ${TEMPFILE}
                        echo "Byl zapsán ${TEMPFILE}" >> /dev/stderr
                        # Následující funkce parsuje formát .ant
                        #testsyntaxant ${TEMPFILE}
                        # Následující funkce parsuje formát .dsed
                        testsyntaxdsed ${TEMPFILE}
                        exit 33
                        local ANTFILE=${CHARSTRING#ant}
                        #/ ořezat mezery před a za
                        if [ -f "${ANTFILE}" ] ; then
                            cat "${ANTFILE}" > "${TEMPFILE}"
                        else
                            writefile "${TEMPFILE}"
                            if [ $? -eq 1 ] ; then
                                printf '; Pravidla pro obsah souboru .ant :\n' >> "${TEMPFILE}"
                                printf '; * Globální meta informace se píší jako součást stránky "shared_anno.iff" \n' >> "${TEMPFILE}"
                                printf '; * Stránka může být identifikována buď pořadovým číslem, nebo jménem\n' >> "${TEMPFILE}"
                                printf '; * Blok meta informací vždy začíná řádkem uvozeným znakem # za kterým následuje identifikátor stránky (číslo, nebo jméno)\n' >> "${TEMPFILE}"
                                printf '; * Text záložky i její cíl musí být v uvozovkách\n' >> "${TEMPFILE}"
                                printf '; * Veškerý text na řádcích začínajících středníkem je považován za komentář\n' >> "${TEMPFILE}"
                                printf '; * Při importu souboru bude zakomentovaný obsah odfiltrován\n' >> "${TEMPFILE}"
                                printf '; * Soubor nesmí končit prázdným řádkem!\n' >> "${TEMPFILE}"
                                printf '; * Pokud se do soubory změny neuloží, tak se vloží zpět původní obsah.\n' >> "${TEMPFILE}"
                                printf ';\n' >> "${TEMPFILE}"
                                printf ';Author "Aleš Novák"\n' >> "${TEMPFILE}"
                                printf ';\n' >> "${TEMPFILE}"
                                printf ';; Aktivní link bez bubliny"\n' >> "${TEMPFILE}"
                                printf ';maparea "https://www.thewoodcraft.org/" ""\n' >> "${TEMPFILE}"
                                printf ';rect 225 0 804 61\n' >> "${TEMPFILE}"
                                printf ';xor\n' >> "${TEMPFILE}"
                                printf ';\n' >> "${TEMPFILE}"
                                printf ';; Aktivní link s bublinou"\n' >> "${TEMPFILE}"
                                printf ';URL ("https://www.thewoodcraft.org/" "_blank" ) "Odkaz na stránky Thewoodcraft.org"\n' >> "${TEMPFILE}"
                                printf ';        (rect 225 0 804 61 )\n' >> "${TEMPFILE}"
                                printf ';        (xor )\n' >> "${TEMPFILE}"
                                printf ';; Aktivní link s bublinou u textu přes dva řádky"\n' >> "${TEMPFILE}"
                                printf ';URL ("https://www.thewoodcraft.org/" "_blank" ) "Odkaz na stránky Thewoodcraft.org"\n' >> "${TEMPFILE}"
                                printf ';        ("https://www.thewoodcraft.org/" "_blank" ) "Odkaz na stránky Thewoodcraft.org"\n' >> "${TEMPFILE}"
                                $0 "${FILE}" export ant >> "${TEMPFILE}"
                            fi
                        fi
                        echo "Obsah byl zapsán do souboru ${TEMPFILE}" >> /dev/stderr
                        case ${ACTION} in
                            edit) echo "Edituji soubor ${TEMPFILE}" >> /dev/stderr
                            ;;
                        esac
                        echo "Importuji soubor ${TEMPFILE}" >> /dev/stderr
                        important "${FILE}" "${TEMPFILE}"
#                        outlinetodjvu "${FILE}" "${TEMPFILE}"

#                        local ANT=${CHARSTRING#* }
#                        if [ -f "${ANT%% *}" ] ; then
#                            echo "import from ant file ${ANT%% *} to ${FILE} to pages: ${ANT#${ANT%% *}}" >> /dev/stderr
#                            #anttodsed "${CHARSTRING#* }"
#                            important "${FILE}" "${ANT%% *}" "${ANT#${ANT%% *}}"
#                        else
#                            echo "ERROR: ${ANT%% *} isn't .ant file!"
#                            return 1
#                        fi
                        return 0
                    ;;
                    meta*) echo "import from meta file to ${FILE}"
                        echo nil
                        ;;
                    outline*) echo "Importuji záložky"
                        echo "Přijato k importu ${CHARSTRING}"
                        #/ Může být předaný i soubor
                        #/ Není-li předaný soubor, zkus načíst stdin
                        local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .outline)
                        local OUTLINEFILE=${CHARSTRING#outline}
                        #/ ořezat mezery před a za
                        if [ -f "${OUTLINEFILE}" ] ; then
                            log info "main() Importuji .outline soubor ${OUTLINEFILE}"
                            cat "${OUTLINEFILE}" > "${TEMPFILE}"
                        else
                            writefile "${TEMPFILE}"
                            if [ $? -eq 1 ] ; then
                                log info "main() Na stdin nebylo nic, přidám záhlaví a vytáhnu stávající záložky"
                                printf '; Pravidla pro obsah souboru .outline :\n' >> "${TEMPFILE}"
                                printf '; * Text záložky i její cíl musí být v uvozovkách\n' >> "${TEMPFILE}"
                                printf ';  * Cíl může být identifikován buď pořadovým číslem stránky, nebo jejím jménem\n' >> "${TEMPFILE}"
                                printf ';  * Identifikátor vždy začíná znakem #\n' >> "${TEMPFILE}"
                                printf ';  * Úroveň zanoření záložky je daná odsazením pomocí tabelátoru\n' >> "${TEMPFILE}"
                                printf ';  * Veškerý text na řádcích začínajících středníkem je považován za komentář\n' >> "${TEMPFILE}"
                                printf ';  * Při importu souboru bude zakomentovaný obsah odfiltrován\n' >> "${TEMPFILE}"
                                printf ';  * Soubor nesmí končit prázným řádkem!\n' >> "${TEMPFILE}"
                                printf ';  * Pokud se do soubory změny neuloží, tak se vloží zpět původní obsah.\n' >> "${TEMPFILE}"
                                printf ';\n' >> "${TEMPFILE}"
                                printf ';"Link první úrovně" "#1"\n' >> "${TEMPFILE}"
                                printf ';      "Link druhé úrovně" "#strana-001.djvu"\n' >> "${TEMPFILE}"
                                $0 "${FILE}" export outline >> "${TEMPFILE}"
                            fi
                        fi
                        echo "Obsah záložek byl zapsán do souboru ${TEMPFILE}" >> /dev/stderr
                        case ${ACTION} in
                            edit) echo "Edituji soubor ${TEMPFILE}" >> /dev/stderr
                            ;;
                        esac
                        lig info "main() Importuji soubor .outline ${TEMPFILE} do ${FILE}"
                        outlinetodjvu "${FILE}" "${TEMPFILE}"
                        echo "Záložky byly aktualizovány" >> /dev/stderr
                        return 0
                    ;;
                    page*) echo "Importuji do svazku DjVu stránku"
                    ;;
                    *) help keyword-${CHARSTRING%% *}
                    #djvuimport "${FILE}" "${CHARSTRING}"
                    ;;
                esac
                return 33
            ;;
            info) #/ Info o DjVu svazku
                djvuinfo "${FILE}" "${CHARSTRING}"
                return 0
            ;;
                    print) #/ Zobrazení položky dle následujícího parametru
                        case "${CHARSTRING%% *}" in
                            ant) printant "${FILE}" "${CHARSTRING#* }"
                            ;;
                            outline) printoutline "${FILE}"
                            ;;
                            test) compgen -A "${CHARSTRING#* }"
                            ;;
                            *) help keyword-print
                            ;;
                        esac
                        return 33
                    ;;
                    rename) log info "main() Rename pages in ${FILE} by TEMPLATE –> ${CHARSTRING}"
                        #/ TODO!
                        return 1
                    ;;
                    set) log info "main() Set bookmark or ant into ${FILE} –> ${CHARSTRING}"
                        #/ REWORK!
                        # meta informaci
                        # URL
                        # maparea
                        # 
                        case "${CHARSTRING%% *}" in
                            meta) setmeta "${FILE}" "${CHARSTRING#* }"
                            ;;
                            outline) outlineset "${FILE}" "${CHARSTRING#outline *}"
                            ;;
                            *) help keyword-meta
                            ;;
                        esac
                        return 0
                    ;;
                    unset) log info "main() Remove bookmark or ant from ${FILE} –> ${CHARSTRING}"
                        #/ REWORK!
                        case "${CHARSTRING%% *}" in
                            meta) unsetmeta "${FILE}" "${CHARSTRING#* }"
                            ;;
                            outline) outlineunset "${FILE}" "${CHARSTRING#outline *}"
                            ;;
                            *) help keyword-meta
                            ;;
                        esac
                        return 0
                    ;;
                    edit1) log info "main() Edit from ${FILE} –> ${CHARSTRING}"
                        #/ REWORK!
                        case "${CHARSTRING}" in
                            ant) # export všech ant 
                                printant "${FILE}" "${CHARSTRING#* }"
                                editor "${TEMPFILE}"
                                echo "chybí funkce pro vložení.. set.."
                            ;;
                            outline) local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .outline)
                                printf '; Pravidla pro obsah souboru .outline :\n' >> "${TEMPFILE}"
                                printf '; * Text záložky i její cíl musí být v uvozovkách\n' >> "${TEMPFILE}"
                                printf ';  * Cíl může být identifikován buď pořadovým číslem stránky, nebo jejím jménem\n' >> "${TEMPFILE}"
                                printf ';  * Identifikátor vždy začíná znakem #\n' >> "${TEMPFILE}"
                                printf ';  * Úroveň zanoření záložky je daná odsazením pomocí tabelátoru\n' >> "${TEMPFILE}"
                                printf ';  * Veškerý text na řádcích začínajících středníkem je považován za komentář\n' >> "${TEMPFILE}"
                                printf ';  * Při importu souboru bude zakomentovaný obsah odfiltrován\n' >> "${TEMPFILE}"
                                printf ';  * Soubor nesmí končit prázným řádkem!\n' >> "${TEMPFILE}"
                                printf ';  * Pokud se do soubory změny neuloží, tak se vloží zpět původní obsah.\n' >> "${TEMPFILE}"
                                printf ';\n' >> "${TEMPFILE}"
                                printf ';"Link první úrovně" "#1"\n' >> "${TEMPFILE}"
                                printf ';      "Link druhé úrovně" "#strana-001.djvu"\n' >> "${TEMPFILE}"
                                printoutline "${FILE}" "${TEMPFILE}"
                                editor "${TEMPFILE}"
                                outlinetodjvu "${FILE}" "${TEMPFILE}"
                            ;;
                            meta) echo "nahrazuje ant"
#							 local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .meta)
#								printmeta "${FILE}" all > "${TEMPFILE}"
#								# Doplnit vzor meta stránky pro případ, že zatím žádný obsah neexistuje
#								editor "${TEMPFILE}"
##								sed --in-place '/^#/d' "${TEMPFILE}"
#								[ $(grep -c ^ "${TARGET}") -eq "0" ] && return 1
#								djvuimport "${FILE}" "${TEMPFILE}"
							;;
							*) help keywords-edit
#								local NAMEPAGE=$(identifypage name "${FILE}" "${CHARSTRING#* }")
#								if [ ! -z "${NAMEPAGE}" ] ; then
#									local TARGET="${TEMPDIR}/${FILE##*/}"
#									local IDPAGE=$(identifypage order "${FILE}" "${PAGENAME}") 
#									local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .meta)
#									printmeta "${FILE}" "${NAMEPAGE}" | grep -v '^$' | grep -v '^\.$' >  "${TEMPFILE}"
#									local METAHEAD=$(head -1 ${TEMPFILE})
#									if [ -z "${METAHEAD}" ] ; then
#										METAHEAD="#${IDPAGE} '${NAMEPAGE}'"
#									fi
#									changemeta "${TEMPFILE}"
#									editor "${TEMPFILE}"
#									printf "$METAHEAD\n" > "${TARGET/.djvu/.meta}"
#									sed '/^#/d' "${TEMPFILE}" | sort >> "${TARGET/.djvu/.meta}"
#									printf "\n\n.\n" >> "${TARGET/.djvu/.meta}"
#									djvuimport "${FILE}" "${TARGET/.djvu/.meta}"
#								else
#									printf "You must add valid parameter. Use -h for more info.\n" >> /dev/stderr
#									exit 1
#								fi
							;;
                        esac
                        return 33
                    ;;
                    view) log info "main() Open –> ${FILE}"
                        djview "${FILE}" &
                        return 0
                    ;;
                    *) help keywords && exit 0
                    ;;
                esac
            ;;
            '') echo "${FILE} –> invalid path!" >> /dev/stderr
                return 1
            ;;
            *) log info "main() Input bitmap file (or archive) ${FILE} is in format –> ${FILETYPE}"
                case ${ACTION} in
                    # ### export
                    # Operace export slouží k extrakci stránek (vrstev)
                    # z formátů, které mohou obsahovat více stránek, případně
                    # k jejich transormaci na jiný rozměr či konverzi do
                    # jiného formát. Viz příklad:
                    #
                    #      djvutool soubor.jpg export 1 jpg 30%
                    #
                    # Vygeneruje JPEG obrázek s názvem soubor_30%.jpg jehož
                    # obsahem bude původní obrázek, zmenšený na 30% velikost
                    #
                    # U kontejnerů, které mají uloženy v sobě obrázky,
                    # lze provést export pouze s uvedením rozsahu. Cílové
                    # soubory se pak budou jmenovat stejně, jako v archívu:
                    #
                    # djvutool soubor.zip export 2-7
                    # 
                    # U formátů s podporou více stránek, které mají
                    # uložen název vrstvy či stránky, je vhodné uvést
                    # cílový formát souboru. Jméno cílového souboru pak
                    # bude stejné jako název příslušné vrstvy či stránky:
                    # 
                    # djvutool soubor.xcf export 2-7
                    #
                    # V případě PDF souborů, které mohou obsahovat mix textu
                    # a obrázků volbou přípony sdělíte, že chcete vyexportovat
                    # pouze obrázky:
                    #
                    # djvutool soubor.pdf export 1 jpg
                    #
                    # V tomto případě se budou jmenovat soubory bůhví jak.
                    # Je tedy v tomto případě žádoucí uvést případně jméno
                    # a případně i výchozí cestu:
                    #
                    # djvutool soubor.pdf export 1 jpg 30% example/
                    #
                    # V tomto případě se obrázky nasypou do adresáře example.
                    # Pokud neexistuje, tak se založí.
                    #
                    #  djvutool soubor.pdf export 1 jpg 30% example
                    #
                    # Pokud nekončí řádek lomítkem, použije se celý zbytek
                    # řetězce jako výchozí vzor pro pojmenování stránky
                    # (obrázku) cílový soubor se tedy bude v tomto případě
                    # jmenovat example_30%_001.jpg
                    export) exportimg
                    ;;
                    info) infoimg
                    ;;
                    view) viewimg
                    ;;
                    set) log info "main() set exif tag in img ${FILE} –> ToDo"
                            ;;
                    unset) log info "main() unset exif tag in ${FILE} –> ToDo"
                            ;;
                    rotate) log info "main() rotate ${FILE}"
                            ;;
                    rename) log info "main() rename ${FILE}"
                            ;;
                    import) echo '''Pokud následuje djvu soubor'''
                echo '''Pokud následuje adresář'''
                echo '''to je existující soubor typu bundle a:
- nenásleduje žádný další existující soubor typu djvu, nebo adresář
    a zároveň existuje $DIRECTORY, pak to znamená že se má rozbalit
    - pokud následuje další soubor, pak to znamená že se má nějakým způsobem s tímto dalším souborem naložit. Je-li to:
    - djvu soubor, má se připojit
    - xml soubor, má se vložit
    - soubor typu dsed má se zpracovat
    - jiný soubor - obrázek, který se má převést a vložit
    '''

                    log info "main() import ${FILE} into DjVu"
                        case ${FILETYPE} in
                                djvu) echo "Konvertovat vstupní soubor a vložit do předchozeného DjVu souboru - TODO" >> /dev/stderr
                                    #/ Sestavit z nich soubor typu bundle
                                    ;;
                                gif) #/ může být mít více vrstev 'Animation frames
                                    ;;
                                mng) #/ může být mít více vrstev 'Animation frames'
                                    ;;
                                png) #/ může být mít více vrstev 'Animation frames'
                                    ;;
                                gimp|xcf) #/může mít více vrstev
                                    ;;
                                tiff) #/ může mít více stránek
                                    ;;
                                pdf) #/ může mít více stránek
                                    ;;
                                xml|XML) #/ imporuji soubor s textovou vrstvou
                                    ;;
                                unknown) echo "Pokud je soubor ${1} typu DjVU, může jít o tzv. SecureDjVu formát, který má kryptované vrstvy. S takovým souborem nelze s opensource nástroji pracovat." >> /dev/stderr
                                    exit 1
                                    ;;
                                *) echo "Záleží na typu " >> /dev/stderr
                                ;;
                        esac
                        ;;
                esac
                ;;
esac
}

main "$@"

exit 0
