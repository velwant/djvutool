#!/bin/bash
# -*- mode: sh -*-

# https://…
# djvutool - tool for conversion and work with DjVu files
#
# Author: Aleš Kapica <kapica@fel.cvut.cz>, 2015-2017
#
shopt -s extglob

# Changelog
# * implementováno OCR do akce 'set'
# * implementovaná akce 'sign'
# * implementována akce 'rename'
# * akce 'info' - umožňuje získávat různé užitečné informace
# * akce 'export' funguje zároveň jako konverzní nástroj
# * implementována akce 'rotate'
# * akce 'delete' odstraňuje stránky
# * akce 'edit', 'export', 'import'
# * akce 'fore' a 'back' pro přesun stránek v DjVu souboru


# Otestovat
# - export ze single-page dokumentu
#
# ## Poznámky:
#
# ### Jak vypsat obsah řádku 3 ze souboru test.txt:
#
#   sed -n 3p test.txt
#
# ### Jak vypsat poslední hodnotu pole
#
#    echo ${pole[@]: -1}

# ToDo
# * Ověřit jestli se používá při separaci masky didjvu vždy, nebo jen když
#   je nastaven pomocí -a nějaký algoritmus
#   - přidat případné varování pro situaci, kdy aplikace didjvu není k dispozici
# * XML import potřebuje důkladný popis..
# * export čistého textu
# * Konverze z bundle na unbundle a naopak
# * ? implementace generování náhledů
# * implementovat kontrolu obrazové vrstvy při importu, aby nedocházelo
#   k nekontrolovatelnému vkládání již existujících stránek
# - přidat kontrolu do akce insert na duplicitní soubory při vkládání
#   vícestránkových DjVu souborů. to ovšem bude vyžadovat samostatnou
#   funkci...
#
# Dílčí úpravy stránek DjVu svazku - velmi nízká priorita
# - Odstranění vrstvy ze stránky
# - Odstranění sdíleného chunku
# - Exporty náhledů a souborů textové vrstvy
NAME="djvutool"
[ -d "${HOME}/.config/${NAME}" ] &&	. ${HOME}/.config/${NAME}/* &>>/dev/null
VERSION="0.8"

DEBUG="-d0"
LOG="${LOG=/dev/null}"
XML="${XML=no}"
DPI="${DPI=300}"
PAGE="${PAGE=no}"
INDIRECT="${INDIRECT=no}"
FORCE="${FORCE=skip}"
EXTENSION=".djvu"
THUMBNAIL="${THUMBNAIL=no}"
INSERTTEXT="${INSERTTEXT=no}"
ALG="${ALG=none}"
EXTRACTPAGE="${EXTRACTPAGE=no}"
ALGORITHM=( none abutaleb bernsen brink djvu niblack otsu sauvola shading-subtraction tsai white-rohrer )

trap '''CHYBA=$? ;
case $CHYBA in
 10) echo "Žádná sdílená metadata"
 ;;
 20) echo "Není nainstalován balík poppler-utils"
 ;;
 19) echo "Není nainstalován balík pdftk"
 ;;
 20) echo "Není nainstalován balík djvu-tools"
 ;;
 21) echo "ERROR: mimetype - tool for detection type of image"
 ;;
 22) echo "ERROR: coreutils - tool for detection absolute path of directory"
 ;;
 23) echo "ERROR: netpbm-sf - pack of utilities for image conversions not installed "
 ;;
 24) echo "ERROR: imagemagick - tool for image convert is not installed"
 ;;
 25) echo "ERROR: xmlstarlet - tool for work with xml not installed"
 ;;
 26) echo "ERROR: xcftools - tool for work with xcf file (GIMP) not installed"
 ;;
 27) echo "ERROR: libtiff-tools - tool for work with tiff file not installed"
 ;;
 28) echo "ERROR: libopenjp2-tools - tool for work with jp2 file not installed"
 ;;
 29) echo "ERROR: 7z - tool for work with compressed archives is not installed"
 ;;
 30) echo "ERROR: PDF viewer not installed"
 ;;
 31) echo "Není nainstalován balík ocrodjvu, takže OCR není možné aplikovat." >> /dev/stderr
 ;;
 32) echo "Pokud má při operaci zpracovat do DjVu bitmapový soubor, je třeba uvést na příkazové řádce parametrem -a jaký se má použít algoritmus. Jaké parametry lze použít se dozvíte pokud místo jména algoritmu napíšete znak ?" >> /dev/stderr
 ;;
 33) NORMDIR=yes
 ;;
 38) echo "ERROR - identifikátor stránky není platný!" >> /dev/stderr
 ;;
esac
[ $NORMDIR ] || rm -rf -- "$TEMPDIR"
exit $CHYBA
''' EXIT

TEMPDIR=$(mktemp -d -p /tmp ${NAME}-XXX) || exit 1

#=== testy závislostí ===
# Dependencies:
#   * feh      ( http://feh.finalrewind.org/ )
#   * exiftool ( http://www.sno.phy.queensu.ca/~phil/exiftool ) in Debian package: libimage-exiftool-perl 
#   * yad      ( http://sourceforge.net/projects/yad-dialog )
REALPATH=$(command -v realpath)
[ ! ${REALPATH} ] && exit 1
REALPATH="$REALPATH -e "
if ! command -v ed >/dev/null 2>&1 ; then
    echo "Musí být nainstalován editor ed" >> /dev/stderr
    exit 1
fi
XMLLINT=$(command -v xmllint)
[ ! ${XMLLINT} ] && echo "Nebude fungovat import XML souborů" >> /dev/stderr
FEH=$(command -v feh)
[ ! ${FEH} ] && exit 18
GEEQIE=$(command -v geeqie)
[ ! ${GEEQIE} ] && exit 18
DIDJVU=$(command -v didjvu)
[ ! ${DIDJVU} ] && echo 'Není nainstalován balík didjvu, nebude možné aplikovat pokročilé algoritmy pro separaci popředí při konverzi do DjVu' >> /dev/stderr && DIDJVU=false
OCRODJVU=$(command -v ocrodjvu)
[ ! ${OCRODJVU} ] && echo "Není k dispozici ocrodjvu takže u na DjVu stránek tak nebude možné při akci set aplikovat OCR." >> /dev/stderr
DJVIEW=$(command -v djview)
[ ! ${DJVIEW} ] && echo 'Není nainstalován balík djview, nebude fungovat testovací zobrazení djvu.souborů' >> /dev/stderr && DJVIEW=false
DDJVU=$(command -v ddjvu)
[ ! ${DDJVU} ] && exit 20
DJVUTXT=$(command -v djvutxt)
[ ! ${DJVUTXT} ] && exit 20
DJVUSED=$(command -v djvused)
[ ! ${DJVUSED} ] && exit 20
DJVUTOXML=$(command -v djvutoxml)
[ ! ${DJVUTOXML} ] && exit 20
DJVUXMLPARSER=$(command -v djvuxmlparser)
[ ! ${DJVUXMLPARSER} ] && exit 20
DJVMCVT=$(command -v djvmcvt)
[ ! ${DJVMCVT} ] && exit 20
DJVUEXTRACT=$(command -v djvuextract)
[ ! ${DJVUEXTRACT} ] && exit 20
DJVM=$(command -v djvm)
[ ! ${DJVM} ] && exit 20
CJB2=$(command -v cjb2)
[ ! ${CJB2} ] && exit 20
DJVUMAKE=$(command -v djvumake)
[ ! ${DJVUMAKE} ] && exit 20
#YAD=$(command -v yad)
#[ ! ${YAD} ] && echo 'Není nainstalován balík yad' && exit 1
MIME=$(command -v mimetype)
[ ! -x "${MIME}" ] && exit 21
STAT=$(command -v stat)
[ ! -x "${STAT}" ] && exit 22
EXIFTOOL=$(command -v exiftool)
[ ! -x "${EXIFTOOL}" ] && exit 23
# Přesunuto do funkce main k volbě -o|--ocr
#TESSERACT=$(command -v  tesseract)
#[ ! -x "${TESSERACT}" ] && exit 31
IDENTIFY=$(command -v identify)
[ ! -x "${IDENTIFY}" ] && echo exit 24
XCFINFO=$(command -v xcfinfo)
[ ! -x "${XCFINFO}" ] && echo exit 26
XCF2PNM=$(command -v xcf2pnm)
[ ! -x "${XCF2PNM}" ] && echo exit 26
TIFFINFO=$(command -v tiffinfo)
[ ! -x "${TIFFINFO}" ] && echo exit 27
PDFVIEW=$(command -v xpdf)
if [ ! -x "${PDFVIEW}" ] ; then
    PDFVIEW=$(command -v evince)
    if [ ! -x "${PDFVIEW}" ] ; then
        if [ ! -x "${xournal}" ] ; then
            echo exit 30
        fi
    fi
fi
PDFTK=$(command -v pdftk)
[ ! -x "${PDFTK}" ] && echo exit 19
PDFTOPPM=$(command -v pdftoppm)
[ ! -x "${PDFTOPPM}" ] && echo exit 18

# Konverze z formátu JPEG2000 (jp2)
JP2TO=$(command -v opj_decompress)
[ ! ${JP2TO} ] && exit 28
JP2IN=$(command -v opj_compress)
[ ! ${JP2IN} ] && exit 28
# Nástroje pro konverzi animovaných gifů a png souborů
# apng2gif, gif2apng, 

ZIP=$(command -v 7z)
[ ! -x "${ZIP}" ] && echo exit 29

# ## Implementované akce
#
ACTIONS=(
    delete
    fore
    back
    rotate
    export
    import
    edit
    info
    rename
    insert
    set
    unset
    sign
    view
    )

# ## Akceptované formáty bitmapových souborů
#
# Neztrátové formáty 
FORMATS_FULL=(
    bmp
    pnm
    png
    tif
)
# Formáty, které mohou mít ztrítovou kompresi
FORMATS_MISS=(
    jpg
    xcf
    jp2
)
# Kontejnerové formáty
FORMATS_CONT=(
    pdf
    zip
    tar
)
FORMATS=(${FORMATS_FULL[@]} ${FORMATS_MISS[@]} ${FORMATS_CONT[@]})

PGMTOPBM=$(command -v pgmtopbm)
[ ! -x "${PGMTOPBM}" ] && exit 23
BMPTOPNM=$(command -v bmptopnm)
[ ! -x "${BMPTOPNM}" ] && exit 23
JPEGTOPNM=$(command -v jpegtopnm)
[ ! -x "${JPEGTOPNM}" ] && exit 23
GIFTOPNM=$(command -v giftopnm)
[ ! -x "${GIFTOPNM}" ] && exit 23
PNGTOPNM=$(command -v pngtopnm)
[ ! -x "${PNGTOPNM}" ] && exit 23
PNMTOJPEG=$(command -v pnmtojpeg)
[ ! -x "${PNMTOJPEG}" ] && exit 23
TIFFTOPNM=$(command -v tifftopnm)
[ ! -x "${TIFFTOPNM}" ] && exit 23
PNMTOPNG=$(command -v pnmtopng)
[ ! -x "${PNMTOPNG}" ] && exit 23
PAMTOJPEG2K=$(command -v pamtojpeg2k)
[ ! -x "${PAMTOJPEG2K}" ] && exit 23
JPEG2KTOPAM=$(command -v jpeg2ktopam)
[ ! -x "${JPEG2KTOPAM}" ] && exit 23
PNMTOJPEG=$(command -v pnmtojpeg)
[ ! -x "${PNMTOJPEG}" ] && exit 23
PNMTOPLAINPNM=$(command -v pnmtoplainpnm)
[ ! -x "${PNMTOPLAINPNM}" ] && exit 23
#/ Konvertuje barvy na stupně šedi
PPMTOPGM=$(command -v ppmtopgm)
#/ Konvertuje stupně šedi na černobílou mmasku
[ ! -x "${PPMTOPGM}" ] && exit 23
#/ Konvertuje binární formát PAM do PNM
PAMTOPNM=$(command -v pamtopnm)
[ ! -x "${PAMTOPNM}" ] && exit 23
#/ Vysekne oblast z obrázku dle souřadnic
PAMCUT=$(command -v pamcut)
[ ! -x "${PAMCUT}" ] && exit 23
#/ Odseparuje masku
PAMARITH=$(command -v pamarith)
[ ! -x "${PAMARITH}" ] && exit 23
#/ generátor prázdných ploch pro masku
PBMMAKE=$(command -v pbmmake)
[ ! -x "${PBMMAKE}" ] && exit 23
#/ integruje plochy do masky
PNMPASTE=$(command -v pnmpaste)
[ ! -x "${PNMPASTE}" ] && exit 23
NETPBMSCALE=$(command -v pamscale)
if [ -x "${NETPBMSCALE}" ] ; then
    # Akceptované škálovací filtry
    FILTERS=(
    point
    box
    triangle
    quadratic 
    cubic 
    catrom 
    mitchell 
    gauss 
    sinc 
    bessel 
    hanning 
    hamming 
    blackman 
    kaiser 
    normal 
    hermite 
    lanczos
    )
    NETPBM=0
else
    exit 23
fi

#=== konec testu závislostí ===

# ### <span id="log">log()</span> ([top](#FUNCTIONS))
# Je-li použita volba `-d` nebo `--debug`, nastaví funkce [main](#main)
# do globální proměnné [$DEBUG](#$DEBUG) řetězcovou hodnotu, která určuje
# kam se budou zprávy předané této funkci posílat. Ta je tvořená řetězcem
# `-d` a číslem. Jakž bude mít toto číslo efekt viz
# [Parametry pro debug](#debug-levels).
#
# První položka, předaná této funkci jako parametr __$1__, určuje
# závažnost zprávy. Ostatní předané položky pak jsou již součástí
# vypisované zprávy.
#
#     log info "Zpráva s informativní hodnotou"
# Informační zprávy obsahují kontrolní výpisy, které informují o průběhu
# zpracování akce skriptem
#
#     log warn "Zpráva, co upozorňuje že by něco nemuselo klapnout"
# Upozorňující zprávy se používají při operacích, které mohou představovat
# problém. Kupř. když skript realizuje nevratný krok. Modelovým příkladem
# takové situace je zpracování příkazu [___delete___](#delete-command-config)
# při akci [__config__](#config), při kterém se odstraňují všechny
# konfigurační soubory pro VM, ze všech hostitelů.
#
#     log err "Zpráva, která oznamuje chybu"
# Chybové zprávy popisují stavy, které mají návratový kód __1__
#
# #### <span id="debug-levels">Parametry pro debug</span>
# Výchozí hodnota pro [$DEBUG](#$DEBUG) je __0__ při které se nevypisuje
# nic. Doporučená úroveň pro ladění skriptu je __7__. A pro normální
# použití, v případě že je skript spravován kupř. přes `cron` __5__.
#
# 1. Vypisuje pouze chybové (ERR) zprávy pouze na standardní chybový výstup
# 2. Zapisuje pouze do logu a pouze chybové (ERR) zprávy
# 3. Vypisuje chybové (ERR) zprávy na standardní výstup a zároveň je
#    zapisuje do logu
# 4. Vypisuje chybové (ERR) a varovné (WARN) zprávy pouze na standardní
#    chybový výstup
# 5. Zapisuje chybové (ERR) a varovné (WARN) zprávy pouze do logu
# 6. Zapisuje chybové (ERR) a varovné (WARN) zprávy na standardní výstup
#    a zároveň je zapisuje do logu
# 7. Vypisuje všechny zprávy pouze na standardní chybový výstup
# 8. Zapisuje všechny zprávy pouze do logu
# 9. Vypisuje všechny zprávy na standardní výstup a zároveň je zapisuje do logu
#
# #### Kde se rozhodně nesmí použít parametr $DEBUG
# Parametr $DEBUG rozhodně nepoužívejte tam, kde se musí zavolat akce na
# vzdáleném stroji přes $SSH a navrácený výstup se má dále zpracovávat.
# Problém spočívá v tom, že SSH s parametrem -t, které se používá pro
# interaktivní práci, přetočí chybový výstup na standardní výstup a tím
# pádem se může vrátit neplatný výsledek.
#
# Typickým příkladem budiž volání akce master. Je-li zavoláno s parametrem
# DEBUG, je výsledek pro další zpracování nepoužitelný!
#
#      local MASTER=$($0 ${DEBUG} master ${PROCESS})
#
# Správně:
#
#      local MASTER=$($0 master ${PROCESS})
#
# #### Místo zpracování ve skriptu
# Při testování je třeba vložit do vypisovaného řetězce proměnnou $LINENO
# ta vypíše číslo řádku zpracovávaného skriptu, kde se zrovna nachází
# Je-li to místo ve funkci, tak proměnná ${BASH_LINENO[0]} vypíše číslo
# řádku, ze kterého byla tato funkce zavolaná, a ve ${BASH_LINENO[1]} je uložen
# index jejího jména v poli ${FUNCNAME[@]}
log() {
    local TIMESTAMP="$(date +%T.%N)"
    local LOG="${LOGDIR}/messages"
    if [ -n "${DEBUG}" ] ; then
        case ${DEBUG} in
            -d0) ;;
            -d1) [ "${1^^}" == "ERR" ] && \
                echo -e "${TIMESTAMP} ${ACTION} ${1^^} ${FUNCNAME[1]}:${BASH_LINENO[0]} ${@:2}" >> /dev/stderr
                ;;
            -d2) [ "${1^^}" == "ERR" ] && \
                echo -e "${TIMESTAMP} ${ACTION} ${1^^} ${FUNCNAME[1]}:${BASH_LINENO[0]} ${@:2}" >> ${LOG}
                ;;
            -d3) [ "${1^^}" == "ERR" ] && \
                echo -e "${TIMESTAMP} ${ACTION} ${1^^} ${FUNCNAME[1]}:${BASH_LINENO[0]} ${@:2}" | \
                tee ${LOG} >> /dev/stderr
                ;;
            -d4) [ "${1^^}" == "ERR" ] || [ "${1^^}" == "WARN" ] && \
                echo -e "${TIMESTAMP} ${ACTION} ${1^^} ${FUNCNAME[1]}:${BASH_LINENO[0]} ${@:2}" >> /dev/stderr
                ;;
            -d5) [ "${1^^}" == "ERR" ] || [ "${1^^}" == "WARN" ] && \
                echo -e "${TIMESTAMP} ${ACTION} ${1^^} ${FUNCNAME[1]}:${BASH_LINENO[0]} ${@:2}" >> ${LOG}
                ;;
            -d6) [ "${1^^}" == "ERR" ] || [ "${1^^}" == "WARN" ] && \
                echo -e "${TIMESTAMP} ${ACTION} ${1^^} ${FUNCNAME[1]}:${BASH_LINENO[0]} ${@:2}" | \
                tee ${LOG} >> /dev/stderr
                ;;
            -d7) echo -e "${TIMESTAMP} ${ACTION} ${1^^} ${BASH_LINENO[0]}:${FUNCNAME[1]}()\t${@:2}" >> /dev/stderr
                ;;
            -d8) echo -e "${TIMESTAMP} ${ACTION} ${1^^} ${FUNCNAME[1]}:${BASH_LINENO[0]} ${@:2}" >> ${LOG}
                ;;
            -d9) echo -e "${TIMESTAMP} ${ACTION} ${1^^} ${FUNCNAME[1]}:${BASH_LINENO[0]} ${@:2}" | \
                tee ${LOG} >> /dev/stderr
                ;;
            *) help_debug && exit 1
                ;;
        esac
    fi
}
# <span id="help_debug" /> ([top](#FUNCTIONS))
help_debug() {
    echo """Chybné nastavení pro debug –> $1"""
    help verbose
}

# ### <span id="anone">anone()</span> ([top](#FUNCTIONS))
# Ověřovací funkce.
# V případě, že se lze pokračovat v realizaci akce vrací __0__,
# v opačném případě __1__.
anone() {
    if [ -n "${1}" ] ; then
        if [ "${FORCE}" != "yes" ] ; then
            echo "$1" >> /dev/stderr
            while true ; do
#                read -p "(ANO/NE) : " yn
                read -er yn
                case $yn in
                    [AaYy]*) break;;
                    [Nn]*) return 1;;
                    *) echo "Napište ANO či NE:" >> /dev/stderr ;;
                esac
            done
        fi
        return 0
    else
        log warn "anone() Not value"
        return 1
    fi
}

# ###  <span id="ant2dsed">ant2dsed()</span> ([top](#FUNCTIONS))
# Tato funkce se stará o zpracování .ant formátu do formátu .dsed
# Je opakem funkce dsed2ant
#
#    # 'shared_anno.iff' ; remove-ant
#    set-ant
#    metadata
#        Author "jméno a příjmení"
#        Exif.Image.DateTime "2017:11:27 17:05:21"
#    background #000000
#    zoom d50
# 
# A výstup takto:
#
#    # ------------------------- 
#    select "shared_anno.iff"
#    set-ant
#    (metadata (Author "jméno a příjmení") (Exif.Image.DateTime "2017:11:27 17:05:21"))
#    (background #000000 ) (zoom d50 ) 
#    .
#
ant2dsed() {
    local OK="OK –> ${line}"
    local ERR="ERR –> Chybí typ datového bloku"
    local INVALID="INVALID –> Neplatný typ datového bloku"
    local START="yes"
    while read -r line ; do
    log info "ant2dsed() –> ${line}"
        case "${line}" in
            \#+([[:blank:]])+([[:digit:]]))
                if [ -n "${START}" ] ; then
                    unset START
                else
                    case "${META}" in
                        metadata)  case "${KEYS}" in
                            '') continue ;;
                            *) printf "(${META} ${KEYS})\n" ;;
                            esac
                        ;;
                        xmp) case "${XMP}" in
                            '') continue ;;
                            *) printf "(${META} \"${XMP//\"/\\\\\"}\")\n" ;;
                            esac
                        ;;
                        maparea) echo "(${META} ${URL} ${BORDER} ${KEYS})"
                        ;;
                    esac
                    unset XMP
                    unset KEYS
                    unset BORDER
                    unset URL
                    unset META
                    printf "\n."
                fi
                printf "\n# ------------------------- \n"
                case "${line#\#+([[:blank:]])}" in
                    0*) printf "select 'shared_anno.iff' ; remove-ant\n"
                    ;;
                    *) printf "select %d\n" "${line#\#+([[:blank:]])}"
                    ;;
                esac
                printf "remove-ant ; set-ant\n"
            ;;
            \#+([[:blank:]])*) 
                if [ -n "${START}" ] ; then
                    unset START
                else
                    case "${META}" in
                        metadata)  case "${KEYS}" in
                            '') continue ;;
                            *) printf "(${META} ${KEYS})\n" ;;
                            esac
                        ;;
                        xmp) case "${XMP}" in
                            '') continue ;;
                            *) printf "(${META} \"${XMP//\"/\\\\\"}\")\n" ;;
                            esac
                        ;;
                        maparea) echo "(${META} ${URL} ${BORDER} ${KEYS})"
                        ;;
                    esac
                    unset XMP
                    unset KEYS
                    unset BORDER
                    unset URL
                    unset META
                    printf "\n."
                fi
                printf "\n# ------------------------- \n"
                local TEMPORAR="${line#\#+([[:blank:]])}"
                case "${TEMPORAR}" in
                    'shared_anno.iff'*|\
                    shared_anno.iff*|\
                    0) printf "select 'shared_anno.iff' ; remove-ant\n"
                    ;;
                    +([[:digit:]])*) printf "select %s; remove-ant\n" "${TEMPORAR%%+([[:blank:]])*}"
                    ;;
                    *)  printf "select %s; remove-ant\n" "${TEMPORAR%%#*}"
                    ;;
                esac
                printf "set-ant\n"
            ;;
            \<*) local XMP="${XMP}${line}"
            ;;
            metadata) case "${META}" in
                        metadata) case "${KEYS}" in
                            '') continue ;;
                            *) printf "(${META} ${KEYS})\n" ;;
                            esac
                        ;;
                        xmp) case "${XMP}" in
                            '') continue ;;
                            *) printf "(${META} \"${XMP//\"/\\\\\"}\")\n" ;;
                            esac
                        ;;
                        maparea) printf "(${META} ${URL} ${BORDER} ${KEYS})\n"
                        ;;
                esac
                unset XMP
                unset KEYS
                unset BORDER
                unset URL
                META='metadata'
            ;;
            maparea) case "${META}" in
                        metadata)  case "${KEYS}" in
                            '') continue ;;
                            *) printf "(${META} ${KEYS})\n" ;;
                            esac
                        ;;
                        xmp) case "${XMP}" in
                            '') continue ;;
                            *) printf "(${META} \"${XMP//\"/\\\\\"}\")\n" ;;
                            esac
                        ;;
                        maparea) echo "(${META} ${URL} ${BORDER} ${KEYS})"
                        ;;
                esac
                unset XMP
                unset KEYS
                unset BORDER
                unset URL
                META='maparea'
            ;;
            xmp) case "${META}" in
                        metadata) case "${KEYS}" in
                            '') continue ;;
                            *) printf "(${META} ${KEYS})\n" ;;
                            esac
                        ;;
                        xmp) case "${XMP}" in
                            '') continue ;;
                            *) printf "(${META} \"${XMP//\"/\\\\\"}\")\n" ;;
                            esac
                        ;;
                        maparea) printf "(${META} ${URL} ${BORDER} ${KEYS})\n"
                        ;;
                esac
                unset XMP
                unset KEYS
                unset BORDER
                unset URL
                META='xmp'
            ;;
            align+([[:blank:]])+(left|center|right)+([[:blank:]])+(top|center|bottom)|\
            background+([[:blank:]])\#[0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F]|\
            mode+([[:blank:]])+(color|bw|fore|black)|\
            pfoot+([[:blank:]])*|\
            phead+([[:blank:]])*|\
            zoom+([[:blank:]])d+([[:digit:]])|\
            zoom+([[:blank:]])+(stretch|one2one|width|page)|\
            note*)
                case "${META}" in
                        metadata)  case "${KEYS}" in
                            '') continue ;;
                            *) printf "(${META} ${KEYS})\n" ;;
                            esac
                        ;;
                        xmp) case "${XMP}" in
                            '') continue ;;
                            *) printf "(${META} \"${XMP//\"/\\\\\"}\")\n" ;;
                            esac
                        ;;
                        maparea) echo "(${META} ${URL} ${BORDER} ${KEYS})"
                        ;;
                esac
                printf "($line) "
                unset XMP
                unset KEYS
                unset BORDER
                unset URL
                unset META
            ;;
            +([[:digit:]])+([[:blank:]])*)
                echo "Klíč tvořený pouze číslem není přípustný –> ${line}" >> /dev/stderr
                return 1
            ;;
            [[:digit:]]+([[:alnum:]])+([[:blank:]])\"*) #/ klíč začínající číslem sice sežere, ale nezobrazí
                echo "Klíč začínající číslem není přípustný –> ${line}" >> /dev/stderr
                return 1               
            ;;
            url+([[:blank:]])\"*\"+([[:blank:]])\"*\")
                [ -n "${META}" ] || echo "${ERR}" >> /dev/stderr
                [ -n "${URL}" ] && echo "URL už je nastaveno!" >> /dev/stderr && return 1
                local TEMPORAR=(${line})
                if [ ${#TEMPORAR[@]} -eq 4 ] ; then
                    local URL="(${line[0]} ${line[1]} ${line[2]}) ${line[3]}"
                else
                    echo "Neplatné nastavení URL –> ${line}"
                    return 1
                fi
            ;;
            \"*\"+([[:blank:]])\"*\")  #maparea bez URL
                [ -n "${META}" ] || echo "${ERR}" >> /dev/stderr
                [ -n "${URL}" ] && echo "URL už je nastaveno!" >> /dev/stderr && return 1
                local URL="${line}"
            ;;
            +(rect|oval|poly|line|text)+([[:blank:]])+([[:digit:]])+([[:blank:]])+([[:digit:]])+([[:blank:]])+([[:digit:]])+([[:blank:]])+([[:digit:]])*)
                [ -n "${META}" ] || echo "${ERR}" >> /dev/stderr
                [ -n "${BORDER}" ] && echo echo "BORDER už je nastaveno! –> ${BORDER}" >> /dev/stderr && return 1
                local BORDER="(${line}) "
            ;;
            #shadow_*) # stínování - číslem uvedená tloušťka
            #;;
            #hilite+([[:blank:]])\#+([[:digit:]])) # barva vysvícení
            #;;
            pushpin) # špendlík
                [ -n "${META}" ] || echo "${ERR}" >> /dev/stderr
                [ "${META}" == "maparea" ] || echo "${INVALID}" >> /dev/stderr
                [ -n "${BORDER}" ] || echo "${ERR}" >> /dev/stderr
                case "${BORDER%% *}" in
                    \(text) local KEYS="${KEYS} (${line})"
                    ;;
                    *) echo "Atribut pushpin lze použít pouze je-li maparea typu text –> ${BORDER}" >> /dev/stderr
                        return 1
                    ;;
                esac
            ;;
            arrow) # šipka
                [ -n "${META}" ] || echo "${ERR}" >> /dev/stderr
                [ "${META}" == "maparea" ] || echo "${INVALID}" >> /dev/stderr
                [ -n "${BORDER}" ] || echo "${ERR}" >> /dev/stderr
                case "${BORDER%% *}" in
                    \(line) local KEYS="${KEYS} (${line})"
                    ;;
                    *) echo "Atribut arrow lze použít pouze u typu 'line' proto se u ostaních typů ignoruje –> ${BORDER}." >> /dev/stderr
                    ;;
                esac
            ;;
            border_avis)
                [ -n "${META}" ] || echo "${ERR}" >> /dev/stderr
                [ "${META}" == "maparea" ] || echo "${INVALID}" >> /dev/stderr
                [ ! -n "${BORDER}" ] && echo "Nejprve musí být nastavena oblast!" >> /dev/stderr
                case "${BORDER%% *}" in
                    \(line) echo "Atribut border_avis typ 'line' nepoužívá, proto při importu ignoruje." >> /dev/stderr
                    ;;
                    *) local KEYS="${KEYS} (${line})"
                    ;;
                esac
            ;;
            xor|none)
                [ -n "${META}" ] || echo "${ERR}" >> /dev/stderr
                [ "${META}" == "maparea" ] || echo "${INVALID}" >> /dev/stderr
                [ ! -n "${BORDER}" ] && echo "Nejprve musí být nastavena oblast!" >> /dev/stderr
                local KEYS="${KEYS} (${line})"
            ;;
            +(opacity|width|shadow_+(in|out|ein|eout))+([[:blank:]])+([[:digit:]]))
                [ -n "${META}" ] || echo "${ERR}" >> /dev/stderr
                [ "${META}" == "maparea" ] || echo "${INVALID}" >> /dev/stderr
                [ ! -n "${BORDER}" ] && echo "Nejprve musí být nastavena oblast!" >> /dev/stderr
                local KEYS="${KEYS} (${line})"
            ;;
            +(backclr|textclr|line_clr|lineclr|border|hilite)+([[:blank:]])\#[0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F])
                [ -n "${META}" ] || echo "${ERR}" >> /dev/stderr
                [ "${META}" == "maparea" ] || echo "${INVALID}" >> /dev/stderr
                [ ! -n "${BORDER}" ] && echo "Nejprve musí být nastavena oblast!" >> /dev/stderr
                local KEYS="${KEYS} (${line})"
            ;;
            '') #echo "Prázdný řádek - vypíše položku a vypne přechozí volbu"
                if [ "${META}" == "metadata" ] ; then
                    echo -e "(${META} ${KEYS})\n"
                    unset META
                    unset XMP
                    unset KEYS
                    unset BORDER
                    unset URL
                elif [ "${META}" == "xmp" ] ; then
                    echo -e "(${META} \"${XMP//\"/\\\\\"}\")\n"
                    unset META
                    unset XMP
                    unset KEYS
                    unset BORDER
                    unset URL
                elif [ "${META}" == "maparea" ] ; then
                    echo -e "(${META} ${URL} ${BORDER} ${KEYS})\n"
                    unset META
                    unset XMP
                    unset KEYS
                    unset BORDER
                    unset URL
                fi
            ;;
            \;*) #/ komentáře
            ;;
            +([[:alpha:]])+([[:alnum:]])+([[:blank:]])\"*\") #/ Metadatové klíče
                [ -n "${META}" ] || echo "${ERR}" >> /dev/stderr
                local KEYS="${KEYS} (${line})"
            ;;
            +([[:alpha:]])+([[:blank:]])\"*\") #/ Metadatové klíče
                [ -n "${META}" ] || echo "${ERR}" >> /dev/stderr
                local KEYS="${KEYS} (${line})"
            ;;
            *) echo "Na řádku je chyba –> #${line}#" >> /dev/stderr
                return 1
            ;;
        esac
    done < $1
    printf "\n.\n"
}

# ###  <span id="dsed2ant">dsed2ant()</span> ([top](#FUNCTIONS))
# Tato funkce se stará o zpracování streamu v .dsed formátu do formátu .ant
# Je opakem funkce ant2dsed(). Vstup vypadá takto:
#
#    # ------------------------- 
#    select "shared_anno.iff"
#    set-ant
#    (metadata (Author "jméno a příjmení") (Exif.Image.DateTime "2017:11:27 17:05:21"))
#    (background #000000 ) (zoom d50 ) 
#    .
# 
# A výstup takto:
#
#    # 'shared_anno.iff' ; remove-ant
#    set-ant
#    metadata
#        Author "jméno a příjmení"
#        Exif.Image.DateTime "2017:11:27 17:05:21"
#    background #000000
#    zoom d50
#
dsed2ant() {
    sed 's/\t/\n/g ; s/(/\n(/g ; s/("/\n\t"/g ; ' | grep -v ^$ | \
    sed '/^(m[ea][tp]a[dr][ae][ta]/! s/^(/\t(/ ; /^\t($/d ; s/) ) )/) )/ ; s/\\/\\\\0/g ; s/</\n</g' | \
    while read line ; do
        #/echo "zpracovávám ${line}" >> /dev/stderr
        case ${line} in
            \(metadata) echo -e "metadata"
                local TAB=""
            ;;
            \(xmp*) echo -e "xmp"
                local XMP="y"
                local TAB="\t"
            ;;
            \(maparea+([[:blank:]])\") echo -e "\n"
                local TAB="\t"
            ;;
            \(note+([[:blank:]])\"*) local TEMPORAR="${line#(}"
                echo -e "${TEMPORAR%\)}"
                unset TEMPORAR
                unset TAB
            ;;
            set-ant|set-txt)
            ;;
            *) if [ "${TAB}" == "\t" ] ; then
                    case "${line:0:2}" in
                        "(u") local TEMPORAR="${line#(}"
                            echo "maparea"
                            echo -e "${TAB}${TEMPORAR//\) /}"
                            unset TEMPORAR
                        ;;
#                        \#*) echo -n "# "
#                            unset TAB
#                        ;;
                        *) if [ -n "${XMP}" ] ; then
                                case "${line: -2}" in
                                    \"\)) local LINE="${line%>*}>"
                                        echo -e "${TAB}${LINE}" | sed 's/\x00//g'
                                        unset XMP
                                        unset LINE
                                    ;;
                                    *) local LINE="${line}"
                                        # local LINE=$(echo "${line}" | decode)
                                        echo -e "${TAB}${LINE}" | sed 's/\x00//g'
                                        unset LINE
                                    ;;
                                esac
                            else
                                local TEMPORAR="${line#(}"
                                echo -e "${TAB}${TEMPORAR// \)/}"
                                unset TEMPORAR
                            fi
                        ;;
                    esac
                else
                    local TEMPORAR="${line//[)(]/}"
                    case "${TEMPORAR}" in
                        maparea*) echo -e "${TEMPORAR/ /\\\n\\\t}"
                            unset TEMPORAR
                        ;;
                        background*|zoom*|mode*|align*|phead*|pfoot*)
                            #local TEMPORAR="${line#(}"
                            #echo -e "${TEMPORAR// \)/}"
                            echo "${TEMPORAR}"
                            unset TEMPORAR
                            unset TAB
                        ;;
                        \#*) echo -n "# "
                            unset TAB
                        ;;
                        select*) echo "${TEMPORAR}"
                        ;;
                        *) echo -e "\t${TEMPORAR}"
                            unset TEMPORAR
                        ;;
                    esac
                fi
            ;;
        esac
    done  | sed 's/) )/)/ ; /^$/d '
}

# ### <span id="printoutline">printoutline()</span> ([top](#FUNCTIONS))
# V původní podobě byl výsledek zapsán do souboru s příponou .outline
# Využívá se při akcích export a edit
# $1 - DjVu file
# $2 - cíl
printoutline() {
    log goto "printoutline() $1 –> $2"
    bookmarktooutline "${1}"
    return 0
    # bookmarktooutline "${1}" | awk '{print i++ "\t|" $0}'
}

# ### <span id="writefile">writefile()</span> ([top](#FUNCTIONS))
# Funkce průběžně konvertuje stream unicode znaků do jejich číselné podoby
# Velmi důležitá funkce!!! Využívá se při akcích outline, import a edit.
writefile() {
    if [ -t 0 ]; then
        log info "writefile() Empty stdin"
        return 1
    else
        tee $1 >> /dev/null
        return 0
    fi
}

# ### <span id="xmlimport">xmlimport()</span> ([top](#FUNCTIONS))
# Funkce zajišťuje import obsahu skryté textové vrstvy DjVu souborů z
# DjVuXML formátu
xmlimport() {
    [ ! -n "${XMLLINT}" ] && return 1
    log goto "$1 –> $2"
    local RANGE=$(isrange "${2}")
    if [ ! -n "${RANGE}" ] ; then
        # / může být seznam stránek ZA KTERÝM není nic
        # oddělit PATTERN od seznamu
        case "${2//+([[:blank:]])/}" in
            '') # jenom příkaz
                echo "Nebylo nic předáno ${2}" >> /dev/stderr
                return 1
                #local PAGES=($(range "0-${#LISTPAGES[@]}"))
            ;;
            *) # seznam stránek oddělených čárkou

                mapfile -t ARRAY <<< $($0 "${1}" info list)
                case "${ARRAY:0:1}" in
                    0) mapfile -t LISTPAGES <<< $(printf "%s\n" "${ARRAY[@]}")
                    ;;
                    *) LISTPAGES="0 none"
                        mapfile -O 1 -t LISTPAGES <<< $(printf "%s\n" "${ARRAY[@]}")
                    ;;
                esac

                local IFS_BAK=$IFS
                local IFS=$','
                local SEZNAM=($2)
                local IFS=$IFS_BAK
                for i in "${LISTPAGES[@]}" ; do
                    if [[ "${SEZNAM[@]}" =~ "${i##+([[:digit:]])+([[:blank:]])}" ]] ; then
                        echo "Stránka ${i}" >> /dev/stderr
                        local TEMP="$TEMP${i%% *} "
                    fi
                    x=$((x + 1))
                done
                local PAGES=($TEMP)
                local STRING="${2##*.djvu+([[:blank:]])}"
            ;;
        esac
    else
        local STRING="${2#*${RANGE}+([[:blank:]])}"
        [ ! -n "${STRING}" ] && return 1
        local PAGES=($(range "${RANGE}"))
    fi

    local XMLFILE=$(${REALPATH} -m -P "${STRING}")
    if [ -f "${XMLFILE}" ] ; then
        local XML=$(grep -b DjVuXML "${XMLFILE}" 2>/dev/null)
        [ ! -n "${XML}" ] && echo "Vstupní soubor není DjVuXML –> ${XML}" >> /dev/stderr && return 1
    else
        echo "Nebyl předán žádný DjVuXML soubor" >> /dev/stderr
    fi

    SUMPAGE=$(grep \<OBJECT "${XMLFILE}" | wc -l)
    local CONTENTFILE=$(tempfile -d ${TEMPDIR} -s .content)
    $0 "${1}" info list > "${CONTENTFILE}"
    [ -z ${SUMPAGE} ] && echo "Soubor ${XMLFILE} neobsahuje žádné stránky" >> /dev/stderr && return 1
    for i in $(range "1-${SUMPAGE}") ; do
        local OBJECTNAME=$(xmllint --xpath 'string (//OBJECT['$i']/@usemap)' "${XMLFILE}")
        local PAGENAME=$(grep "${OBJECTNAME}" ${CONTENTFILE})
        if [[ "${PAGES[@]}" =~ "${PAGENAME%%+([[:blank:]])*}" ]] ; then
            echo "Stránka ${PAGENAME} má objekt" >> /dev/stderr
            local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .xml)
            ${XMLLINT} --xpath '//OBJECT['$i']' "${XMLFILE}" > "${TEMPFILE}"
            case ${DEBUG} in
                -d1|-d3|-d4|-d6|-d7|-d9) cat "${TEMPFILE}" >> /dev/stderr
            esac
            local H=$(${XMLLINT} --xpath 'string(//@height)' "${TEMPFILE}")
            local W=$(${XMLLINT} --xpath 'string(//@width)' "${TEMPFILE}")
            local DPI=$(${XMLLINT} --xpath 'string(//@value[1])' "${TEMPFILE}")
            log info "${OBJECTNAME} ${H} ${W} ${DPI}"
            ${DJVUMAKE} "${TEMPDIR}/temp.djvu" INFO=${W},${H},${DPI} 2>/dev/null
            local NEXTFILE=$(tempfile -d ${TEMPDIR} -s .xml)
            local DSEDFILE=$(tempfile -d ${TEMPDIR} -s .dsed)
            (
echo '''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE DjVuXML PUBLIC "-//W3C//DTD DjVuXML 1.1//EN" "pubtext/DjVuXML-s.dtd">
<DjVuXML>
<HEAD>file://localhost/home/want/a.djvu</HEAD>
<BODY>
<OBJECT data="file:///temp.djvu" type="image/x.djvu" height="'''${H}'''" width="'''${W}'''" usemap="temp.djvu" >
<PARAM name="DPI" value="'''${DPI}'''" />
<PARAM name="GAMMA" value="2.200000" />
<PARAM name="PAGE" value="temp.djvu" />
<PARAM name="background" value="#FF0000" />'''
            ${XMLLINT} --xpath '//HIDDENTEXT' "${TEMPFILE}"
echo '''</OBJECT>
<MAP name="temp.djvu" >
</MAP>
</BODY>
</DjVuXML>
'''
            ) > ${NEXTFILE}
            ${DJVUXMLPARSER} -o "${TEMPDIR}/temp.djvu" ${NEXTFILE}
            echo "select '${OBJECTNAME}' ; remove-txt" > ${DSEDFILE}
            ${DJVUSED} "${TEMPDIR}/temp.djvu" -e 'select 1; output-txt' >> ${DSEDFILE}
            if [ -n "${DIFF}" ] ; then
                echo "Pokud máte nainstalovaný vim, můžete se ještě přes realizací změn podívat, v čem se bude nový obsah stránky lišit od stávajícího." >> /dev/stderr
                echo "V případě, že v obsahu nebude rozdíl, neozobrazí se nic! Aplikaci vimdiff ukončíte tím, že napíšete :qa" >> /dev/stderr
                anone "Chcete si prohlédnout změny?" >> /dev/stderr
                if [ ! $? -eq 1 ] ; then
                    ${DJVUTOXML} --page $i "${1}" | ${XMLLINT} --xpath '//HIDDENTEXT' - | perl -C -MHTML::Entities -pe 'decode_entities($_);' &>>  "${TEMPDIR}/orig.xml"
                    ${XMLLINT} --xpath '//HIDDENTEXT' "${TEMPFILE}" | perl -C -MHTML::Entities -pe 'decode_entities($_);' >> "${TEMPDIR}/new.xml"
                    vimdiff -c 'set encoding=utf-8' "${TEMPDIR}/orig.xml" "${TEMPDIR}/new.xml"
                fi
            fi
            anone "Objekt ${OBJECTNAME} ze souboru ${XMLFILE} nahradí v souboru ${1} text strany č. $i, ignorovat změny?" >> /dev/stderr
            if [ $? -eq 1 ] ; then
                ${DJVUSED} "${1}" -f ${DSEDFILE} -s
                echo -n "Vyčkejte než bude dokončeno ověření zbylých stránek DjVuXML souboru :" >> /dev/stderr
            else
                continue
            fi
        else
            echo -ne "\r$i" >> /dev/stderr
        fi
    done
    echo -e "\rHotovo!" >> /dev/stderr
    return 0
}

# ### <span id="decode">decode()</span> ([top](#FUNCTIONS))
# Funkce průběžně konvertuje číselnou podobu unicode znaků ve streamu  do UTF-8
# Velmi důležitá funkce!!!
decode() {
    sed 's/\\/\\0/g' | tr '\000' '\\'
}

# ### <span id="encode">encode()</span> ([top](#FUNCTIONS))
# Funkce průběžně konvertuje stream unicode znaků do jejich číselné podoby
# Velmi důležitá funkce!!!
encode() {
    while read -n 1 a
    do
    CHAR=($( echo "$a" | od -A n -t c ))
    if [ "${#CHAR[@]}" -gt "2" ] ; then 
        echo -n "\\${CHAR[0]}\\${CHAR[1]}"
    elif [ "${#CHAR[@]}" == "1" ] ; then 
        echo -n " "
    else
        if [ "${#CHAR[0]}" == "0" ] ; then
            echo -n " "
        else
            echo -n "${CHAR[0]}"
        fi
    fi
    done
}

# ### <span id="encodefile">encodefile()</span> ([top](#FUNCTIONS))
# Konvertuje bitmapový soubor v PAM formátu, předaný jako __$1__ do
# DjVu souboru __$2__
# Základním předpokladem je, že pro tento PAM soubor (s příponou `.pam`)
# existuje minimálně jeden soubor ve formátu PBM pro vygenerování masky.
#
# Přednost má přitom soubor s příponou `.text`, který (pokud existuje)
# obsahuje vyseparované textové bloky.
#
# V případě že neexistuje, je automaticky vyžadován soubor s příponou
# `.fore`, který byl vygenerován funkcí [separatemask](#separatemask)
encodefile() {
    log goto "encodefile() Use $1 –> $2"
    if [ -f "${1/.pam/.text}" ] ; then
        ${CJB2} -lossy -clean "${1/.pam/.text}" "${1}.mask";
    else
        ${CJB2} -lossy -clean "${1/.pam/.fore}" "${1}.mask";
    fi
    ${DJVUMAKE} "${2}" Sjbz="${1}.mask" PPM="${1}";
}

# ### <span id="separatemask">separatemask()</span> ([top](#FUNCTIONS))
# Z bitmapového souboru ve formátu PAM, který je předán jako __$1__
# generuje černobílou masku __$2__ ve formátu PBM.
# Jako parametr __$3__ se předává buď algoritmus s parametry, nebo hodnota
# `none` s nastavením prahové hodnoty
#
# shading-subtraction - k od 3 (málo šumu) do 12 (hodně šumu),
# šum lze odstranit nastavením prahu (hodnota float)
# Výsledek je přesně opačný než při nastavení prahu - čím vyšší hodnota,
# tím míň toho proleze
separatemask() {
    log goto "separatemask() Use $3 for $1 –> $2"
    case "${3%:*}" in
        none) if [ "${3#*:}" == "none" ] ; then
                log info "${PAMTOPNM} ${1} | ${PPMTOPGM} | ${PGMTOPBM} -threshold -value 0.5 | ${PNMTOPLAINPNM} > ${2}"
                ${PAMTOPNM} ${1} | ${PPMTOPGM} | ${PGMTOPBM} -threshold -value 0.5 | ${PNMTOPLAINPNM} > ${2}
            else
                log info "${PAMTOPNM} ${1} | ${PPMTOPGM} | ${PGMTOPBM} -threshold -value 0.${3#*:} | ${PNMTOPLAINPNM} > ${2}"
                ${PAMTOPNM} ${1} | ${PPMTOPGM} | ${PGMTOPBM} -threshold -value 0.${3#*:} | ${PNMTOPLAINPNM} > ${2}
            fi
            while [ ! -f "${2}" ] ; do
                sleep 0.1
            done
        ;;
        *) if [ -f "${HOME}/.config/${NAME}/${3}.conf" ] ; then
                local PARAMS=$(grep -v '^#' "${HOME}/.config/${NAME}/${3}.conf" | awk '{print "--param", $1}' | tr '\n' ' ')
            fi
            if [[ "${3}" =~ ":" ]] ; then
                local TEMPORAR="${3#*:}"
                local PARAMS=$(printf "xxx %s" ${TEMPORAR//,/ })
            fi
            ${DIDJVU} separate -o "${2}.png" ${LEVEL} -m "${3%:*}" ${PARAMS//xxx/ -x} "${1}"
            while [ ! -f "${2}.png" ] ; do
                sleep 0.1
            done
            pngtopam "${2}.png" > "${2}"
        ;;
    esac
    return $?
}

# ### <span id="bookmarktooutline">bookmarktooutline()</span> ([top](#FUNCTIONS))
# Funkce zpracovává záložky z DjVu souboru do formátu s odsazením
bookmarktooutline() {
    local TARGET="$1"
    local BEGIN=""
    local TAB=0
    ${DJVUSED} "${1}" -e 'print-outline' | sed -n '
    s|(|\n(\n|g
    s|)|\n)\n|g
    s|\\|\\\\0|g
    p
    ' |	while read y
    do
        case "$y" in
            \)) local TAB=$((TAB - 1))
            ;;
            \() local TAB=$((TAB + 1))
            ;;
            \"*) if [ "${BEGIN}" == "" ] ; then
                    local TEXT="$y"
                    local BEGIN="yes"
                else
                    for i in $(seq $((TAB-2))) ; do echo -en '\t' ; done
                    echo -e "${TEXT} ${y}"
                    local BEGIN=""
                fi
            ;;
        esac
    done
}

# ### <span id="outlinetodjvu">outlinetodjvu()</span> ([top](#FUNCTIONS))
# Funkce převádí obsah .outline souboru na formát .dsed
# a výsledek zapisuje do djvu souboru
# $1 - DjVu file
# $2 - soubor ve formátu .outline
outlinetodjvu() {
    log goto "outlinetodjvu() From $2 into $1"
    local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .bookmarks)
    if [ -f "${2}" ] ; then
        outlinetodsed "${2}" | encode > "${TEMPFILE}"
        ${DJVUSED}  "${1}" -e "set-outline ${TEMPFILE}; save"
    else
        log err "outlinetodjvu() Not any outline file"
        return 1
    fi
    return $?
}

# ### <span id="outlinetodjvu">outlinetodjvu()</span> ([top](#FUNCTIONS))
# Funkce převádí obsah ve formátu .outline na formát .dsed
# $1 - .outline file with TAB syntax
# Output is txt stream
outlinetodsed() {
    local TARGET="$1"
    # Remove comment from .outline file
    sed --in-place '/^#/d ; /^;/d' "${TARGET}"
    [ $(grep -c ^ "${TARGET}") -eq "0" ] && return 1
    local LEVEL="1"
    IFS=''
    echo -n "(bookmarks "
    CONTENT=$(sed '
        s/\ \ \ \ /\t/g
        s/^/\t/
        ' "${TARGET}" | while read line ; do
        local SPACE="${line%%\"*}"
        if [ "${#SPACE}" -gt "${LEVEL}" ] ; then
            local PREV="${PREV%)} ( ${line} )"
            local LEVEL=$((${LEVEL} + 1))
        elif [ "${#SPACE}" -eq "${LEVEL}" ] ; then
            local PREV="${PREV} ( ${line} )"
        elif [ "${#SPACE}" -lt "${LEVEL}" ] ; then
            local ROZDIL=$((${LEVEL} - ${#SPACE}))
            local ZAV=$(seq  -f "%1.0f" -s '' ${ROZDIL})
            local PREV="${PREV} ${ZAV//[[:digit:]]/)} ( $line )"
            local LEVEL=$((${LEVEL} - ${ROZDIL}))
        fi
        echo "${PREV}"
        echo "-----${LEVEL}"
    done | sed 's/\t/\ /g' | tail -2)
    TEST="${CONTENT##*-----}"
    echo -n "${CONTENT%-----*}"
    local ZAV=$(seq  -f "%1.0f" -s '' ${TEST})
    echo "${ZAV//[[:digit:]]/)}"
    return 0
}

function getocr {
    log goto "getocr() OCR ${OCR} –> ${1}"
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	if [ "${OCR}" ] ; then
		${OCRODJVU} --in-place -l "${OCR}" "${SOURCE}"
		[ "$?" ] && log info "getocr() OCR was applicated on ${FILE}" 
	fi
}

# ### <span id="mimefile">mimefile()</span> ([top](#FUNCTIONS))
# Function return type file by MIME
#
# $1 - jméno testovaného souboru se kterým se pracuje
mimefile() {
    local SOURCE=$(${REALPATH} -m -P "${1}")
    local FILE="${SOURCE##*/}"
    if [ -f "${SOURCE}" ] ; then
        local TYPE=$(${MIME} -dbM "${SOURCE}" | awk '{print $1}')
    else
        log err "File ${1} is NOT valid."
        return 1
    fi
    log info "${1} –> ${TYPE,,}"
    echo "${TYPE,,}"
    return 0
}

# ### <span id="isbundle">isbundle()</span> ([top](#FUNCTIONS))
# Function for test type file. For DjVu bundle (0), single (1), or another (1)
# $1 - file path
isbundle() {
    if [ $(mimefile "${1}") == "djvu" ] ; then
        ${DJVM} -l "${1}" &>/dev/null
        [ $? -eq 1 ] && log info "${1} –> DjVu single file" && return 2
    else
        log err "${1} –> NOT DjVu file"
        return 1
    fi
    log info "${1} –> DjVu bundle file"
    return 0
}

# ### <span id="istarget">istarget()</span> ([top](#FUNCTIONS))
# Funkce nastavuje TARGETDIR a TARGETSAMPLE
istarget() {
    log goto "istarget() –> $1"
    case "${1:$((${#1}-1)):1}" in
        /) TARGETSAMPLE="ORIGINAL"
            TARGETDIR=$(${REALPATH} -m -P "${1}")
            log info "targets() Export pages with a original names into –> ${TARGETDIR}"
            [ ! -d "${TARGETDIR}" ] && mkdir -p "${TARGETDIR}"
        ;;
        *) if [[ "${1}" =~ "/" ]] ; then
                #/ obsahuje cestu
                local TEMPORARY=$(${REALPATH} -m -P "${1}")
                TARGETDIR="${TEMPORARY%/*}"
                TARGETSAMPLE="${TEMPORARY##*/}"
                log info "targets() Export pages a named by sample ${TARGETSAMPLE} –> ${TARGETDIR}"
                [ ! -d "${TARGETDIR}" ] && mkdir -p "${TARGETDIR}"
            else
                #/ jde o vzorek
                TARGETDIR="$(pwd)/"
                TARGETSAMPLE="${1}"
                log info "targets() Export pages a named by sample ${TARGETSAMPLE} into actual directory"
            fi
        ;;
    esac
    return 0
}

# ### <span id="isrange">isrange()</span> ([top](#FUNCTIONS))
# Testuje, jestli předaný řetězec __$1__ nezačíná rozsahem (RANGE).
isrange() {
    local PARAMS=($1)
    case "${PARAMS[0]}" in
        +([0-9\-,]))
            log info "OK range –> ${PARAMS[0]}"
            echo "${PARAMS[0]}"
            ;;
        *) log info "NOT range –> ${PARAMS[0]}"
            return 1
            ;;
    esac
    return 0
}

# ### <span id="isscale">isscale()</span> ([top](#FUNCTIONS))
# Zjišťuje, zda-li předaný řetězec začíná kódem podporovaného formátu
isformat() {
    log goto "isformat() string –> $1"
    local PARAMS=($1)
    case "${PARAMS[0]}" in
        all)  #/ Volba pro DjVu
            #/ Vyexportuje všechno
            ;;
        ant) #/ Volba pro DjVu
            #/ Poznámky
            ;;
        note)  #/ Volba pro DjVu
            #/ export skrytých poznámek
            ;;
        xmp)  #/ Volba pro DjVu
            #/ export XMP kódu
            ;;
        ocr) #/ Volba pro DjVu
            #/ aplikace OCR
            ;;
        meta) #/ Volba pro DjVu
            ;;
        line|word|para) #/ Volby pro djvutxt
            ;;
        outline) #/ Volba pro DjVu
            #/ Obsah
            ;;
        bookmark) #/ Volba pro DjVu
            #/ Záložky
            ;;
        dsed*) #/ Volba pro DjVu
            #/ Export textové vrstvy v dsed formátu
            #/ dsed-ant
            #/ dsed-all
            #/ dsed-txt
            ;;
        djvu) #/ Bitmapový soubor bude konvertován do djvu
            #/ U DjVu souboru budou vyexportované stránky složené opět
            #/ do DjVu souboru
            ;;
        txt|text) #/ V případě DjVu či PDF souborů bude exportován text
            #/ V ostatních případech se stránka prožene přes OCR
            ;;
        image*) #/ akceptováno u PDF a DjVu
            #/ Výsledkem exporu bude obrázek stránky (u DjVu) nebo extrahované
            #/ obrázky z PDF
            ;;
        orig*) #/ původní formát
            ;;
        jpg|jpeg|jp2)
            ;;
        pnm|pam|pbm)
            ;;
        mask|black|background|foreground|color) #/ Typ exportované obrazové vrstvy
            ;;
        xcf|gimp)
            ;;
        xml) #/ Volba pro DjVu
            #/ export XML vrstvy
            #/ xml-ant
            #/ xml-all
            #/ xml-txt
            ;;
        *) return 1
            ;;
    esac
    log value "isformat() OK –> ${PARAMS[0]}"
    echo "${PARAMS[0]}"
    return 0
}

# ### <span id="parsecut">parsecut()</span> ([top](#FUNCTIONS))
# Parsuje předaný řetězec, který můře být buď ve formě:
# * LEFT,TOP,SIRKA,VYSKA
# * SIRKAxVYSKA+LEFT+TOP
#
# a vrací hodnoty v daném pořadí: W H X Y
#
# * W - (weight) šířka boxu
# * H - (height) výška boxu
# * X - horizontální vzdálenost od levého okraje
# * Y - vertikální vzdálenost od horního okraje
parsecut() {
    log goto "parsecut() $1"
    case ${1} in
                +([0-9])x+([0-9])|+([0-9])x+([0-9])[+]+([0-9])[+]+([0-9]))
                    local W="${1%%x*}"
                    local TEMPORAR="${1#*x}"
                    local H="${TEMPORAR%%+*}"
                    local TEMPORAR="${1#*+}"
                    local X="${TEMPORAR%+*}"
                    local Y="${1##*+}"
                ;;
                +([0-9]),+([0-9]),+([0-9]),+([0-9]))
                    local TEMPORAR=( ${1//,/ } )
                    local X="${TEMPORAR[0]}"
                    local Y="${TEMPORAR[1]}"
                    local W="${TEMPORAR[2]}"
                    local H="${TEMPORAR[3]}"
                ;;
                *) echo "Neplatné nastavení pro cut –> ${1}" >> /dev/stderr
                    return 1
                ;;
    esac
    echo "$W $H $X $Y"
}

# ### <span id="cutimg">cutimg()</span> ([top](#FUNCTIONS))
# Funkce zpracovává řetězec, kterým je identifikována oblast vyžadující
# speciální ošetření. Ta může být nastavena dvěma možnými způsoby:
# LEFT,TOP,SIRKA,VYSKA nebo SIRKAxVYSKA+LEFT+TOP
# Za tímto řetězcem může následovat dvojtečka, která specifikuje typ rámce
# T - vymezená textová oblast se nakopíruje na prázdnou plochu `.text`
# I - vymezená oblast bude na masce `.fore` začerněná
# M - vymezená oblast bude na masce `.fore` zabílená
# G - grafika (čáry a linky)
# bez specifikace typu rámce se předpokládá že se má "zamaskovat" obrázek
#
# Pro zjištění souřadnic lze použít kupř. geeqie Zobrazit –> Zobrazit informace o pixelech
#
# Pro nastavení oblastí lze použít i nástroj djvusmooth, ale souřadnice se musí přepočítat
# rect 225 0 804 61
#     LEFT,BOTTOM, LEFT+WIDTH,HEIGHT
cutimg() {
    log goto "cutimg() $1 –> $2"
    local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .pam)
    local SIZE=(${1/:/ })
    local W=($(parsecut ${SIZE[0]}))
    [ $? -eq 1 ] && return 1
    if [ "${W[0]}" -eq "0" ] || [ "${W[1]}" -eq "0" ] || [ "${W[0]:0:1}" == "-" ] || [ "${W[1]:0:1}" == "-" ] ; then
        echo "${W[2]},${W[3]},[1m${W[0]}[0m,[1m${W[1]}[0m –> Šířka a výška plochy musí mít nenulovou velikost" >> /dev/stderr
        return 1
    fi
    local Y="${W[3]}"
    local X="${W[2]}"
    local H="${W[1]}"
    local W="${W[0]}"
    log info "cutimg W $W H $H X $X Y $Y"
    local FILENAME="${2%.*}"
    case ${#SIZE[@]} in
        1) #/ Vyjme vybranou oblast za černou plochu
            ${PBMMAKE} -black ${W} ${H} > ${TEMPFILE}
            log info "cutimg() ${FILENAME}.fore –> ${FILENAME}.temp"
            ${PAMTOPNM} "${FILENAME}.fore" | ${PNMPASTE} ${TEMPFILE} "${X}" "${Y}" > "${FILENAME}.temp"
            mv -f "${FILENAME}.temp" "${FILENAME}.fore"
            rm -f ${TEMPFILE}
            log info "cutimg() Plocha $1 byla zamaskována"
        ;;
        2) case ${SIZE[1]} in
            M) #/ Nahradí oblast za bílou plochu (ve výsledku dojde k rozmazání
                ${PBMMAKE} -white ${W} ${H} > ${TEMPFILE}
                ${PAMTOPNM} "${FILENAME}.fore" | ${PNMPASTE} ${TEMPFILE} "${X}" "${Y}" > "${FILENAME}.temp"
                mv -f "${FILENAME}.temp" "${FILENAME}.fore"
                log info "cutimg() Plocha $1 byla odmaskována"
            ;;
            T) #/ Text - vybraná plocha z fore je naklíčovaná na bílou plochu
                #/ maska bude mít příponu text
                ${PAMTOPNM} "${FILENAME}.fore" | ${PAMCUT} -left ${X} -top ${Y} -width ${W} -height ${H} > ${TEMPFILE}
                [ ! -f "${FILENAME}.text" ] && \
                    ${PBMMAKE} -white $(head -2 "${FILENAME}.fore" |tail -1) > "${FILENAME}.text"
                ${PAMTOPNM} "${FILENAME}.text" | ${PNMPASTE} ${TEMPFILE} "${X}" "${Y}" > "${FILENAME}.temp"
                mv -f "${FILENAME}.temp" "${FILENAME}.text"
                log info "cutimg() Plocha textu $1 byla vyseparovaná"
            ;;
            I) #/ Obrázek - vybraná plocha je na masce začerněná
                ${PBMMAKE} -black ${W} ${H} > ${TEMPFILE}
                ${PAMTOPNM} "${FILENAME}.fore" | ${PNMPASTE} ${TEMPFILE} "${X}" "${Y}" > "${FILENAME}.temp"
                mv -f "${FILENAME}.temp" "${FILENAME}.fore"
                log info "cutimg() Plocha $1 byla zamaskována"
            ;;
            G) #/ Grafika - v rámci vybrané plochy zredukuje barvy a pak ji naklíčuje do barevného pozadí
            ;;
            *) echo "Neimplemnetováno {SIZE[1]}" >> /dev/stderr
                return 1
            ;;
            esac
        ;;
        *) echo "Neplatné nastavení pro cut –> $1" >> /dev/stderr
        ;;
    esac
}

# ### <span id="iscut">iscut()</span> ([top](#FUNCTIONS))
# Ověřuje, zda-li následuje řetězec pro specifikaci oblastí pro zvláštní
# zacházení. Těchto oblastí může být specifikováno více, v takovém případě
# však musí být odděleny středníkem a uzavřeny v uvozovkách
iscut() {
    log goto "iscut() string –> $1"
    local PARAMS=($1)
    log info "vysledek ${PARAMS[0]}"
    case "${PARAMS[0]}" in
        -cut) echo "${PARAMS[1]}"
        ;;
    esac
}

# ### <span id="isscale">isscale()</span> ([top](#FUNCTIONS))
# Nastavuje proměnnou SCALE a vrací ořezaný řetězec
isscale() {
    log goto "isscale() string –> $1"
    local PARAMS=($1)
    log info "vysledek ${PARAMS[0]}"
    case "${PARAMS[0]}" in
        [1-9]+([0-9])x[1-9]+([0-9]))
            case "${PARAMS[1]}" in
                -xyfit|-xyfill|-xysize)
                    SCALE="${PARAMS[1]} ${PARAMS[0]/x/ }"
                    local TEMPORAR=${1#*${PARAMS[1]}}
                ;;
                *) echo """Při škálování na fixní rozmět musí být nastaven jeden z následujících parametrů: 
  -xyfit
  -xyfill
  -xysize
                """
                    echo false
                ;;
            esac
        ;;
        0.|0.0|0.00) echo "Chybně nastavena hodnota škálování: ${PARAMS[0]}" >> /dev/stderr
            echo false
        ;;
        [1-9]+([0-9])x|x[1-9]+([0-9])) echo "Chybně nastavený škálovací box: ${PARAMS[0]}" >> /dev/stderr
            echo false
        ;;
        [0-9].[0-9]?([0-9])|+([0-9]))
            SCALE="${PARAMS[0]}"
            local TEMPORAR=${1#*${PARAMS[0]}}
        ;;
        *) return 1
            ;;
    esac
    if [[ "${TEMPORAR}" =~ "-filter=" ]] ; then
        local PARAMS=(${TEMPORAR#*-filter=})
        if [[ "${FILTERS[@]}" =~ "${PARAMS[0]}" ]] ; then
            echo "${SCALE} -filter=${PARAMS[0]}"
        else
            echo "Neplatný škálovací filtr: ${PARAMS[0]}" >> /dev/stderr
            echo false
        fi
    else
        echo "${SCALE}"
    fi
}

# ### <span id="importdjvu">importdjvu()</span> ([top](#FUNCTIONS))
# Funkce zajišťuje akce import a edit
importdjvu() {
    case "${2}" in
        ant*) #/ Importuji obsah .ant souboru
            local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .ant)
            local ANTFILE="${2#ant+([[:blank:]])}"
            #/ ořezat mezery před a za
            if [ -f "${ANTFILE}" ] ; then
                cat "${ANTFILE}" > "${TEMPFILE}"
            else
                writefile "${TEMPFILE}"
                if [ $? -eq 1 ] ; then
                    (
                    printf '; Pravidla pro obsah souboru .ant :\n'
                    printf '; * Globální meta informace se píší jako součást stránky "shared_anno.iff" \n'
                    printf '; * Stránka může být identifikována buď pořadovým číslem, nebo jménem\n'
                    printf '; * Blok meta informací vždy začíná řádkem uvozeným znakem # za kterým následuje identifikátor stránky (číslo, nebo jméno)\n'
                    printf '; * Text záložky i její cíl musí být v uvozovkách\n'
                    printf '; * Veškerý text na řádcích začínajících středníkem je považován za komentář\n'
                    printf '; * Při importu souboru bude zakomentovaný obsah odfiltrován\n'
                    printf '; * Soubor nesmí končit prázdným řádkem!\n'
                    printf '; * Pokud se do soubory změny neuloží, tak se vloží zpět původní obsah.\n'
                    printf ';\n'
                    printf ';Author "Aleš Novák"\n'
                    printf ';\n'
                    printf ';; Aktivní link bez bubliny"\n'
                    printf ';maparea "https://www.thewoodcraft.org/" ""\n'
                    printf ';rect 225 0 804 61\n'
                    printf ';xor\n'
                    printf ';\n'
                    printf ';; Aktivní link s bublinou"\n'
                    printf ';URL ("https://www.thewoodcraft.org/" "_blank" ) "Odkaz na stránky Thewoodcraft.org"\n'
                    printf ';        (rect 225 0 804 61 )\n'
                    printf ';        (xor )\n'
                    printf ';; Aktivní link s bublinou u textu přes dva řádky"\n'
                    printf ';URL ("https://www.thewoodcraft.org/" "_blank" ) "Odkaz na stránky Thewoodcraft.org"\n'
                    printf ';        ("https://www.thewoodcraft.org/" "_blank" ) "Odkaz na stránky Thewoodcraft.org"\n'
                    $0 "${FILE}" export "${2}"
                    echo "" ) | tee "${TEMPDIR}/ant.orig" >> "${TEMPFILE}"
                fi
            fi
            if [ "${FORCE}" != "yes" ] ; then
                if [ -f "${HOME}/.config/${NAME}/default.conf" ] ; then
                    local STRING="$(grep '^CREATOR' "${HOME}/.config/${NAME}/default.conf" | cut -d\= -f2)"
                else
                    echo "Není uveden CREATOR ve výchozím souboru, použiji tedy aktuálního uživatele" >> /dev/stderr
                    local STRING="${USER}"
                fi
                setkey "${TEMPFILE}" "Producer" "${STRING}, ${NAME} ${VERSION}"
                setkey "${TEMPFILE}" "ModDate" "$(date -u +%FT%T%:z)"
                setkey "${TEMPFILE}" "HostComputer" "$(hostname)"
            fi
            case ${ACTION} in
                edit)
                    editor "${TEMPFILE}"
                ;;
            esac
            if [ -n "${DIFF}" ] ; then
                echo "Pokud máte nainstalovaný vim, můžete se ještě přes realizací změn podívat, v čem se bude nový obsah stránky lišit od stávajícího." >> /dev/stderr
                echo "V případě, že v obsahu nebude rozdíl, neozobrazí se nic! Aplikaci vimdiff ukončíte tím, že napíšete :qa" >> /dev/stderr
                anone "Chcete si prohlédnout změny?" >> /dev/stderr
                if [ ! $? -eq 1 ] ; then
                    vimdiff -c 'set encoding=utf-8' "${TEMPDIR}/ant.orig" "${TEMPFILE}"
                fi
                anone "Uložit změny?" >> /dev/stderr
                [ $? -eq 1 ] && return 1
            fi
            local DSEDFILE=$(tempfile -d ${TEMPDIR} -s .dsed)
            ant2dsed "${TEMPFILE}" > "${DSEDFILE}"
            if [ $? -eq 1 ] ; then
                echo "V importovaném souboru ${TEMPFILE} byla syntaktická chyba" >> /dev/stderr
                exit 33
                return 1
            fi
            ${DJVUSED} "${1}" -f "${DSEDFILE}" -s
        ;;
        outline*) echo "Importuji záložky"
            echo "Přijato k importu ${2}"
            #/ Může být předaný i soubor
            #/ Není-li předaný soubor, zkus načíst stdin
            local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .outline)
            local OUTLINEFILE="${2#outline+([[:blank:]])}"
            #/ ořezat mezery před a za
            if [ -f "${OUTLINEFILE}" ] ; then
                log info "main() Importuji .outline soubor ${OUTLINEFILE}"
                cat "${OUTLINEFILE}" > "${TEMPFILE}"
            else
                writefile "${TEMPFILE}"
                if [ $? -eq 1 ] ; then
                    log info "main() Na stdin nebylo nic, přidám záhlaví a vytáhnu stávající záložky"
                    (
                    printf '; Pravidla pro obsah souboru .outline :\n'
                    printf '; * Text záložky i její cíl musí být v uvozovkách\n'
                    printf ';  * Cíl může být identifikován buď pořadovým číslem stránky, nebo jejím jménem\n'
                    printf ';  * Identifikátor vždy začíná znakem #\n'
                    printf ';  * Úroveň zanoření záložky je daná odsazením pomocí tabelátoru\n'
                    printf ';  * Veškerý text na řádcích začínajících středníkem je považován za komentář\n'
                    printf ';  * Při importu souboru bude zakomentovaný obsah odfiltrován\n'
                    printf ';  * Soubor nesmí končit prázným řádkem!\n'
                    printf ';  * Pokud se do soubory změny neuloží, tak se vloží zpět původní obsah.\n'
                    printf ';\n'
                    printf ';"Link první úrovně" "#1"\n'
                    printf ';      "Link druhé úrovně" "#strana-001.djvu"\n'
                    $0 "${1}" info list | sed 's/^/; /'
                    $0 "${1}" export outline ) | tee "${TEMPDIR}/outline.orig" >> "${TEMPFILE}"
                fi
            fi
            case ${ACTION} in
                edit) editor "${TEMPFILE}"
                ;;
            esac
            if [ -n "${DIFF}" ] ; then
                echo "Pokud máte nainstalovaný vim, můžete se ještě přes realizací změn podívat, v čem se bude nový obsah stránky lišit od stávajícího." >> /dev/stderr
                echo "V případě, že v obsahu nebude rozdíl, neozobrazí se nic! Aplikaci vimdiff ukončíte tím, že napíšete :qa" >> /dev/stderr
                anone "Chcete si prohlédnout změny?" >> /dev/stderr
                if [ ! $? -eq 1 ] ; then
                    vimdiff -c 'set encoding=utf-8' "${TEMPDIR}/outline.orig" "${TEMPFILE}"
                fi
            fi
            outlinetodjvu "${1}" "${TEMPFILE}"
            if [ $? -eq 1 ] ; then
                echo "V importovaném souboru ${TEMPFILE} byla syntaktická chyba" >> /dev/stderr
                return 1
            else
                echo "Záložky byly aktualizovány" >> /dev/stderr
            fi
        ;;
        page*)
            local TEMP="${2#page+([[:blank:]])}"
            local RANGE=$(isrange "${TEMP}")
            case "${RANGE}" in
                +([[:digit:]]))
                    local DJVUFILE=$(${REALPATH} -m -P "${TEMP#${RANGE}+([[:blank:]])}")
                ;;
                *) if [ -n "${RANGE}" ] ; then
                        echo "Při importu nelze použít rozsah." >> /dev/stderr
                        return 1
                    else
                        local DJVUFILE=$(${REALPATH} -m -P "${TEMP}")
                    fi
                ;;
            esac
            if [ -f "${DJVUFILE}" ] ; then
                if [ -n "${RANGE}" ] ; then
                    anone "Opravdu vložit soubor ${DJVUFILE} na pozici ${RANGE}?"
                    [ $? -eq 1 ] && return 1
                    ${DJVM} -i "${1}" "${DJVUFILE}" "${RANGE}"
                else
                    anone "Opravdu připojit soubor ${DJVUFILE}?"
                    [ $? -eq 1 ] && return 1
                    ${DJVM} -i "${1}" "${DJVUFILE}"
                fi
            else
                echo "Neplatná cesta k souboru –> ${DJVUFILE}" >> /dev/stderr
                return 1
            fi
        ;;
        xml*) xmlimport "${1}" "${2#xml+([[:blank:]])}"
        ;;
        *) help keyword-${2%% *}
        ;;
    esac
    return $?
}

# ### <span id="exportdjvu">exportdjvu()</span> ([top](#FUNCTIONS))
# Na rozdíl od funkce exportfile, se zde zpracovávají předané parametry
# __$1__ je cesta ke kontejneru ze kterého se exportuje stránka
# __$2__ obsahuje parametry
#
# * ant - Exportuje hyperlinky a meta atributy ve formátu .ant
# * meta - Exportuje meta informace stránky, její rozměry a stav rotace
# * djvu - Exportuje DjVu stránky
# * mask|background|foreground|color|black - oxportuje obrázek pozadí
# * dsed-*
# * xml-*
exportdjvu() {
    log goto "exportdjvu() ${FILETYPE} $1 –> $2"
    local INTO=$(isformat "${2}")
    if [ -n "${INTO}" ] ; then
        local TEMPORAR="${2#*${INTO}}"
    else
        echo "Cílový formát musí být vždy uveden!" >> /dev/stderr
        return 1
    fi

    local RANGE=$(isrange "${TEMPORAR}")
    if [ -n "${RANGE}" ] ; then
        local TEMPORAR="${TEMPORAR#*${RANGE}}"
    fi

    case "${TEMPORAR:$((${#TEMPORAR}-1)):1}" in
        /) TARGETDIR=$(${REALPATH} -m -P "${TEMPORAR## }")
            log info "exportdjvu() Export pages with a original names into –> ${TARGETDIR}"
            [ ! -d "${TARGETDIR}" ] && mkdir -p "${TARGETDIR}"
        ;;
        *) if [[ "${TEMPORAR}" =~ "/" ]] ; then
                #/ obsahuje cestu
                local TEMPORARY=$(${REALPATH} -m -P "${TEMPORAR## }")
                TARGETDIR="${TEMPORARY%/*}"
                TARGETSAMPLE="${TEMPORARY##*/}"
                log info "exportdjvu() Export pages a named by sample ${TARGETSAMPLE} –> ${TARGETDIR}"
                [ ! -d "${TARGETDIR}" ] && mkdir -p "${TARGETDIR}"
            else
                #/ jde o vzorek
                TARGETDIR="$(pwd)"
                TARGETSAMPLE="${TEMPORAR## }"
                log info "targets() Export pages a named by sample ${TARGETSAMPLE} into actual directory"
            fi
        ;;
    esac
    echo """
    RANGE ${RANGE}
    INTO ${INTO}
    TARGETDIR ${TARGETDIR}
    TARGETSAMPLE ${TARGETSAMPLE}
    TEMPORAR ${TEMPORAR}
    Můžeme přikročit k akci
    """ >> /dev/stderr
    mapfile -t ARRAY <<< $($0 "${1}" info list)
    case "${ARRAY:0:1}" in
        0) mapfile -t LISTPAGES <<< $(printf "%s\n" "${ARRAY[@]}")
        ;;
        *) LISTPAGES="0 none"
        mapfile -O 1 -t LISTPAGES <<< $(printf "%s\n" "${ARRAY[@]}")
        ;;
    esac
#/    echo "ARRAY ${#ARRAY[@]} ${ARRAY[@]}" >> /dev/stderr
#/    echo "LISTPAGES ${#LISTPAGES[@]} ${LISTPAGES[@]}" >> /dev/stderr
    case "${INTO}" in
        djvu|ant|note|meta|mask|background|foreground|color|black|dsed*|xmp|xml|\
        line|word|para)
            if [ -n "${RANGE}" ] ; then
                local PAGES=($(range "${RANGE}"))
            else
                case "${TEMPORAR//+([[:blank:]])/}" in
                    '') # jenom příkaz
                        local PAGES=($(range "0-${#LISTPAGES[@]}"))
                    ;;
                    *) # seznam stránek oddělených čárkou
                        local IFS_BAK=$IFS
                        local IFS=$','
                        local SEZNAM=($TEMPORAR)
                        local IFS=$IFS_BAK
                        for i in "${LISTPAGES[@]}" ; do
                            if [[ "${SEZNAM[@]}" =~ "${i##+([[:digit:]])+([[:blank:]])}" ]] ; then
                                local TEMP="$TEMP${i%% *} "
                            fi
                            x=$((x + 1))
                        done
                        local PAGES=($TEMP)
                    ;;
                esac
            fi
#/            echo "PAGES ${#PAGES[@]} ${PAGES[@]}" >> /dev/stderr
            for i in ${PAGES[@]} ; do
                local PAGENAME="${LISTPAGES[$i]##+([[:digit:]])+([[:blank:]])}"
                local PAGEORDER="${LISTPAGES[$i]%% *}"
                echo "PAGEORDER ${#PAGEORDER[@]} ${PAGEORDER[@]}" >> /dev/stderr
                echo "PAGENAME ${#PAGENAME} ${PAGENAME}" >> /dev/stderr
                case "${TARGETSAMPLE}" in
                    orig*) local TARGET=$(${REALPATH} -m -P "${TARGETDIR}/${PAGENAME}")
                    ;;
                    '') unset TARGET
                    ;;
                    *)  local TARGET=$(${REALPATH} -m -P "${TARGETDIR}/${TARGETSAMPLE}_${PAGEORDER}")
                    ;;
                esac
                case "${PAGEORDER}" in
                    0) case "${PAGENAME}" in
                            none)
                            ;;
                            *) case ${INTO} in
                                line|word|para)
                                ;;
                                ant)printf "# 'shared_anno.iff'\n"
                                    ${DJVUSED} "${1}" -e "select 'shared_anno.iff'; print-ant" | dsed2ant
                                ;;
                                meta) printf "# 'shared_anno.iff'\n"
                                    local META=$(${DJVUSED} "${1}" -e "select 'shared_anno.iff'; print-meta" | decode)
                                    echo -e "${META}"
                                ;;
                                note) ${DJVUSED} "${1}" -e "select 'shared_anno.iff'; print-ant" | dsed2ant | grep ^note | xargs -n1 | grep -v ^note
                                ;;
                                xmp) ${DJVUSED} "${1}" -e "select 'shared_anno.iff'; print-ant" | dsed2ant | while read line
                                    do
                                        case "${line}" in
                                            xmp) local PRINT="yes" ;;
                                            \<*) echo "${line}" ;;
                                            *) [ -n "${PRINT}" ] && break ;;
                                        esac
                                    done
                                ;;
                                djvu) log info "Pořadové číslo 0 má vždy soubor sdílených poznámek, který nelze vyexportovat jako DjVu stránku"
                                ;;
                                dsed) local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .dsed)
                                    case ${INTO} in
                                        dsed-all|dsed-ant|dsed) (
                                                local EXPORT="output-ant"
                                                printf "select '${PAGENAME}' ; remove-ant\n"
                                                ${DJVUSED} "${1}" -e "select 'shared_anno.iff'; ${EXPORT}"
                                            ) >> "${TEMPFILE}"
                                            if [ -n "${TARGET}" ] ; then
                                                mv -i "${TEMPFILE}" "${TARGET}"
                                            else
                                                cat "${TEMPFILE}"
                                            fi
                                            ;;
                                        esac
                                ;;
                                xml) if [ ! -n "${TARGETSAMPLE}" ] ; then
                                        local TARGETSAMPLE="${1##*/}"
                                    fi
                                    local TARGET=$(${REALPATH} -m -P "${TARGETDIR}/${TARGETSAMPLE/.djvu/.xml}")
                                    if [ -f "${TARGET}" ] ; then
                                        anone "XML soubor ${TARGET} již existuje a může obsahovat změny. Mám ho přepsat?" >> /dev/stderr
                                        [ $? -eq 1 ] && return 1
                                    fi
                                    touch "${TARGET}"
                                    ${DJVUTOXML} --with-text --without-anno "${1}" "${TARGET}"
                                    [ $? -eq 1 ] && return 1
                                    echo "XML soubor ${TARGET} do kterého byl exportován XML obsah všech stránek byl zapsán" >> /dev/stderr
                                    return 0
                                ;;
                            esac
                            ;;
                        esac
                    ;;
                    '') echo ""
                    ;;
                    *) log info "Jdu exportovat xml"
                        local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .ant)
                        case ${INTO} in
                            line|word|para)  printf "# '${PAGENAME}' # page ${PAGEORDER}\n"
                                ${DJVUTXT} -page="${PAGEORDER}" -detail="${INTO}" "${FILE}" 
                                ;;
                            ant) printf "# '${PAGENAME}' # page ${PAGEORDER}\n"
                                ${DJVUSED} "${1}" -e "select ${PAGEORDER}; print-ant" | dsed2ant
                            ;;
                            meta) printf "# '${PAGENAME}' # page ${PAGEORDER} "
                                ${DJVUSED} "${1}" -e "select ${PAGEORDER}; size"
                                local META=$(${DJVUSED} "${1}" -e "select ${PAGEORDER}; print-meta" | decode)
                                [ -n "${META}" ] && echo -e "${META}"
                            ;;
                            note) ${DJVUSED} "${1}" -e "select ${PAGEORDER}; print-ant" | dsed2ant | grep ^note | xargs -n1 | grep -v ^note
                            ;;
                            xmp) ${DJVUSED} "${1}" -e "select ${PAGEORDER}; print-ant" | dsed2ant | while read line
                                do
                                    case "${line}" in
                                        xmp) local PRINT="yes" ;;
                                        \<*) echo "${line}" ;;
                                        *) [ -n "${PRINT}" ] && break ;;
                                    esac
                                done
                            ;;
                            djvu)
                                if [ -n "${TARGETSAMPLE}" ] ; then
                                    local TARGET=$(${REALPATH} -m -P "${TARGETDIR}/${TARGETSAMPLE}")
                                else
                                    local TARGET=$(${REALPATH} -m -P "${TARGETDIR}/${PAGENAME}")
                                fi
                                if [ -f "${TARGET}" ] ; then
                                    anone "Soubor ${TARGET} již existuje. Mám ho přepsat?"
                                    [ $? -eq 1 ]&& continue
                                fi
                                ${DJVUSED} "${1}" -e "select ${PAGEORDER}; save-page-with '${TARGET}'"
                                echo "Exportuji stránku ${PAGEORDER} do souboru ${TARGET}" >> /dev/stderr
                            ;;
                            mask|background|foreground|color|black)
                                local TARGET=$(${REALPATH} -m -P "${TARGETDIR}/${PAGENAME/.djvu/.png}")
                                ${DDJVU} -format=pnm -mode=${INTO} -page="${PAGEORDER}" "${1}" | ${PNMTOPNG} > "${TARGET}"
                                [ $? -eq 1 ] && return 1
                                echo "Soubor ${TARGET} byl zapsán" >> /dev/stderr
                            ;;
                            dsed*) local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .dsed)
                                case ${INTO} in
                                    dsed-all)
                                        local EXPORT="output-all"
                                        local IMPORT="remove-ant; remove-txt"
                                        [ -n "${TARGET}" ] && local TARGET="${TARGET}.dsed"
                                        ;;
                                    dsed-txt)
                                        local EXPORT="output-txt"
                                        local IMPORT="remove-txt"
                                        [ -n "${TARGET}" ] && local TARGET="${TARGET}.txt.dsed"
                                        ;;
                                    dsed-ant|dsed)
                                        local EXPORT="output-ant"
                                        local IMPORT="remove-ant"
                                        [ -n "${TARGET}" ] && TARGET="${TARGET}.ant.dsed"
                                    ;;
                                esac
                                log info "export ${INTO} –> ${TARGET}"
                                (
                                    printf "select '${PAGENAME}' ; ${IMPORT}\n"
                                    ${DJVUSED} "${1}" -e "select ${PAGEORDER}; ${EXPORT}"
                                ) >> "${TEMPFILE}"
                                if [ -n "${TARGET}" ] ; then
                                    mv -i "${TEMPFILE}" "${TARGET}"
                                else
                                    cat "${TEMPFILE}"
                                fi
                            ;;
                            xml)local TARGET=$(${REALPATH} -m -P "${TARGETDIR}/${PAGENAME/.djvu/.xml}")
                                if [ -f "${TARGET}" ] ; then
                                    anone "XML soubor ${PAGENAME} již existuje a může obsahovat změny. Mám ho přepsat?" >> /dev/stderr
                                    [ $? -eq 1 ]&& return 1
                                fi
                                ${DJVUTOXML} --page "${PAGEORDER}" --with-text --without-anno "${1}" "${TARGET}"
                                [ $? -eq 1 ] && return 1
                                echo "Soubor ${TARGET} byl zapsán" >> /dev/stderr
                            ;;
                        esac
                    ;;
                esac
            done
            ;;
        outline) # Export obsahu ve formátu .outline
            printoutline "${1}"
            ;;
        bookmark) # Export obsahu ve formátu .bookmarks
            local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .outline)
            printoutline "${1}" > ${TEMPFILE}
            outlinetodsed ${TEMPFILE} | encode
            printf "\n"
            ;;
        *) echo "Nedělám nic ${INTO}" >> /dev/stderr
            ;;
    esac
    return $?
}

# ### Původní zpracování - očekává parametry ze startu message
# Zpracovává stream. pokud se vyskytne, vrátí parametr a zbytek řetězce
#
# Funkce je závislá na obsahu lokální proměnné ELEMENT z funkce setdjvu
object() {
    # Je tady - vrátí parametr, řetězec a 0
    # Není tady nic - vrátí řetězec a 1
    log goto "object() ${ELEMENT} –> $@"
    while [ $# -gt 0 ]
    do
        case ${1} in
            border_avis|none|xor) case ${ELEMENT} in
                rect|oval|text) echo -e "\t$1" && shift
                ;;
                *) return 1
                ;;
            esac
            ;;
            pushpin) case ${ELEMENT} in
                text) echo -e "\t$1" && shift
                ;;
                *) return 1
                ;;
            esac
            ;;
            hilite) case ${ELEMENT} in
                rect) local PROPERTY="${1}" && shift
                    case "${1}" in
                        [0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F]) echo -e "\t${PROPERTY} #$1" && shift
                        ;;
                        *) help set-${PROPERTY}
                            return 1
                        ;;
                    esac
                ;;
                line|oval|text|arrow) shift
                    case "${1}" in
                        [0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F]) shift
                            echo "Nastavení parametru border (barva okraje) u objektu ${ELEMENT} nedává smysl, proto ho ignoruji" >> /dev/stderr
                            echo "Barvu linky lze změnit parametrem lineclr" >> /dev/stderr
                            return 1
                        ;;
                        *) help set-line
                            return 1
                        ;;
                    esac
                ;;
                *) return 1
                ;;
            esac
            ;;
            textclr|backclr|lineclr) case ${ELEMENT} in
                rect|oval|text|arrow) local PROPERTY="${1}" && shift
                    case "${1}" in
                        [0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F]) echo -e "\t${PROPERTY} #$1" && shift
                        ;;
                        *) help set-${PROPERTY}
                            return 1
                        ;;
                    esac
                ;;
                line) shift
                    case "${1}" in
                        [0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F]) shift
                            echo "Nastavení parametru border (barva okraje) u objektu ${ELEMENT} nedává smysl, proto ho ignoruji" >> /dev/stderr
                            echo "Barvu linky lze změnit parametrem lineclr" >> /dev/stderr
                            return 1
                        ;;
                        *) help set-line
                            return 1
                        ;;
                    esac
                ;;
                *) return 1
                ;;
            esac
            ;;
            _blank) echo -e "$1" && shift
                # Kvůli url
            ;;
            border) case "${ELEMENT}" in
                rect|oval) local PROPERTY="${1}" && shift
                    case "${1}" in
                        [0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F]) echo -e "\t${PROPERTY} #$1" && shift
                        ;;
                        *) echo "xxxxx ${1}" >> /dev/stderr
                            help set-${PROPERTY}
                            return 1
                        ;;
                    esac
                ;;
                line) shift
                    case "${1}" in
                        [0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F]) shift
                            echo "Nastavení parametru border (barva okraje) u objektu ${TYPE} nedává smysl, proto ho ignoruji" >> /dev/stderr
                            echo "Barvu linky lze změnit parametrem lineclr" >> /dev/stderr
                            return 1
                        ;;
                        *) help set-line
                            return 1
                        ;;
                    esac
                ;;
                *) return 1
                ;;
            esac
            ;;
            shadow_+(in|out|ein|eout)) case ${ELEMENT} in
                rect) local PROPERTY="${1}" && shift
                    case "${1}" in
                        [1-9]|[1-9][0-9]) echo -e "\t${PROPERTY} $1" && shift
                        ;;
                        *) help set-${PROPERTY}
                            return 1
                        ;;
                    esac
                ;;
                text) echo "Nastavení stínovaného okraje by zobrazování objektu ${TYPE} znemožnilo, proto ho ignoruji" >> /dev/stderr
                    case "${1}" in
                        [1-9]|[1-9][0-9]) shift
                            echo "Nastavení stínovaného okraje by zobrazování objektu ${TYPE} znemožnilo, proto ho ignoruji" >> /dev/stderr
                        ;;
                        *) help set-${PROPERTY}
                            return 1
                        ;;
                    esac
                ;;
                *) return 1
                ;;
            esac
            ;;
            opacity) case ${ELEMENT} in
                rect|oval) local PROPERTY="${1}" && shift
                    case "${1}" in
                        [1-9]|[1-9][0-9]) echo -e "\t${PROPERTY} $1" && shift
                        ;;
                        *) help set-${PROPERTY}
                            return 1
                        ;;
                    esac
                ;;
                *) return 1
                ;;
            esac
            ;;
            width) case ${ELEMENT} in
                line|arrow) local PROPERTY="${1}" && shift
                    case "${1}" in
                        [1-9]|[1-9][0-9]) echo -e "\t${PROPERTY} $1" && shift ;;
                        *) help set-${PROPERTY} ; return 1 ;;
                    esac
                ;;
                rect|text|oval|poly)
                    case "${1}" in
                        [1-9]|[1-9][0-9]) shift ;;
                        *) help set-${PROPERTY} ; return 1 ;;
                    esac
                ;;
                *) return 1
                ;;
            esac
            ;;
            *) # echo "$@"
                break
            ;;
        esac
    done
    return 0
}

# ### <span id="djvumove">djvumove()</span> ([top](#FUNCTIONS))
# __$1__ je cesta k DjVu souboru ve kterém se přejmenovává stránka
# __$2__ obsahuje parametry
# [[:digit:]] - přesouvá stránku
# by default se stránka přesouvá dozadu
# fore - obrátí směr přesunu
djvumove() {
    # ověřit nejprve jde-li o jednu stránku
    mapfile -t ARRAY <<< $($0 "${1}" info list)
    case "${ARRAY:0:1}" in
        0) mapfile -t LISTPAGES <<< $(printf "%s\n" "${ARRAY[@]}")
        ;;
        *) LISTPAGES="0 none"
            mapfile -O 1 -t LISTPAGES <<< $(printf "%s\n" "${ARRAY[@]}")
        ;;
    esac
    for i in "${LISTPAGES[@]}" ; do
        if [[ "${2}" =~ "${i##+([[:digit:]])+([[:blank:]])}" ]] ; then
            log info "Jedna stránka ${i}"
            local TEMP="$TEMP${i%% *} "
        fi
        x=$((x + 1))
    done
    local TEMP=(${TEMP})
    case "${#TEMP[@]}" in
        2) # obě jménem
            local TEST="${2//${LISTPAGES[${TEMP[0]}]##+([[:digit:]])+([[:blank:]])}/}"
            case "${TEST: -1:1}" in
                +([[:blank:]])) # Když zůstane na konci mezera, bylo to na pozici 2
                    log info "Stránku ${LISTPAGES[${TEMP[0]}]} přesouvám vůči ${LISTPAGES[${TEMP[1]}]} –> ${ACTION}"
                    local POS1="${LISTPAGES[${TEMP[0]}]%%+([[:blank:]])*}"
                    local POS2="${LISTPAGES[${TEMP[1]}]%%+([[:blank:]])*}"
                ;;
                u) # Když zůstane na konci u, bylo to na pozici 1
                    log info "Stránku ${LISTPAGES[${TEMP[1]}]}  přesouvám vůči ${LISTPAGES[${TEMP[0]}]} –> ${ACTION}"
                    local POS1="${LISTPAGES[${TEMP[1]}]%%+([[:blank:]])*}"
                    local POS2="${LISTPAGES[${TEMP[0]}]%%+([[:blank:]])*}"
                ;;
                *) echo "Nějaké divné" >> /dev/stderr
                ;;
            esac
        ;;
        1) # jedna jménem, nebo jenom jedna
            local TEST="${2//${LISTPAGES[${TEMP[0]}]##+([[:digit:]])+([[:blank:]])}/}"
            case "${TEST:0:1}" in
                +([[:digit:]])) # Když zůstane na začátku číslo, bylo to na pozici 2
                    log info "Stránku ${TEST} přesouvám vůči ${LISTPAGES[${TEMP[0]}]} –> ${ACTION}"
                    local POS1="${TEST// /}"
                    local POS2="${LISTPAGES[${TEMP[0]}]%%+([[:blank:]])*}"
                ;;
                +([[:blank:]])) # Když zůstane na začátku mezera, bylo to na pozici 1
                    log info "Stránku ${LISTPAGES[${TEMP[0]}]}  přesouvám vůči ${TEST} –> ${ACTION}"
                    local POS1="${LISTPAGES[${TEMP[0]}]%%+([[:blank:]])*}"
                    local POS2="${TEST// /}"
                ;;
                *) log info "Jenom jedna stránka ${LISTPAGES[${TEMP[0]}]} –> ${ACTION}"
                    local POS1="${LISTPAGES[${TEMP[0]}]%%+([[:blank:]])*}"
                ;;
            esac
        ;;
        *) local TEST=(${2})
            case "${#TEST[@]}" in
                2) #/ echo "Dvě číslem"
                    for i in ${TEST[@]}
                    do case $i in
                        +([[:digit:]])) ;;
                        *) echo "Neplatný identifikátor $i" >> /dev/stderr && return 1 ;;
                        esac
                    done
                    local POS1=${TEST[0]}
                    local POS2=${TEST[1]}
                ;;
                1) #/ echo "Jedna číslem"
                    case "${TEST[0]}" in
                        +([[:digit:]])) ;;
                        *) echo "Neplatný identifikátor ${TEST[0]}" >> /dev/stderr && return 1 ;;
                    esac
                    local POS1=${TEST[0]}
                ;;
                *) echo "Něco je špatně" >> /dev/stderr
                    return 1
                ;;
            esac
        ;;
    esac
    local TEMP="${LISTPAGES[@]: -1}"
    local LAST="${TEMP%%+([[:blank:]])*}"
    echo """
Stránku z pozice
${POS1}
${ACTION}
${POS2}
${LAST}
""" >> /dev/null
    [[ "${POS1}" -lt "1" ]] && return 1
    [[ "${POS1}" -gt "${LAST}" ]] && echo "Soubor má pouze ${LAST} stránek" >> /dev/stderr && return 1
    if [ -n "${POS2}" ] ; then
        [[ "${POS2}" -lt "1" ]] && return 1
        [[ "${POS2}" -gt "${LAST}" ]] && echo "Soubor má pouze ${LAST} stránek" >> /dev/stderr && return 1
        if [ ${POS1} -lt ${POS2} ] ; then
            case "${ACTION}" in
                fore) if [ ${POS1} == $((${POS2} - 1)) ] ; then
                        echo "Nedělám nic. Pozice stránky ${LISTPAGES[$POS1]##+([[:digit:]])+([[:blank:]])} by zůstala stejná" >> /dev/stderr
                    else
                        echo "Přesun dozadu z pozice ${POS1} na $((${POS2}-1))"  >> /dev/stderr
                        local PAGE="${LISTPAGES[$POS1]##+([[:digit:]])+([[:blank:]])}"
                        $0 "${1}" export djvu "${POS1}" "${TEMPDIR}/${PAGE}"
                        [ $? -eq 1 ] && echo "Při pokusu o export stránky ${POS1} se vyskytla chyba" && return 1
                        $0 "${1}" delete "${POS1}"
                        [ $? -eq 1 ] && echo "Při pokusu o odstranění stránky ${POS1} se vyskytla chyba" && return 1
                        $0  -f "${1}" import page "$((${POS2}-1))" "${TEMPDIR}/${PAGE}"
                    fi
                ;;
                *) if [ ${POS1} == $((${POS2} - 1)) ] ; then
                        echo "Nedělám nic, pozice stránky ${LISTPAGES[$POS1]##+([[:digit:]])+([[:blank:]])} by zůstala stejná"  >> /dev/stderr
                    else
                        log info "Přesun dozadu z pozice ${POS1} na ${POS2}"
                        local PAGE="${LISTPAGES[$POS1]##+([[:digit:]])+([[:blank:]])}"
                        $0 "${1}" export djvu "${POS1}" "${TEMPDIR}/${PAGE}"
                        [ $? -eq 1 ] && echo "Při pokusu o export stránky ${POS1} se vyskytla chyba" && return 1
                        $0 "${1}" delete "${POS1}"
                        [ $? -eq 1 ] && echo "Při pokusu o odstranění stránky ${POS1} se vyskytla chyba" && return 1
                        $0  -f "${1}" import page "${POS2}" "${TEMPDIR}/${PAGE}"
                    fi
                ;;
            esac
        elif [ ${POS1} -gt ${POS2} ] ; then
            #/ po odstranění ${POS1} se pořadí nezmění
            case "${ACTION}" in
                fore)
                    log info "Přesun stránky z pozice ${POS1} na pozici ${POS2}"
                    local PAGE="${LISTPAGES[$POS1]##+([[:digit:]])+([[:blank:]])}"
                    $0 "${1}" export djvu "${POS1}" "${TEMPDIR}/${PAGE}"
                    [ $? -eq 1 ] && echo "Při pokusu o export stránky ${POS1} se vyskytla chyba" && return 1
                    $0 "${1}" delete "${POS1}"
                    [ $? -eq 1 ] && echo "Při pokusu o odstranění stránky ${POS1} se vyskytla chyba" && return 1
                    $0  -f "${1}" import page "${POS2}" "${TEMPDIR}/${PAGE}"
                ;;
                *) if [ ${POS1} == $((${POS2} + 1)) ] ; then
                        echo "Nedělám nic. Pozice stránky ${LISTPAGES[$POS1]##+([[:digit:]])+([[:blank:]])} by zůstala stejná"  >> /dev/stderr
                    else
                        log info "Přesun z pozice ${POS1} na pozici $((${POS2}+1))"
                        local PAGE="${LISTPAGES[$POS1]##+([[:digit:]])+([[:blank:]])}"
                        $0 "${1}" export djvu "${POS1}" "${TEMPDIR}/${PAGE}"
                        [ $? -eq 1 ] && echo "Při pokusu o export stránky ${POS1} se vyskytla chyba" && return 1
                        $0 "${1}" delete "${POS1}"
                        [ $? -eq 1 ] && echo "Při pokusu o odstranění stránky ${POS1} se vyskytla chyba" && return 1
                        $0  -f "${1}" import page "$((${POS2}+1))" "${TEMPDIR}/${PAGE}"
                    fi
                ;;
            esac
        else
            echo "Stránka ${LISTPAGES[$POS1]##+([[:digit:]])+([[:blank:]])} je na určené pozici" >> /dev/stderr
        fi
    else
        # / přesouvám dokud nedojdu na konec, či na začátek
        case "${ACTION}" in
            fore) if [ ${POS1} == 1 ] ; then
                    echo "Stránka ${LISTPAGES[1]##+([[:digit:]])+([[:blank:]])} je na začátku souboru" >> /dev/stderr
                else
                    log info "Přesun z pozice ${POS1} na pozici $((${POS1}-1))"
                    local PAGE="${LISTPAGES[$POS1]##+([[:digit:]])+([[:blank:]])}"
                    $0 "${1}" export djvu "${POS1}" "${TEMPDIR}/${PAGE}"
                    [ $? -eq 1 ] && echo "Při pokusu o export stránky ${POS1} se vyskytla chyba" && return 1
                    $0 "${1}" delete "${POS1}"
                    [ $? -eq 1 ] && echo "Při pokusu o odstranění stránky ${POS1} se vyskytla chyba" && return 1
                    $0  -f "${1}" import page "$((${POS1}-1))" "${TEMPDIR}/${PAGE}"
                fi
            ;;
            *) if [ ${POS1} == ${LAST} ] ; then
                    echo "Stránka ${LISTPAGES[$POS1]##+([[:digit:]])+([[:blank:]])} je na konci souboru" >> /dev/stderr
                else
                    log info "Přesun z pozice ${POS1} na pozici $((${POS1}+1)) – číslování stránek se po odstranění stránky zmenší"
                    local PAGE="${LISTPAGES[$POS1]##+([[:digit:]])+([[:blank:]])}"
                    $0 "${1}" export djvu "${POS1}" "${TEMPDIR}/${PAGE}"
                    [ $? -eq 1 ] && echo "Při pokusu o export stránky ${POS1} se vyskytla chyba" && return 1
                    $0 "${1}" delete "${POS1}"
                    [ $? -eq 1 ] && echo "Při pokusu o odstranění stránky ${POS1} se vyskytla chyba" && return 1
                    $0  -f "${1}" import page "$((${POS1}+1))" "${TEMPDIR}/${PAGE}"
                fi
            ;;
        esac
    fi
}

# ### <span id="djvurename">djvurename()</span> ([top](#FUNCTIONS))
# __$1__ je cesta k DjVu souboru ve kterém se přejmenovává stránka
# __$2__ obsahuje parametry
djvurename() {
    local RANGE=$(isrange "${2}")
    if [ ! -n "${RANGE}" ] ; then
        # / může být seznam stránek ZA KTERÝM není nic
        # oddělit PATTERN od seznamu
        case "${2//+([[:blank:]])/}" in
            '') # jenom příkaz
                echo "Nebylo nic předáno ${2}" >> /dev/stderr
                return 1
                #local PAGES=($(range "0-${#LISTPAGES[@]}"))
            ;;
            *) # seznam stránek oddělených čárkou

                mapfile -t ARRAY <<< $($0 "${1}" info list)
                case "${ARRAY:0:1}" in
                    0) mapfile -t LISTPAGES <<< $(printf "%s\n" "${ARRAY[@]}")
                    ;;
                    *) LISTPAGES="0 none"
                        mapfile -O 1 -t LISTPAGES <<< $(printf "%s\n" "${ARRAY[@]}")
                    ;;
                esac

                local IFS_BAK=$IFS
                local IFS=$','
                local SEZNAM=($2)
                local IFS=$IFS_BAK
                for i in "${LISTPAGES[@]}" ; do
                    if [[ "${SEZNAM[@]}" =~ "${i##+([[:digit:]])+([[:blank:]])}" ]] ; then
                        echo "Stránka ${i}" >> /dev/stderr
                        local TEMP="$TEMP${i%% *} "
                    fi
                    x=$((x + 1))
                done
                local PAGES=($TEMP)
                local STRING="${2##*.djvu+([[:blank:]])}"
            ;;
        esac
    else
        local STRING="${2#*${RANGE}+([[:blank:]])}"
        [ ! -n "${STRING}" ] && return 1
        local PAGES=($(range "${RANGE}"))
    fi
    case "${STRING:0:1}" in
        [a-Z])
        ;;
        *) echo "Neplatný PATTERN –> ${STRING}" >> /dev/stderr
            return 1
        ;;
    esac
    if [ "${PAGES[0]}" == "0" ] ; then
        log warn "Sobor se sdílenými informacemi nelze přejmenovat"
    else
        case "${#PAGES[@]}" in
            1) # jedna položka
                local PATTERN="${STRING}.djvu"
            ;;
            *) local DIGIT="${PAGES[@]: -1}"
                local PATTERN="${STRING}%${#DIGIT}d.djvu"
            ;;
        esac
        local z i
        for i in ${PAGES[@]} ; do
            [ "$i" == "0" ] && log warn "Sobor se sdílenými informacemi nelze přejmenovat" && continue
            ((++z))
            local TARGET=$(printf "${PATTERN}" $z)
            ## export stránky do dočasného pod názvem + pattern
            $0 "${1}" export djvu $i "${TEMPDIR}/${TARGET}"
            [ $? -eq 1 ] && echo "Při pokusu o export stránky $i se vyskytla chyba" && return 1
            log info "Save page $i –> ${TARGET}"
            anone "Opravdu chcete nahradit stránku $i za její přejmenovanou verzi?"
            [ $? -eq 1 ] && return 1
            $0 "${1}" delete $i
            [ $? -eq 1 ] && echo "Při pokusu o odstranění stránky $i se vyskytla chyba" && return 1
            log info "Remove page $i"
            ## a její import pod novým názvem
            $0  -f "${1}" import page $i "${TEMPDIR}/${TARGET}"
            [ $? -eq 1 ] && echo "Při pokusu o odstranění stránky $i se vyskytla chyba" && return 1
            log info "Page ${TARGET} –> $i"
        done
    fi
    return $?
}

# ### <span id="unsetkey">unsetkey()</span> ([top](#FUNCTIONS))
# Odstraňuje v .ant souboru metadatové klíče
# $1 - .ant soubor
# $2 - KEY
# $3 - VALUE
unsetkey() {
    local KEY="${2}"
    local VALUE="${3}"
    mapfile -d\: -t -c1 LINE <<< $(grep -n "${KEY} \"" "${1}")
    log info "${KEY} –> ${LINE[0]}"
    case "${LINE[0]}" in
        +([[:digit:]])) #/ Tady je třeba ověřit jestli metadatový blok má více než jeden řádek
                # nejlépe ověřit řádek před a po…
                # Jestli je o řádek dřív tag metadata…
            local BEGIN=$((${LINE[0]} - 1))
            local START="$(sed -n ${BEGIN}p ${1})" 
            local END="$(sed -n $((${LINE[0]} + 1))p ${1})"
            case "${START}" in
                metadata) # Odstraňuji dva řádky
                    case "${END%%([[:blank:]])*}" in
                        ''|metadata|xmp|note|align|background|zoom|mode)
                            ed "${1}" 2>/dev/null <<-EOF
${BEGIN},${LINE[0]}d
w
q
EOF
                            ;;
                        *)  # Odstraňuji jeden řádek
                        setmeta "${1}" "${KEY} \"" 
                        ;;
                    esac
                ;;
                *) # Odstraňuji jeden řádek
                    setmeta "${1}" "${KEY} \"" 
                ;;
            esac
        ;;
    esac
    return $?
}

# ### <span id="replacenote">replacenote()</span> ([top](#FUNCTIONS))
# Nahrazuje a odstraňuje v dočasném souboru skryté poznámky
replacenote() {
    mapfile -d\: -t -c1 LINE <<< $(grep -n "${KEY} \"${VALUE}\"" "${TEMPFILE}")
    log info "${KEY} \"${VALUE}\" –> ${LINE[0]}"
    case "${ACTION}" in
        unset) case "${LINE[0]}" in
                +([[:digit:]])) log info "Remove note from ${LINE[0]}"
                    setmeta "${TEMPFILE}" "${KEY} \"${VALUE}\""
                ;;
                *) log warn "Note is not set"
                    return 1
                ;;
        esac
        ;;
        set) case "${LINE[0]}" in
                +([[:digit:]])) log info "This note exists"
                ;;
                *) log info "Set new note"
                    echo -e "${KEY} \"${VALUE}\"\n" >> "${TEMPFILE}"
                ;;
        esac
        ;;
    esac
}

# ### <span id="replacexmp">replacexmp()</span> ([top](#FUNCTIONS))
# Nahrazuje v dočasném souboru XMP kód
replacexmp() {
    mapfile -t ITEM <<< $(sed  '/xmp/,/^[abmnpz#]/!d ; = ; /^[abmnpz#]/q' "${TEMPFILE}" | grep ^[0-9])
    local XMP=$(echo ${STRING#xmp+([[:blank:]])} | encode)
    case "${ITEM[0]}" in
        +([0-9])) case "$(sed -n ${ITEM[@]: -1}p ${TEMPFILE})" in
            +(maparea|metadata|note|mode|zoom|background|align)*)
                local BEGIN="${ITEM[0]}"
                local END="${ITEM[@]: -2:1}"
            ;;
            *) local BEGIN="${ITEM[0]}"
                local END="${ITEM[@]: -1}"
            ;;
        esac
        ;;
        *) log info "XMP unexist"
        ;;
    esac
    case "${ACTION}" in
        unset) # jestli xmp existuje - zrušit (stačí grep)
            if [ -n "${BEGIN}" ] ; then
                log info "Delete XMP code –> ${BEGIN},${END}d"
                ed "${TEMPFILE}" 2>/dev/null <<-EOF
${BEGIN},${END}d
w
q
EOF
            fi
        ;;
        set) # Jestli xmp existuje - přepsat
            if [ -n "${BEGIN}" ] ; then
                log info "Change XMP code –> ${BEGIN},${END}c"
                ed "${TEMPFILE}" 2>/dev/null <<-EOF
${BEGIN},${END}c
xmp
${XMP//></>\\\n<}
.
w
q
EOF
            else
                # jestli neexistuje - vložit
                log info "Add XMP code to end file"
                echo "xmp" >> "${TEMPFILE}"
                echo -e "${XMP//></>\\\n<}" >> "${TEMPFILE}"
            fi
        ;;
    esac
    return $?
}

# ### <span id="setdjvu">setdjvu()</span> ([top](#FUNCTIONS))
# Na rozdíl od funkce exportfile, se zde zpracovávají předané parametry
# __$1__ je cesta ke kontejneru ze kterého se exportuje stránka
# __$2__ obsahuje parametry
#
# * ant - Exportuje hyperlinky a meta atributy ve formátu .ant
# * meta - Exportuje meta informace stránky, její rozměry a stav rotace
# * djvu - Exportuje DjVu stránky
# * mask|background|foreground|color|black - oxportuje obrázek pozadí
# * dsed-*
# * xml-*#
#
# Akce set je určena pro primární nastavení odkazů v obsahu, či poznámek v textu
# Souřadnice se při ní přepočítávají podle velikosto stránky
# a zároveň se kontroluje syntaxe.
# Dodatečné úpravy lze pak provádět buď přes djvusmooth, nebo editací vrstvy .ant
# set outline : "#cíl" "popis"
# set meta RANGE : key "Popis"
# set note RANGE : key "Obsah skryté poznámky"
# set poly RANGE : "" "" {none|xor|border} [border_avis] x1 y1 x2 y2 …
# set rect : "" {none|xor|border c} [hilite c] [border_avis] x1 y1 x2 y2
# set oval : "" {none|xor|border} [border_avis] x1 y1 x2 y2
# set line : 
# Jak upravit line - nejprve někam nastavit a pak přes djvusmooth upravit odkud kam
# set text : x1 y1 x2 x3
# URL
# maparea
setdjvu() {
    log goto "$1 –> $2"
    local RANGE=$(isrange "${2}")
    if [ ! -n "${RANGE}" ] ; then
        local RANGE="${2%%+([[:blank:]])*}"
    fi

    local TEMPORAR="${2#*${RANGE}+([[:blank:]])}"
    [ ! -n "${TEMPORAR##+([[:blank:]])}" ] && return 1

    case "${RANGE}" in
        global|all|\
        mode|align|background|zoom|note|key) echo """
Pokud chcete nastavit element, či parametr, tak aby ho obsahovala každá
stránka, tak máte dvě možnosti:
  1, Buď nastavíte RANGE na hodnotu 0 (nula). V takovém případě se prvek
     vloží mezi sdílená metadata.
  2, Nebo nastavíte RANGE na rozsah od první do poslední stránky (např. 1-99)
     Prvek se pak nastaví pro každou z nich samostatně.
""" >> /dev/stderr
        ;;
        outline)
            [ "${ACTION}" == "unset" ] && echo "Nastavené záložky lze odstraňovat jedině při akci edit" && return 1
            local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .outline)
            $0 "${FILE}" export outline > "${TEMPFILE}"
            local TEMP="${TEMPORAR#+([[:blank:]])}"
            case "${TEMP}" in
                +([[:digit:]])+([[:blank:]])*) echo "\"${TEMP#+([[:digit:]])+([[:blank:]])}\" \"#${TEMP%%+([[:blank:]])*}\"" >> "${TEMPFILE}"
                ;;
                http*)  echo "\"${TEMP#http*+([[:blank:]])}\" \"${TEMP%%+([[:blank:]])*}\"" >> "${TEMPFILE}"
                ;;
                *) local TARGET="${TEMP%%+([[:blank:]])*}"
                    if [[ "${TARGET}" =~ ".djvu" ]] ; then
                        echo "\"${TEMP#${TARGET}+([[:blank:]])}\" \"${TARGET}\"" >> "${TEMPFILE}"
                    else
                        echo "Neplatná záložka –> z${TEMPORAR}z x${TEMP}x" >> /dev/stderr
                        return 1
                    fi
                ;;
            esac
            anone "Uložit změny?" >> /dev/stderr
            [ $? -eq 1 ] && return 1
            outlinetodjvu "${FILE}" "${TEMPFILE}"
            if [ $? -eq 1 ] ; then
                echo "Při importu záložek se vyskytla chyba" >> /dev/stderr
                return 1
            else
                echo "Pozici a zanoření záložky v obsahu můžete upravit přes akci edit" >> /dev/stderr
            fi
            return $?
        ;;
        *) local TEST=($($0 "${1}" info list))
            local STRING="${TEMPORAR#+([[:blank:]])}"
            local ELEMENT="${STRING%%+([[:blank:]])*}"
            case "${ELEMENT}" in
                xmp) if [ "${RANGE}" == "0" ] ; then
                        if [ "${TEST[0]}" -eq "0" ] ; then
                            local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .ant)
                            log info "From shared_ant –> $i"
                            $0 "${1}" export ant 0 > "${TEMPFILE}"
                            replacexmp
                            #/ Na konci musí být alespoň jedna prázdná linka 
                            echo ""  >> "${TEMPFILE}"
                            anone "Uložit změny?" >> /dev/stderr
                            [ $? -eq 1 ] && return 1
                            cat "${TEMPFILE}" | $0 "${1}" import ant
                        else
                            case "${ACTION}" in
                                set) ${DJVUSED} "${1}" -e 'create-shared-ant ; set-ant' -s
                                    ( $0 "${1}" export ant 0
                                        echo "xmp"
                                        echo -e "\t\"${VALUE}\"\n"
                                    ) | $0 "${1}" import ant
                                ;;
                            esac
                        fi
                    else
                        local PAGES=($(range ${RANGE}))
                        for i in ${PAGES[@]} ; do
                            local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .ant)
                            log info "From page –> $i"
                            $0 "${1}" export ant $i > "${TEMPFILE}"
                            replacexmp
                            #/ Na konci musí být alespoň jedna prázdná linka 
                            echo "" >> "${TEMPFILE}"
                            anone "Uložit změny?" >> /dev/stderr
                            [ $? -eq 1 ] && return 1
                            cat "${TEMPFILE}" | $0 "${1}" import ant
                        done
                    fi
                    return $?
                ;;
                ocr|\
                note|\
                key)
                    local TEMP=(${STRING//+([[:blank:]])/ })
                    case "${TEMP[0]}" in
                        note) local KEY="${TEMP[0]}"
                            local VALUE="${STRING#${TEMP[0]}+([[:blank:]])}"
                            #/ vždy na jednom řádku
                            if [ "${RANGE}" == "0" ] ; then
                                if [ "${TEST[0]}" -eq "0" ] ; then
                                    local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .ant)
                                    log info "From shared_ant –> $i"
                                    $0 "${1}" export ant 0 > "${TEMPFILE}"
                                    replacenote
                                    #/ Na konci musí být alespoň jedna prázdná linka 
                                    echo ""  >> "${TEMPFILE}"
                                    anone "Uložit změny?" >> /dev/stderr
                                    [ $? -eq 1 ] && return 1
                                    cat "${TEMPFILE}" | $0 "${1}" import ant
                                else
                                    case "${ACTION}" in
                                        set) ${DJVUSED} "${1}" -e 'create-shared-ant ; set-ant' -s
                                            ( $0 "${1}" export ant 0
                                                echo -e "${KEY} \"${VALUE}\"\n"
                                            ) | $0 "${1}" import ant
                                        ;;
                                    esac
                                fi
                            else
                                local PAGES=($(range ${RANGE}))
                                for i in ${PAGES[@]} ; do
                                    local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .ant)
                                    log info "From page –> $i"
                                    $0 "${1}" export ant $i > "${TEMPFILE}"
                                    echo "" >> "${TEMPFILE}"
                                    replacenote
                                    #/ Na konci musí být alespoň jedna prázdná linka 
                                    echo "" >> "${TEMPFILE}"
                                    anone "Uložit změny?" >> /dev/stderr
                                    [ $? -eq 1 ] && return 1
                                    cat "${TEMPFILE}" | $0 "${1}" import ant
                                done
                            fi
                        ;;
                        ocr) case "${ACTION}" in
                                set) [ ! ${OCRODJVU} ] && exit 31
                                    echo "Aplikuji OCR na DjVu soubor #${STRING}#" >> /dev/stderr
                                    local VALUE="${STRING#ocr}"
                                    case "${VALUE##+([[:blank:]])}" in
                                        help) ${OCRODJVU} -h
                                        ;;
                                        '') if [ "${RANGE}" == "${RANGE//0/}" ] ; then
                                            log info "Aplikuji OCR u souboru ${1} na rozsah ${RANGE}"
                                            ${OCRODJVU} --in-place --pages "${RANGE}" "${1}"
                                        else
                                            log info "Aplikuji OCR na všechny stránky souboru ${1}"
                                            ${OCRODJVU} --in-place "${1}"
                                        fi
                                        ;;
                                        *) if [ "${RANGE}" == "${RANGE//0/}" ] ; then
                                            log info "Aplikuji OCR u souboru ${1} na rozsah ${RANGE} –> ${VALUE}"
                                            ${OCRODJVU} ${VALUE} --pages "${RANGE}" "${1}"
                                        else
                                            log info "Aplikuji OCR na všechny stránky souboru ${1} –> ${VALUE}"
                                            ${OCRODJVU} ${VALUE} "${1}"
                                        fi
                                        ;;
                                    esac
                                ;;
                                unset)
                                    local PAGES=($(range ${RANGE}))
                                    for i in ${PAGES[@]} ; do
                                        [ "$i" == "0" ] && continue
                                        anone "Opravdu chcete odstranit textovou vrstvu ze stránky č.$i v souboru ${1}?"
                                        [ $? -eq 1 ] && continue
                                        ${DJVUSED} "${1}" -e "select $i ; remove-txt" -s
                                    done
                                ;;
                            esac
                        ;;
                        key) local KEY="${TEMP[1]}"
                            [ "${KEY}" == "xmp" ] && echo "XMP kód se nenastavuje přes key, ale xmp" >> /dev/stderr && return 1
                            [ "${KEY}" == "note" ] && echo "Pro skryté poznámky se nepoužívá key, ale note" >> /dev/stderr && return 1
                            local VALUE="${STRING#${TEMP[0]}+([[:blank:]])${TEMP[1]}+([[:blank:]])}"
                            if [ "${RANGE}" == "0" ] ; then
                                if [ "${TEST[0]}" -eq "0" ] ; then
                                    local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .ant)
                                    log info "From shared_ant –> $i"
                                    $0 "${1}" export ant 0 > "${TEMPFILE}"
                                    case "${ACTION}" in
                                        set) setkey "${TEMPFILE}" "${KEY}" "${VALUE}"
                                        ;;
                                        unset) unsetkey "${TEMPFILE}" "${KEY}" "${VALUE}"
                                        ;;
                                    esac
                                    #/ Na konci musí být alespoň jedna prázdná linka 
                                    echo ""  >> "${TEMPFILE}"
                                    anone "Uložit změny?" >> /dev/stderr
                                    [ $? -eq 1 ] && return 1
                                    cat "${TEMPFILE}" | $0 "${1}" import ant
                                else
                                    case "${ACTION}" in
                                        set) ${DJVUSED} "${1}" -e 'create-shared-ant ; set-ant' -s
                                            ( $0 "${1}" export ant 0
                                                case "${KEY}" in
                                                    note) echo -e "${KEY} \"${VALUE}\"\n"
                                                    ;;
                                                    *) echo "metadata" >> "${TEMPFILE}"
                                                        echo -e "\t${KEY} \"${VALUE}\"\n"
                                                    ;;
                                                esac
                                            ) | $0 "${1}" import ant
                                        ;;
                                    esac
                                fi
                            else
                                local PAGES=($(range ${RANGE}))
                                for i in ${PAGES[@]} ; do
                                    local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .ant)
                                    log info "From page –> $i"
                                    $0 "${1}" export ant $i > "${TEMPFILE}"
                                    case "${ACTION}" in
                                        set) setkey "${TEMPFILE}" "${KEY}" "${VALUE}"
                                        ;;
                                        unset) unsetkey "${TEMPFILE}" "${KEY}" "${VALUE}"
                                        ;;
                                    esac
                                    echo "" >> "${TEMPFILE}"
                                    anone "Uložit změny?" >> /dev/stderr
                                    [ $? -eq 1 ] && return 1
                                    cat "${TEMPFILE}" | $0 "${1}" import ant
                                done
                            fi
                        ;;
                        *) #/ ještě nevím
                            return 1
                        ;;
                    esac
                    return $?
                ;;
                align|\
                background|\
                mode|\
                pfoot|\
                phead|\
                zoom) #/ Metadata co se mohou vyskytovat vždy pouze jednou
                    local KEY="${ELEMENT}"
                    case "${ACTION}" in
                        unset)
                        ;;
                        set)
                            local VALUE="${STRING#${KEY}+([[:blank:]])}"
                            case "${KEY}" in
                                align) case "${VALUE}" in
                                    +(left|center|right)+([[:blank:]])+(top|center|bottom))
                                        ;;
                                        *) log err "align invalid value –> #${VALUE}#"
                                            help set-align
                                            return 1
                                        ;;
                                    esac
                                    ;;
                                background) case "${VALUE}" in
                                        [0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F]) # Mohu nastavit
                                        local VALUE="#${VALUE}"
                                        ;;
                                        *) log err "background invalid value –> ${VALUE}#"
                                            help set-background
                                            return 1
                                        ;;
                                    esac
                                    ;;
                                mode) case "${VALUE}" in
                                        color|bw|fore|black) # Mohu nastavit
                                        ;;
                                        *) log err "mode invalid value –> #${VALUE}#"
                                            help set-mode
                                            return 1
                                        ;;
                                    esac
                                    ;;
                                pfoot|phead) case "${VALUE}" in
                                        '') log err "${KEY} invalid value –> #${VALUE}#"
                                            help set-${KEY}
                                            return 1
                                        ;;
                                        *) echo "Záhlaví a zápatí není ve většině prohlížečů, proto ani nedává smysl ho nastavovat, ale když chcete…"
                                            local VALUE="\"${VALUE}\""
                                        ;;
                                    esac
                                    ;;
                                zoom) case "${VALUE}" in
                                    stretch|one2one|width|page|d+([[:digit:]]))
                                        ;;
                                        *) log err "zoom invalid value –> #${VALUE}#"
                                            help set-zoom
                                            return 1
                                        ;;
                                    esac
                                    ;;
                                *) #/ ještě nevím
                                    return 1
                                    ;;
                            esac
                        ;;
                    esac
                    if [ "${RANGE}" == "0" ] ; then
                        if [ "${TEST[0]}" -eq "0" ] ; then
                            local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .ant)
                            log info "From shared_ant –> $i"
                            $0 "${1}" export ant 0 > "${TEMPFILE}"
                            [ -n "${VALUE}" ] && setmeta "${TEMPFILE}" "${KEY}" "${KEY} ${VALUE}" || setmeta "${TEMPFILE}" "${KEY}"
                            anone "Uložit změny?" >> /dev/stderr
                            [ $? -eq 1 ] && return 1
                            cat "${TEMPFILE}" | $0 "${1}" import ant
                        else
                            if [ -n "${VALUE}" ] ; then
                                ${DJVUSED} "${1}" -e 'create-shared-ant ; set-ant' -s
                                ( $0 "${1}" export ant 0
                                    echo "${KEY} ${VALUE}"
                                ) | $0 "${1}" import ant
                            fi
                        fi
                    else
                        local PAGES=($(range ${RANGE}))
                        for i in ${PAGES[@]} ; do
                            local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .ant)
                            log info "From page –> $i"
                            $0 "${1}" export ant $i > "${TEMPFILE}"
                            [ -n "${VALUE}" ] && setmeta "${TEMPFILE}" "${KEY}" "${KEY} ${VALUE}" || setmeta "${TEMPFILE}" "${KEY}"
                            anone "Uložit změny?" >> /dev/stderr
                            [ $? -eq 1 ] && return 1
                            cat "${TEMPFILE}" | $0 "${1}" import ant
                        done
                    fi
                    return $?
                ;;
                *) # Prvky vyžadující koordináty
                   # link, oval, rect, text, ram, line, arrow a poly
                    local TEMP="${STRING#${ELEMENT}+([[:blank:]])}"
                    # odfiltrováná koordinátů
                    local MESSAGE="${TEMP//+([[:digit:]])+([[:blank:]])+([[:digit:]])+([[:blank:]])/}"
                    local COORDS="${TEMP%${MESSAGE}}"
                    # další parametry následují za dvojtečkou
                    if [[ "${MESSAGE}" =~ ":" ]] ; then
                        mapfile PARAMS < <( object ${MESSAGE##*:+([[:blank:]])} )
                        #object "${MESSAGE##*:+([[:blank:]])}"
                        local MESSAGE="${MESSAGE%+([[:blank:]]):*}"
                    fi
                    if [[ ${MESSAGE:0:1} =~ [0-9] ]] ; then
                        echo "Chyba v počtu koordinátů –> ${MESSAGE}" >> /dev/stderr
                        return 1
                    else
                        # Většina typů ploch může mít pouze 4 souřadnice
                        local TEST=(${COORDS})
                        case "${ELEMENT}" in
                            link|oval|rect|text|ram|line|arrow) [ ${#TEST[@]} -ge 5 ] && help set-${ELEMENT} && return 1
                        esac
                        echo "MESSAGE ${MESSAGE%+([[:blank:]]):*}" >> /dev/stderr
                        echo "COORDS ${COORDS}" >> /dev/stderr
                        printf "%s" "${PARAMS[@]}" >> /dev/stderr
                        #return 0
                        local PAGES=($(range ${RANGE}))
                        for i in ${PAGES[@]} ; do
                            (
                            # co mohu mměnit - buď souřadnice, nebo cílovou message
                            local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .ant)
                            local INCFILE=$(tempfile -d ${TEMPDIR} -s .inc)
                            $0 "${1}" export ant $i > "${TEMPFILE}"
                            case "${ACTION}" in
                                set) (
                                    echo "maparea"
                                    case "${MESSAGE}" in
                                        +([a-Z0-9])\.djvu+([[:blank:]])*)
                                            case "${ELEMENT}" in
                                                arrow) echo "U prvku typu arrow a line odkazy nelze použít, proto link na #${MESSAGE%%+([[:blank:]])*} ignoruji" >> /dev/stderr
                                                    echo -e "\t\"\" \"${MESSAGE#*+([[:blank:]])}\""
                                                    if [ "${ELEMENT}" == "arrow" ] ; then
                                                        echo -e "\tline ${COORDS}"
                                                        echo -e "\tarrow"
                                                        printf "%s" "${PARAMS[@]/_blank}"
                                                    elif [ "${ELEMENT}" == "line" ] ; then
                                                        echo -e "\tline ${COORDS}"
                                                        printf "%s" "${PARAMS[@]/_blank}"
                                                    else
                                                        echo -e "\t${ELEMENT} ${COORDS}"
                                                        printf "%s" "${PARAMS[@]}"
                                                        printf "%s" "${PARAMS[@]/_blank}"
                                                    fi
                                                ;;
                                                *) echo -e "\t\"#${MESSAGE%%+([[:blank:]])*}\" \"${MESSAGE#*+([[:blank:]])}\""
                                                    echo -e "\t${ELEMENT} ${COORDS}"
                                                    #printf "%s" "${PARAMS[@]/_blank}"
                                                    printf "%s" "${PARAMS[@]}"
                                                ;;
                                            esac
                                        ;;
                                        http\:\/\/*) # link na www stránku
                                            case "${ELEMENT}" in
                                                arrow|line) echo "U prvku typu arrow a line odkazy nelze použít, proto link na URL ${MESSAGE%%+([[:blank:]])*} ignoruji" >> /dev/stderr
                                                    echo -e "\t\"\" \"${MESSAGE}\""
                                                    if [ "${ELEMENT}" == "arrow" ] ; then
                                                        echo -e "\tline ${COORDS}"
                                                        echo -e "\tarrow"
                                                        printf "%s" "${PARAMS[@]/_blank}"
                                                    elif [ "${ELEMENT}" == "line" ] ; then
                                                        echo -e "\tline ${COORDS}"
                                                        printf "%s" "${PARAMS[@]/_blank}"
                                                    else
                                                        echo -e "\t${ELEMENT} ${COORDS}"
                                                        printf "%s" "${PARAMS[@]}"
                                                        printf "%s" "${PARAMS[@]/_blank}"
                                                    fi
                                                ;;
                                                *) if [[ "${PARAMS}" =~ "_blank" ]] ; then
                                                        echo -e "\turl \"${MESSAGE%%+([[:blank:]])*}\" \"_blank\" \"${MESSAGE#*+([[:blank:]])}\""
                                                        echo -e "\t${ELEMENT} ${COORDS}"
                                                        printf "%s" "${PARAMS[@]/_blank}"
                                                    else
                                                        echo -e "\t\"${MESSAGE%%+([[:blank:]])*}\" \"${MESSAGE#*+([[:blank:]])}\""
                                                        echo -e "\t${ELEMENT} ${COORDS}"
                                                        printf "%s" "${PARAMS[@]}"
                                                    fi
                                                ;;
                                            esac
                                        ;;
                                        *)  # bez linku
                                            echo -e "\t\"\" \"${MESSAGE}\""
                                            if [ "${ELEMENT}" == "arrow" ] ; then
                                                echo -e "\tline ${COORDS}"
                                                echo -e "\tarrow"
                                                printf "%s" "${PARAMS[@]}"
                                            elif [ "${ELEMENT}" == "line" ] ; then
                                                echo -e "\tline ${COORDS}"
                                                printf "%s" "${PARAMS[@]}"
                                            else
                                                echo -e "\t${ELEMENT} ${COORDS}"
                                                printf "%s" "${PARAMS[@]}"
                                            fi
                                        ;;
                                    esac
                                    echo -e "\n"
                                    ) > "${INCFILE}"
                                    local INC=$(cat "${INCFILE}")
                                    local ADRESA=$(infile "${TEMPFILE}")
                                    case "${ADRESA}" in
                                    +([[:digit:]])\ +([[:digit:]]))
                                            # echo "${ADRESA/ /,}c" >> /dev/stderr
                                            ed "${TEMPFILE}" 2>/dev/null <<-EOF
${ADRESA/ /,}c
${INC}

.
w
q
EOF
                                            echo "" >> "${TEMPFILE}"
                                        ;;
                                        *) echo "${INC}" >> "${TEMPFILE}"
                                            echo "" >> "${TEMPFILE}"
                                        ;;
                                    esac
                                ;;
                                unset) local ADRESA=$(infile "${TEMPFILE}")
                                    case "${ADRESA}" in
                                        +([[:digit:]])\ +([[:digit:]]))
                                            # echo "${ADRESA/ /,}d" >> /dev/stderr
                                            ed "${TEMPFILE}" 2>/dev/null <<-EOF
${ADRESA/ /,}d
w
q
EOF
                                            echo "" >> "${TEMPFILE}"
                                        ;;
                                        *) echo "Pokoušíte se odstranit neexistující položku" >> /dev/stderr
                                        ;;
                                    esac
                                ;;
                            esac
                            #echo "---------"  >> /dev/stderr
                            case ${DEBUG} in
                                -d1|-d3|-d4|-d6|-d7|-d9) cat "${TEMPFILE}" >> /dev/stderr
                            esac
                            anone "Uložit změny?" >> /dev/stderr
                            [ $? -eq 1 ] && return 1
                            cat "${TEMPFILE}" ) | $0 "${1}" import ant
                        done
                    fi
                ;;
        esac
        case ${ACTION} in
            set) echo "Nastavuji informaci pro sdílenou stránku - pozici v obsahu upravte přes akci edit" >> /dev/stderr
        esac
        ;;
    esac
}

# ### <span id="exportimg">exportimg()</span> ([top](#FUNCTIONS))
# Na rozdíl od funkce exportfile, se zde zpracovávají předané parametry
# __$1__ je cesta ke kontejneru ze kterého se exportuje stránka
# __$2__ obsahuje parametry
#
exportimg() {
    log goto "exportimg() $1 –> $2"

    local INTO=$(isformat "${2}")
    if [ -n "${INTO}" ] ; then
        local TEMPORAR="${2#*${INTO}}"
    else
        echo "Cílový formát musí být vždy uveden!" >> /dev/stderr
        return 1
    fi

    local RANGE=$(isrange "${TEMPORAR}")
    if [ -n "${RANGE}" ] ; then
        local TEMPORAR="${TEMPORAR#*${RANGE}}"
    fi

    local CUT=$(iscut "${TEMPORAR}")
    if [ -n "${CUT}" ] ; then
        local TEMPORAR="${TEMPORAR#*${CUT}}"
    fi

    local SCALE=$(isscale "${TEMPORAR}")
    if [ -n "${SCALE}" ] ; then
        [ "${SCALE}" == "false" ] && return 1
        local PARAM=(${SCALE})
        case "${PARAM[$((${#PARAM[@]}-1))]}" in
            -filter=*)
                log info "exportimg()" \
                "Scale use any resize filter –> ${PARAM[$((${#PARAM[@]}-1))]}"
                local TEMPORAR="${TEMPORAR#*${PARAM[$((${#PARAM[@]}-1))]}}"
            ;;
            [0-9]*)
                case ${#PARAM[@]} in
                1) log info "exportimg()" \
                    "Only resize scale –> ${PARAM[$((${#PARAM[@]}-1))]}"
                    local TEMPORAR="${TEMPORAR#*${PARAM[$((${#PARAM[@]}-1))]}}"
                ;;
                2) echo \
                    "Někde je chyba v nastavení škálování –> ${SCALE}" >> /dev/stderr
                    return 1
                ;;
                *) #/ 3 a více položek
                    case "${PARAM[0]}" in
                        -xy*) local TEMPORAR="${TEMPORAR#*${PARAM[0]}}"
                        ;;
                        *) echo \
                            "Někde je chyba v nastavení škálování –> ${SCALE}" >> /dev/stderr
                            return 1
                        ;;
                    esac
                ;;
            esac
            ;;
            *) echo "${PARAM[$((${#PARAM[@]}-1))]}"
            ;;
        esac
    fi
    case "${TEMPORAR:$((${#TEMPORAR}-1)):1}" in
        /) TARGETDIR=$(${REALPATH} -m -P "${TEMPORAR## }")
            log info "targets() Export pages with a original names into –> ${TARGETDIR}"
            [ ! -d "${TARGETDIR}" ] && mkdir -p "${TARGETDIR}"
        ;;
        *) if [[ "${TEMPORAR}" =~ "/" ]] ; then
                #/ obsahuje cestu
                local TEMPORARY=$(${REALPATH} -m -P "${TEMPORAR## }")
                TARGETDIR="${TEMPORARY%/*}"
                TARGETSAMPLE="${TEMPORARY##*/}"
                log info "targets() Export pages a named by sample ${TARGETSAMPLE} –> ${TARGETDIR}"
                [ ! -d "${TARGETDIR}" ] && mkdir -p "${TARGETDIR}"
            else
                #/ jde o vzorek
                TARGETDIR="$(pwd)"
                TARGETSAMPLE="${TEMPORAR## }"
                log info "targets() Export pages a named by sample ${TARGETSAMPLE} into actual directory"
            fi
        ;;
    esac
    echo "RANGE ${RANGE}"
    echo "INTO ${INTO}"
    echo "CUT ${CUT}"
    echo "SCALE ${SCALE}"
    echo "TARGETDIR ${TARGETDIR}"
    echo "TARGETSAMPLE ${TARGETSAMPLE}"
    echo "TEMPORAR ${TEMPORAR}"
    echo "Můžeme přikročit k akci ${FILETYPE}"
    echo "DPI ${DPI}"
    echo "ALG ${ALG[@]}"
    # exit 33
    case ${FILETYPE} in
        pbm|pgm|ppm) log info "exportimg() Export from ${FILETYPE^^}"
            if [ -n "${RANGE}" ] && [ ! ${RANGE} -eq 1 ] ; then
                echo "Formát ${FILETYPE} podporuje pouze jednu stránku" >> /dev/stderr
                return 1
            fi
            local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .pam)
            #/ Nejdřív je třeba obrázek nakopírovat do pracovního prostoru
            cp "${FILE}" "${TEMPFILE}"
            #/ Pak je třeba vyseparovat výchozí masku
            if [ ${#ALG[@]} -gt 1 ] ; then
                cp "${TEMPFILE}" "${TEMPFILE}.in"
                COUNT=1
                for i in ${ALG[@]} ; do
                    separatemask "${TEMPFILE}.in" "${TEMPFILE}.${COUNT}" "$i"
                    while [ ! -f "${TEMPFILE}.${COUNT}" ] ; do
                        sleep 0.1
                    done
                    ${PAMARITH} -divide "${TEMPFILE}" "${TEMPFILE}.${COUNT}" > "${TEMPFILE}.in"
                    COUNT=$((COUNT + 1))
                done
                echo "Je třeba složit ${COUNT} masek"
                case ${COUNT} in
                    1) #/ Pouze jedna maska 
                        echo "Došlo k nějaké chybě při zpracování cyklu!" >> /dev/stderr
                        return 1 
                    ;;
                    *) #/ Více masek
                        #cp "${TEMPFILE}.1" "${TEMPFILE}.in"
                        while [ ! ${COUNT} -eq 2 ] ; do
                            log info "Slučuji ${TEMPFILE}.$((COUNT - 1)) ${TEMPFILE}.$((COUNT - 2))"
                            ${PAMARITH} -and "${TEMPFILE}.$((COUNT - 1))" "${TEMPFILE}.$((COUNT - 2))" > "${TEMPFILE/.pam/.fore}"
                            COUNT=$((COUNT - 1))
                        done
                    ;;
                esac
                log ok "Masky sloučeny"
            else
                separatemask "${TEMPFILE}" "${TEMPFILE/.pam/.fore}" "${ALG}"
            fi
            if [ -n "${CUT}" ] ; then
                #/ Na masku se aplikují vybrané rámečky
                local BOX=( "${CUT//;/ }" )
                echo "${CUT}" >> /dev/stderr
                for i in ${BOX[@]} ; do
                    cutimg "${i}" "${TEMPFILE}"
                done
            fi
            #exit 33
            if [ -n "${TARGETSAMPLE}" ] ; then
                # jedu podle vzorku
                local TARGET="${TARGETDIR}/${TARGETSAMPLE}.${INTO}"
            else
                local TARGET="${TARGETDIR}/${FILE##*/}.${INTO}"
            fi
            case "${INTO}" in
                djvu) #/ V tomto bodě se v případě DjVu provede konverze
                    encodefile ${TEMPFILE} "${TARGET}"
                    # na anglicke texty dává lepší výsledky cuneiform
                ;;
                mask|pbm) #/ Výsledkem je soubor s cílovým názvem, ale příponou pbm
                    if [ -f "${TEMPFILE/.pam/.text}" ] ; then
                        cp "${TEMPFILE/.pam/.text}" "${TARGET/.mask/.pbm}"
                    else
                        cp "${TEMPFILE/.pam/.fore}" "${TARGET/.mask/.pbm}"
                    fi
                ;;
                back) #/ Výsledkem je PNG soubor pozadí s cílovým názvem, a příponou back.png
                    if [ -f "${TEMPFILE/.pam/.text}" ] ; then
                        ${PAMTOPNG} -alpha="${TEMPFILE/.pam/.text}" "${TEMPFILE}" > "${TARGET}.png"
                    else
                        ${PAMTOPNG} -alpha="${TEMPFILE/.pam/.fore}" "${TEMPFILE}" > "${TARGET}.png"
                    fi
                ;;
                png) #/ konvertuji pozadí
                    if [ -n "${SCALE}" ] ; then
                        ${PAMTOPNM} ${TEMPFILE} | ${PAMSCALE} ${SCALE} | ${PAMTOPNG} > "${TARGET}"
                    else
                        ${PAMTOPNG} ${TEMPFILE} > "${TARGET}"
                    fi
                ;;
                jpg|jpeg)
                    if [ -n "${SCALE}" ] ; then
                        ${PAMTOPNM} ${TEMPFILE} | ${PAMSCALE} ${SCALE} | ${PNMTOJPEG} > "${TARGET}"
                    else
                        ${PNMTOJPEG} ${TEMPFILE} > "${TARGET}"
                    fi
                ;;
                jp2)
                    if [ -n "${SCALE}" ] ; then
                        ${PAMTOPNM} ${TEMPFILE} | ${PAMSCALE} ${SCALE} | ${PAMTOJPEG2K} > "${TARGET}"
                    else
                        ${PAMTOJPEG2K} ${TEMPFILE} > "${TARGET}"
                    fi
                ;;
                *) log info "Konverze do výchozího formátu ${FILETYPE} není nutná"
                    cp "${TEMPFILE}" "${TARGET%.}.pam"
                ;;
            esac
        ;;
        jpeg) log info "exportimg() Export from JPEG into ${INTO}"
            #exit 33
            local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .pam)
            if [ -n "${TARGETSAMPLE}" ] ; then
                # jedu podle vzorku
                local TARGET="${TARGETDIR}/${TARGETSAMPLE}.${INTO}"
            else
                local TARGET="${TARGETDIR}/${FILE##*/}.${INTO}"
            fi
            case "${INTO}" in
                djvu) #/ V tomto bodě se v případě DjVu provede konverze
                    encodefile ${TEMPFILE} "${TARGET}"
                    # na anglicke texty dává lepší výsledky cuneiform
                ;;
                mask|pbm) #/ Výsledkem je soubor s cílovým názvem, ale příponou pbm
                    $0 ${FILE} export 1 mask ${TEMPFILE}
                    #if [ -f "${TEMPFILE/.pam/.text}" ] ; then
                    #    cp "${TEMPFILE/.pam/.text}" "${TARGET/.mask/.pbm}"
                    #else
                    #    cp "${TEMPFILE/.pam/.fore}" "${TARGET/.mask/.pbm}"
                    #fi
                ;;
                back) #/ Výsledkem je PNG soubor pozadí s cílovým názvem, a příponou back.png
                    $0 ${FILE} export 1 back ${TEMPFILE}
                ;;
                pnm) echo "POZOR! Při konverzi do PNM formátu dojde ke ztrátě meta informací a tím i k anonymizaci obrázku" >> /dev/stderr
                    ${JPEGTOPNM} -dct float -dumpexif -exif="${TEMPFILE/.pam/.exif}" -repair "${FILE}" > ${TEMPFILE}
                    if [ -n "${SCALE}" ] ; then
                        ${PAMTOPNM} ${TEMPFILE} | ${PAMSCALE} ${SCALE} > "${TARGET}"
                    else
                        cp ${TEMPFILE} "${TARGET}"
                    fi
                ;;
                png) log info "export do PNG"
                    if [ -n "${SCALE}" ] ; then
                        $0 ${FILE} export 1 png ${TEMPFILE}
                    else
                        $0 ${FILE} export 1 png ${TEMPFILE}
                    fi
                ;;
                jpg|jpeg) 
                    if [ -n "${SCALE}" ] ; then
                        $0 ${FILE} export 1 pnm ${TEMPFILE}
                        ${PAMTOPNM} ${TEMPFILE} | ${PAMSCALE} ${SCALE} | ${PNMTOJPEG} > "${TARGET}"
                    else
                        log info "export do výchozího formátu ${FILETYPE} má smysl pouze při přeškálování"
                    fi
                ;;
                jp2)
                    if [ -n "${SCALE}" ] ; then
                        ${PAMTOPNM} ${TEMPFILE} | ${PAMSCALE} ${SCALE} | ${PAMTOJPEG2K} > "${TARGET}"
                    else
                        ${PAMTOJPEG2K} ${TEMPFILE} > "${TARGET}"
                    fi
                ;;
                *) log info "Konverze do výchozího formátu ${FILETYPE} má smysl pouze při škálování"
                    return 1
                ;;
            esac
        ;;
        png)   log info "exportimg() Export from PNG"
            case "${INTO}" in
                images) echo "Parametr použitelný pouze u PDF - exportují se obrázky místo stránek" >> /dev/stderr
                    return 1
                ;;
                ocr) echo "TODO Aplikace OCR na konverovaný originální soubor" >> /dev/stderr
                ;;
                txt|text) echo "Parametr použitelný pouze u PDF - exportují se text místo stránky" >> /dev/stderr
                    return 1
                ;;
                *)
                    log info "exportimg() Original file is exported from container without conversion"
                    local PAGES=($(range "${RANGE}"))
                    local LISTPAGES=($(listpng "${FILE}"))
                    #/ echo "${LISTPAGES[-1]}"
                    #/ echo "${PAGES[@]}"
                    for i in ${PAGES[@]} ; do
                        local PAGE="${LISTPAGES[$((i-1))]}"
                        case "${INTO}" in
                            png|orig*)
                                if [ -n "${TARGETSAMPLE}" ] ; then
                                    # jedu podle vzorku
                                    local TEMPORAR=$(printf "${TARGETSAMPLE}" $i)
                                    local TARGET="${TARGETDIR}/${TEMPORAR// /0}.png"
                                else
                                    local TARGET="${TARGETDIR}/${PAGE}.png"
                                fi
                                local TEMPFILE=$(tempfile)
                                if [ -n "${SCALE}" ] ; then
                                    local FORSCALE=$(tempfile)
                                    $(itempng "${FILE}" "${PAGE}" > "${FORSCALE}")
                                    pamscale ${SCALE} ${FORSCALE} > ${TEMPFILE}
                                    rm ${FORSCALE}
                                else
                                    $(itempng "${FILE}" "${PAGE}" > "${TEMPFILE}")
                                fi
                                convertovergimp png "${TEMPFILE}"
                                mv -i "${TEMPFILE}.png" "${TARGET}"
                                [ -f "${TEMPFILE}" ] && rm "${TEMPFILE}"
                            ;;
                            mask|pbm)
                                if [ -n "${TARGETSAMPLE}" ] ; then
                                    # jedu podle vzorku
                                    local TEMPORAR=$(printf "${TARGETSAMPLE}%d" $i)
                                    local TARGET="${TARGETDIR}/${TEMPORAR// /0}.${INTO}"
                                else
                                    local TARGET="${TARGETDIR}/${PAGE}.${INTO}"
                                fi
                                local TEMPFILE=$(tempfile)
                                if [ -n "${SCALE}" ] ; then
                                    local FORSCALE=$(tempfile)
                                    $(itempng "${FILE}" "${PAGE}" > "${FORSCALE}")
                                    pamscale ${SCALE} ${FORSCALE} | ${PPMTOPGM} | ${PGMTOPBM} | ${PNMTOPLAINPNM} > ${TEMPFILE}
                                    rm ${FORSCALE}
                                else
                                    $(itempng "${FILE}" "${PAGE}" | ${PPMTOPGM} | ${PGMTOPBM} | ${PNMTOPLAINPNM}> "${TEMPFILE}")
                                fi
                                case "${INTO}" in
                                    mask|pbm)
                                        log info "Move ${TEMPFILE} –> ${TARGET}" >> /dev/stderr
                                            mv -i "${TEMPFILE}" "${TARGET}"
                                        ;;
                                    *) echo "Unsupported format –> ${INTO}" >> /dev/stderr
                                            return 1
                                    ;;
                                esac
                                [ -f "${TEMPFILE}" ] && rm "${TEMPFILE}"
                            ;;
                                pnm|pam)
                                    if [ -n "${TARGETSAMPLE}" ] ; then
                                        # jedu podle vzorku
                                        local TEMPORAR=$(printf "${TARGETSAMPLE}" $i)
                                        local TARGET="${TARGETDIR}/${TEMPORAR// /0}.${INTO}"
                                    else
                                        local TARGET="${TARGETDIR}/${PAGE}.${INTO}"
                                    fi
                                    local TEMPFILE=$(tempfile)
                                    if [ -n "${SCALE}" ] ; then
                                        local FORSCALE=$(tempfile)
                                        $(itempng "${FILE}" "${PAGE}" > "${FORSCALE}")
                                        pamscale ${SCALE} ${FORSCALE} > ${TEMPFILE}
                                        rm ${FORSCALE}
                                    else
                                        $(itempng "${FILE}" "${PAGE}" > "${TEMPFILE}")
                                    fi
                                    case "${INTO}" in
                                        pnm|pam)
                                            log info "Move ${TEMPFILE} –> ${TARGET}" >> /dev/stderr
                                            mv -i "${TEMPFILE}" "${TARGET}"
                                        ;;
                                        *) echo "Unsupported format –> ${INTO}" >> /dev/stderr
                                            return 1
                                        ;;
                                    esac
                                    [ -f "${TEMPFILE}" ] && rm "${TEMPFILE}"
                                ;;
                                *) echo "U XCF souborů je třeba uvést typ cílového souboru" >> /dev/stderr
                                    return 1
                                ;;
                            esac
                        done
                ;;
            esac
        ;;
        pdf)  log info "exportimg() Export from PDF"
            case "${INTO}" in
                images) log info "exportuji pouze obrázky z ředaného rozsahu"
                ;;
                ocr) log info "exportuji stránku jako obrázek a aplikuji OCR"
                ;;
                txt|text) log info "exportuji stránku jako text"
                ;;
                pdf) 
                    if [ -n "${TARGETSAMPLE}" ] ; then
                        # jedu podle vzorku
                        local TEMPORAR=$(printf "${TARGETSAMPLE}" $i)
                        local TARGET="${TARGETDIR}/${TARGETSAMPLE}_${RANGE}.pdf"
                    else
                        local TARGET="${TARGETDIR}/${FILE##*/}"
                        pdftopdf "${FILE}" "${TARGET/.pdf/${RANGE}}.pdf"
                    fi
                ;;
                *) if [ "${INTO}" == "" ] ; then
                        echo "Neuvedený formát. " >> /dev/stderr
                        if [ -n "${TARGETSAMPLE}" ] ; then
                            # jedu podle vzorku
                            local TEMPORAR=$(printf "${TARGETSAMPLE}" $i)
                            local TARGET="${TARGETDIR}/${TEMPORAR// /0}.${INTO}"
                        else
                            local TARGET="${TARGETDIR}/${FILE##*/}"
                            pdftopdf "${FILE}" "${TARGET/.pdf/_${RANGE}}.pdf"
                        fi
                    else
                        echo "Unsupported format –> ${INTO}" >> /dev/stderr
                        return 1
                    fi
                ;;
            esac
        ;;
        gimp|xcf) log info "exportimg() Export from XCF"
            case "${INTO}" in
                images) echo "Parametr použitelný pouze u PDF - exportují se obrázky místo stránek" >> /dev/stderr
                    return 1
                ;;
                ocr) echo "TODO Aplikace OCR na konverovaný originální soubor" >> /dev/stderr
                ;;
                txt|text) echo "Parametr použitelný pouze u PDF - exportují se text místo stránky" >> /dev/stderr
                    return 1
                ;;
                *)
                    log info "exportimg() Original file is exported from container without conversion"
                    local PAGES=($(range "${RANGE}"))
                    local LISTPAGES=($(listxcf "${FILE}"))
                    #/ echo "${LISTPAGES[-1]}"
                    #/ echo "${PAGES[@]}"
                    for i in ${PAGES[@]} ; do
                        local PAGE="${LISTPAGES[$((i-1))]}"
                        case "${INTO}" in
                            xcf|orig*)
                                if [ -n "${TARGETSAMPLE}" ] ; then
                                    # jedu podle vzorku
                                    local TEMPORAR=$(printf "${TARGETSAMPLE}" $i)
                                    local TARGET="${TARGETDIR}/${TEMPORAR// /0}.xcf"
                                else
                                    local TARGET="${TARGETDIR}/${PAGE}.xcf"
                                fi
                                local TEMPFILE=$(tempfile)
                                if [ -n "${SCALE}" ] ; then
                                    local FORSCALE=$(tempfile)
                                    $(itemxcf "${FILE}" "${PAGE}" > "${FORSCALE}")
                                    pamscale ${SCALE} ${FORSCALE} > ${TEMPFILE}
                                    rm ${FORSCALE}
                                else
                                    $(itemxcf "${FILE}" "${PAGE}" > "${TEMPFILE}")
                                fi
                                convertovergimp xcf "${TEMPFILE}"
                                mv -i "${TEMPFILE}.xcf" "${TARGET}"
                                [ -f "${TEMPFILE}" ] && rm "${TEMPFILE}"
                            ;;
                                pnm|pam)
                                    if [ -n "${TARGETSAMPLE}" ] ; then
                                        # jedu podle vzorku
                                        local TEMPORAR=$(printf "${TARGETSAMPLE}" $i)
                                        local TARGET="${TARGETDIR}/${TEMPORAR// /0}.${INTO}"
                                    else
                                        local TARGET="${TARGETDIR}/${PAGE}.${INTO}"
                                    fi
                                    local TEMPFILE=$(tempfile)
                                    if [ -n "${SCALE}" ] ; then
                                        local FORSCALE=$(tempfile)
                                        $(itemxcf "${FILE}" "${PAGE}" > "${FORSCALE}")
                                        pamscale ${SCALE} ${FORSCALE} > ${TEMPFILE}
                                        rm ${FORSCALE}
                                    else
                                        $(itemxcf "${FILE}" "${PAGE}" > "${TEMPFILE}")
                                    fi
                                    case "${INTO}" in
                                        pnm|pam)
                                            mv -i "${TEMPFILE}" "${TARGET}"
                                        ;;
                                        *) echo "Unsupported format –> ${INTO}" >> /dev/stderr
                                            return 1
                                        ;;
                                    esac
                                    [ -f "${TEMPFILE}" ] && rm "${TEMPFILE}"
                                ;;
                                *) echo "U XCF souborů je třeba uvést typ cílového souboru" >> /dev/stderr
                                    return 1
                                ;;
                            esac
                        done
                ;;
            esac
        ;;
        zip|tar) log info "exportimg() Export from archive"
            case "${INTO}" in
                images) echo "Parametr použitelný pouze u PDF - exportují se obrázky místo stránek" >> /dev/stderr
                    return 1
                ;;
                ocr) echo "TODO Aplikace OCR na konverovaný originální soubor" >> /dev/stderr
                ;;
                txt|text) echo "Parametr použitelný pouze u PDF - exportují se text místo stránky" >> /dev/stderr
                    return 1
                ;;
                *) local PAGES=($(range "${RANGE}"))
                    local LISTPAGES=($(listzip "${FILE}"))
                    #echo "${LISTPAGES[-1]}"
                    #echo "${PAGES[@]}"
                    for i in ${PAGES[@]} ; do
                        local PAGE="${LISTPAGES[$((i-1))]}"
                        case "${INTO}" in
                            pnm|pam|png|jpg|tiff|jp2) local SUFFIX="${PAGE##*.}"
                                case ${SUFFIX} in
                                    jp2) $(itemzip "${FILE}" "${PAGE}" |\
                                        ${JPEG2KTOPAM} > "${TEMPFILE}")
                                    ;;
                                    jpg) $(itemzip "${FILE}" "${PAGE}" |\
                                        ${JPEGTOPNM} > "${TEMPFILE}")
                                    ;;
                                    png) $(itemzip "${FILE}" "${PAGE}" |\
                                        ${PNGTOPNM} > "${TEMPFILE}")
                                    ;;
                                    tiff) $(itemzip "${FILE}" "${PAGE}" |\
                                        ${TIFFTOPNM} > "${TEMPFILE}")
                                    ;;
                                    *) echo "Nepodporovaný formát ${SUFFIX}"
                                        return 1
                                    ;;
                                esac
                                if [ -n "${TARGETSAMPLE}" ] ; then
                                    # jedu podle vzorku
                                    local TEMPORAR=$(printf "${TARGETSAMPLE}" $i)
                                    local TARGET="${TARGETDIR}/${TEMPORAR// /0}.${INTO}"
                                else
                                    local TEMPORAR="${PAGE#*/}"
                                    local TARGET="${TARGETDIR}/${TEMPORAR%.*}.${INTO}"
                                fi
                                case ${INTO} in
                                    jp2) if [ -n "${SCALE}" ] ; then
                                            $(${PAMTOPNM} ${TEMPFILE} |\
                                                ${PAMSCALE} ${SCALE} |\
                                                ${PAMTOJPEG2K} > "${TARGET}")
                                        else
                                            $(${PAMTOPNM} ${TEMPFILE} |\
                                                ${PAMTOJPEG2K} > "${TARGET}")
                                        fi
                                    ;;
                                    jpg)if [ -n "${SCALE}" ] ; then
                                            $(${PAMTOPNM} ${TEMPFILE} |\
                                                ${PAMSCALE} ${SCALE} |\
                                                ${PNMTOJPEG} > "${TARGET}")
                                        else
                                            $(${PAMTOPNM} ${TEMPFILE} |\
                                                ${PNMTOJPEG} > "${TARGET}")
                                        fi
                                    ;;
                                    tiff) if [ -n "${SCALE}" ] ; then
                                            $(${PAMTOPNM} ${TEMPFILE} |\
                                                ${PAMSCALE} ${SCALE} |\
                                                ${PAMTOTIFF} > "${TARGET}")
                                        else
                                            $(${PAMTOPNM} ${TEMPFILE} |\
                                                ${PAMTOTIFF} > "${TARGET}")
                                        fi
                                    ;;
                                    png) if [ -n "${SCALE}" ] ; then
                                            $(${PAMTOPNM} ${TEMPFILE} |\
                                                ${PAMSCALE} ${SCALE} |\
                                                ${PAMTOPNG} > "${TARGET}")
                                        else
                                            $(${PAMTOPNM} ${TEMPFILE} |\
                                                ${PAMTOPNG} > "${TARGET}")
                                        fi
                                    ;;
                                    pnm|pam) if [ -n "${SCALE}" ] ; then
                                            $(${PAMTOPNM} ${TEMPFILE} |\
                                                ${PAMSCALE} ${SCALE} > "${TARGET}")
                                        else
                                            $(${PAMTOPNM} ${TEMPFILE} > "${TARGET}")
                                        fi
                                    ;;
                                esac
                                echo "Page $i saved as ${TARGET}" >> /dev/stderr
                                ;;
                            *) local SUFFIX="${PAGE##*.}"
                                if [ -n "${TARGETSAMPLE}" ] ; then
                                    # jedu podle vzorku
                                    local TEMPORAR=$(printf "${TARGETSAMPLE}" $i)
                                    local TARGET="${TARGETDIR}/${TEMPORAR// /0}.${SUFFIX}"
                                else
                                    local TARGET="${TARGETDIR}/${PAGE#*/}"
                                fi
                                if [ -n "${SCALE}" ] ; then
                                    anone "Při přeškálování do původního formátu dojde k degradaci kvality obrazu mám pokračovat?"
                                    [ $? -eq 1 ] && return 1
                                    case ${SUFFIX} in
                                        jp2) $(itemzip "${FILE}" "${PAGE}" |\
                                                ${JPEG2KTOPAM} |\
                                                ${PAMSCALE} ${SCALE} |\
                                            ${PAMTOJPEG2K} > "${TARGET}")
                                        ;;
                                        jpg) $(itemzip "${FILE}" "${PAGE}" |\
                                            ${JPEGTOPNM} |\
                                            ${PAMSCALE} ${SCALE} |\
                                            ${PNMTOJPEG} > "${TARGET}")
                                        ;;
                                        png) $(itemzip "${FILE}" "${PAGE}" |\
                                            ${PNGTOPNM} |\
                                            ${PAMSCALE} ${SCALE} |\
                                            ${PAMTOPNG} > "${TARGET}")
                                        ;;
                                        tiff) $(itemzip "${FILE}" "${PAGE}" |\
                                            ${TIFFTOPNM} |\
                                            ${PAMSCALE} ${SCALE} |\
                                            ${PAMTOTIFF} > "${TARGET}")
                                        ;;
                                    esac
                            else
                                log info "exportimg() Original file ${PAGE} is exported from container without conversion"
                                $(itemzip "${FILE}" "${PAGE}" > "${TARGET}")
                            fi
                            echo "Page $i saved as ${TARGET}" >> /dev/stderr
                            ;;
                        esac
                    done
                ;;
            esac
        ;;
    esac
    return 0
}

# ### <span id="exportfile">exportfile()</span> ([top](#FUNCTIONS))
# Funkce exportuje ze souboru stránky jako obrázky.
# Vstupními parametry jsou globální proměnné:
# * FILE - Soubor ze kterého se stránka exportuje.
# * CHARSTRING - Proměnná, která obsahuje další parametry:
# ** Rozsah exportovaných stránek. Není-li uveden, budou exportovány
#    všechny stránky ze souboru.
# ** Formát cílového souboru
# ** Velikost cílového souboru, nastavená buď formou XxY, nebo procetuálně Z%
#
# Místo parametrů může být také předána také cesta k souboru, ve kterém
# mohou být parametry nastaveny specificky pro každou stránku (rozsah)
# zvlášť. Tento soubor __musí__ mít příponu `.list`
#
# Za parametry, nebo cestou k souboru s příponou `.list` může následovat
# cílový adresář, resp. vzor pro pojmenování stránek
#
#     example/example
#
# Při exportu jpeg souborů z archívu uloží do podadresáře example
# exportované stránky pod názvy: example_00001.jpg, example_00002.jpg, …
#
# #### export
# Operace export slouží k extrakci stránek (vrstev)
# z formátů, které mohou obsahovat více stránek, případně
# k jejich transormaci na jiný rozměr či konverzi do
# jiného formát. Viz příklad:
#
#      djvutool soubor.jpg export 1 jpg 30%
#
# Vygeneruje JPEG obrázek s názvem soubor_30%.jpg jehož
# obsahem bude původní obrázek, zmenšený na 30% velikost
#
# U kontejnerů, které mají uloženy v sobě obrázky,
# lze provést export pouze s uvedením rozsahu. Cílové
# soubory se pak budou jmenovat stejně, jako v archívu:
#
# djvutool soubor.zip export 2-7
# 
# U formátů s podporou více stránek, které mají
# uložen název vrstvy či stránky, je vhodné uvést
# cílový formát souboru. Jméno cílového souboru pak
# bude stejné jako název příslušné vrstvy či stránky:
# 
# djvutool soubor.xcf export 2-7
#
# V případě PDF souborů, které mohou obsahovat mix textu
# a obrázků volbou přípony sdělíte, že chcete vyexportovat
# pouze obrázky:
#
# djvutool soubor.pdf export 1 jpg
#
# V tomto případě se budou jmenovat soubory bůhví jak.
# Je tedy v tomto případě žádoucí uvést případně jméno
# a případně i výchozí cestu:
#
# djvutool soubor.pdf export 1 jpg 30% example/
#
# V tomto případě se obrázky nasypou do adresáře example.
# Pokud neexistuje, tak se založí.
#
#  djvutool soubor.pdf export 1 jpg 30% example
#
# Pokud nekončí řádek lomítkem, použije se celý zbytek
# řetězce jako výchozí vzor pro pojmenování stránky
# (obrázku) cílový soubor se tedy bude v tomto případě
# jmenovat example_30%_001.jpg
exportfile() {
    log goto "exportfile() ${FILE} –> ${CHARSTRING}"
    if [[ "${CHARSTRING}" =~ "?" ]] ||\
        [[ "${CHARSTRING}" =~ "-h" ]] ||\
        [[ "${CHARSTRING}" =~ "help" ]] ; then
        help bitmap-export
    elif [[ "${CHARSTRING}" =~ ".list" ]] ; then
        local SOURCE=$(${REALPATH} -m -P "${CHARSTRING%.list*}.list" 2>/dev/null)
        if [ -f "${SOURCE}" ] ; then
            log info "exportfile() Read params from –> ${SOURCE}"
            local TARGET="${CHARSTRING#*.list}"
            while read line ; do
                CHARSTRING="$line ${TARGET}"
                exportimg "${FILE}" "${CHARSTRING}"
            done < "${SOURCE}"
        else
            return 1
        fi
    else
        exportimg "${FILE}" "${CHARSTRING}"
    fi
    return $?
}

# ### <span id="viewdjvu">viewdjvu()</span> ([top](#FUNCTIONS))
# Funkce se volá při akci view, když si chci prohlédnout DjVu soubor
viewdjvu() {
     log info "View –> ${FILE}"
    (${DJVIEW} "${FILE}" &)
}

# ### <span id="imgview">imgview()</span> ([top](#FUNCTIONS))
# Funkce se volá při akci view, když si chceš prohlédnout bitmapový 
# obrázek
imgview() {
    log info "imgview() open –> ${FILE}"
    case ${FILETYPE} in
        pnm|ppm|pgm|pbm|pam|\
        png|jpg|jpeg|bmp|gif|tiff) if [ -n "${FEH}" ] ; then
                local TEMPORARY=($(parsecut $(xrandr | grep '[ ]connected' | head -1 | cut -d' ' -f3)))
                echo "${TEMPORARY[@]}" >> /dev/stderr
                local W=$(( ${TEMPORARY[0]} / 2 ))
                local H=$(( ${TEMPORARY[1]} / 2 ))
                local X=50
                local Y=50
                echo "${W}x${H}+${X}+${Y}" >> /dev/stderr
                ${FEH} --scale-down --auto-zoom --geometry "${W}x${H}+${X}+${Y}" "${FILE}"
            else
                ${GEEQIE} "${FILE}"
            fi
        ;;
        plain|jpeg-2000) local TEMPFILE="${TEMPDIR}/${FILE##*/}"
            ${JPEG2KTOPAM} ${FILE} > ${TEMPFILE}
            #opj_decompress -i ${FILE} -o ${TEMPFILE} -l 1
            ls -alh ${TEMPFILE}
            exiftool ${TEMPFILE}
            $0 ${TEMPFILE} view
        ;;
#        gimp|pdf|xcf|eps|psd|tga|ps)
#            ${GIMP} "${FILE}"
#        ;;
        gimp) isrange ${CHARSTRING}
            if [ $? -eq 0 ] ; then
                local PAGES=($(range "${CHARSTRING}"))
                local LISTPAGES=($(listxcf "${FILE}"))
                #echo "${LISTPAGES[-1]}"
                #echo "${PAGES[@]}"
                for i in ${PAGES[0]} ; do
                    local PAGE="${LISTPAGES[$((i-1))]}"
                    $(itemxcf "${FILE}" "${PAGE}" > "${TEMPDIR}/${PAGE##*/}.pam")
#                    exit 33
                    $0 view "${TEMPDIR}/${PAGE##*/}.pam"
                done
            else
                echo "V případě xcf souboru musí být uvedeno číslo stránky" >> /dev/stderr
                return 1
            fi
        ;;
        zip) isrange ${CHARSTRING}
            if [ $? -eq 0 ] ; then
                local PAGES=($(range "${CHARSTRING}"))
                local LISTPAGES=($(listzip "${FILE}"))
                #echo "${LISTPAGES[-1]}"
                #echo "${PAGES[@]}"
                for i in ${PAGES[0]} ; do
                    local PAGE="${LISTPAGES[$((i-1))]}"
                    $(itemzip "${FILE}" "${PAGE}" > "${TEMPDIR}/${PAGE##*/}")
                    $0 view "${TEMPDIR}/${PAGE##*/}"
                done
            else
                echo "V případě kontejneru musí být uvedeno číslo stránky" >> /dev/stderr
                return 1
            fi
        ;;
        *) echo "Nepodporovaný formát ${FILETYPE}" >> /dev/stderr
            return 1
        ;;
    esac
}

# ### <span id="imginfo">imginfo()</span> ([top](#FUNCTIONS))
# Funkce vypisuje info o bitmapových souborech a případně vicestránkových
# formátů i jejich stránkách.
# Vstupními parametry jsou globální proměnné:
# * FILE - Soubor ze kterého se stránka exportuje.
# * CHARSTRING - Proměnná, která obsahuje další parametry:
# ** typ zobrazované informace
# ** a případně číslo konkrétní stránky (vrstvy)
imginfo() {
    log goto "imginfo() ${FILE} –> ${CHARSTRING}"
    if [[ "${CHARSTRING}" =~ "?" ]] ||\
        [[ "${CHARSTRING}" =~ "-h" ]] ||\
        [[ "${CHARSTRING}" =~ "help" ]] ; then
        help bitmap-info
    else
        case ${FILETYPE} in
            gif) # GIF je grafický formát, s bezztrátovou kompresí, který
                # má podporu pro animace.
                # Je omezený především v tom, že má k dispozici pouze 256
                # barev. Za určitých okolností může fungovat i jako
                # kontejner pro více stránkové dokumenty (co vrstva, to stránka).
                #
                # Výhodou GIF formátu oproti MNG či (AP)NG je především
                # to, že má širokou podporu u webových prohlížečů. Proto
                # se vyžívá především pro náhledy vícestránkových dokumentů.
                # Kdy se náhledy vybraných stránek, uložené jako jednotlivé
                # snímky přehrávají v nekonečné smyčce.
                # Počet snímků (stránek) udává exif tag 'Animation frames'
                #
                # .gif
                case ${CHARSTRING} in
                    meta*) ${EXIFTOOL} "${FILE}"
                    ;;
                    pages) echo "Zjistit počet vrstev"
                    ;;
                    *) local INFO=($(cat "${FILE}"|infoitem))
                        echo "${INFO[@]}"
                    ;;
                esac
            ;;
            jpg|jpeg) # JPEG je grafický formát se ztrátovou kompresí, který
                # podporuje pouze jednu vrstvu
                #
                # .jpg, .jpeg, .jpe, .jif, .jfif, .jfi
                case ${CHARSTRING} in
                    meta*) ${EXIFTOOL} "${FILE}"
                    ;;
                    pages) echo "1"
                    ;;
                    *) local INFO=($(cat "${FILE}"|infoitem))
                        echo "${INFO[@]}"
                    ;;
                esac
            ;;
            jpeg-2000) # JPEG 2000 je grafický formát, který pracuje se
                # ztrátovou, ale i bezeztrátovou wavelet kompresí. To je
                # klíčovým rozdílem oproti DjVu, protože u DjVu z principu
                # vždy dojde k částečné ztrátě grafické informace.
                # Oproti bezeztrátovému PNG má lepší kompresní poměr. A
                # při ztrátové kompresi je výsledek po dekompresi vždy
                # lepší než u JPEG formátu.
                # Nevýhodou je zdlouhavá dekomprese a tím i pomalejší
                # zobrazování v prohlížeči. Proto se využívá především
                # pro archivaci původního skenu.
                #
                # Nepodporuje více vrstev! Proto se naskenované soubory
                # obvykle zabalí do `.zip` kontejneru
                #
                # .jp2, .j2k, .jpf, .jpx, .jpm, .mj2
                case ${CHARSTRING} in
                    meta*) ${EXIFTOOL} "${FILE}"
                    ;;
                    pages) echo "1"
                    ;;
                    *) local INFO=($(cat "${FILE}"|infoitem))
                        echo "${INFO[@]}"
                    ;;
                esac
            ;;
            pnm|pgm|pbm|ppm) # Formát se kterým přišel projekt Netpbm.
                # Nepodporuje více vrstev!!!
                # PNM formát (portable anymap) zastupuje následující formáty:
                # * PBM - portable bitmap (černobílé obrázky)
                #   V hlavičce má P1 (P4 - binární formát)
                # * PGM - portable graymap (obrázky ve stupních šedi)
                #   V hlavičce má P2 (P5 - binární formát)
                # * PPM - portable pixmap (RGB obrázky)
                #   V hlavičce má P3 (P6 - binární formát)
                # * PAM - portable anymap, zastupuje podobně jako PNM
                #   všechny formáty a v má hlavičce P7. Je schopen zachytit
                #   barvy stejně jako CMYK
                #
                # Rozdíly jsou především v podpoře bitové hloubky barev:
                # 48-bitů podporuje pouze PPM (rgb48be)
                # 32-bitů podporuje plain PNM a plain PAM - binární verze nikoliv!!!
                # 24-bitová podopora je u všech formátů
                # 16-bitů PGM a PAM bez průhlednosti (grap16be)
                #
                # https://en.wikipedia.org/wiki/Netpbm_format
                case ${CHARSTRING} in
                    meta*) ${EXIFTOOL} "${FILE}"
                    ;;
                    pages) echo "1"
                    ;;
                    *) local INFO=($(cat "${FILE}"|infoitem))
                        echo "${INFO[@]}"
                    ;;
                esac
            ;;
            mng) # MNG je formát pro animace, založený na PNG, podobně
                # jako (A)PNG. Není moc rozšířený.
                # Počet vrstev udává v exifu 'Animation frames'
                #
                # .mng
                case ${CHARSTRING} in
                    meta*) ${EXIFTOOL} "${FILE}"
                    ;;
                    pages) local SUMPAGES=$(${IDENTIFY} "${FILE}" | wc -l)
                        echo "${SUMPAGES}"
                    ;;
                    *) local INFO=($(cat "${FILE}"|infoitem))
                        local SUMPAGES=$(${IDENTIFY} "${FILE}" | wc -l)
                        echo "${INFO[@]} ${SUMPAGES}"
                    ;;
                esac
            ;;
            png) # PNG je formát, u kterého se původně vůbec nepočítalo,
                # že by mohl mít více než jednu vrstvu. Protože ale formát
                # GIF, který animace podporuje, má svá omezení (nepodporuje
                # průhlednost a má k dispozici pouze 256 barev), vzniklo
                # jako alternativa APNG – což je svým způsobem video
                # kontejner, který obsahuje řadu po sobě jdoucích PNG obrázků.
                #
                # Oproti podobnému MNG formátu však umožňuje zpětnou
                # kompatibilitu, kdy se v prohlížečích co animace nepodporují,
                # zobrazuje pouze první snímek. Soubory mají stejnou příponu
                # .png, jako klasické PNG
                #
                # Počet vrstev udává exif tag 'Animation frames'
                #
                # .png
                case ${CHARSTRING} in
                    meta*) ${EXIFTOOL} "${FILE}"
                    ;;
                    pages) echo "Zjistit počet vrstev"
                    ;;
                    *) local INFO=($(cat "${FILE}"|infoitem))
                        echo "${INFO[@]}"
                    ;;
                esac
            ;;
            gimp|xcf) # Nativní formát Gimpu může mít více vrstev
                case ${CHARSTRING} in
                    meta*)  ${EXIFTOOL} "${FILE}"
                    ;;
                    pages\ +([0-9])|pages\ all|pages)
                        local TEMPORAR=(${CHARSTRING})
                        case ${TEMPORAR[1]} in
                            all) ${XCFINFO} -u "${FILE}"
                            ;;
                            +([0-9])) ${XCFINFO} -u "${FILE}" | \
                                grep -m ${TEMPORAR[1]} '^+.*RGB.*Normal' | \
                                tail -1
                            ;;
                            *) local SUMPAGES=$(${XCFINFO} "${FILE}" | wc -l)
                                echo "${SUMPAGES}"
                            ;;
                        esac
                    ;;
                    *) local INFO=($(cat "${FILE}"|infoitem))
                        local SUMPAGES=$(${XCFINFO} "${FILE}" | wc -l)
                        echo "${INFO[@]} ${SUMPAGES}"
                    ;;
                esac
            ;;
            tiff) # Formát TIFF může mít více stránek
                case ${CHARSTRING} in
                    meta*) ${EXIFTOOL} "${FILE}"
                    ;;
                    pages) local SUMPAGES=$(${TIFFINFO} "${FILE}" | grep "TIFF Directory" | wc -l)
                        echo "${SUMPAGES}"
                    ;;
                    *) local INFO=($(cat "${FILE}"|infoitem))
                        local SUMPAGES=$(${TIFFINFO} "${FILE}" | grep "TIFF Directory" | wc -l)
                        echo "${INFO[@]} ${SUMPAGES}"
                    ;;
                esac
            ;;
            stl|pcd) # PCD je rastrový formát fy. Kodak
                # Starší formát, pro jehož konverzi lze použít ImageMagick,
                # ale lepší výsledky dává již delší dobu neudržovaná konverzní
                # utilita pcdtojpeg.
                # http://pcdtojpeg.sourceforge.net/Download.html
                #
                # Formát je podobný formátu Tiled Multi-Resolution TIFF
                # …
                # Obrázek je v kontejneru uložen v 6
                # velikostech:
                # Suffix [1] produces an image 192 by 128 ("Base/16")
                # Suffix [2] produces an image 384 by 256 ("Base/4")
                # Suffix [3] produces an image 768 by 512 ("Base")
                # Suffix [4] produces an image 1536 by 1024 ("4 Base")
                # Suffix [5] produces an image 3072 by 2048 ("16 Base")
                # Suffix [6] produces an image 6144 by 4096 ("64 Base")
                #
                # Poznámka: Když použijete číslo 7 a vyšší tak to má stejný
                # efekt jako když se použije 6
                #
                # Při konverzi vychází obrázek moc tmavý to lze pořešit buď
                # nastavením barevného profilu, nebo gammy
                # Resolutin
                # Contrast
                # Saturation
                # Red
                # Green
                # Nepodporuje více stránek
                #
                # https://en.wikipedia.org/wiki/Photo_CD
                case ${CHARSTRING} in
                    meta*) ${EXIFTOOL} "${FILE}"
                    ;;
                    pages) echo "1"
                    ;;
                    *) local INFO=($(cat "${FILE}"|infoitem))
                        echo "${INFO[@]}"
                    ;;
                esac
            ;;
            psd|psb) # Proprietární formát Photoshopu
                # PSB je PSD rozšířené na podporu obrázků o velikosti
                # 300 tis. pixelů. Standardní PSD podporuje max. 30 tis.
                # pixelů. Pracuje s vrstvami
                # .psd .psb
            ;;
            pdf) # PDF - portable document format, je do učité míry
                # alternativou k DjVu. Nebyl ale navržen pro rychlé
                # prohlížení (jako DjVu) ale pro lepší přenositelnost mezi
                # operačními systémy. Z toho plynou i jeho nevýhody.
                # Především zdlouhavá dekomprese.
                #
                # Z principu má podporu pro více stránek
                case ${CHARSTRING} in
                    meta*) pdfinfo -box "${FILE}"
                    ;;
                    *) local INFO=($(cat "${FILE}"|infoitem))
                        local SUMPAGES=$(${EXIFTOOL} -s3 -PageCount "${FILE}")
                        echo "${INFO[@]} ${SUMPAGES}"
                    ;;
                esac
            ;;
            sgi) #
                # https://en.wikipedia.org/wiki/Silicon_Graphics_Image
            ;;
            tga) # 
                # https://en.wikipedia.org/wiki/Truevision_TGA
            ;;
            webp) #
                # https://en.wikipedia.org/wiki/WebP
            ;;
            xbm) #
                # https://en.wikipedia.org/wiki/X_BitMap
            ;;
            xpm) #
                # https://en.wikipedia.org/wiki/X_PixMap
            ;;
            xwd) # Formát do kterého ukládá screenshoty obrazovky X Windows systems
                # https://en.wikipedia.org/wiki/Xwd
            ;;
            tar|zip) # Nejde o grafické formáty, ale kontejnery, co můžou
                # obsahovat různé typy souborů. Na serveru archive.org se
                # využívají pro zabalení souborů skenů ve formátu jp2, jpeg aj.
                case ${CHARSTRING} in
                    list) listzip "${FILE}"
                    ;;
                    meta*) #/ může být archiv s obrázky
                        local LISTPAGES=($(listzip "${FILE}"))
                        local PAGE="${CHARSTRING#meta }"
                        case ${PAGE} in
                            meta) log info "main() Exif info for first file ${LISTPAGES[0]} from archive ${FILE}"
                                echo $(itemzip "${FILE}" "${LISTPAGES[0]}" | infoitem)
                            ;;
                            *) if [ "${PAGE}" -ge "0" ] && [ "${PAGE}" -lt "${#LISTPAGES[@]}" ] ; then
                                    log info "main() Exif info for ${PAGE} file: ${LISTPAGES[${PAGE}]} from archive ${FILE}"
                                    itemzip "${FILE}" "${LISTPAGES[${PAGE}]}" | ${EXIFTOOL} -
                                else
                                    echo "Ivalid value ${PAGE}" >> /dev/stderr
                                    return 1
                                fi
                            ;;
                        esac
                    ;;
                    pages\ +([0-9])|pages\ all|pages) local TEMPORAR=(${CHARSTRING})
                        case ${TEMPORAR[1]} in
                            all) local LISTPAGES=($(listzip "${FILE}"))
                                printf "%s\n" ${LISTPAGES[@]}
                            ;;
                            +([0-9])) local LISTPAGES=($(listzip "${FILE}"))
                                printf "%s\n" ${LISTPAGES[@]} | \
                                grep -m ${TEMPORAR[1]} -v /$ | tail -1
                            ;;
                            *) local SUMPAGES=$(listzip "${FILE}" | wc -l)
                                echo "${SUMPAGES}"
                            ;;
                        esac
                    ;;
                    *) # zjistit jakého typu jsou obrázky v archivu
                        local SUMPAGES=$(listzip "${FILE}" | wc -l)
                        echo "${FILETYPE^^} ${SUMPAGES}"
                    ;;
                esac
            ;;
        esac
    fi
    return $?
}

# ### <span id="listpdf">listpdf()</span> ([top](#FUNCTIONS))
# Funkce vrací seznam stránek v PDF souboru.
#
# pdftk soubor.pdf dump_data | grep PageMedia
#
# PageMediaNumber: 5
# PageMediaRotation: 0
# PageMediaRect: 0 0 533 838
# PageMediaDimensions: 533 838
#
# Důležité jsou rozměry, rotace a číslo
#     + 2451x3363+0+0 RGB-alpha Normal 46
#
# 1, položka viditelnost vrstvy (+|-)
# 2, položka rozměry vrstvy
# 3, 
# 4, typ vrstvy - by měly být typu Normal 
# 5, jméno vrstvy
#
# Pokud se u některé z viditelných vrstev vyskytuje jiný typ, než Normal,
# pak se vrací upozornění, že jde o rozpracovaný soubor a výsledek nemusí
# odpovídat požadovku
#
# Pořadové číslo souboru tak odpovídá číslu stránky
listpdf() {
    log goto "listpdf() From "
    ${PDFTK} "${1}" dump_data | awk '/^PageMediaNumber/ {print $2}'
}

# ### <span id="pdftopdf">pdftopds()</span> ([top](#FUNCTIONS))
# Export rozsahu ${RANGE} stránek z pdf souboru $1 do nového pdf souboru $2
pdftopdf() {
    log goto "pdftopdf() From pdf $1 range ${RANGE}"
    local TEMPORAR=(${RANGE//,/ })
    local RANGE=$(printf "A%s " ${TEMPORAR[@]})
    ${PDFTK} A="${1}" cat ${RANGE} output "${2}"
}

# ### <span id="itemxcf">itemxcf()</span> ([top](#FUNCTIONS))
# Funkce vyblije na standardní výstup stránku __$2__ z PDF souboru __$1__
itempdf() {
    ${PDFTOPPM} -f ${2} -l ${2} < "${1}"
}

# ### <span id="listxcf">listxcf()</span> ([top](#FUNCTIONS))
# Funkce vrací seznam vrstev v XCF souboru.
#
# Ovšem tento vstupní XCF soubor musí být připraven ke konverzi a to tak,
# že vrstvy, které mají být považovány za stránky, musí být typu Normal a
# viditelné. 
#
#     + 2451x3363+0+0 RGB-alpha Normal 46
#
# 1, položka viditelnost vrstvy (+|-)
# 2, položka rozměry vrstvy
# 3, 
# 4, typ vrstvy - by měly být typu Normal 
# 5, jméno vrstvy
#
# Pokud se u některé z viditelných vrstev vyskytuje jiný typ, než Normal,
# pak se vrací upozornění, že jde o rozpracovaný soubor a výsledek nemusí
# odpovídat požadovku
#
# Pořadové číslo souboru tak odpovídá číslu stránky
listxcf() {
    local TEST=$( ${XCFINFO} "${1}" | grep ^+ | awk '{print $4}' | grep -v Normal )
    ${XCFINFO} -u "${1}" | while read line ; do
        case "${line:0:1}" in
            +) echo "${line#*RGB* Normal }"
            ;;
        esac
    done
    [ -n "${TEST}" ] && return 1 || return 0
}

# ### <span id="itemxcf">itemxcf()</span> ([top](#FUNCTIONS))
# Funkce vyblije na standardní výstup z XCF __$1__ vrstvu __$2__
itemxcf() {
    log goto "itemxcf() From $1 flush –> $2"
    ${XCF2PNM} "${1}" "${2}"
}

# ### <span id="itempng">itempng()</span> ([top](#FUNCTIONS))
# Funkce vyblije na standardní výstup z XCF __$1__ vrstvu __$2__
itempng() {
    log goto "itempng() From $1 flush –> $2"
    # ${XCF2PNM} "${1}" "${2}"
    ${PNGTOPNM} "${1}"
}

# ### <span id="listpng">listpng()</span> ([top](#FUNCTIONS))
# Vrací pořadové číslo vrstvy, které odpovídá číslu stránky
listpng() {
    local TEMPORARY="${1##*/}"
    mkdir ${TEMPORARY}
    # ${ZIP} l -so "${1}" | awk '{print $6}' | grep '/' | sort -t _
}

# ### <span id="listzip">listzip()</span> ([top](#FUNCTIONS))
# Vrací setříděný seznam souborů v ZIP archivu - je založen na syntaxi
# používané u souborů archive.org, kdy číslování stránek je před příponou
# souboru, oddělené od jména adresáře podtržítkem
#
#         pg35600_jp2/pg35600_0158.jp2
#
# Pořadové číslo souboru tak odpovídá číslu stránky
listzip() {
    ${ZIP} l -so "${1}" | awk '{print $6}' | grep '/' | sort -t _
}

# ### <span id="itemzip">itemzip()</span> ([top](#FUNCTIONS))
# Funkce vyblije na standardní výstup ze zazipovaného archívu __$1__
# soubor __$2__
itemzip() {
    log goto "itemzip() From $1 flush –> $2"
    ${ZIP} e -so "${1}" "${2}"
}

# ### <span id="infile">infile()</span> ([top](#FUNCTIONS))
# Vrací adresy počátečního a poslední řádku bloku, který vyhovuje odpovídajícímu vzorku
# $1 - jméno souboru
# $COORDS
# $MESSAGE
infile() {
    log goto "infile() $1 –> ${COORDS}"

    mapfile -d\: -t -c1 CORDANT <<< $(grep -n "${COORDS%+([[:blank:]])}" "${1}")
    mapfile -d\: -t -c1 MESANT <<< $(grep -n "${MESSAGE}" "${1}")
    #echo "${MESSAGE}" >> /dev/stderr
    #echo "${MESANT}" >> /dev/stderr
    mapfile -t TEMP <<< $(grep -n '^[a-Z#]' "${1}")
    local POLEOBJEKTU=(${TEMP[@]%:*})
    local RADKYCELKEM=$(wc -l < ${1})

    _f() {
        local z i
        for i in ${POLEOBJEKTU[@]} ; do [ $i -gt $1 ] && break || ((++z)) ; done
        if [ $i -lt $1 ] ; then
            log info "_f() Za řádkem $1 už nebyl žádný objekt"
            echo "$i" "${RADKYCELKEM}"
        else
            log info "_f() Za řádkem $1 začínal další objekt na $i"
            echo "${POLEOBJEKTU[$((z - 1))]}" "$((i - 1))"
        fi
    }
    
    case "${MESANT}" in
        +([[:digit:]])) #/ jenom MESANT
            _f "${MESANT}"
        ;;
        *) case "${CORDANT}" in
            +([[:digit:]]))
                _f  "${CORDANT}"
            ;;
            *) return 1
            ;;
        esac
        ;;
    esac
    return 0
}

# ### <span id="infoitem">infoitem()</span> ([top](#FUNCTIONS))
# Na vstupu je stream a výstupem je sada hodnot
infoitem() {
    ${EXIFTOOL} -s3 -FileType -ImageSize -Compression -AnimationFrames -FrameCount -
}

# ### <span id="convertovergimp">convertovergimp()</span> ([top](#FUNCTIONS))
# Bitmapový editor gimp lze rovněž využívat ke konverzi bitmapových souborů
#
# $1 - výstupní formát
convertovergimp() {
    # Start gimp with python-fu batch-interpreter
    gimp -i --batch-interpreter=python-fu-eval -b - << EOF
import gimpfu

def convert(filename):
    img = pdb.gimp_file_load(filename, filename)
    new_name = filename.rsplit(".",1)[0] + ".$1"
    layer = pdb.gimp_image_merge_visible_layers(img, 1)

    pdb.gimp_file_save(img, layer, new_name, new_name)
    pdb.gimp_image_delete(img)

convert('${2}')

pdb.gimp_quit(1)
EOF
}

# ### <span id="identifypage">identifypage()</span> ([top](#FUNCTIONS))
# Function return DjVu page actual ORDER in DjVu bundle
# $1 type (order|name)
# $2 DjVu file
# $3 Page identificator (order or name)
identifypage() {
    log goto "identifypage() ${1} page ${3} from ${2}"
    case "${3}" in
        +([[:digit:]])) #/ Identifikace podle čísla stránky
            local PAGE=$(${DJVUSED} "${2}" -e dump | grep "\[P${3}\]")
        ;;
        *) #/ Identifikace podle názvu stránky
            local PAGE=$(${DJVUSED} "${2}" -e dump | grep "\{${3}\}")
        ;;
    esac
    [ ! -n "${PAGE}" ] && \
        log err "identifypage() Invalid identificator ${1} for ${2}" && \
        return 1
    case "${1}" in
        name) local TEMPORAR="${PAGE##*\{}"
            echo "${TEMPORAR%%\}*}"
        ;;
        order) local TEMPORAR="${PAGE##*\[P}"
            echo "${TEMPORAR%%\]*}"
        ;;
        *) log err "identifypage() Invalid type –> ${1}"
            return 1
        ;;
    esac
    return 0
}

# ### <span id="deletepage">deletepage()</span> ([top](#FUNCTIONS))
# Odstraňuje z DjVu svazku stránky, pokud jejich celkový počet je > 1
#
# $1 - jméno DjVu svazku se kterým se pracuje
# $2 - číslo, nebo název strany co se má odstranit
#
# Pokud je stránka úspěšně odstraněna, vrací __0__
# Pokud se stránka ve svazku nevyskytuje, vrací __1__
# Pokud není DjVu soubor typu bundle, vrací __2__
deletepage() {
    log goto "deletepage() From ${1} –> ${2}"
    [ -z ${2} ] && return 1
    local SUMPAGE=$(${DJVUSED} "${1}" -e 'n')
    [ $? -eq 1 ] && return 1
    case $SUMPAGE in
        1) echo "Single page DjVu file –> ${FILE}" >> /dev/stderr
            return 0
            ;;
        *) local PAGE=$(identifypage order "${1}" "${2}")
            if [ ! -z "${PAGE}" ] ; then
                ${DJVM} -d "${1}" "${PAGE}"
                echo "Page ${2} from ${1} was removed" >> /dev/stderr
            else
                return 1
            fi
            ;;
    esac
    return $?
}

# ### <span id="djvurotate">djvurotate()</span> ([top](#FUNCTIONS))
# $1 - soubor se kterým se pracuje
# $2 - číslo, nebo název strany která se má rotovat
# $3 - hodnota rotace
#	echo "$*" >> /dev/stderr
function djvurotate {
    log goto "$1 –> $2"
    local INFO="""
Uvedenou hodnotu rotace nelze akceptovat. Rotaci lze nastavit buď 
absolutně, a nebo relativně (pootočit o 90°). AKceptované hodnoty:

      0 - výchozí pozice
      1 - natočení vpravo
      2 - otočení  vzhůru nohama
      3 - natočení vlevo
   left - rotace směrem doleva
  right - rotace směrem doprava).
    180 - přetočení o 180°

Každá jiná hodnota parametru je ignorována."""

    local ROTATE="${2%%+([[:blank:]])*}"
    case "${ROTATE}" in
        0|1|2|3|180|left|right)
            local TEMPORAR="${2#${ROTATE}+([[:blank:]])}"
            mapfile -t ARRAY <<< $($0 "${1}" info list)
            case "${ARRAY:0:1}" in
                0) mapfile -t LISTPAGES <<< $(printf "%s\n" "${ARRAY[@]}")
                ;;
                *) LISTPAGES="0 none"
                    mapfile -O 1 -t LISTPAGES <<< $(printf "%s\n" "${ARRAY[@]}")
                ;;
            esac
            RANGE=$(isrange "${TEMPORAR}")
            if [ -n "${RANGE}" ] ; then
                local PAGES=($(range "${RANGE}"))
            else
                case "${TEMPORAR//+([[:blank:]])/}" in
                    '') echo "${INFO}" >> /dev/stderr
                        return 1
                    ;;
                    *) # seznam stránek oddělených čárkou
                        local IFS_BAK=$IFS
                        local IFS=$','
                        local SEZNAM=($TEMPORAR)
                        local IFS=$IFS_BAK
                        for i in "${LISTPAGES[@]}" ; do
                            if [[ "${SEZNAM[@]}" =~ "${i##+([[:digit:]])+([[:blank:]])}" ]] ; then
                                local TEMP="$TEMP${i%% *} "
                            fi
                            x=$((x + 1))
                        done
                        local PAGES=($TEMP)
                    ;;
                esac
            fi
            echo "ROTATE ${ROTATE} PAGES ${#PAGES[@]} ${PAGES[@]}" >> /dev/stderr
            for i in ${PAGES[@]} ; do
                local PAGENAME="${LISTPAGES[$i]##+([[:digit:]])+([[:blank:]])}"
                local PAGEORDER="${LISTPAGES[$i]%% *}"
                case "${PAGEORDER}" in
                    0) case "${PAGENAME}" in
                            none)
                            ;;
                            *) # globální rotace
                                case "${ROTATE}" in
                                    0|1|2|3)  ${DJVUSED} -e "set-rotation ${ROTATE}; save" "${1}"
                                    ;;
                                    left) ${DJVUSED} -e "set-rotation +1; save" "${1}"
                                    ;;
                                    right) ${DJVUSED} -e "set-rotation -1; save" "${1}"
                                    ;;
                                    180) ${DJVUSED} -e "set-rotation +2; save" "${1}"
                                    ;;
                                    *) echo "${INFO}" >> /dev/stderr
                                    ;;
                                esac
                            ;;
                        esac
                    ;;
                    '') #/ nic
                    ;;
                    *) #/ stránky dle rozsahu či seznamu
                        case "${ROTATE}" in
                            0|1|2|3)  ${DJVUSED} -e "select '${PAGEORDER}'; set-rotation ${ROTATE}; save" "${1}"
                            ;;
                            left) ${DJVUSED} -e "select '${PAGEORDER}'; set-rotation +1; save" "${1}"
                            ;;
                            right) ${DJVUSED} -e "select '${PAGEORDER}'; set-rotation -1; save" "${1}"
                            ;;
                            180) ${DJVUSED} -e "select '${PAGEORDER}'; set-rotation +2; save" "${1}"
                            ;;
                            *) echo "${INFO}" >> /dev/stderr
                            ;;
                        esac
                    ;;
                esac
            done
        ;;
        *) printf "%s - is not valid rotate VALUE" "${ROTATE}" >> /dev/stderr
            return 1
        ;;
    esac
}

# ### <span id="range">range()</span> ([top](#FUNCTIONS))
# Funkce, která zpracuje předaný řetězec do sekvence čísel
# 1,2,3-9,10-20
# Pokud zpracování řetězce proběhne v pořádku je návratový kód __0__,
# v opačném případě __1__.
range() {
    log goto "range() –> ${@}"
    case "${1:0:1}" in
        [[:digit:]]) local INPUTARRAY=( ${1//,/ } )
            for i in ${INPUTARRAY[@]} ; do
                if [[ "$i" =~ "-" ]] ; then
                    seq ${i//-/ }
                else
                    seq ${i} ${i}
                fi
            done | sort -nu
            return 0
        ;;
        *) printf "range: FAIL - range of pages must be set only from order numbers, commas and hyphens.\n" >> /dev/stderr
            return 1
        ;;
    esac
}

# ###  <span id="metasign">metasign()</span> ([top](#FUNCTIONS))
# Funkce hodnoty pro tyto klíčové atributy, pokud existují
# Producer
# ModDate
# HostComputer
metasign() {
    if [ -f "${HOME}/.config/${NAME}/default.conf" ] ; then
        local STRING="$(grep '^CREATOR' "${HOME}/.config/${NAME}/default.conf" | cut -d\= -f2)"
    else
        echo "Není uveden CREATOR ve výchozím souboru, použiji tedy aktuálního uživatele" >> /dev/stderr
        local STRING="${USER}"
    fi
    setmeta "${1}" "Producer" "Producer ${STRING}, ${NAME} ${VERSION}"
    setmeta "${1}" "ModDate" "ModDate $(date -u +%FT%T%:z)"
    setmeta "${1}" "HostComputer" "HostComputer $(hostname)"
    return $?
}

# ###  <span id="djvusign">djvusign()</span> ([top](#FUNCTIONS))
# Funkce nastaví do stránky tyto meta atributy
# Producer
# ModDate
# HostComputer
djvusign() {
    local RANGE=$(isrange "${2}")
    if [ ! -n "${RANGE}" ] ; then
        # / může být seznam stránek ZA KTERÝM není nic
        # oddělit PATTERN od seznamu
        case "${2//+([[:blank:]])/}" in
            '') # jenom příkaz
                echo "Nebyl předán RANGE, zapíšu info mezi sdílené poznámky" >> /dev/stderr
                local PAGES=("0")
                #local PAGES=($(range "0-${#LISTPAGES[@]}"))
            ;;
            *) # seznam stránek oddělených čárkou

                mapfile -t ARRAY <<< $($0 "${1}" info list)
                case "${ARRAY:0:1}" in
                    0) mapfile -t LISTPAGES <<< $(printf "%s\n" "${ARRAY[@]}")
                    ;;
                    *) LISTPAGES="0 none"
                        mapfile -O 1 -t LISTPAGES <<< $(printf "%s\n" "${ARRAY[@]}")
                    ;;
                esac

                local IFS_BAK=$IFS
                local IFS=$','
                local SEZNAM=($2)
                local IFS=$IFS_BAK
                for i in "${LISTPAGES[@]}" ; do
                    if [[ "${SEZNAM[@]}" =~ "${i##+([[:digit:]])+([[:blank:]])}" ]] ; then
                        echo "Stránka ${i}" >> /dev/stderr
                        local TEMP="$TEMP${i%% *} "
                    fi
                    x=$((x + 1))
                done
                local PAGES=($TEMP)
                local STRING="${2##*.djvu+([[:blank:]])}"
            ;;
        esac
    else
        local STRING="${2#*${RANGE}+([[:blank:]])}"
        [ ! -n "${STRING}" ] && return 1
        local PAGES=($(range "${RANGE}"))
    fi
    case "${STRING:0:1}" in
        [a-Z])
        ;;
        *) if [ -f "${HOME}/.config/${NAME}/default.conf" ] ; then
                local STRING="$(grep '^CREATOR' "${HOME}/.config/${NAME}/default.conf" | cut -d\= -f2)"
            else
                echo "Není uveden CREATOR ve výchozím souboru, použiji tedy aktuálního uživatele" >> /dev/stderr
                local STRING="${USER}"
            fi
        ;;
    esac
    for i in ${PAGES[@]} ; do
        $0 -f "${1}" set "${i}" key Producer "${STRING}, ${NAME} ${VERSION}"
        $0 -f "${1}" set "${i}" key ModDate "$(date -u +%FT%T%:z)"
        $0 -f "${1}" set "${i}" key HostComputer "$(hostname)"
    done
    return $?
}

# ### <span id="setkey">setkey()</span> ([top](#FUNCTIONS))
# $1 - soubor ve formátu .ant
# $2 - KEY
# $3 - VALUE
setkey() {
    local KEY="${2}"
    local VALUE="${3}"
    mapfile -d\: -t -c1 LINE <<< $(grep -n "${KEY} \"" "${1}")
    log info "${KEY} –> ${LINE[0]}"
    case "${LINE[0]}" in
        +([[:digit:]])) log info "Replace content key –> ${KEY}"
            setmeta "${1}" "${KEY} \"" "${KEY} \"${VALUE}\""
        ;;
        *) mapfile -t METADATA <<< $(sed  '/metadata/!d ; = '  "${1}" | grep -v metadata)
            local BEGIN="${METADATA[@]: -1}"
            case "${BEGIN}" in
                +([[:digit:]])) log info "New metadata key –> ${KEY}"
                    local KEYDATA="${KEY} \"${VALUE}\""
                    ed "${1}" 2>/dev/null <<-EOF
${BEGIN}a
${KEYDATA}
.
w
q
EOF
                ;;
                *) log info "Set new metadata block for key –> ${KEY}"
                    echo "metadata" >> "${1}"
                    echo -e "\t${KEY} \"${VALUE}\"\n" >> "${1}"
                ;;
            esac
        ;;
    esac
}


# ### <span id="setmeta">setmeta()</span> ([top](#FUNCTIONS))
# V souboru $1 najít $2, pokud se vyskytuje, tak ho nahradit za $3,
# pokud nevyskytuje, přidat $3 na konec
setmeta() {
    mapfile -d\: -t -c1 ITEM <<< $(grep -n "${2}" "${1}")
    case "${ITEM[0]}" in
        +([[:digit:]])) #/ vyskytuje se
            case "${3}" in
                '') log info "Delete –> $2"
                    ed "${1}" 2>/dev/null <<-EOF
${ITEM[0]}
d
w
q
EOF
                ;;
                *) #/ nahrazuji
                    log info "Replace $2 –> $3"
                    log info "${ITEM[0]}c"
                    ed "${1}" 2>/dev/null <<-EOF
${ITEM[0]}c
${3}
.
w
q
EOF
                ;;
            esac
        ;;
        *) #/ nevyskytuje se
            case "${3}" in
                '')
                ;;
                *) #/ přidám na konec
                    echo "${3}" >> "${1}"
                    log info "Add $3 to end"
                ;;
            esac
        ;;
    esac
    return $?
}

# ### <span id="djvuinfo">djvuinfo()</span> ([top](#FUNCTIONS))
# Prvním parametrem __$1__ je cesta k DjVu souboru a druhým $2 požadovaná
# informace:
#
# * list
# * exif
# * meta
# * pages
# * grep
#
# Pokud není předaná platná hodnota , vrací funkce pouze informaci o typu
# souboru, ev. doplněnou o počet stran či vrstev
djvuinfo() {
    log goto "$1 –> $2"
    case ${2} in
        '') local INFO=($(cat "${1}"|infoitem))
            isbundle "${1}"
            case $? in
                0) local SUMPAGES=$(${DJVM} -l "${1}" | grep PAGE\ # | wc -l)
                 local TEMP=$(${DJVM} -l "${1}" | grep SHARED_ANNO)
                ;;
                2) local SUMPAGES=1
                ;;
                *) local SUMPAGES=error
                ;;
            esac
            if [ -n "${TEMP}" ] ; then
                echo "${INFO[@]} ${SUMPAGES} shared_anno"
            else
                echo "${INFO[@]} ${SUMPAGES}"
            fi
        ;;
        pages) isbundle "${1}"
            case $? in
                0) ${DJVM} -l "${1}" | grep PAGE\ # | wc -l
                ;;
                2) echo 1
                ;;
                *) echo error
                ;;
            esac
        ;;
        list) isbundle "${1}"
            case $? in
                0) ${DJVM} -l "${1}" |\
                    sed -E 's/SHARED_ANNO/#0/ ; s/[[:alnum:][:blank:]]+#// ; /^Size/d ; /^\-/d' | sort -n
                ;;
                2) ${DJVUSED} "${1}" -e 'dump' | grep '{' | grep -v INCL |\
                    awk -F'}' '{print $2,$1}' | \
                    sed -E 's/][[:blank:]]+[[:alnum:]:]+[[:blank:]]+\[[[:digit:]]+\][[:blank:]]+\{/ / ; s/ \[// ; s/^P// ; s/^S/0/' | sort -n
                ;;
                *) echo error
                ;;
            esac
        ;;
        exif) ${EXIFTOOL} "${1}"
        ;;
        dsed*) log dsed "djvuinfo() –> ${2#dsed+([[:blank:]])}"
            ${DJVUSED} "${1}" -e "${2#dsed+([[:blank:]])}"
        ;;
        grep*) log grep "grep –> ${2#grep+([[:blank:]])}"
            $0 "${1}" info list | \
            while read line ; do
                case "${line%% *}" in
                    O)
                    ;;
                    '') return 1
                    ;;
                    *) local PAGE="${line#* }"
                        local ORDER="${line%% *}"
                        local TEMPORAR=$(${DJVUTXT} "${1}" -page=${ORDER} | ${2} 2>1)
                        if [ -n "${TEMPORAR}" ] ; then
                            echo "# ${PAGE} #[P${ORDER}]"
                            printf "%s\n" "${TEMPORAR}"
                        fi
                    ;;
                esac
            done
        ;;
        *) return 1
        ;;
    esac
    return $?
}

# ### <span id="help">help()</span> ([top](#FUNCTIONS))
#
help() {
    log info "$1"
	case "$1" in
        actions) echo """Implementované akce: """
        ;;
		algorithm) echo """

Binarizační algoritmy ovliňují vygenerování optimální černobílé masky
Utilita DiDjVu podporuje tyto algoritmy:

abutaleb
bernsen
  - region-size=N (1 .. 50, default: 11)
  - contrast-limit=N (0 .. 255, default: 80)
  - doubt-to-black
brink
djvu (default) (vhodný pro černobílé obrázky)
  - smoothness=X (0.0 .. 1.0, default: 0.2)
  - max-block-size=N (default: 512)
  - min-block-size=N (default: 64)
  - block-factor=N (1 .. 8, default: 2)
global
  - threshold=N
niblack
  - region-size=N (default: 15)
  - sensitivity=X (default: -0.2)
  - lower-bound=N (0 .. 255, default: 20)
  - upper-bound=N (0 .. 255, default: 150)
otsu (vhodný pro černobílé obrázky, lepší komprese než u výchozího djvu)
sauvola
  - region-size=N (default: 15)
  - sensitivity=X (default: 0.5)
  - dynamic-range=N (1 .. 255, default: 128)
  - lower-bound=N (0 .. 255, default: 20)
  - upper-bound=N (0 .. 255, default: 150)
shading-subtraction
  - k=N (default: 7)
  - threshold=N
tsai
white-rohrer
  - x-lookahead=N (default: 8)
  - y-lookahead=N (default: 1)
  - bias-mode=N (default: 0)
  - bias-factor=N (default: 100)
  - f-factor=N (default: 100)
  - g-factor=N (default: 100)

Výchozí nastavení algoritmů lze upravit 
		"""
		;;
        bitmap) echo """
        """
        ;;
		bitmap-export) echo """
U bitmapových souborů, které mají podporu pro více stránek (či vrstev)
lze využít export k jejich extrakci a případně i transformaci na jiný
rozměr či konverzi do jiného formátu – včetně DjVu. Viz příklad:

    ${APP} soubor.jpg export jpg 1 30%

Vygeneruje JPEG obrázek s názvem soubor_30%.jpg jehož obsahem bude původní
obrázek ze souboru soubor.jpg, zmenšený na 30% původní velikosti.

U kontejnerů typu zip či tar, které mohou obsahovat obrázky v různých formátech,
lze provést export pouze s uvedením rozsahu. Cílové soubory se pak budou
jmenovat stejně, jako ty v archívu:

    ${APP} soubor.zip export orig 2-7

U bitmapových formátů s podporou více stránek, které mají v sobě uložen
také název vrstvy či stránky, bude mít vyexportovaný soubor stejné jméno
jako byl název příslušné vrstvy či stránky.

    ${APP} soubor.xcf export 2-7

V tomto případě tedy bude výsledkem série šesti souborů ve formátu .xcf,
vytvořených z druhé až sedmé vrstvy souboru soubor.xcf pojmenovaných podle
jejich názvů.

Pokud se mají soubory jmenovat podle jiného vzoru, musí být uveden výchozí
vzorek. Viz příklad:

    ${APP} soubor.xcf export 2-7 soubor

V takovém případě se budou vyexportované soubory jmenovat soubor_00002.xcf
až soubor_00007.xcf

Akci export lze využít i ke konverzi do jiného formátu:

    ${APP} soubor.pdf export 1 jpg

V případě PDF souborů, které mohou obsahovat mix textu a obrázků bude v tomto
případě výstupem jako bitmapový obrázek celá stránka. Pokud však chcete,
aby výstupem byly pouze vložené obrázky (nebo text), je třeba jako výstupní
formát uvést co chcete:

    ${APP} soubor.pdf export 1 images

Není-li řečeno jinak, jsou výsledné soubory v původním rozlišení. Ovšem
při konverzi lze velikost cílového obrázku rovnou přeškálovat:

    ${APP} soubor.pdf export 1 jpg 0.5 example

Tímto způsobem zvolíte, že cílová velikost bude obrázku bude 50% původní
velikosti.

Velikost výsledného souboru také můžete uvést uvedením rozměru cílového
obrázku. V takovém případě ale musíte použít i jeden z následujících
parametrů, kterým určíte jak se má při škálování postupovat:

-xysize přeškáluje obrázek tím způsebem, že použije kratší rozměr a ten
        co bude přesahovat ořízne tak aby výsledek odpovídal velikosti
        vymezeného prostoru a zároveň zůstal zachován poměr stran výchozího
        obrázku
-xyfit  roztáhne obrázek tak aby vyplnil celý uvedený rozměr, poměr stran
        tedy nebude zachován
-xyfill přeškáluje obrázek podle většího rozměru, tak aby se vešel do
        vymezeného prostoru celý a poměr stran při tom zůstal zachován.

Viz příklad:

    ${APP} soubor.pdf export 1 jpg 250x300 -xysize example

Při škálování se automaticky použije volba -nomix, můžete ji ale zaměnit
za konkrétní škálovací filtr. Viz příklad:

    ${APP} soubor.pdf export 1 jpg 250x300 -filter=box example
"""
        echo "Seznam použitelných škálovacích filtrů:"
        printf "\t%s\n" ${FILTERS[@]}
echo """
Ve všech uvedených příkladech jsou výsledné soubory uloženy do adresáře,
ve kterém se ${APP} spouští. Pokud se mají uložit jinam, je třeba uvést
i cílovou  cestu:

    djvutool soubor.pdf export 1 jpg 0.33 example/

V tomto případě se vyexportované stránky nasypou do podadresáře example.
Pokud neexistuje, tak se vytvoří. Pokud se mají soubory při exportu také
přejmenovat, je třeba za lomítkem uvést také příslušný vzor:

    djvutool soubor.pdf export 1 jpg 0.33 example/example

V tomto případě by se tedy výsledný soubor jmenoval example_30%_00001.jpg

Pokud má být číslování jiné než výchozí pětimístné, vypadá vzorek takto:

    djvutool soubor.pdf export 1 jpg 30% example/example_XX
"""
		;;
        bitmap-info) echo """
  ACTION [1minfo[0m

  If isn't subkey, return basic informations about file: Format, dimensions
  of page and for file in multipage format summary count of pages.

  [1m${0##*/}[0m info <file> [ pages | list | meta <num> ]

         num  - order of page (or layer) in file

  SUBKEYS:
         [3mlist[23m - (only multipage file) return list names, or numbers of
                pages from multipage file, or from container 
         [3mmeta[23m - return exif info about page from container or file
        [3mpages[23m - return only sumary count of pages as number

[3mNotice:[23m
  * For [3m'meta'[23m [2minfo[22m different from [2mexport[22m in that output is purified from syntax chars, whose is required for [2mimport[22m.
  * When is passed subkey [3m'exif'[23m with an identificator of page, be export a page into temporary dir and view info only about this page.
  * Subkey [3m'pages'[23m with an identificator of page return only item for this.
        """
        ;;
		bundle) echo """Nápověda pro volbu typu svazku.. ToDo
		"""
		;;
		dpi) echo """
[1mOption:[0m --dpi  <[2mčíslo[22m> Hodnota DPI, která se má použít při zpracování obrázku.
                               při konverzi. Optimální je zjistit hodnotu přímo ze vstupního
                               obrázku. Před nastavením této hodnoty pro finální konverzi. lze vyzkoušet
                               optimální nastavení na některém ze souborů s využitím parametru
                               --test

  Rozsah číselné hodnoty je od 72 do 6000 dpi. Výchozí hodnota 300 se použije 
  v případě, že parametr --dpi není vůbec uveden.
  Vliv dpi na zpracování obrazu..
"""
		;;
		dsed) echo """Option [1m-d[0m ([1m--dsed[0m)

  Extrakce skryté textové vrstvy DjVu stránky ve formátu pro djvused.
  Parametrem lze zvolit, co se má při akci [2mexport[22m uložit.

  [1m${0##*/}[0m ... {-d|--dsed} [yes|no|all|txt|ant] ...
  
         yes - stejný efekt jako volba all
         no  - textová vrstva se neexportuje (default)
         all - exportuje se celý obsah skryté textové vrstvy
         txt - exportuje se pouze obsah stránky
         ant - exportují se meta atributy stránky, hyperlinky, atp.

[4mPoznámka:[24m
  * Pokud za volbou není uveden žádný další parametr, tak se automaticky
    předpokládá - yes.
  * Výchozí parametr - no - lze implicitně změnit nastavením proměnné
    DSED do souboru v adresáři ${HOME}/.config/${NAME}/
  * Exportovaná data se ukládají do souborů s příponou [3m.dsed[23m.
"""
		;;
    exif) echo """Nastavení exif tagu Creator:

    [1m${0##*/}[0m soubor.djvu set 1,3,7-12 key Creator Thomas Jefferson

Přehled nejpoužívanějších EXIF tagů:
        [3mTitle[23m - Název dokumentu
      [3mCreator[23m - Osoba, která zpracovala sken do DjVu stránky
 [3mCreationDate[23m - Datum pořízení skenu
     [3mKeywords[23m - Klíčová slova pro indexaci DjVu souboru
       [3mannote[23m - Poznámka o původu dokumentu & etc.
  [3mDescription[23m - Popis obsahu dokumentu
       [3mAuthor[23m - Autor dokumentu
     [3mNickname[23m - Přezdívka
  [3mContactInfo[23m - Kontaktní informace na zpracovatele dokumentu
     [3mProducer[23m - Software kterým byl sken zpracován do DjVu
  [3mCreatorTool[23m - Zařízení na kterém byl sken či snímek pořízen
      [3mModDate[23m - Čas zpracování do DjVu
   [3mModifyDate[23m - Čas zpracování do DjVu
 [3mMetadataDate[23m - Čas, kdy byla naposled aktualizována metadata
                              na stránce
    DocumentName
ImageDescription
        Software
        DateTime
          Artist
       Copyright
    ImageHistory
       MakerNote
     UserComment
"""
    ;;
		existed) echo """
  Soubor $2 existuje. Pokud se má přepsat, musí být
  uveden parametr -f (--force)
"""
		;;
		exporttometa) echo """volba [1m-m[0m ([1m--meta[0m)

  Extrakce DjVu stránky ze svazku

  [1m${0##*/}[0m ... {-x|--xml} [yes|no] ...
  
  Prostřednictvím této volby lze zvolit zda se má, nebo nemá při akci
  [3mexport[23m z DjVu svazku exportovat i celá DjVu stránka. Pokud za volbou
  nenásleduje parametr, pak se automaticky předpokládá že ano (yes).
  Výchozí nastavení (no), lze implicitně změnit prostřednictvím
  uživatelského konfiguračního souboru umístěného v v adresáři:

    ${HOME}/.config/${NAME}/
"""
		;;
		exporttothumb) echo """volba [1m-t[0m ([1m--thumb[0m)

  Extrakce DjVu stránky ze svazku

  [1m${0##*/}[0m ... {-t|--thumb} [yes|no] ...
  
  Prostřednictvím této volby lze zvolit zda se má, nebo nemá při akci
  [3mexport[23m z DjVu svazku exportovat i celá DjVu stránka. Pokud za volbou
  nenásleduje parametr, pak se automaticky předpokládá že ano (yes).
  Výchozí nastavení (no), lze implicitně změnit prostřednictvím
  uživatelského konfiguračního souboru umístěného v v adresáři:

    ${HOME}/.config/${NAME}/
"""
		;;
		force) echo """volba [1m-f[0m ([1m--force[0m)

  Nastavením této volby si lze vynutit výchozí chování k souborům při
  akci [2mexport[22m. Není-li uvedena, tak se skript před každým
  přepsáním již existujícího souboru zeptá, zda-li má, nebo nemá
  pokračovat.

  [1m${0##*/}[0m ... {-f|--force} [yes|no|skip] ...
  
         yes  - všechny soubory se budou bez keců přepisovat.
         no   - skript se před přepsáním souboru bude dotazovat, zda-li
                má soubor přepsat.
         skip - pokud bude cílový soubor existovat, tak se akce přeskočí.

[4mPoznámka:[24m
  * Pokud za volbou není uveden žádný další parametr, tak se automaticky
    předpokládá - skip.
  * Výchozí parametr hodnotu parametru  (skip) - lze implicitně změnit
    nastavením proměnné FORCE v uživatelském konfiguračním souboru.
"""
		;;

		indirect) echo"""
[1mVolba[0m
         --indirect Volba, kterou lze změnit výchozí typ vícestránkového 
                    DjVu svazku (bundeled)

  Volbu je třeba aplikovat pokud chcete rozbalit stvávající DjVu svazek 
  do podoby volného svazku, nebo pokud chcete při konverzi bitmapových
  souborů rovnou sestavit DjVu svazek jako volný

  Výhodou volného svazku je, že lze dodatečně upravovat jednotlivé stránky
  jako samostatné DjVu soubory, aniž by je bylo nutné exportovat.

  Pro finalizaci DjVu svazku je pak lepší svazek překonvertovat na typ
  bundled, kdy je vše zabaleno v jednom souboru
"""
		;;
    '') echo """
 DJVUTOOL - nástroj pro práci s obrázky a DjVu soubory

       [1m${0##*/}[0m [volby] [2m[-h][22m AKCE [2m[-h][22m SOUBOR …
  resp.
       [1m${0##*/}[0m [volby] [2m[-h][22m SOUBOR {AKCE} [2m[-h][22m …

Pro podrobnější informace o volbě, akci či atributu, můžete vždy použít volbu [2m-h[22m"""
    help options
    help keywords
    ;;
    keywords) echo """
AKCE:
    export - exportem se řeší u bitmapových souborů, konverze jejich vrstev
             či stránek do jiných formátů, včetně DjVu. V případě DjVu souborů
             lze vyexportovat buď celou obrazovou vrstvu, nebo její část ve
             formě bitmapového obrázku, či obsah textové, či metadatové vrstvy.
      info - zjištuje informace o souboru či stránce.
      view - zobrazuje obrazový soubor, resp. vybranou stránku.
       ocr - aplikace OCR na obrazovou vrstvu. U DjVu souborů se OCR aplikuje
             přes akci set a výsledek se ukládá – není-li určeno jinak,
             rovnou do souboru

AKCE specifické pro práci s DjVu soubory:
      edit - editace textové vrstvy DjVu souboru
    delete - odstranění stránky z DjVu svazku
fore, back - přesuny a import stránek v rámci DjVu svazku
    rotate - změna rotace stránky v DjVu souboru
    import - import do DjVu svazku souborů typu
             [3m.djvu[23m    - import DjVu stránky či celého svazku
             [3m.ant[23m     - metadata
             [3m.outline[23m - obsah
             [3m.xml[23m     - textová vrstva
             [3m.dsed[23m    - obsah, metadata i text
? indirect,bundle - změna typu DjVu svazku
    rename - přejmenování stránek v DjVu svazku dle vzorku
       set - nastavení meta atributu, položky v obsahu, resp. aplikace OCR
             na vybrané stránky DjVu souboru
     unset - zrušení meta atributu či textového obsahu DjVu stránky
      sign - vložení metadat s informacemi o poslední změně stránky

AKCE které nevyžadují žádný soubor:
    coords - přepočítává koordináty [3m.dsed[23m souborů
"""
    ;;
    keywords-delete) echo """
  ACTION: [1mdelete[0m

  [1m${0##*/}[0m [volby] <svazek> delete RANGE

  Odstraňuje stránky z DjVu svazku. Pozor, akce je [4mnevratná[24m!
"""
        help range
        echo """[4mPoznámky:[24m
  * Při odstraňování stránek je uvedený rozsah setříděn tak, aby se stránky
    odstraňovaly postupně odzadu, tak aby se během odstraňování neměnilo
    jejich pořadové číslo.
  * K odstranění stránky dojde pouze v případě že DjVu soubor tvoří víc než
    jedna stránka.
  * Při odstraňování stránek je bezpečnější používat k identifikaci jména
    stránek, neboť pozice stránky se může v průběhu zpracování DjVu svazku
    měnit, kdežto jméno zůstává vždy v rámci svazku jedinečné.
"""
    ;;
    delete-*) help keywords-delete
        ;;
    keywords-fore) echo """
  ACTION [1mfore[0m

  Přesun stránky v rámci DjVu svazku o pozici vpřed. V případě, už je
  přesouvaná stránka na první pozici, se nestane nic.
  Při přesunu vpřed, lze rovněž přesunout stránku skokem na pozici před
  stránkou určenou její pozicí v souboru, nebo jménem.

  [1m${0##*/}[0m [volby] <svazek> fore {ORDER|PAGE} [ORDER|PAGE]

ORDER
    Pořadové číslo stránky v DjVu svazku

PAGE
   Jméno stránky v DjVu svazku

  Je doporučeno použít jako identifikátor jména stránek, místo jejich 
  aktuální pozice, prtotže ta se v průběhu zpracování DjVu svazku mění,
  kdežto její jméno stránky je vždy v rámci DjVu svazku jedinečné.
"""
    ;;
    keywords-back) echo """
  ACTION [1mback[0m

  Přesun stránky v rámci DjVu svazku o pozici zpět. V případě, už je
  přesouvaná stránka na poslední pozici, se nestane nic.
  Při přesunu zpět, lze rovněž přesunout stránku skokem na pozici za
  stránkou určenou její pozicí v souboru, nebo jménem.

  [1m${0##*/}[0m [volby] <svazek> back {ORDER|PAGE} [ORDER|PAGE]

ORDER
    Pořadové číslo stránky v DjVu svazku

PAGE
   Jméno stránky v DjVu svazku

  Je doporučeno použít jako identifikátor jména stránek, místo jejich 
  aktuální pozice, prtotže ta se v průběhu zpracování DjVu svazku mění,
  kdežto její jméno stránky je vždy v rámci DjVu svazku jedinečné.
"""
    ;;
    keywords-edit) echo """
  ACTION [1medit[0m

  Editace textové vrstvy DjVu svazku - meta tagy, bookmarks, outline,…

  [1m${0##*/}[0m [volby] <DjVu svazek> edit FORMAT [RANGE]

FORMAT
      ant - poznámky a další metadatové elementy
  outline - obsah DjVu svazku
"""
    help range
    ;;
    edit-ant) echo """
  [1m${0##*/}[0m <DjVu> edit ant [<num>|<name>|<RANGE>]
    """
    ;;
    edit-outline)
        help metadata-outline
        echo """
  [1m${0##*/}[0m <DjVu> edit outline

         outline - výpis aktuálního obsahu DjVu svazku ve formátu .outline

[3mPoznámka:[23m
  Vygenerovanou šablonu .outline formátu lze upravit editací v libovolném
  textovém editoru. Řádky s nevyužitými položkami je třeba smazat.
  Do dalších úrovní lze položky obsahu zanořit pomocí odsazení řádku
                   1 úroveň = 1 tabulátor = 8 mezer
  Aktuální obsah lze vyexportovat v .outline formátu parametrem print
  Upravený obsah lze do DjVu svazku naimportovat ze souboru přes akci [2mimport[22m,
[1mPozor:[0m Soubor ve formátu .outline musí mít (až na příponu) stejné jméno,
  jako má DjVu svazek do kterého se má vložit, jinak se nenaimportuje!
    """
    ;;
    keywords-export) echo """
  ACTION: [1mexport[0m

  [1m${0##*/}[0m [volby] <DjVu svazek> export {FORMAT} [RANGE] [TARGET]

FORMAT
      ant - poznámky
     note - export skrytých poznámek
      xmp - export xmp
      xml - na výstup bude vypsán XML obsah vybraného rozsahu stránek
     dsed - na výstup bude vypsán obsah vybraného rozsahu stránek v dsed formátu
  outline - na výstup bude vypsán obsah DjVu svazku ve formátu pro import
     meta - meta atributy stránek, jejich rozměry a info o rotaci

     color - plnobarevná stránka
     black - černobílá kresba
foreground - vrstva popředí
background - vrstva pozadí
      mask - maska

RANGE
      num - pořadové číslo stránky v DjVu svazku
     name - jméno stránky v DjVu svazku
TARGET
      dir - adresář do kterého má být výstup uložen
      all - předmětem exportu bude obsah celého DjVu svazku

  O tom co bude předmětem exportu rozhoduje typ vstupního souboru, a další 
  volby.

  Je-li je vstupním souborem jiný formát souboru než DjVu, umožňuje export:
  * u vícestránkových dokumentů extrakci jednotlivých stránek
  * jejich konverzi do jiných bitmapových formátů, včetně přeškálování
  * i konverzi do DjVu
  
  Je-li vstupním souborem DjVu dokument, jsou výsledkem exportu soubory,
  které lze po úpravě importovat zpět a tak provádět kupř. textovou korekturu
  jeho původního obsahu, či doplňovat obsah a další metadata.
  
  Export textové vrstvy zajistí volby [3m-x[23m a [3m-d[23m, náhled obrazové vrstvy
  se generuje při volbě [3m-i[23m, a celá stránka v DjVu formátu se exportuje
  při volbě [3m-p[23m.

[4mPoznámky:[24m
  * Pro zpracování single-page DjVu stránek je parametr [3mall[23m doporučený
  * Není-li uveden cílový adresář, budou soubory exporované do adresáře,
    kde byl [1m${0##*/}[0m spuštěn.
  * Přepsání již existujících souborů si lze vynutit volbou [3m--force yes[23m
    Výchozí chování je - [3mskip[23m (existující soubory se znovu neexportují)
"""
    ;;
    export-ant) echo """
Nápověda pro export metainformacé
"""
    ;;
    export-dsed) echo """
ACTION [1mexport[0m –> dsed

  [1m${0##*/}[0m [volby] <DjVu soubor> export DSED [RANGE] [TARGET]

  Tato akce vrací na základě parametru DSED informace z DjVu souboru v [3m.dsed[23m formátu.

DSED
     dsed - na výstup bude vypsán obsah metadatové vrstvy (dsed-ant)
 dsed-txt - na výstup bude vypsán obsah skryté textové vrstvy
 dsed-all - na výstup bude vypsán obsah obou textových vrstev"""
    help target
    echo """
[4mPoznámky:[24m
  Výstup je zpracováván pro každou stránku samostatně. Vrstva sdílených
  poznámem (shared_annotation.iff) je zahrnuta pouze je-li součástí RANGE
  0 (nula). Pokud chcete kompletní výstup v .dsed formátu, využijte příkaz
  předaný při akci info:

    [1m${0##*/}[0m svazek.djvu info dsed output-all > svazek.dsed
"""
    ;;
    export-meta) echo """
ACTION [1mexport[0m –> meta

  [1m${0##*/}[0m [volby] <DjVu soubor> export meta [RANGE]

  Vypisuje meta informace z DjVu souboru, včetně jmen a pořadí stránek,
  jejich rozměrů a případně aktuální stav rotace. Viz ukázka výstupu:

   # 'shared_anno.iff' #[S]
   Creator    \"Zpracovatel DjVu svazku\"
   # 'w01.djvu' #[P1] #width=4019 height=4910
   # 'další stránka.djvu' #[P2] #width=3972 height=4904 rotation=2
   CreatorPage2    \"Zpracovatel stránky č. 2\"

SEE ALSO
    [1mexport[0m –> ant, [1minfo[0m –> exif, [1minfo[0m –> meta
"""
    help range
    ;;
    export-note)
    help metadata-note
    echo """
 Jak a proč exportovat note
    """
    ;;
    export-outline)
        help metadata-outline
        echo """
  [1m${0##*/}[0m <DjVu soubor> export outline

  Vyexportuje záložky ve formátu .outline. Pro export záložek ve formátu
  .dsed, lze využít akci info
"""
    ;;
    export-dsed-*) echo """
Nápověda pro export metainformacé
"""
    ;;
    export-page) echo """
  AKCE [1mexport[0m –> meta

  [1m${0##*/}[0m [volby] <DjVu soubor> export page RANGE [PATTERN]

  Exportuje stránku z DjVu souboru, pterý pojmenuje dle předaného vzoru
  PATTERN. Pokud žádný předaný není, uloží exportovanou stránku pod jejím
  původním jménem.
"""
    ;;
    export-xml) echo """
Nápověda pro export XML textu – doplnit
"""
    ;;
    export-color|\
    export-black|\
    export-background|\
    export-foreground|\
    export-mask) echo """
Nápověda pro export grafické vrstvy
    """
    ;;
    export-line|\
    export-word|\
    export-para) echo """
Nápověda pro export textové vrstvy
    """
    ;;
    export-grep|export-pages|export-exif) help keywords-export
    ;;
    keywords-import) echo """
   AKCE: [1mimport[0m

  Zajišťuje import změn do textové vrstvy stránek DjVu souboru

  [1m${0##*/}[0m [volby] <DjVu svazek> import FORMAT RANGE …

FORMAT
  outline - import obsahu ze souboru formátu [3m.outline[23m
      ant - import meta informací ze souboru formátu [3m.ant[23m (tagy a poznámky)
      xml - import obsahu textové vrstvy z DjVuXML (formát [3m.xml[23m)
     page - import Djvu stránek (konverzi bitmapových souborů dělá akce [2mexport[22m
     dsed - import souborů v .dsed formátu (aktuálně řeší akce info)
"""
    ;;
    import-ant)
    help edit-ant
    echo """
  Import předhozeného souboru a případná editace jeho obsahu
  Před editací meta informací, je doporučeno zkontrolovat a případně 
  vyexportovat aktuální stav, příkazem
  
  djvutool <DJVU soubor> export ant [> aktualni_stav.ant]
  
  Pokud chcete mít obarvený výstup a zároveň ho uložit obvarvený do souboru, použijte následující kombinaci:
  
  ( grc djvutool soubor.djvu export ant | tee >(sed -r \"s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})*)?m//g\" > soubor.ant) )
"""
        ;;
    import-note)
        help metadata-note
        echo """
  Poznámky lze vládat buď přes akci set, nebo během editace metadatové vrstvy"""
        help edit-ant
        ;;
    import-outline)
        help metadata-outline
        echo """
  Jednotlivé položky obsahu lze vládat buď přes akci set, nebo během editace obsahu"""
        help edit-outline
        ;;
    import-page) echo """
  AKCE [1mimport[0m –> page

  [1m${0##*/}[0m [volby] <DjVu svazek> import page [ORDER] <DjVu soubor>

  Importuje DjVu soubor na pozici určenou parametrem ORDER. Pokud není
  uveden, bude soubor připojen na konec svazku.
"""
        ;;
    import-xml) echo """
  AKCE [1mimport[0m –> xml

  [1m${0##*/}[0m [volby] <DjVu svazek> import xml RANGE <DjVuXML soubor>

  Importuje do DjVu souboru obsah ze souboru DjVuXML. Pokud obsahuje více
  stránek, může být určeno ze kterých se má obsah naimportovat uvedením RANGE.

Příklad:

    djvutoolsvazek.djvu import xml -h 1,8,12 svazek.xml
    """
    ;;
    keywords-info) echo """
  ACTION [1minfo[0m

  [1m${0##*/}[0m [volby] <DjVu soubor> info [SUBKEY] [-h]

  Vypisuje informace o DjVu souboru. Není-li uveden žádný SUBKEY, vypadá
  výstup jako u následujících ukázek:

  A, DjVu Bundle o 3 stránkách, ovšem bez sdílených metainformací.

        DJVU (multi-page) 3983x4874 3

  B, DjVu Bundle o jedné straně, se sdílenými metainformacemi.

        DJVU (multi-page) 4007x4867 1 shared_anno

  C, DjVu Single.

        DJVU 4019x4910 1

SUBKEY
    pages - vrací celkový počet stran v DjVu svazku
     list - vrací setříděný seznam stránek DjVu svazku
     exif - vypisuje exif informace k DjVu souboru, včetně meta informací
            ze stránek
     meta - vypisuje rozměry stránek DjVu souboru a info o případné rotaci
     dsed - aplikuje nad soubor příkaz předaný utilitě [1mdjvused[0m
     grep - aplikuje na plain textový výstup z DjVu souboru příkaz [1mgrep[0m
            s předanými parametry

[3mPoznámka:[23m
  * Výstupy lze dále zpracovávat přes rouru, nebo používat ve skriptech
"""
    ;;
    info-dsed) echo """
  ACTION [1minfo[0m –> dsed

  [1m${0##*/}[0m [volby] <DjVu soubor> info dsed …

  Řetězec se předá k dalšímu zpracování utilitě djvused
"""
    ;;
    info-exif) echo """
  ACTION [1minfo[0m –> exif

  [1m${0##*/}[0m [volby] <DjVu soubor> info exif

  Vrací exif informace o DjVu souboru – včetně metainformací, pokud je
  obsahuje.
"""
    ;;
    info-grep) echo """
  ACTION [1minfo[0m –> grep

  [1m${0##*/}[0m [volby] <DjVu soubor> info grep …

  Aplikuje příkazy utility grep na výstup textového obsahu DjVu souboru,
  pokud nějaký obsahuje. V případě že nalezený vzorek podmínce příkazu
  vyhoví, tak se – kromě nalezeného vzorku – vypíše také jméno a pořadové
  číslo příslušné stránky v DjVu svazku.
"""
    ;;
    info-list) echo """
  ACTION [1minfo[0m –> list

  [1m${0##*/}[0m [volby] <DjVu soubor> info list

  Vrací seznam všech stránek v DjVu souboru, včetně speciální stránky
  shared_anno.iff, která (pokud se ve svazku vyskytuje) je vždy označena
  jako stránka 0. Výpis pak vypadá takto:

0     shared_anno.iff
1     w03.djvu
2     Příliš žluťoučký kůň.djvu
3     w02.djvu
"""
    ;;
    info-pages) echo """
  ACTION [1minfo[0m –> pages

  [1m${0##*/}[0m [volby] <DjVu soubor> info pages

  Vrací celkový počet stran v DjVu souboru. V případě DjVu single vrací 1,
  stejně jako v případě DjVu svazku s jednou stránkou.
"""
    ;;
    keywords-rename) echo """
  AKCE [1mrename[0m

  Přejmenování stránek v DjVu souboru.

  [1m${0##*/}[0m [option] <DjVu> rename [RANGE] PATTERN

Příklad:

  [1m${0##*/}[0m [option] <DjVu> rename 1,3-8 Stránka o něčem novém

  Výsledkem akce bude, že stránky vymezené rozsahem budou přejmenovány, a
  v případě že jich bude více také přečíslovány dle uvedeného vzoru PATTERN
"""
    help range
    ;;
    keywords-rotate) echo """
  AKCE [1mrotate[0m

  Mění výchozí orientaci stránek v DjVu souboru.

  [1m${0##*/}[0m [option] <DjVu> rotate {VALUE} {RANGE}

Pro nastavení orientace všech stránek na výchozí hodnotu, použijte: 0

  [1m${0##*/}[0m [option] <DjVu> rotate 0 0

  VALUE:
             0 - výchozí orientace (0°)
             1 - otočit stránku o 90° doprava
             2 - otočit stránku o 180° (vzhůru nohama)
             3 - otočit stránku o 90° doleva (na 270°)
          left - rotovat stránku o 90° směrem doleva
         right - rotovat stránku o 90° směrem doprava
           180 - otočit stránku opačně než aktuálně je

Pozor! Je-li uvedeno pouze jedno číslo, je aplikováno zároveň jako nastavení
       rotace i rozsah RANGE.

"""
    help range
    ;;
    keywords-unset) echo """
  AKCE [1munset[0m

  Jde o akci s reverzní funkcí vůči akci [2mset[22m, umožňující zrušení nastavených
  metadat a elementů DjVu souboru z příkazové řádky. Alternativní možností k této
  akci, je přímá editace obsahu, resp. metadatové vrstvy při akci [2medit[22m.

OCR
     [1m${0##*/}[0m [volby] <DjVu svazek> unset RANGE ocr

METADATA
     [1m${0##*/}[0m [volby] <DjVu svazek> unset [RANGE] key KEY

     [1m${0##*/}[0m [volby] <DjVu svazek> unset [RANGE] note DESC

ELEMENTY:
     [1m${0##*/}[0m [volby] <DjVu svazek> unset [RANGE] ELEMENT …

[3mPoznámka:[23m
  * Obsah (outline) přes unset zrušit nelze
  * Skrytou poznámku (note) lze zrušit pouze tehdy, když při akci unset odpovídá
    i její obsah DESC
  * Elementy lze rušit buď na základě předaných koordinátů (upřednostněná varianta),
    nebo na základě shody textového obsahu elementu, ovšem v případě elementů se
    shodným popisem by mohlo dojít k nechtěnému odstranění jiného elementu.
"""
    ;;
    keywords-set) echo """
  AKCE [1mset[0m

  Akce je určena k nastavení metadat a dalších prvků DjVu souboru z příkazové
  řádky. Přes [2mset[22m lze také dodatečně měnit vlastnosti ELEMENTU a jeho ATRIBUTY.
  METADATA a ELEMENTY lze odstranit při akci [2munset[22m nebo [2medit[22m.

     [1m${0##*/}[0m [volby] <DjVu svazek> set RANGE ocr [-h] …

OCR:
       ocr -  Rozpoznávání textu přes externí aplikaci [1mocrodjvu[0m

    [1m${0##*/}[0m [volby] <DjVu svazek> set RANGE METADATA [-h] …

METADATA:       
       key - metadatový klíč (vypisuje se přes exiftools)
      note - skrytá poznámka v metadatové vrstvě DjVu dokumentu
   outline - položka aktivního obsahu DjVu dokumentu (záložka)
      mode - výchozí zobrazovací mód obrazové vrstvy
background - barva pozadí okna prohlížeče DjVu souboru (djview)
       xmp - nastavené XMP atributů
      zoom - výchozí velikost zobrazení stránky

    [1m${0##*/}[0m [volby] <DjVu svazek> set RANGE ELEMENT [-h] … [: ATRIBUTY [-h]]

ELEMENTY:
  Jsou prvky, jimiž lze uživatelsky doplnit informační hodnotu původního
  obsahu stránky. Jde kupř. o hyperlinky v textu, zvýrazněné oblasti,
  poznámky, upozornění atp.

     arrow - šipka
      line - čára
      oval - oválné ohraničení oblasti
      poly - ohraničení oblasti polygonem
      rect - ograničení oblasti rámcem
      text - textová poznámka
            
Každý z elementů má své výchozí vlastnosti, které lze v případě modifikovat
nastavením dalších  atributů. Tyto atributy jsou při nastavení elementu od
základních parametrů  odděleny dvojtečkou. Viz příklad:

   … set oval 123 123 123 123 Popis oblasti : border FF0000

ATRIBUTY elementů:
    align               lineclr               textclr
    backclr             none                  width
    border              pushpin               xor
    border_avis         shadow_*

[3mPoznámka:[23m
  Více informací lze vypsat tak, že se bezprostředně za klíčovým slovem napíše
  volba -h.
"""
    ;;
    set-align)
        help metadata-align
        echo """
  [1m${0##*/}[0m [volby] <DjVu svazek> set {RANGE} align HORIZONTAL VERTICAL

HORIZONTAL
    left,center,right
VERTICAL
    top,center,bottom

Příklad zarovnání stránky do levého dolního rohu:
 … set 0 align left bottom

Příklad zarovnání stránky do středu okna:
 … set 1,5,10-25 center center

[3mPoznámka:[23m
  Pro globální nastavení použijte hodnotu RANGE nula – 0.
"""
    ;;
    set-arrow) echo """
  ELEMENT [1m${1#set-}[0m

  Šipka, je ve skutečnosti element line, s nastaveným atributem arrow,
  která se pak na stránce zobrazuje jako šipka.

   … set arrow X1 Y1 X2 Y2 DESC : [lineclr COLOR] [width SIZE]

X1 Y1
  Současnice bodu, ze kterého bude šipka vycházet
X2 Y2
  Souřadnice bodu do kterého bude šipka ukazovat

DESC
  Popis k šipce

Použitelné atributy:
  linecrl - barva šipky v RGB
    width - tloušťka čáry šipky
"""
    ;;
    set-backclr) echo """
ATRIBUT [1m${1#set-}[0m
(volitelný prvek)
Barva pozadí prvku. Dává smysl pouze u typu:
    rect - barva orámované plochy a
    text - barva pozadí textu

V případě prvků typu oval, poly, line nebo arrow, se vybarví pravoúhlá plocha
"""
    ;;
    set-background)
        help metadata-background
        echo """
  [1m${0##*/}[0m [volby] <DjVu svazek> set {RANGE} background {COLOR}

     COLOR - Barva v RGB

Příklad:
 … set 0 background F8F8F8
 … set 1,5,10-25 background FF0000

[3mPoznámka:[23m
  Pro globální nastavení barnu pozadí použijte hodnota RANGE nula – 0.
"""
    ;;
    set-+(border|xor|none)) echo """
ELEMENT [1m${1#set-}[0m
Nastavení okraje rámečku

  border <BARVA> - nastaví jinou barvu rámečku (výchozí je černá)
             xor - rámeček je tvořen přerušovanou linkou
            none - vypne zobrazování rámečku úplně

Okraj je zobrazen tenkou linkou, jejíž tloušťku nelze změnit!!!
"""
    ;;
    set-border_avis) echo """
ELEMENT [1m${1#set-}[0m
(volitelný prvek)
border_avis - nastavení viditelnosti prvku

Není-li řečeno jinak, zůstávají elementy typu rect na DjVu stránce skryté – zobrazují se teprve v okamžiku, kdy nad ně najedete myší.
Ovšem v případě prvku, co má být ihned viditelný se takové chování nehodí. Proto existuje tento parametr, kterým se nastaví aby byl
prvek viditelný stále
"""
    ;;
    set-key)
    help metadata-key
    echo """
Nastavení, resp. přenastavení klíče:

  [1m${0##*/}[0m <DjVu> set RANGE key KEY VALUE

Zrušení klíče:

  [1m${0##*/}[0m <DjVu> uset RANGE key KEY [VALUE]

KEY
  Řetězec znaků bez mezer a diakritiky, který nesmí začínat číslem

VALUE
  Hodnota klíče. Vyvarujte se použití kulatých závorek!

[3mPoznámka:[23m
  * I když je to technicky možné, jeden klíč nelze na stránce použít víc
    než jednou. Při pokusu o nastavení klíče s jinou hodnotou VALUE, dojde
    k nahrazení obsahu klíče stávajícího  novým obsahem.

Pro přehled nejčastěji používaných EXIF (či XMP) tagů spusťte:

  [1m${0##*/}[0m exif
"""
		;;
    set-line) echo """
  ELEMENT [1m${1#set-}[0m

  Linka která se zobrazuje na stránce. Od prvku arrow (šipka) se liší tím,
  nemá nastaveno aby se na jejím konci zobrazovala šipka.

   … set line X1 Y1 X2 Y2 DESC : [lineclr COLOR] [width SIZE]

X1 Y1
  Současnice bodu, ze kterého bude linka vycházet
X2 Y2
  Souřadnice bodu ve kterém bude linka končit

DESC
  Popis k lince

Použitelné atributy:
  linecrl - barva čáry v RGB
    width - tloušťka čáry
"""
    ;;
    set-lineclr) echo """
ATRIBUT [1m${1#set-}[0m
(volitelný prvek)
Nastavení barvy vykreslené čáry. Dává smysl pouze u typu
     line - linka
    arrow - šipka

U prvků rect, oval, poly a text se nastavuje barva linky, co ohraničuje plochu volitelným parametrem border
"""
    ;;
    set-metadata) echo """
METADATA [1m${1#set-}[0m
Nastavení metadatového klíče
"""
    ;;
    set-mode)
        help metadata-mode
        echo """
 Použít lze buď akci set:

  [1m${0##*/}[0m <DjVu svazek> set [RANGE] mode MODE

MODE
   color - normální barevné zobrazení
      bw - černobílé zobrazení masky
    fore - zobrazení popředí
   black - černobílé zobrazení

Pokud se místo rozsahu, či seznamu stránek RANGE uvede klíčové slovo
'global', bude nastaven tento meta atribut do sdílené metadatové vrstvy.
Tím se zapne nastavená volba jako výchozí pro všechny stránky, u kterých
nebude nastavená jinak. Atribut lze nastavit také při přímé editaci metadat:

  [1m${0##*/}[0m <DjVu svazek> edit ant

Do bloku příslušné stránky přidejte následující řádek
    …
    mode bw
    …
"""
    ;;
    set-note)
        help metadata-note
        echo """
   … set 0 note NOTE

NOTE
  Může být libovolný textový řetězec, který neobsahuje kulaté závorky.
  Do poznámky lze vložit také soubor. Podmínkou je, že musí být zakryptovaný
  do textového řetězce. Viz následující příklad vložení binárního archivu,
  zakódovaného do řetězce pomocí base64:

  djvutool a.djvu set 0 note \$(base64 archiv.zip | tr '\n' '-')

  A jeho vytažení:

  djvutool a.djvu export note 0 | tr '-' '\n' | base64 -d > kopie.zip

[3mPoznámka:[23m
  Na rozdíl od exif tagů, vkládaných přes metadatový klíč [1mkey[0m, může být
  skrytých poznámek vložených do metadatové vrstvy neomezeně. Pro zrušení
  skryté poznámky při akci [2munset[22m ovšem musí být uveden i řetězec, který
  obsahuje. Ten však lze získat při akci [2mexport[22m.

  Alternativní možností je odstranění skryté poznámky při akci [2medit[22m.
"""
    ;;
    set-none) echo """
ATRIBUT [1m${1#set-}[0m
(volitelný prvek)
none - vypne zobrazování okraje plochy

Anuluje nastavení hodnoty border i boorder_avis
"""
    ;;
    set-ocr) echo """
OCR

  K rozpoznávání textu se využívá aplikace [1mocrodjvu[0m, které se předávají
  případné další parametry jimiž lze ovlivnit použitý engine a jazyk slovníku.
  Jaké to jsou, lze zjistit, když se přidá jako parametr řetězec help

     [1m${0##*/}[0m [volby] <DjVu svazek> set RANGE ocr help

  Aplikace OCR na stránky určené rozsahem RANGE a uložení výsledku do souboru text.dsed
  ve formátu [2m.dsed[23m, který lze naimportovat prostřednictvím aplikace [1mdjvused[0m:

    [1m${0##*/}[0m [volby] soubor.djvu set 1,5-8 ocr --save-script text.dsed

  

"""
    ;;
    set-outline)
        help metadata-outline
        echo """
  [1m${0##*/}[0m [volby] <DjVu svazek> set outline {TARGET} {DESC}

    TARGET - Cíl záložky. Externí link (řetězec začínající http://…), pořadí (číslo),
             či jméno stránky v DjVu souboru (např. p0003.djvu)
      DESC - Popis záložky

Příklady:
 … set outline 1 Záložka odkazující na stránku č. 1
 … set outline jmeno_stranky.djvu Záložka odkazující na interní stránku jménem
 … set outline http://example.org Záložka odkazující na externí web

[3mPoznámka:[23m
 * Záložky, jejich pořadí či úroveň zanoření lze upravit při akci [2medit[22m.
 * Záložky lze přes akci [2mexport[22m vyexportovat v [3m.outline[23m či [3m.dsed[23m formátu
 * Soubor v [3m.outline[23m formátu lze upravit editací v libovolném textovém editoru.
   Prázdné řádky je třeba smazat. Na rozdíl od nastavení záložky přes akci set,
   je v .outline formátu na řádce vždy nejprve uveden popis (DESC) a teprve pak
   následuje cíl (TARGET), kterému předchází znak #
   Každá z nich je uzavřena v závorkách. Do nižsí úrovně vůči předchozí záložce
   lze záložku zanořit odsazení celého obsahu řádku tabulátorem:
                   1 úroveň = 1 tabulátor = 8 mezer
 * Záložky lze naimportovat buď ze souboru ve formátu [3m.outline[23m přes akci [2mimport[22m,
  nebo přes [1mdjvused[0m (formát  [3m.dsed[23m)"""
    ;;
    set-oval) echo """
ELEMENT [1m${1#set-}[0m
Nastavení oválné (kruhové) plochy
Default:

barva a typ okraje - černá, přerušovaná linka (xor) 
barvu a průhlednost plochy - průhledná (nelze změnit) 
URL - aktivní

    oval 0 0 50 50

Nakreslí kružnici o poloměru 50 pixelů, která bude umístěna v levém dolním
rohu.
První souřadnice udávají x,y souřadnice výchozího bodu, od kterého se pak
odměří X,Y součadnice středu kružnice.

    oval 350 125 100 100

Vykreslí kružnici o poloměru 100px, co bude mít střed na absolutních
souřadnicích 450 225

"""
    ;;
    set-+(pfoot|phead)) echo """
METADATA [1m${1#set-}[0m
Záhlaví a zápatí

Většina prohlížečů je neumí zobrazit. Je tedy zbytečné je nastavovat.
"""
    ;;
    set-poly) echo """
ELEMENT [1m${1#set-}[0m
Polynomický obrys plochy
Default:
barva a průhlednost plochy - průhledná. Obarvit lze pouze pravoúhlou plochu ve které je polynom vepsaný

Použitelné parametry:
  [border_avis]
  [none|border c] 
"""
    ;;
    set-rect) echo """
ELEMENT [1m${1#set-}[0m
Nastavení pravoúhlé plochy
    rect 0 0 50 50

Nakreslí čtverec o straně 50x50 pixelů, jehož levý dolní roh bude na souřadnicích
x,y a pravý horní se odměří jako vzdálenost X,Y

    rect 350 125 100 100

Vykreslí čtverec o straně 100x100 pixelů, co bude mít střed na absolutních
souřadnicích 450 225

Vykreslení pomocí djvutxt:
want@schroeder:~$ djvutxt -detail=line -page=1 b.djvu | grep SEIFERT
  (line 281 498 776 535 \"MILOŠ SEIFERT \")

 ­… set 1 area rect 281 498 $((535-281)) $((776-498)) Miloš Seifert, zakladatel LLM

Nejdřív přes info grep zjistit souřadnice textu

"""
    ;;
    set-shadow_+(in|out|ein|eout)) echo """
ATRIBUT [1m${1#set-}[0m

Nastavení velikosti stínu u pravoúhlého rámečku

  shadow_in - vnitřní plocha rámečku vypadá jako zahloubená dovnitř
 shadow_out - vnitřní plocha rámečku vypadá jako vystouplá ven
 shadow_ein - vnější okraj rámečku vypadá jako zahloubený dovnitř
shadow_eout - vnější okraj rámečku vypadá jako vystouplý ven

Nastavení libovolného parametru okraje (none, xor, nebo border) aplikaci stínu vyloučí!!!
"""
    ;;
    set-text)  echo """
ELEMENT [1m${1#set-}[0m
Nastavení pravoúhlé plochy
    text 0 0 50 50
         X Y W H
Do obdélníku o rozměrech WxH, s levým dolním rohem na souřadnicích XxY
vepíše text. Velikost písma upraví dle množství textu v rámci
"""
    ;;
    set-textclr) echo """
ATRIBUT [1m${1#set-}[0m
(volitelný prvek)
Barva textu - Dává smysl pouze u typu text

V případě prvků rect, oval, poly, line a arrow je tento parametr zbytečný, protože se u nich žádný text nezobrazuje
"""
    ;;
    set-width) echo """
ATRIBUT [1m${1#set-}[0m
    (volitelný prvek)
width - Nastavení šířky čáry (šipky). Celé číslo od 1 do 999
"""
    ;;
    set-xmp)
        help metadata-xmp
        echo """
  … set 0 key xmp '<rdf:RDF xmlns:rdf=…     …scription></rdf:RDF>'

[3mPoznámka:[23m
  * I když je to technicky možné, na jedné stránce je akceptován vždy pouze
    jeden XMP element. Při nastavení jiného kódu dojde k nahrazení toho 
    stávajícího novým obsahem.  Pro dílčí úpravy je tedy vhodnější použít
    akci edit.

Pro více informací o XMP spusťte:

  [1m${0##*/}[0m xmp
"""
    ;;
    set-zoom)
    help metadata-zoom
    echo """
  [1m${0##*/}[0m [volby] <DjVu svazek> set {RANGE} zoom {SIZE}

SIZE
  stretch - roztáhne stránku podle okna
  one2one - zobrazení 1:1
    width - na maximální šířku stránky
     page - celá stránka
 d1-99999 - velikost stránky v procentech
     

Příklad:
 … set 0 zoom stretch
 … set 1,5,10-25 zoom d150

[3mPoznámka:[23m
  * Pro globální nastavení velikosti stránky použijte hodnotu RANGE nula – 0.
  * Bohužel většina prohlížečů s tímto parametrem (ani djview), ale plugin
    založený na djvulibre ano.
"""
    ;;
    keywords-sign) echo """
Nastavuje metatagy ModDate Producer a HostComputer
Ty se nastavují automaticky při každém zásahu do metadatové vrstvy přes
akci import ant.

Pozor! Při hromadné editaci se automaticky se mění pouze u prvního výskytu.
Tohle je nutné mít na paměti, pokud se editují metadata pro více stránek
najednou. Individiálně to lze nastavit přes akci sign.

Ta umožňuje i obsah těchto metadat přenastavit, ovšem pouze za předpokladu,
že je předaná volba force. Při této volbě se automaticky nevkládá tento údaj
ani při importu.
"""
    ;;
    keywords-view) echo """
  AKCE: [1mview[0m

  [1m${0##*/}[0m [volby] <SOUBOR> view

  Otevře na pozadí soubor v prohlížeči. V případě bitmapových obrázků se
  použije [1mfeh[0m a v případě DjVu souborů [1mdjview4[0m.
"""
    ;;
		level) echo """
[1mParametr[0m
         -l|--level  <[2mčíslo[22m> Hodnota akceptovatelných ztrát u černobílé kresby
                               při konverzi. Před nastavením této hodnoty vyzkoušejte
                               optimální nastavení na některém ze souborů a s parametrem
                               --test

  Kromě číselné hodnoty, která musí být menší než 200 lze úroveň ztrát
  nastavit i pomocí některého z následujících parametrů - v případě že 
  jich bude uvedeno víc, má prioritu poslední z nich.

        --lossless     0 - žádné ztráty (default)
        --clean        1 - ignorují se body o velikosti 1 pixelu
        --lossy        100 - ignorují se plochy
"""
		;;
    metadata-align) echo """
  METADATA [1m${1#*-}[0m

  Metadatový atribut align určuje jakým způsobem má být zarovnána stránka
  vůči oknu prohlížečky DjVu souborů v horizontálním a vertikálním směru.
"""
    ;;
    metadata-background) echo """
  METADATA [1m${1#*-}[0m

  Meta atribut background nastavuje barvu pozadí okna prohlížeče, ve kterém
  se zobrazuje příslušná stránka. Smysl dává především tehdy. je-li vhodné
  barvu pozadí změnit vůči stránce tak, aby dávala lepší barevný kontrast.
  Většinou se nastavuje globálně, ale je možné ho nastavit také pro konkrétní
  stránky."""
    ;;
    metadata-key) echo """
  METADATA [1m${1#*-}[0m

  Přes metadatový element key se nastavují metadatové klíče, které mohou
  být interpretovány jako EXIF tagy. Tu obsahují informace o souboru,
  podobně jako XMP kód, pro který však existuje samostatný metadatový
  element xmp."""
    ;;
    metadata-mode) echo """
  METADATA [1m${1#*-}[0m

  Metadatový element mode umožňuje změnit výchozí zobrazení DkVu stránky
  v prohlížeči. Může se nastavit buď globálně, pro všechny stránky najednou,
  ale i pro každou stránku extra. To se může hodit obzvlástě v situaci,
  kdy jsou v rámci jednoho DjVu svazku zkombinovány stránky zpracované
  různým způsobem - černobílé bez pozadí, nebo barevné bez černobílé masky.
  Uživatel si pak nemusí při prohlížení přepínat mód zobrazení manuálně."""
    ;;
    metadata-note) echo """
  METADATA [1m${1#*-}[0m

  Metadatový element note obsahuje skrytou poznámku, kterou nezobrazuje,
  ani nezpracovává žádný prohlížeč DjVu souborů. Lze ji využít pro uložení
  informací o průběhu zpracování dokumentu, pro digitální podpisy obrazových
  vrstev & etc."""
    ;;
    metadata-outline) echo """
  METADATA [1m${1#*-}[0m

  Záložky (outline), patří mezi metadata. V prohlížeči DjVu souborů se
  zobrazují jako rozbalovací víceúrovňové menu odkazů na interní stránky
  resp. externí linky. Jednotlivé záložky lze nastavit prostřednictvím
  akce set. Jejich obsah a úroveň zanoření lze dodatečně upravit při akci
  edit."""
    ;;
    metadata-xmp) echo """
  METADATA [1m${1#*-}[0m

  Metadatový element xmp obsahuje XMP kód, který se pak interpretuje
  podobně jako EXIF tagy."""
    ;;
    metadata-zoom) echo """
  METADATA [1m${1#*-}[0m

  Meta atribut zoom umožňuje změnit výchozí velikost zobrazovaných stránek.
  Většinou se nastavuje globálně, ale je možné ho nastavit také pro konkrétní
  stránky. To se může hodit, pokud jsou v rámci jednoho DjVu svazku umístěné
  různě velké stránky."""
    ;;
    options) echo """
Volby:
    -a|--algorithm Nastavení algoritmu pro vytvoření masky při konverzi do DjVu
    -d|--diff       Zobrazování rozdílů v souborech co mění textovou vrstvu před
                   realizací importu
       --dpi       Nastavení jiné než výchozí hodnoty DPI (300) obrázku při exportu 
    -f|--force     Vynucení akce obchází veškeré potvrzovací dialogy
       --clean     Nastavení úrovně ztrát u masky při exportu do formátu DjVu
       --lossy
       --lossless
       --level
    -h|--help      Main options for help about option, or action
    -v|--verbose   Nastavení logovací úrovně"""
    ;;
    range) echo """RANGE
    Stránky lze identifikovat buď jménem nebo aktuální pozicí v rámci DjVu
    souboru. Pokud chceme identifikovat více stránek najednou, lze použít
    buď seznam jmen stránek, oddělených čárkou:

                        … 'name_1.djvu,name_23.djvu,name_4.djvu'

    Nebo seznam jejich pořadových čísel v souboru. Přičemž pomlčka
    identifikuje rozsah od-do:
                        … 1,10,4-5
[4mPoznámka:[24m
  * Před realizací akce se na základě jmen v seznamu vytvoří rozsah pořadí
    stránek v souboru, který se následně setřídí. Nezáleží tedy na tom, v
    jakém pořadí byly stránky, či jejich pořadová čísla předány.
  * Jména stránek co v DjVu svazku neexistují se při zpracování ignorují
"""
    ;;
    target) echo """
TARGET
  Určuje kam má jít výstup akce. Není-li uvedeno nic, tak se automaticky předpokládá,
  že je cílem standardní výstup (/dev/stdout), ze kterého je možné datový proud
  přesměrovat buď do souboru, nebo k dalšímu zpracování.

  orig - Je-li uvedeno klíčové slovo orig, použije se jméno stránky v DjVu svazku

  Prostřednictvím parametru TARGET lze určit nejenom PATTERN pro název cílového
  souboru, ale také cílový adresář. Viz příklad použití při exportu stránky č. 1

    … export djvu 1 nekam_na_disk/vzor

   jehož výsledkem bude uložení DjVu souboru s názvem vzor_1.djvu do relativně
   umístěného podadresáře nekam_na_disk"""
    ;;
    verbose) echo """
  Volba [1m-v[0m ([1m--verbose[0m)
  
  Prostřednictvím této volby si lze přesměrovat výstup doplňujících
  informačních výpisů na konzoli. Díky nim pak lze podrobně sledovat
  postup skriptu při zpracování souboru

  [1m${0##*/}[0m ... {-v|--verbose} ...

  Použít lze pouze čísla od 1 do 9. Nastavení lze provést těmito způsoby:

    … -v2 …
    … -v 2 …
    … -v=2 …
    … --verbose 2 …
    … --verbose=2 …

  0 Je výchozí stav, při kterém se logovací zprávy nevypisují nikam.
  1 Vypisuje pouze chybové (ERR) zprávy pouze na standardní chybový
    výstup.
  2 Zapisuje pouze do logu a pouze chybové (ERR) zprávy.
  3 Vypisuje chybové (ERR) zprávy na standardní výstup a zároveň je
    zapisuje do logu.
  4 Vypisuje chybové (ERR) a varovné (WARN) zprávy pouze na standardní
    chybový výstup.
  5 Zapisuje chybové (ERR) a varovné (WARN) zprávy pouze do logu.
  6 Zapisuje chybové (ERR) a varovné (WARN) zprávy na standardní výstup
    a zároveň je zapisuje do logu.
  7 Vypisuje všechny zprávy pouze na standardní chybový výstup.
  8 Zapisuje všechny zprávy pouze do logu.
  9 Vypisuje všechny zprávy na standardní výstup a zároveň je zapisuje
    do logu.
"""
    ;;
    xmp) echo """Nastavení XMP

  Na rozdíl od EXIF tagů, které lze nastavovat postupně jako metadatové klíče,
  jsou XMP atributy uloženy ve speciálním metadatovém klíči XMP, který musí
  být v rámci stránky vždy jedinečný.

  Následující ukázkový příklad demonstruje, jak vypadá obdobná informace
  nastavená jako EXIF tag, i jako XMP atribut.

  user@stroj:~$ djvutool soubor.djvu export ant 0
  # 'shared_anno.iff'
  metadata
      Title \"Název dokumentu\"
  xmp
      <rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\">
      <rdf:Description rdf:about=\"\">
      <dc:title xmlns:dc=\"http://purl.org/dc/elements/1.1/\">Název dokumentu
      </dc:title>
      </rdf:Description>
      </rdf:RDF>
"""
    ;;
    *) echo "Nápověda pro $1 nebyla dosud implementována" >> /dev/stderr
        return 1
    ;;
    esac
}

# Zpracování parametrů předaných při startu skriptu
main() {
case $# in
    0) help  && return 0
esac
while [ $# -gt 0 ]
do
    case ${1} in
        coords) case "$@" in
                coords+([[:blank:]])+([[:digit:]])+([[:blank:]])+([[:digit:]])+([[:blank:]])+([[:digit:]])+([[:blank:]])+([[:digit:]]))
                echo "${2} ${3} $((${4} - ${2})) $((${5} - ${3}))"
                ;;
                coords+([[:blank:]])+([[:digit:]]),+([[:digit:]]),+([[:digit:]]),+([[:digit:]]))
                # LEFT,TOP,SIRKA,VYSKA
                local TEMP=(${@//,/ })
                echo "${TEMP[3]},${TEMP[4]},${TEMP[1]#*+([[:blank:]])},${TEMP[2]}"
                ;;
                coords+([[:blank:]])+([[:digit:]])x+([[:digit:]])\++([[:digit:]])\++([[:digit:]]))
                #SIRKAxVYSKA+LEFT+TOP
                local TEMP=(${@//[x+]/ })
                echo "${TEMP[3]},${TEMP[4]},${TEMP[1]#*+([[:blank:]])},${TEMP[2]}"
                ;;
            esac
            return 0
        ;;
        exif|xmp) help ${1}
            return 0
        ;;
        -a|--algorithm) #/ S proměnnou ALG, která se nastavuje přes tuto volbu
            #/ pracuje funkce exportimg
            #/ Není-li uveden žádný kompresní algoritmus, tak se bude aplikovat
            #/ výchozí nastavení proměnné příslušné $ALG z konfigurace
            case ${2} in
                -h|--help) help algorithm
                    exit 0
                    ;;
                *) for i in ${2//;/ } ; do
                    if [[ ${ALGORITHM[@]} =~ (^|[^[:alpha:]])${i%:*}([^[:alpha:]]|$) ]] ; then
                        log info "main() Verify algorithm $i –> OK"
                    else
                        printf "Algorithm %s isn't supported\n" "$i" 1>&2
                        exit 0
                    fi
                    done
                    ALG=(${2//;/ })
                    log set "main() Compression algorithm –> ${ALG[@]}"
                    shift && shift
                    ;;
            esac
        ;;
        -d|--diff) # Je-li nastavena tato volba, pak se při importu nabízí možnost 
            # zobrazení rozdílů prostřednictvím aplikace vimdiff
            case ${2} in
                -h*|--help*) help diff && exit 0
                ;;
                *) DIFF="yes"
                    [ ! ${DIFF} ] && exit 18
                    shift
                ;;
            esac
        ;;
        --dpi) # Volba pro akci insert
            case ${2} in
                -h*|--help*) help dpi && exit 0
                    ;;
                [[:digit:]])
                    if [ "${2}" -ge "72" ] && [ "${2}" -le "6000" ] ; then
                        DPI="${2}"
                        log info "main() Aplikuji pro DPI parametr - ${DPI}"
                        shift && shift
                    else
                        echo "Hodnota u volby --dpi se musí pohybovat v rozmezí od 72 do 6000" >> /dev/stderr
                        exit 1
                    fi
                    ;;
                *) echo "Nebyla uvedena hodnota dpi. Pokud chcete volbou --dpi změnit výchozí hodnotu (300), musíte ji uvést jako číselný parametr" >> /dev/stderr
                    exit 1
                    ;;
            esac
        ;;
        -f|--force)
            case ${2} in
                -h*|--help*) help force && exit 0
                    ;;
                yes|no|skip) FORCE=${2}
                    log info "main() Aplikuji pro FORCE parametr - ${FORCE}"
                    shift && shift
                    ;;
                *) log warn "main() Nebyl uveden žádný parametr, aplikuji pro FORCE parametr - skip"
                    FORCE="yes"
                    shift
                    ;;
            esac
            log set "main() FORCE –> ${FORCE}"
        ;;
        --clean) LEVEL="--loss-level=1" && shift
        ;;
        --lossy) LEVEL="--loss-level=100" && shift
        ;;
        --lossless) LEVEL="--loss-level=0" && shift
        ;;
        --level) # Volba pro akci insert
            case ${2} in
                -h*|--help*) help force && exit 0
                    ;;
                [[:digit:]])
                    if [ "${2}" -ge "0" ] && [ "${2}" -lt "200" ] ; then
                        LEVEL="--loss-level=${2}"
                        log info "main() Aplikuji pro LEVEL hodnotu - ${LEVEL}"
                        shift && shift
                    else
                        help level && exit 0
                    fi
                    ;;
                *) echo "main() Volba --loss-level musí mít vždy uvedenou číselnou hodnotu v rozmezí 0-199" >> /dev/stderr
                    exit 1
                    ;;
            esac
            log info "main() Úroveň ztrátovosti při kompresi ${LEVEL}"
        ;;
        -v*|--verbose*) #/ Změna výchozí hodnoty proměnné $DEBUG
            case ${1} in
                -v|--verbose)
                    case ${2} in
                        -h|--help|help|\?)
                            help verbose && exit 0
                            ;;
                        [0-9])
                            DEBUG="-d${2}"
                            shift && shift
                            ;;
                        *) DEBUG="-d1"
                            shift
                            ;;
                    esac
                    ;;
                -v[0-9])
                    DEBUG="-d${1:2}"
                    shift
                    ;;
                *=*)
                    case "${1#*=}" in
                        0) shift
                            ;;
                        [1-9]) DEBUG="-d${1#*=}"
                            shift
                            ;;
                        *) help_debug "${1#*=}" && exit 1
                            ;;
                    esac
                    ;;
            esac
            log set "DEBUG –> ${DEBUG}"
        ;;
        *) if [[ ${ACTIONS[@]} =~ (^|[^[:alpha:]])${1}([^[:alpha:]]|$) ]] && [ "?" != "${1}" ]; then
                ACTION=${1}
                shift
                case ${1} in
                    -h|--help|help|?) help keywords-${ACTION}
                        return 0
                    ;;
                esac
                local FILE=$(realpath -P "${1}")
                FILETYPE=$(mimefile "${1}")
                if [[ ${FORMATS[@]} =~ ${FILETYPE} ]] ; then
                    shift
                    local CHARSTRING="$@"
                    log info "ACTION before FILE –> ${ACTION}"
                    log info "Set CHARSTRING –> ${CHARSTRING}"
                    break
                else
                    echo "${1} – Nepodporovaný typ souboru" >> /dev/stderr
                    return 1
                fi
            else
                case ${1} in
                    -h|--help|help|?) help
                        return 0
                    ;;
                esac
                local FILE=$(realpath -P "${1}")
                FILETYPE=$(mimefile "${1}")
                if [[ ${FORMATS[@]} =~ ${FILETYPE} ]] ; then
                    shift
                    if [[ ${ACTIONS[@]} =~ (^|[^[:alpha:]])${1}([^[:alpha:]]|$) ]] && [ "?" != "${1}" ]; then
                        ACTION=${1}
                        shift
                        local CHARSTRING="$@"
                        log info "ACTION after FILE –> ${ACTION}"
                        log info "Set CHARSTRING –> ${CHARSTRING}"
                        break
                    else
                        case ${1} in
                            -h|--help|help|?) help
                                help actions
                                printf "\t"
                                printf "%s " ${ACTIONS[@]}
                                echo ""
                                return 0
                            ;;
                            *) echo "For file ${FILE} unknown ACTION –> $@" >> /dev/stderr
                                return 1
                            ;;
                        esac
                    fi
                else
                    echo "Se souborem ${FILETYPE} tento skript neumí pracovat" >> /dev/stderr
                    return 1
                fi
            fi
        ;;
    esac
done

#/ echo "${ACTION}" >> /dev/stderr
#/ echo "${FILETYPE}" >> /dev/stderr
#/ echo "$@" >> /dev/stderr

if [[ "${CHARSTRING}" =~ "-h" ]] ; then
        if [ -n "${ACTION}" ] ; then
            case ${FILETYPE} in
                djvu) case "${CHARSTRING%%+([[:blank:]])*}" in
                        ant|dsed|meta|note|outline|page|xml|xmp) help "${ACTION}-${CHARSTRING%%+([[:blank:]])*}"
                        ;;
                        exif|grep|list|pages) help "info-${CHARSTRING%%+([[:blank:]])*}"
                        ;;
                        *) local TEMP=(${CHARSTRING%%+(-)h*})
                            local PROPERTY="${TEMP[@]: -1}"
                            case "${PROPERTY}" in
                                align|\
                                arrow|\
                                backclr|\
                                background|\
                                border|\
                                border_avis|\
                                key|\
                                line|\
                                lineclr|\
                                mode|\
                                none|\
                                ocr|\
                                oval|\
                                poly|\
                                pushpin|\
                                rect|\
                                shadow_*|\
                                text|\
                                textclr|\
                                width|\
                                xor|\
                                zoom) help set-${PROPERTY}
                                ;;
                                *) help "keywords-${ACTION}"
                                ;;
                            esac
                        ;;
                    esac
                ;;
                *) help "bitmap-${ACTION}"
                ;;
            esac
        else
            help
        fi
        exit 0
fi

case ${FILETYPE} in
    '') echo "${FILE} –> invalid path!" >> /dev/stderr
        return 1
    ;;
    djvu) #/ Pracuji se souborem v DjVu formátu
        log goto "Actions for DjVu file"
        case "${ACTION}" in
            delete) local TEST=$(isrange "${CHARSTRING}")
                if [ -n "${TEST}" ] ; then
                    #/ Rozsah stránek identifikovaných pořadím
                    RANGE=$(range ${TEST})
                else
                    #/ Seznam stránek oddělených čárkami
                    x=0
                    for i in ${CHARSTRING//,/ } ; do
                       RANGE[$x]=$(identifypage order "${FILE}" "${i}")
                    done
                fi
                #/ Setřídění RANGE pozpátku, 
                for i in $(printf "%d\n" ${RANGE[@]} | sort -nr) ; do
                    deletepage "${FILE}" "${i}"
                    [ $? -eq 1 ] && echo "Page isn't in ${FILE} –> $i" >> /dev/stderr && return 1
                done
            ;;
            fore|back)
                djvumove "${FILE}" "${CHARSTRING}"
            ;;
            export) exportdjvu "${FILE}" "${CHARSTRING}" |\
                xxd -p |\
                paste -s -d'-' |\
                sed 's/0a-09/-0a09/g ; s/0a09-0a09/-0a09/g ; s/0a090a09/0a09/g ; s/0a0928/2028/g' |\
                tr '-' '\n' | xxd -r -p
            ;;
            import|edit)
                importdjvu "${FILE}" "${CHARSTRING}"
            ;;
            info) djvuinfo "${FILE}" "${CHARSTRING}"
            ;;
            rename) djvurename "${FILE}" "${CHARSTRING}"
            ;;
            rotate) djvurotate "${FILE}" "${CHARSTRING}"
            ;;
            set|unset) setdjvu  "${FILE}" "${CHARSTRING}"
            ;;
            sign) djvusign "${FILE}" "${CHARSTRING}"
            ;;
            view) viewdjvu
            ;;
        esac
        return $?
    ;;
    *) log info "Input bitmap file (or archive) ${FILE} in format –> ${FILETYPE}"
        case ${ACTION} in
            export) exportfile
            ;;
            info) imginfo
            ;;
            view) imgview
            ;;
            set) log info "main() set exif tag in img ${FILE} –> ToDo"
            ;;
            unset) log info "main() unset exif tag in ${FILE} –> ToDo"
            ;;
            rotate) log info "main() rotate ${FILE}"
            ;;
            rename) log info "main() rename ${FILE}"
            ;;
            import) echo '''Pokud následuje djvu soubor'''
                echo '''Pokud následuje adresář'''
                echo '''to je existující soubor typu bundle a:
- nenásleduje žádný další existující soubor typu djvu, nebo adresář
    a zároveň existuje $DIRECTORY, pak to znamená že se má rozbalit
    - pokud následuje další soubor, pak to znamená že se má nějakým způsobem s tímto dalším souborem naložit. Je-li to:
    - djvu soubor, má se připojit
    - xml soubor, má se vložit
    - soubor typu dsed má se zpracovat
    - jiný soubor - obrázek, který se má převést a vložit
    '''
                log info "main() import ${FILE} into DjVu"
                case ${FILETYPE} in
                    djvu) echo "Konvertovat vstupní soubor a vložit do předchozeného DjVu souboru - TODO" >> /dev/stderr
                        #/ Sestavit z nich soubor typu bundle
                        ;;
                    gif) #/ může být mít více vrstev 'Animation frames
                        ;;
                    mng) #/ může být mít více vrstev 'Animation frames'
                        ;;
                    png) #/ může být mít více vrstev 'Animation frames'
                        ;;
                    gimp|xcf) #/může mít více vrstev
                        ;;
                    tiff) #/ může mít více stránek
                        ;;
                    pdf) #/ může mít více stránek
                        ;;
                    xml|XML) #/ imporuji soubor s textovou vrstvou
                        ;;
                    unknown) echo "Pokud je soubor ${1} typu DjVU, může jít o tzv. SecureDjVu formát, který má kryptované vrstvy. S takovým souborem nelze s opensource nástroji pracovat." >> /dev/stderr
                        exit 1
                        ;;
                    *) echo "Záleží na typu " >> /dev/stderr
                    ;;
                esac
            ;;
        esac
    ;;
esac
}

main "$@"

exit 0
