#!/bin/bash
# -*- mode: sh -*-

# https://…
# djvutool - tool for conversion and work with DjVu files
#
# Author: Aleš Kapica <kapica@fel.cvut.cz>, 2015-2017
#
shopt -s extglob

# Changelog
# * akce 'info' - umožňuje získávat různé užitečné informace
# * akce 'export' funguje zároveň jako konverzní nástroj
# * implementována akce 'rotate'
# * akce 'delete' odstraňuje stránky
# * akce 'edit', 'export', 'import'

# Otestovat
# - export ze single-page dokumentu
#

# ToDo
# - dopsat manuál pro akci set, argumenty, xmp, atp.
# V odstraňování metadat typu zoom, nebo background je nějaká chybka. Vezme to
# o řádku více než by mělo
#
# - OCR zpracované do samostatné funkce
# - ošetřena situace, kdy není nainstalován ocrodjvu
# - akce 'fore' a 'back' přesouvají stránky podle udaných parametrů
# - implementovány přesuny stránek (akce fore a back)
# - implementováno generování náhledů do exportu
# - upraveny funkce pro export náhledů a souborů textové vrstvy
# Odstranění vrstvy ze stránky
# Odstranění sdíleného chunku
# Doplnit nové funkce do wiki souboru
# implementovat kontrolu do funkce todjvu, aby nedocházelo k nekontrolovatelnému vkládání již existujících stránek
# - přidat kontrolu do akce insert na duplicitní soubory při vkládání
#   vícestránkových DjVu souborů. to ovšem bude vyžadovat samostatnou
#   funkci...
# - implementovat import
NAME="djvutool"
[ -d "${HOME}/.config/${NAME}" ] &&	. ${HOME}/.config/${NAME}/* &>>/dev/null

DEBUG="-d0"
LOG="${LOG=/dev/null}"
XML="${XML=no}"
DPI="${DPI=300}"
DSED="${DSED=no}"
PAGE="${PAGE=no}"
META="${META=no}"
IMG="${IMG=no}"
INDIRECT="${INDIRECT=no}"
FORCE="${FORCE=skip}"
RENAME="no"
EXTENSION=".djvu"
THUMBNAIL="${THUMBNAIL=no}"
INSERTTEXT="${INSERTTEXT=no}"
ALG="${ALG=none}"
EXTRACTPAGE="${EXTRACTPAGE=no}"
IMGPAGE="${IMGPAGE=no}"
ALGORITHM=( none abutaleb bernsen brink djvu niblack otsu sauvola shading-subtraction tsai white-rohrer )
TABS="8"

trap '''CHYBA=$? ;
case $CHYBA in
 10) echo "Žádná sdílená metadata"
 ;;
 20) echo "Není nainstalován balík poppler-utils"
 ;;
 19) echo "Není nainstalován balík pdftk"
 ;;
 20) echo "Není nainstalován balík djvu-tools"
 ;;
 21) echo "ERROR: mimetype - tool for detection type of image"
 ;;
 22) echo "ERROR: readlink - tool for detection absolute path of directory"
 ;;
 23) echo "ERROR: netpbm-sf - pack of utilities for image conversions not installed "
 ;;
 24) echo "ERROR: imagemagick - tool for image convert is not installed"
 ;;
 25) echo "ERROR: xmlstarlet - tool for work with xml not installed"
 ;;
 26) echo "ERROR: xcftools - tool for work with xcf file (GIMP) not installed"
 ;;
 27) echo "ERROR: libtiff-tools - tool for work with tiff file not installed"
 ;;
 28) echo "ERROR: libopenjp2-tools - tool for work with jp2 file not installed"
 ;;
 29) echo "ERROR: 7z - tool for work with compressed archives is not installed"
 ;;
 30) echo "ERROR: PDF viewer not installed"
 ;;
 31) echo "Není nainstalován balík ocrodjvu, na djvu soubory nelze aplikovat OCR. Buďto jej doinstalujte, nebo odstraňte z příkazové řádky parametr -o (--ocr)" >> /dev/stderr
 ;;
 32) echo "Pokud má při operaci zpracovat do DjVu bitmapový soubor, je třeba uvést na příkazové řádce parametrem -a jaký se má použít algoritmus. Jaké parametry lze použít se dozvíte pokud místo jména algoritmu napíšete znak ?" >> /dev/stderr
 ;;
 33) NORMDIR=yes
 ;;
 38) echo "ERROR - identifikátor stránky není platný!" >> /dev/stderr
 ;;
esac
[ $NORMDIR ] || rm -rf -- "$TEMPDIR"
exit $CHYBA
''' EXIT

TEMPDIR=$(mktemp -d -p /tmp ${NAME}-XXX) || exit 1

#=== testy závislostí ===
# Dependencies:
#   * feh      ( http://feh.finalrewind.org/ )
#   * exiftool ( http://www.sno.phy.queensu.ca/~phil/exiftool ) in Debian package: libimage-exiftool-perl 
#   * yad      ( http://sourceforge.net/projects/yad-dialog )
REALPATH=$(command -v realpath)
[ ! ${REALPATH} ] && exit 1
REALPATH="$REALPATH -e "
if ! command -v ed >/dev/null 2>&1 ; then
    echo "Musí být nainstalován editor ed" >> /dev/stderr
    exit 1
fi
FEH=$(command -v feh)
[ ! ${FEH} ] && exit 18
GEEQIE=$(command -v geeqie)
[ ! ${GEEQIE} ] && exit 18
DIDJVU=$(command -v didjvu)
[ ! ${DIDJVU} ] && echo 'Není nainstalován balík didjvu, nebude možné aplikovat pokročilé algoritmy pro separaci popředí při konverzi do DjVu' >> /dev/stderr && DIDJVU=false
OCRODJVU=$(command -v ocrodjvu)
[ ! ${OCRODJVU} ] && OCRODJVU=31
DJVIEW=$(command -v djview)
[ ! ${DJVIEW} ] && echo 'Není nainstalován balík djview, nebude fungovat testovací zobrazení djvu.souborů' >> /dev/stderr && DJVIEW=false
DDJVU=$(command -v ddjvu)
[ ! ${DDJVU} ] && exit 20
DJVUTXT=$(command -v djvutxt)
[ ! ${DJVUTXT} ] && exit 20
DJVUSED=$(command -v djvused)
[ ! ${DJVUSED} ] && exit 20
DJVUTOXML=$(command -v djvutoxml)
[ ! ${DJVUTOXML} ] && exit 20
DJVUXMLPARSER=$(command -v djvuxmlparser)
[ ! ${DJVUXMLPARSER} ] && exit 20
DJVMCVT=$(command -v djvmcvt)
[ ! ${DJVMCVT} ] && exit 20
DJVUEXTRACT=$(command -v djvuextract)
[ ! ${DJVUEXTRACT} ] && exit 20
DJVM=$(command -v djvm)
[ ! ${DJVM} ] && exit 20
CJB2=$(command -v cjb2)
[ ! ${CJB2} ] && exit 20
DJVUMAKE=$(command -v djvumake)
[ ! ${DJVUMAKE} ] && exit 20
#YAD=$(command -v yad)
#[ ! ${YAD} ] && echo 'Není nainstalován balík yad' && exit 1
MIME=$(command -v mimetype)
[ ! -x "${MIME}" ] && exit 21
STAT=$(command -v readlink)
[ ! -x "${STAT}" ] && exit 22
EXIFTOOL=$(command -v exiftool)
[ ! -x "${EXIFTOOL}" ] && exit 23
# Přesunuto do funkce main k volbě -o|--ocr
#TESSERACT=$(command -v  tesseract)
#[ ! -x "${TESSERACT}" ] && exit 31
IDENTIFY=$(command -v identify)
[ ! -x "${IDENTIFY}" ] && echo exit 24
CONVERT=$(command -v convert)
[ ! -x "${CONVERT}" ] && echo exit 24
IMGVIEW=$(command -v display)
[ ! -x "${IMGVIEW}" ] && echo exit 24
XCFINFO=$(command -v xcfinfo)
[ ! -x "${XCFINFO}" ] && echo exit 26
XCF2PNM=$(command -v xcf2pnm)
[ ! -x "${XCF2PNM}" ] && echo exit 26
TIFFINFO=$(command -v tiffinfo)
[ ! -x "${TIFFINFO}" ] && echo exit 27
PDFVIEW=$(command -v xpdf)
if [ ! -x "${PDFVIEW}" ] ; then
    PDFVIEW=$(command -v evince)
    if [ ! -x "${PDFVIEW}" ] ; then
        if [ ! -x "${xournal}" ] ; then
            echo exit 30
        fi
    fi
fi
PDFTK=$(command -v pdftk)
[ ! -x "${PDFTK}" ] && echo exit 19
PDFTOPPM=$(command -v pdftoppm)
[ ! -x "${PDFTOPPM}" ] && echo exit 18

# Konverze z formátu JPEG2000 (jp2)
JP2TO=$(command -v opj_decompress)
[ ! ${JP2TO} ] && exit 28
JP2IN=$(command -v opj_compress)
[ ! ${JP2IN} ] && exit 28
# Nástroje pro konverzi animovaných gifů a png souborů
# apng2gif, gif2apng, 

ZIP=$(command -v 7z)
[ ! -x "${ZIP}" ] && echo exit 29

# ## Implementované akce
#
ACTIONS=(
    delete
    fore
    back
    rotate
    export
    import
    convert
    edit
    info
    rename
    insert
    print
    set
    unset
    view
    )

# ## Akceptované formáty bitmapových souborů
#
# Neztrátové formáty 
FORMATS_FULL=(
    bmp
    pnm
    png
    tif
)
# Formáty, které mohou mít ztrítovou kompresi
FORMATS_MISS=(
    jpg
    xcf
    jp2
)
# Kontejnerové formáty
FORMATS_CONT=(
    pdf
    zip
    tar
)
FORMATS=(${FORMATS_FULL[@]} ${FORMATS_MISS[@]} ${FORMATS_CONT[@]})

PGMTOPBM=$(command -v pgmtopbm)
[ ! -x "${PGMTOPBM}" ] && exit 23
BMPTOPNM=$(command -v bmptopnm)
[ ! -x "${BMPTOPNM}" ] && exit 23
JPEGTOPNM=$(command -v jpegtopnm)
[ ! -x "${JPEGTOPNM}" ] && exit 23
GIFTOPNM=$(command -v giftopnm)
[ ! -x "${GIFTOPNM}" ] && exit 23
PNGTOPNM=$(command -v pngtopnm)
[ ! -x "${PNGTOPNM}" ] && exit 23
PNMTOJPEG=$(command -v pnmtojpeg)
[ ! -x "${PNMTOJPEG}" ] && exit 23
TIFFTOPNM=$(command -v tifftopnm)
[ ! -x "${TIFFTOPNM}" ] && exit 23
PNMTOPNG=$(command -v pnmtopng)
[ ! -x "${PNMTOPNG}" ] && exit 23
PAMTOJPEG2K=$(command -v pamtojpeg2k)
[ ! -x "${PAMTOJPEG2K}" ] && exit 23
JPEG2KTOPAM=$(command -v jpeg2ktopam)
[ ! -x "${JPEG2KTOPAM}" ] && exit 23
PNMTOJPEG=$(command -v pnmtojpeg)
[ ! -x "${PNMTOJPEG}" ] && exit 23
PNMTOPLAINPNM=$(command -v pnmtoplainpnm)
[ ! -x "${PNMTOPLAINPNM}" ] && exit 23
#/ Konvertuje barvy na stupně šedi
PPMTOPGM=$(command -v ppmtopgm)
#/ Konvertuje stupně šedi na černobílou mmasku
[ ! -x "${PPMTOPGM}" ] && exit 23
#/ Konvertuje binární formát PAM do PNM
PAMTOPNM=$(command -v pamtopnm)
[ ! -x "${PAMTOPNM}" ] && exit 23
#/ Vysekne oblast z obrázku dle souřadnic
PAMCUT=$(command -v pamcut)
[ ! -x "${PAMCUT}" ] && exit 23
#/ Odseparuje masku
PAMARITH=$(command -v pamarith)
[ ! -x "${PAMARITH}" ] && exit 23
#/ generátor prázdných ploch pro masku
PBMMAKE=$(command -v pbmmake)
[ ! -x "${PBMMAKE}" ] && exit 23
#/ integruje plochy do masky
PNMPASTE=$(command -v pnmpaste)
[ ! -x "${PNMPASTE}" ] && exit 23
NETPBMSCALE=$(command -v pamscale)
if [ -x "${NETPBMSCALE}" ] ; then
    # Akceptované škálovací filtry
    FILTERS=(
    point
    box
    triangle
    quadratic 
    cubic 
    catrom 
    mitchell 
    gauss 
    sinc 
    bessel 
    hanning 
    hamming 
    blackman 
    kaiser 
    normal 
    hermite 
    lanczos
    )
    NETPBM=0
else
    exit 23
fi

#=== konec testu závislostí ===

## Pomocné funkce...
# ### <span id="xtabs">xtabs()</span> ([top](#FUNCTIONS))
# Používá ji pouze funkce outlineset
# $1 - count of tabs
# return string of tabs
xtabs() {
    local TAB=$1
    while [ ! $TAB -eq 0 ] ; do
        printf '\t'
        TAB=$(( $TAB - 1 ))
    done 
}

function tabs {
	# $1 - file with tabs
	local TAB=$(printf '%.0s\ ' {0..${TABS}})
	sed "s/\t/${TAB}/g" "${1}"
}

# ### <span id="log">log()</span> ([top](#FUNCTIONS))
# Je-li použita volba `-d` nebo `--debug`, nastaví funkce [main](#main)
# do globální proměnné [$DEBUG](#$DEBUG) řetězcovou hodnotu, která určuje
# kam se budou zprávy předané této funkci posílat. Ta je tvořená řetězcem
# `-d` a číslem. Jakž bude mít toto číslo efekt viz
# [Parametry pro debug](#debug-levels).
#
# První položka, předaná této funkci jako parametr __$1__, určuje
# závažnost zprávy. Ostatní předané položky pak jsou již součástí
# vypisované zprávy.
#
#     log info "Zpráva s informativní hodnotou"
# Informační zprávy obsahují kontrolní výpisy, které informují o průběhu
# zpracování akce skriptem
#
#     log warn "Zpráva, co upozorňuje že by něco nemuselo klapnout"
# Upozorňující zprávy se používají při operacích, které mohou představovat
# problém. Kupř. když skript realizuje nevratný krok. Modelovým příkladem
# takové situace je zpracování příkazu [___delete___](#delete-command-config)
# při akci [__config__](#config), při kterém se odstraňují všechny
# konfigurační soubory pro VM, ze všech hostitelů.
#
#     log err "Zpráva, která oznamuje chybu"
# Chybové zprávy popisují stavy, které mají návratový kód __1__
#
# #### <span id="debug-levels">Parametry pro debug</span>
# Výchozí hodnota pro [$DEBUG](#$DEBUG) je __0__ při které se nevypisuje
# nic. Doporučená úroveň pro ladění skriptu je __7__. A pro normální
# použití, v případě že je skript spravován kupř. přes `cron` __5__.
#
# 1. Vypisuje pouze chybové (ERR) zprávy pouze na standardní chybový výstup
# 2. Zapisuje pouze do logu a pouze chybové (ERR) zprávy
# 3. Vypisuje chybové (ERR) zprávy na standardní výstup a zároveň je
#    zapisuje do logu
# 4. Vypisuje chybové (ERR) a varovné (WARN) zprávy pouze na standardní
#    chybový výstup
# 5. Zapisuje chybové (ERR) a varovné (WARN) zprávy pouze do logu
# 6. Zapisuje chybové (ERR) a varovné (WARN) zprávy na standardní výstup
#    a zároveň je zapisuje do logu
# 7. Vypisuje všechny zprávy pouze na standardní chybový výstup
# 8. Zapisuje všechny zprávy pouze do logu
# 9. Vypisuje všechny zprávy na standardní výstup a zároveň je zapisuje do logu
#
# #### Kde se rozhodně nesmí použít parametr $DEBUG
# Parametr $DEBUG rozhodně nepoužívejte tam, kde se musí zavolat akce na
# vzdáleném stroji přes $SSH a navrácený výstup se má dále zpracovávat.
# Problém spočívá v tom, že SSH s parametrem -t, které se používá pro
# interaktivní práci, přetočí chybový výstup na standardní výstup a tím
# pádem se může vrátit neplatný výsledek.
#
# Typickým příkladem budiž volání akce master. Je-li zavoláno s parametrem
# DEBUG, je výsledek pro další zpracování nepoužitelný!
#
#      local MASTER=$($0 ${DEBUG} master ${PROCESS})
#
# Správně:
#
#      local MASTER=$($0 master ${PROCESS})
#
# #### Místo zpracování ve skriptu
# Při testování je třeba vložit do vypisovaného řetězce proměnnou $LINENO
# ta vypíše číslo řádku zpracovávaného skriptu, kde se zrovna nachází
# Je-li to místo ve funkci, tak proměnná ${BASH_LINENO[0]} vypíše číslo
# řádku, ze kterého byla tato funkce zavolaná, a ve ${BASH_LINENO[1]} je uložen
# index jejího jména v poli ${FUNCNAME[@]}
log() {
    local TIMESTAMP="$(date +%T.%N)"
    local LOG="${LOGDIR}/messages"
    if [ -n "${DEBUG}" ] ; then
        case ${DEBUG} in
            -d0) ;;
            -d1) [ "${1^^}" == "ERR" ] && \
                echo -e "${TIMESTAMP} ${ACTION} ${1^^} ${FUNCNAME[1]}:${BASH_LINENO[0]} ${@:2}" >> /dev/stderr
                ;;
            -d2) [ "${1^^}" == "ERR" ] && \
                echo -e "${TIMESTAMP} ${ACTION} ${1^^} ${FUNCNAME[1]}:${BASH_LINENO[0]} ${@:2}" >> ${LOG}
                ;;
            -d3) [ "${1^^}" == "ERR" ] && \
                echo -e "${TIMESTAMP} ${ACTION} ${1^^} ${FUNCNAME[1]}:${BASH_LINENO[0]} ${@:2}" | \
                tee ${LOG} >> /dev/stderr
                ;;
            -d4) [ "${1^^}" == "ERR" ] || [ "${1^^}" == "WARN" ] && \
                echo -e "${TIMESTAMP} ${ACTION} ${1^^} ${FUNCNAME[1]}:${BASH_LINENO[0]} ${@:2}" >> /dev/stderr
                ;;
            -d5) [ "${1^^}" == "ERR" ] || [ "${1^^}" == "WARN" ] && \
                echo -e "${TIMESTAMP} ${ACTION} ${1^^} ${FUNCNAME[1]}:${BASH_LINENO[0]} ${@:2}" >> ${LOG}
                ;;
            -d6) [ "${1^^}" == "ERR" ] || [ "${1^^}" == "WARN" ] && \
                echo -e "${TIMESTAMP} ${ACTION} ${1^^} ${FUNCNAME[1]}:${BASH_LINENO[0]} ${@:2}" | \
                tee ${LOG} >> /dev/stderr
                ;;
            -d7) echo -e "${TIMESTAMP} ${ACTION} ${1^^} ${BASH_LINENO[0]}:${FUNCNAME[1]}()\t${@:2}" >> /dev/stderr
                ;;
            -d8) echo -e "${TIMESTAMP} ${ACTION} ${1^^} ${FUNCNAME[1]}:${BASH_LINENO[0]} ${@:2}" >> ${LOG}
                ;;
            -d9) echo -e "${TIMESTAMP} ${ACTION} ${1^^} ${FUNCNAME[1]}:${BASH_LINENO[0]} ${@:2}" | \
                tee ${LOG} >> /dev/stderr
                ;;
            *) help_debug && exit 1
                ;;
        esac
    fi
}
# <span id="help_debug" /> ([top](#FUNCTIONS))
help_debug() {
    echo """Chybné nastavení pro debug –> $1

Pro debug lze použít pouze čísla od 1 do 9. Nastavení lze provést těmito způsoby:

    … -d2 …
    … -d 2 …
    … -d=2 …
    … --debug 2 …
    … --debug=2 …

  0 Je výchozí stav, při kterém se logovací zprávy nevypisují nikam.
  1 Vypisuje pouze chybové (ERR) zprávy pouze na standardní chybový
    výstup.
  2 Zapisuje pouze do logu a pouze chybové (ERR) zprávy.
  3 Vypisuje chybové (ERR) zprávy na standardní výstup a zároveň je
    zapisuje do logu.
  4 Vypisuje chybové (ERR) a varovné (WARN) zprávy pouze na standardní
    chybový výstup.
  5 Zapisuje chybové (ERR) a varovné (WARN) zprávy pouze do logu.
  6 Zapisuje chybové (ERR) a varovné (WARN) zprávy na standardní výstup
    a zároveň je zapisuje do logu.
  7 Vypisuje všechny zprávy pouze na standardní chybový výstup.
  8 Zapisuje všechny zprávy pouze do logu.
  9 Vypisuje všechny zprávy na standardní výstup a zároveň je zapisuje
    do logu.
"""
}

function pushd {
    command pushd "$@" > /dev/null
}

function popd {
    command popd "$@" > /dev/null
}

# ### <span id="anone">anone()</span> ([top](#FUNCTIONS))
# Ověřovací funkce.
# V případě, že se lze pokračovat v realizaci akce vrací __0__,
# v opačném případě __1__.
anone() {
    if [ -n "${1}" ] ; then
        if [ "${FORCE}" != "yes" ] ; then
            echo "$1"
            while true ; do
#                read -p "(ANO/NE) : " yn
                read -er yn
                case $yn in
                    [AaYy]*) break;;
                    [Nn]*) return 1;;
                    *) echo "Napište ANO či NE:";;
                esac
            done
        fi
        return 0
    else
        log warn "anone() Not value"
        return 1
    fi
}

function potvrdit {
    read -r -p "${1:-Opravdu chcete akci provést? [y/N]} " response
    case $response in
        [yY][eE][sS]|[yY]) 
            true
            ;;
        [aA][nN][oO]|[aA]) 
            true
            ;;
        *)
            false
            ;;
    esac
}

function printtext {
	echo "${#1}" >> /dev/stderr
	echo -e "${@}"
}

function escape_path {
# Zatím nepoužitá
	echo "escape_path $*" >> /dev/stderr
	echo "$*" | sed \
  -e 's/\ /\\\ /g'
}

function extractmaparea {
	if [ $1 == "(maparea" ] ; then
		if [ $2 == "(url" ] ; then
			echo "URL ($3 $4"
			shift && shift && shift && shift
		else
			echo "NOTE $2"
			shift && shift
		fi
		echo -e $@ | sed 's/ (/\n(/g' | sed 's/^/\t/' | sed 's/))/)/'
	fi
}

# ###  <span id="testsyntaxant">testsyntaxant()</span> ([top](#FUNCTIONS))
# Tato funkce se stará o zpracování .ant formátu do formátu .dsed
# Je opakem funkce formatsed
#
#    # 'shared_anno.iff' ; remove-ant
#    set-ant
#    metadata
#        Author "jméno a příjmení"
#        Exif.Image.DateTime "2017:11:27 17:05:21"
#    background #000000
#    zoom d50
# 
# A výstup takto:
#
#    # ------------------------- 
#    select "shared_anno.iff"
#    set-ant
#    (metadata (Author "jméno a příjmení") (Exif.Image.DateTime "2017:11:27 17:05:21"))
#    (background #000000 ) (zoom d50 ) 
#    .
#
testsyntaxant() {
    local OK="OK –> ${line}"
    local ERR="ERR –> Chybí typ datového bloku"
    local INVALID="INVALID –> Neplatný typ datového bloku"
    local START="yes"
    while read -r line ; do
    log info "textsyntax() –> ${line}"
        case "${line}" in
            \#+([[:blank:]])+([[:digit:]]))
                if [ -n "${START}" ] ; then
                    unset START
                else
                    case "${META}" in
                        metadata)  case "${KEYS}" in
                            '') continue ;;
                            *) printf "(${META} ${KEYS})\n" ;;
                            esac
                        ;;
                        maparea) echo "(${META} ${URL} ${BORDER} ${KEYS})"
                        ;;
                    esac
                    unset KEYS
                    unset BORDER
                    unset URL
                    unset META
                    printf "\n."
                fi
                printf "\n# ------------------------- \n"
                case "${line#\#+([[:blank:]])}" in
                    0*) printf "select 'shared_anno.iff' ; remove-ant\n"
                    ;;
                    *) printf "select %d\n" "${line#\#+([[:blank:]])}"
                    ;;
                esac
                printf "remove-ant ; set-ant\n"
            ;;
            \#+([[:blank:]])*) 
                if [ -n "${START}" ] ; then
                    unset START
                else
                    case "${META}" in
                        metadata)  case "${KEYS}" in
                            '') continue ;;
                            *) printf "(${META} ${KEYS})\n" ;;
                            esac
                        ;;
                        maparea) echo "(${META} ${URL} ${BORDER} ${KEYS})"
                        ;;
                    esac
                    unset KEYS
                    unset BORDER
                    unset URL
                    unset META
                    printf "\n."
                fi
                printf "\n# ------------------------- \n"
                local TEMPORAR="${line#\#+([[:blank:]])}"
                case "${TEMPORAR}" in
                    'shared_anno.iff'*|\
                    shared_anno.iff*|\
                    0) printf "select 'shared_anno.iff' ; remove-ant\n"
                    ;;
                    +([[:digit:]])*) printf "select %s; remove-ant\n" "${TEMPORAR%%+([[:blank:]])*}"
                    ;;
                    *)  printf "select %s; remove-ant\n" "${TEMPORAR%%#*}"
                    ;;
                esac
                printf "set-ant\n"
            ;;
            metadata) case "${META}" in
                        metadata) case "${KEYS}" in
                            '') continue ;;
                            *) printf "(${META} ${KEYS})\n" ;;
                            esac
                        ;;
                        maparea) printf "(${META} ${URL} ${BORDER} ${KEYS})\n"
                        ;;
                esac
                unset KEYS
                unset BORDER
                unset URL
                META='metadata'
            ;;
            maparea) case "${META}" in
                        metadata)  case "${KEYS}" in
                            '') continue ;;
                            *) printf "(${META} ${KEYS})\n" ;;
                            esac
                        ;;
                        maparea) echo "(${META} ${URL} ${BORDER} ${KEYS})"
                        ;;
                esac
                unset KEYS
                unset BORDER
                unset URL
                META='maparea'
            ;;
            align+([[:blank:]])+(left|center|right)+([[:blank:]])+(top|center|bottom)|\
            background+([[:blank:]])\#[0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F]|\
            mode+([[:blank:]])+(color|bw|fore|black)|\
            pfoot+([[:blank:]])*|\
            phead+([[:blank:]])*|\
            zoom+([[:blank:]])d+([[:digit:]])|\
            zoom+([[:blank:]])+(stretch|one2one|width|page)|\
            note*)
                case "${META}" in
                        metadata)  case "${KEYS}" in
                            '') continue ;;
                            *) printf "(${META} ${KEYS})\n" ;;
                            esac
                        ;;
                        maparea) echo "(${META} ${URL} ${BORDER} ${KEYS})"
                        ;;
                esac
                printf "($line) "
                unset KEYS
                unset BORDER
                unset URL
                unset META
            ;;
            +([[:digit:]])+([[:blank:]])*)
                echo "Klíč tvořený pouze číslem není přípustný –> ${line}" >> /dev/stderr
                return 1
            ;;
            [[:digit:]]+([[:alnum:]])+([[:blank:]])\"*) #/ klíč začínající číslem sice sežere, ale nezobrazí
                echo "Klíč začínající číslem není přípustný –> ${line}" >> /dev/stderr
                return 1               
            ;;
            url+([[:blank:]])\"*\"+([[:blank:]])\"*\")
                [ -n "${META}" ] || echo "${ERR}" >> /dev/stderr
                [ -n "${URL}" ] && echo "URL už je nastaveno!" >> /dev/stderr && return 1
                local TEMPORAR=(${line})
                if [ ${#TEMPORAR[@]} -eq 4 ] ; then
                    local URL="(${line[0]} ${line[1]} ${line[2]}) ${line[3]}"
                else
                    echo "Neplatné nastavení URL –> ${line}"
                    return 1
                fi
            ;;
            \"*\"+([[:blank:]])\"*\")  #maparea bez URL
                [ -n "${META}" ] || echo "${ERR}" >> /dev/stderr
                [ -n "${URL}" ] && echo "URL už je nastaveno!" >> /dev/stderr && return 1
                local URL="${line}"
            ;;
            +(rect|oval|poly|line|text)+([[:blank:]])+([[:digit:]])+([[:blank:]])+([[:digit:]])+([[:blank:]])+([[:digit:]])+([[:blank:]])+([[:digit:]])*)
                [ -n "${META}" ] || echo "${ERR}" >> /dev/stderr
                [ -n "${BORDER}" ] && echo echo "BORDER už je nastaveno! –> ${BORDER}" >> /dev/stderr && return 1
                local BORDER="(${line}) "
            ;;
            #shadow_*) # stínování - číslem uvedená tloušťka
            #;;
            #hilite+([[:blank:]])\#+([[:digit:]])) # barva vysvícení
            #;;
            pushpin) # špendlík
                [ -n "${META}" ] || echo "${ERR}" >> /dev/stderr
                [ "${META}" == "maparea" ] || echo "${INVALID}" >> /dev/stderr
                [ -n "${BORDER}" ] || echo "${ERR}" >> /dev/stderr
                case "${BORDER%% *}" in
                    \(text) local KEYS="${KEYS} (${line})"
                    ;;
                    *) echo "Atribut pushpin lze použít pouze je-li maparea typu text –> ${BORDER}" >> /dev/stderr
                        return 1
                    ;;
                esac
            ;;
            arrow) # šipka
                [ -n "${META}" ] || echo "${ERR}" >> /dev/stderr
                [ "${META}" == "maparea" ] || echo "${INVALID}" >> /dev/stderr
                [ -n "${BORDER}" ] || echo "${ERR}" >> /dev/stderr
                case "${BORDER%% *}" in
                    \(line) local KEYS="${KEYS} (${line})"
                    ;;
                    *) echo "Atribut arrow lze použít pouze u typu 'line' proto se u ostaních typů ignoruje –> ${BORDER}." >> /dev/stderr
                    ;;
                esac
            ;;
            border_avis)
                [ -n "${META}" ] || echo "${ERR}" >> /dev/stderr
                [ "${META}" == "maparea" ] || echo "${INVALID}" >> /dev/stderr
                [ ! -n "${BORDER}" ] && echo "Nejprve musí být nastavena oblast!" >> /dev/stderr
                case "${BORDER%% *}" in
                    \(line) echo "Atribut border_avis typ 'line' nepoužívá, proto při importu ignoruje." >> /dev/stderr
                    ;;
                    *) local KEYS="${KEYS} (${line})"
                    ;;
                esac
            ;;
            xor|none)
                [ -n "${META}" ] || echo "${ERR}" >> /dev/stderr
                [ "${META}" == "maparea" ] || echo "${INVALID}" >> /dev/stderr
                [ ! -n "${BORDER}" ] && echo "Nejprve musí být nastavena oblast!" >> /dev/stderr
                local KEYS="${KEYS} (${line})"
            ;;
            +(opacity|width|shadow_+(in|out|ein|eout))+([[:blank:]])+([[:digit:]]))
                [ -n "${META}" ] || echo "${ERR}" >> /dev/stderr
                [ "${META}" == "maparea" ] || echo "${INVALID}" >> /dev/stderr
                [ ! -n "${BORDER}" ] && echo "Nejprve musí být nastavena oblast!" >> /dev/stderr
                local KEYS="${KEYS} (${line})"
            ;;
            +(backclr|textclr|line_clr|lineclr|border|hilite)+([[:blank:]])\#[0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F])
                [ -n "${META}" ] || echo "${ERR}" >> /dev/stderr
                [ "${META}" == "maparea" ] || echo "${INVALID}" >> /dev/stderr
                [ ! -n "${BORDER}" ] && echo "Nejprve musí být nastavena oblast!" >> /dev/stderr
                local KEYS="${KEYS} (${line})"
            ;;
            '') #echo "Prázdný řádek - vypíše položku a vypne přechozí volbu"
                if [ "${META}" == "metadata" ] ; then
                    echo "(${META} ${KEYS})"
                    unset META
                    unset KEYS
                    unset BORDER
                    unset URL
                elif [ "${META}" == "maparea" ] ; then
                    echo "(${META} ${URL} ${BORDER} ${KEYS})"
                    unset BORDER
                    unset META
                    unset URL
                    unset KEYS
                fi
            ;;
            \;*) #/ komentáře
            ;;
            +([[:alpha:]])+([[:alnum:]])+([[:blank:]])\"*\") #/ Metadatové klíče
                [ -n "${META}" ] || echo "${ERR}" >> /dev/stderr
                local KEYS="${KEYS} (${line})"
            ;;
            +([[:alpha:]])+([[:blank:]])\"*\") #/ Metadatové klíče
                [ -n "${META}" ] || echo "${ERR}" >> /dev/stderr
                local KEYS="${KEYS} (${line})"
            ;;
            *) echo "Na řádku je chyba –> ${line}" >> /dev/stderr
                return 1
            ;;
        esac
    done < $1
    printf "\n.\n"
}

# ### <span id="testsyntaxdsed">testsyntaxdsed()</span> ([top](#FUNCTIONS))
# Funkce pro zpracování výstupu příkazu output-ant
testsyntaxdsed() {
    local ANTFILE=$(tempfile -d ${TEMPDIR} -s .ant)
    local TXTFILE=$(tempfile -d ${TEMPDIR} -s .txt)
    while read -r line ; do
        case "${line}" in
            select\;*) # Následuje výstup příkazu output-ant
                local ALL="yes"
            ;;
            select+([[:blank:]])\"*) # Následuje zpracování stránky
                local PAGE="# ${line#select+([[:blank:]])}"
                echo "${PAGE}"
            ;;
            set-ant) local ANT="yes"
            ;;
            set-txt) local TXT="yes"
            ;;
            \.) if [ -n "${ANT}" ] ; then
                    cat ${ANTFILE} | formatdsed
                    unset ANT
                elif [ -n "${TXT}" ] ; then
                    cat ${TXTFILE} | formatdsed
                    unset TXT
                fi
            ;;
            \#+([[:blank:]])+(-)) # echo "Konec stránky" >> /dev/stderr
                unset PAGE
            ;;
            *) if [ -n "${ANT}" ] ; then
                    echo "${line}" >> ${ANTFILE}
                elif [ -n "${TXT}" ] ; then
                    echo "${line}" >> ${TXTFILE}
                fi
            ;;
        esac
    done < $1
}

# ###  <span id="formatdsed">formatdsed()</span> ([top](#FUNCTIONS))
# Tato funkce se stará o zpracování streamu v .dsed formátu do formátu .ant
# Je opakem funkce testsyntaxant(). Vstup vypadá takto:
#
#    # ------------------------- 
#    select "shared_anno.iff"
#    set-ant
#    (metadata (Author "jméno a příjmení") (Exif.Image.DateTime "2017:11:27 17:05:21"))
#    (background #000000 ) (zoom d50 ) 
#    .
# 
# A výstup takto:
#
#    # 'shared_anno.iff' ; remove-ant
#    set-ant
#    metadata
#        Author "jméno a příjmení"
#        Exif.Image.DateTime "2017:11:27 17:05:21"
#    background #000000
#    zoom d50
#
formatdsed() {
    sed 's/\t/\n/g ; s/(/\n(/g ; s/("/\n\t"/g ; ' | grep -v ^$ | \
    sed '/^(m[ea][tp]a[dr][ae][ta]/! s/^(/\t(/ ; /^\t($/d ; s/) ) )/) )/ ; s/\\/\\\\0/g ; s/</\n</g' | \
    while read line ; do
        #/echo "zpracovávám ${line}" >> /dev/stderr
        case ${line} in
            \(metadata) echo -e "metadata"
                local TAB=""
            ;;
            \(xmp*) echo -e "xmp"
                local XMP="y"
                local TAB="\t"
            ;;
            \(maparea+([[:blank:]])\") echo -e "\n"
                local TAB="\t"
            ;;
            \(note+([[:blank:]])\"*) local TEMPORAR="${line#(}"
                echo -e "${TEMPORAR%\)}"
                unset TEMPORAR
                unset TAB
            ;;
            set-ant|set-txt)
            ;;
            *) if [ "${TAB}" == "\t" ] ; then
                    case "${line:0:2}" in
                        "(u") local TEMPORAR="${line#(}"
                            echo "maparea"
                            echo -e "${TAB}${TEMPORAR//\) /}"
                            unset TEMPORAR
                        ;;
#                        \#*) echo -n "# "
#                            unset TAB
#                        ;;
                        *) if [ -n "${XMP}" ] ; then
                                case "${line: -2}" in
                                    \"\)) echo -e "${TAB}${line%>*}>"
                                        unset XMP
                                    ;;
                                    *)  echo -e "${TAB}${line}"
                                    ;;
                                esac
                            else
                                local TEMPORAR="${line#(}"
                                echo -e "${TAB}${TEMPORAR// \)/}"
                                unset TEMPORAR
                            fi
                        ;;
                    esac
                else
                    local TEMPORAR="${line//[)(]/}"
                    case "${TEMPORAR}" in
                        maparea*) echo -e "${TEMPORAR/ /\\\n\\\t}"
                            unset TEMPORAR
                        ;;
                        background*|zoom*|mode*|align*|phead*|pfoot*)
                            #local TEMPORAR="${line#(}"
                            #echo -e "${TEMPORAR// \)/}"
                            echo "${TEMPORAR}"
                            unset TEMPORAR
                            unset TAB
                        ;;
                        \#*) echo -n "# "
                            unset TAB
                        ;;
                        select*) echo "${TEMPORAR}"
                        ;;
                        *) echo -e "\t${TEMPORAR}"
                            unset TEMPORAR
                        ;;
                    esac
                fi
            ;;
        esac
    done  | sed 's/) )/)/ ; /^$/d '
}

# ### <span id="printmeta">printmeta()</span> ([top](#FUNCTIONS))
# Odstraňuje z DjVu Bundle svazku stránky
#
# $1 - svazek
# $2 - identifikátor, klíčové slovo 'all' nebo atribut
printmeta() {
    log goto "printmeta() ${1} –> ${2}"
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	case "${2}" in
		all) log info "printmeta() All meta attributes for %s\n" "${FILE}"
			local META=$(${DJVUSED} "${SOURCE}" -e "select; print-meta" | sed 's/\\/\\0/g')
			if [ -n "${META}" ] ; then
				echo "#"
				echo -e "${META}" | tr '\000' '\\'
				echo -e "\n."
			fi
			for i in $(seq $(lastpage ${SOURCE})) ; do
				local PAGENAME=$(identifypage name "${SOURCE}" "${i}")
				local META=$(${DJVUSED} "${SOURCE}" -e "select '${PAGENAME}'; print-meta" | sed 's/\\/\\0/g')
				if [ -n "${META}" ] ; then
					echo "#$i '${PAGENAME}'"
					echo -e "${META}" | tr '\000' '\\'
					echo -e "\n."
				fi
			done
		;;
		global) printf "printmeta: Global meta attributes from %s\n" "${FILE}" >> ${LOG}
			local META=$(${DJVUSED} "${SOURCE}" -e "select; print-meta" | sed 's/\\/\\0/g')
			if [ ! -z "${META}" ] ; then
				echo "#"
				echo -e "${META}" | tr '\000' '\\'
				echo -e "\n."
			fi
		;;
		+([[:digit:]])|*.djvu) printf "printmeta: Meta attributes for page %s from %s\n" "${2}" "${FILE}" >> ${LOG}
			local PAGENAME=$(identifypage name "${SOURCE}" "${2}")
			if [ ! -z "${PAGENAME}" ] ; then
				local IDPAGE=$(identifypage order "${SOURCE}" "${PAGENAME}")
				local META=$(${DJVUSED} "${SOURCE}" -e "select '${PAGENAME}'; print-meta" | sed 's/\\/\\0/g')
				if [ ! -z "${META}" ] ; then
					echo "#${IDPAGE} '${PAGENAME}'"
					echo -e "${META}" | tr '\000' '\\'
					echo -e "\n."
				fi
			fi
		;;
		*) printmeta "${SOURCE}" all
		;;
	esac
}

# ### <span id="printoutline">printoutline()</span> ([top](#FUNCTIONS))
# V původní podobě byl výsledek zapsán do souboru s příponou .outline
# V tomto příoa
printoutline() {
    log goto "printoutline() $1 –> $2"
	# $1 - DjVu file
	# $2 - cíl
    bookmarktooutline "${1}"
    return 0
    # bookmarktooutline "${1}" | awk '{print i++ "\t|" $0}'
}

function djvuimport {
	# Import nevkládá nové stránky, ale importuje soubory textové vrstvy
	# $1 - DjVu file
	# $2 - soubor identifikátor + cílový adresář
	#echo "1- ${1}" >> /dev/stderr
	#echo "2- ${2}" >> /dev/stderr
	#echo "3- ${3}" >> /dev/stderr
	local SOURCE=$(${REALPATH} -m -P "${1}")
	echo "djvuimport: SOURCE ${SOURCE}" >> /dev/stderr
	local FILE="${SOURCE##*/}"
	if [ -z "${2}" ] ; then
		local FROM=$(${REALPATH} -m -P "$(pwd)")
		echo "djvuimport: FROM ${FROM}" >> /dev/stderr
	else
		local FROM=$(${REALPATH} -m -P "${2}")
		echo "djvuimport: FROM ${FROM}" >> /dev/stderr
	fi

	if [ -d "${FROM}" ] ; then
		local LIST=$(djvuinfo "${SOURCE}" list)
		local IFS_BAK=$IFS
		local IFS=$'\n'
		for i in  ${LIST} ; do

			local PAGENAME="${i##*:}"
			log info "djvuimport() Hledám soubory pro import dat do stránky ${PAGENAME} v souboru ${FILE}"
			if [ -f "${FROM}/${PAGENAME/.djvu/.dsed}" ] ; then
				importdsedpage "${SOURCE}" "${PAGENAME}" "${FROM}/${PAGENAME/.djvu/.dsed}"
			fi
			if [ -f "${FROM}/${PAGENAME/.djvu/.xml}" ] ; then
				importxmlpage "${SOURCE}" "${FROM}/${PAGENAME/.djvu/.xml}"
			fi
			if [ -f "${FROM}/${PAGENAME/.djvu/.meta}" ] ; then
				importmetapage "${SOURCE}" "${PAGENAME}" "${FROM}/${PAGENAME/.djvu/.meta}"
			fi

		done
		local IFS=$IFS_BAK
		log info "djvuimport() Importuji meta atributy a obsah pro celý soubor ${FILE}"
		# Import obsahu souboru..
		if [ -f "${FROM}/${FILE/.djvu/.meta}" ] ; then
			importmetaall "${SOURCE}" "${FROM}/${FILE/.djvu/.meta}"
		fi
		if [ -f "${FROM}/${FILE/.djvu/.outline}" ] ; then
			importoutline "${SOURCE}" "${FROM}/${FILE/.djvu/.outline}"
		fi
	elif [ -f "${FROM}" ] ; then
		case "$(head -c 1 ${FROM})" in
			\<) echo "import: import XML file" >> /dev/stderr
				XML="yes"
				importxmlpage "${SOURCE}" "${FROM}"
				return 0
			;;
			s) echo "import: import file in dsed format" >> /dev/stderr
				DSED="yes"
				importdsedall "${SOURCE}" "${FROM}"
				return 0
			;;
			\") echo "import: import outline file" >> /dev/stderr
				local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .outline)
				outlinetodsed "${FROM}" | encode > "${TEMPFILE}"
				importoutline "${SOURCE}" "${TEMPFILE}"
				return 0
			;;
			\() echo "import: import outline in dsed format" >> /dev/stderr
				"${SOURCE}" 
				importoutline "${SOURCE}" "${FROM}"
				return 0
			;;
			\#) echo "import: import meta atribute file" >> /dev/stderr
				META="yes"
				importmeta "${SOURCE}" "${FROM}"
				return 0
			;;
			[[:alpha:]]) echo "import: meta TODO atribute file for one page - not implemented" >> /dev/stderr
				echo "může jít i o seznam stránek k importu do souboru.." >> /dev/stderr
				local FROMFILE="${FROM##*/}"
				#echo  "${FILE%.*} ${FROMFILE%.*}" >> /dev/stderr
				log info "djvuimport() Importuji data do stránky ${FROMFILE}"
				local LIST=$(djvuinfo "${SOURCE}" list)
				local IFS_BAK=$IFS
				local IFS=$'\n'
				for i in  ${LIST} ; do
					local PAGENAME="${i##*:}"
					if [ "${PAGENAME%.*}" == "${FROMFILE%.*}" ] ; then
						echo "Importuji data ze souboru ${FROM} do stránky ${PAGENAME} v souboru ${FILE}" >> /dev/stderr
						case "${FROMFILE}" in
							*.dsed) DSED="yes"
								importdsedpage "${SOURCE}" "${PAGENAME}" "${FROM}"
							;;
							*.meta) META="yes"
								importmeta "${SOURCE}" "${PAGENAME}" "${FROM}"
							;;
							*.xml) XML="yes"
								importxmlpage "${SOURCE}" "${FROM}"
							;;
							*) echo "import: Při importu textových dat do stránky jsou akceptovány pouze soubory s příponou .dsed, .xml a .meta" >> /dev/stderr
							;;
						esac
					fi
				done
				local IFS=$IFS_BAK
				return 0
			;;
			*) echo "import: FAIL - unknown file" >> /dev/stderr
				exit 1
			;;
		esac
	else
		echo "import: Parametrem akce import může být buď adresář se soubory, nebo soubor s daty k importu" >> /dev/stderr
		exit 1
	fi
}

function djvuexport {
	# $1 - DjVu file
	# $2 - identifikátor + cílový adresář
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"

	# Parsing $2
	local CHARSTRING="$2"
	if [ "${CHARSTRING}" == "" ] ; then
		help keywords-export
		exit 0
	fi

#	echo "${PAGE} ${DSED} ${XML} ${IMG} ${META} ${FORCE} option" >> /dev/stderr
	export EXPORTVALUE=0
	[ "${PAGE}" != "no" ] && export EXPORTVALUE=$(( $EXPORTVALUE + 1 )) && echo "actual $EXPORTVALUE" >> /dev/stderr
	[ "${IMG}" != "no" ] && export EXPORTVALUE=$(( $EXPORTVALUE + 2 )) && echo "actual $EXPORTVALUE" >> /dev/stderr
	[ "${XML}" != "no" ] && export EXPORTVALUE=$(( $EXPORTVALUE + 4 )) && echo "actual $EXPORTVALUE" >> /dev/stderr
	[ "${META}" != "no" ] && export EXPORTVALUE=$(( $EXPORTVALUE + 8 )) && echo "actual $EXPORTVALUE" >> /dev/stderr
	[ "${DSED}" != "no" ] && export EXPORTVALUE=$(( $EXPORTVALUE + 16 )) && echo "actual $EXPORTVALUE" >> /dev/stderr
#	if [ "${PAGE}" == "no" ] && [ "${DSED}" == "no" ] && [ "${XML}" == "no" ] && [ "${IMG}" == "no" ] && [ "${META}" == "no" ] ; then

	if  [ "${FORCE}" == "skip" ] ; then
		# Interaktivní mód
		printf "export: For export from DjVu bundle we must use any option\n" >> /dev/stderr
		# Co mám vyexportovat ze svazku?
		# 1) pouze stránky ve formátu DjVu
		# 2) pouze náhledy stránek ve formátu PNG
		# 3) 0+P
		# 4) pouze xml soubory textové vrstvy
		# 5) X+P
		# 6) X+O
		# 7) X+O+P
		# 8) pouze metainformace
		# 9) M+P
		# 10) M+O
		# 11) M+O+P
		# 12) M+X
		# 13) M+X+P
		# 14) M+X+O
		# 15) M+X+O+P
		# 16) pouze dsed soubory
		# 17) D+P
		# 18) D+O
		# 19) D+O+P
		# 20) D+X
		# 21) D+X+P
		# 22) D+X+O
		# 23) D+X+O+P
		# 24) D+M
		# 25) D+M+P
		# 26) D+M+O
		# 27) D+M+O+P
		# 28) D+M+X
		# 29) D+M+X+P
		# 30) D+M+X+O
		# 31) D+M+X+O+P
		printf "Export of DjVu pages from bundle?\n" >> /dev/stderr
		potvrdit && export EXPORTVALUE=$(( $EXPORTVALUE + 1 ))
		printf "Export pages as PNG too?\n" >> /dev/stderr
		potvrdit && export EXPORTVALUE=$(( $EXPORTVALUE + 2 ))
		printf "Export text layer as XML file?\n" >> /dev/stderr
		potvrdit && export EXPORTVALUE=$(( $EXPORTVALUE + 4 ))
		printf "Export meta and outline from bundle?\n" >> /dev/stderr
		potvrdit && export EXPORTVALUE=$(( $EXPORTVALUE + 8 ))
		printf "Export text from bundle in DSED format?\n" >> /dev/stderr
		potvrdit && export EXPORTVALUE=$(( $EXPORTVALUE + 16 ))
#		echo "Budu zpracovávat $EXPORTVALUE"
	fi

	if [ $EXPORTVALUE == 0 ] ; then
		printf "export: Options are necessary for specify of content for export from DjVu bundle.\n" >> /dev/stderr
		return 1
	fi

	local CHARCOUNT=$((${#CHARSTRING} + 1))
	local CHARPOS=0
	local STRPOS=0
	while [ "${CHARCOUNT}" -gt "0" ] ; do
		case "${CHARSTRING:0:$((${CHARPOS} - ${STRPOS}))}" in
			*.[dD][jJ][vV][uU]) local PAGENAME="${CHARSTRING:0:$((${CHARPOS} - ${STRPOS}))}"
				local STRPOS="${CHARPOS}"
				local CHARSTRING="${CHARSTRING#${PAGENAME}}"
				local CHARCOUNT=$((${#CHARSTRING} + 1))
			;;
		esac
		local CHARPOS=$((CHARPOS + 1))
		local CHARCOUNT=$((CHARCOUNT - 1))
	done

	if [  -z "${CHARSTRING}" ] ; then
		if [ -z "${PAGENAME}" ] ; then
			log info "djvuexport() Export all pages from ${FILE} into aktual directory - do set TARGETDIR"
			local TARGETDIR=$(targetdir $(pwd))
			exportdjvuall "${SOURCE}" "${TARGETDIR}"
			return 0
		else
			log info "djvuexport() Export page identificated by ${PAGENAME} from ${FILE} into aktual directory - do set TARGETDIR"
			local IDPAGE=$(identifypage order "${SOURCE}" "${PAGENAME}")
			if [ -z "${IDPAGE}" ] ; then
				case "${PAGENAME%%\ *}" in
					meta) printmeta "${SOURCE}" "${PAGENAME#* }"
						return 0
					;;
					*) echo "export: In ${FILE} is not any page identificated by ${PAGENAME}"  >> /dev/stderr &&  exit 1
					;;
				esac
			else
				local NAMEPAGE=$(identifypage name "${SOURCE}" "${PAGENAME}")
				local TARGETDIR=$(targetdir $(pwd))
			fi
		fi
	else
		if [ -z "${PAGENAME}" ] ; then
			local TEMP=${CHARSTRING##+([[:blank:]])}
			local IDPAGE=${TEMP%%+([[:blank:]])*}
			local CHARSTRING=${TEMP#${IDPAGE}}
			local TARGETDIR=${CHARSTRING##+([[:blank:]])}
			# Tady může být nějaký jiný parametr, než pořadové číslo, a také TARGETDIR může být prázdný.
			case "${IDPAGE}" in
				all) if [ -z "${TARGETDIR}" ] ; then
						log info "djvuexport() Export all pages from ${FILE} into actual directory - do set TARGETDIR"
						local TARGETDIR=$(targetdir $(pwd))
						exportdjvuall "${SOURCE}" "${TARGETDIR}"
						return 0
					else
						log info "djvuexport() Export all pages from ${FILE} into ${TARGETDIR}"
						local TARGETDIR=$(targetdir "${TARGETDIR}")
						exportdjvuall "${SOURCE}" "${TARGETDIR}"
						return 0
					fi
				;;
				meta) printmeta "${SOURCE}" "${TARGETDIR}"
					return 0
				;;
				outline) bookmarktooutline "${SOURCE}"
					return 0
				;;
				*) log info "djvuexport() Export page identificated by order -${IDPAGE}- from ${FILE} into -${TARGETDIR}-"
					local NAMEPAGE=$(identifypage name "${SOURCE}" "${IDPAGE}")
					if [ -z "${NAMEPAGE}" ] ; then
						# djvutool bundle.djvu export
						if [ -e "${IDPAGE}" ] ; then
							if [ -d "${IDPAGE}" ] ; then
								djvuexport "${SOURCE}" "all ${IDPAGE}"
							else
								echo "export: In ${FILE} is not any page on position ${IDPAGE}"  >> /dev/stderr &&  exit 1
							fi
						else
							djvuexport "${SOURCE}" "all ${IDPAGE}"
						fi
					else
						local TARGETDIR=$(targetdir "${TARGETDIR}")
					fi
				;;
			esac
		else
			local NAMEPAGE=${PAGENAME##+([[:blank:]])}
			local TARGETDIR=${CHARSTRING##+([[:blank:]])}
			log info "djvuexport() Export page identificated by name -${NAMEPAGE}- from ${FILE} into -${TARGETDIR}-"
			local IDPAGE=$(identifypage order "${SOURCE}" "${NAMEPAGE}")
			[ -z "${IDPAGE}" ] && echo "export: In ${FILE} is not any page with name ${NAMEPAGE}" >> /dev/stderr &&  exit 1
			local TARGETDIR=$(targetdir "${TARGETDIR}")
		fi
	fi

#	echo "export: SOURCE ${SOURCE}">> /dev/stderr
#	echo "export: FILE ${FILE}">> /dev/stderr
#	echo "export: IDPAGE ${ODPAGE}">> /dev/stderr
#	echo "export: NAMEPAGE ${NAMEPAGE}">> /dev/stderr
#	echo "export: TARGETDIR ${TARGETDIR}">> /dev/stderr
#	echo "export: FORCE ${FORCE}">> /dev/stderr

	exportdjvupage "${SOURCE}" "${NAMEPAGE}" "${TARGETDIR}"
	exportdsedpage "${SOURCE}" "${NAMEPAGE}" "${TARGETDIR}"
	#echo "export: For export text content from DjVu page in dsed format we must use option -d" >> /dev/stderr
	exportxmlpage "${SOURCE}" "${NAMEPAGE}" "${TARGETDIR}"
	#echo "export: For export hidden text layer of pages from DjVu bundle in XML format we must use option -x" >> /dev/stderr
	exportpage2img "${SOURCE}" "${NAMEPAGE}" "${TARGETDIR}"
	#echo "export: For export image of page from DjVu bundle we must use option -i" >> /dev/stderr
	exportmetapage "${SOURCE}" "${NAMEPAGE}" "${TARGETDIR}"
	# echo "export: For export meta attributes from pages DjVu bundle in we must use option -m" >> /dev/stderr
}

function exportdjvuall {
	# $1 - DjVu file - full path
	# $2 - targetdir - full path
	echo "$EXPORTVALUE" >> /dev/stderr
	local EXPORTDJVU="1|3|5|9|11|13|15|17|19|21|23|25|27|29|31"
	local EXPORTIMG="2|3|6|7|10|11|14|15|18|19|22|23|26|27|30|31"
	local EXPORTXML="4|5|6|7|12|13|14|15|20|21|22|23|28|29|30|31"
	local EXPORTMETA="8|9|10|11|12|13|14|15|24|25|26|27|28|29|30|31"
	local EXPORTDSED="16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31"
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	[ "${PAGE}" != "no" ] || echo "exportdjvuall: For export pages in DjVu format we must use option -p" >> /dev/stderr
	[ "${DSED}" != "no" ] || echo "exportdjvuall: For export hidden text layer of pages from DjVu bundle in dsed format we must use option -d" >> /dev/stderr
	[ "${XML}" != "no" ] || echo "exportdjvuall: For export hidden text layer of pages from DjVu bundle in XML format we must use option -x" >> /dev/stderr
	[ "${IMG}" != "no" ] || echo "exportdjvuall: For export image of page from DjVu bundle we must use option -i" >> /dev/stderr
	[ "${META}" != "no" ] || echo "exportdjvuall: For export meta attributes from pages DjVu bundle in we must use option -m" >> /dev/stderr
	local PAGES=$(lastpage "${SOURCE}")
	local NUMPAGE=1
	while [ ${PAGES} -gt "0" ] ; do
		local NAMEPAGE=$(identifypage name "${SOURCE}" "${NUMPAGE}")
		log info "exportdjvuall() Exportuji stránku ${NAMEPAGE}"

		[[ $EXPORTDJVU =~ $EXPORTVALUE ]] && exportdjvupage "${1}" "${NAMEPAGE}" "${2}"
		[[ $EXPORTIMG =~ $EXPORTVALUE ]] && exportpage2img "${1}" "${NAMEPAGE}" "${2}"
		[[ $EXPORTXML =~ $EXPORTVALUE ]] && exportxmlpage "${1}" "${NAMEPAGE}" "${2}"
		[[ $EXPORTMETA =~ $EXPORTVALUE ]] && exportmetapage "${1}" "${NAMEPAGE}" "${2}"
		[[ $EXPORTDSED =~ $EXPORTVALUE ]] && exportdsedpage "${1}" "${NAMEPAGE}" "${2}"

		local NUMPAGE=$((NUMPAGE + 1))
		local PAGES=$((PAGES - 1))
	done
	[[ $EXPORTXML =~ $EXPORTVALUE ]] && exportxmlbundle "${1}" "${2}"
	[[ $EXPORTMETA =~ $EXPORTVALUE ]] && exportmetabundle "${1}" "${2}"
	[[ $EXPORTMETA =~ $EXPORTVALUE ]] && bookmarktooutline "${1}" > "${2}/${FILE/.djvu/.outline}"
	[[ $EXPORTDSED =~ $EXPORTVALUE ]] && exportdsedbundle "${1}" "${2}"
}

function exportdsedbundle {
	# $1 - DjVu file - full path
	# $2 - targetdir - full path
	local FILE="${1##*/}"
	pushd "${2}"
	case "${DSED}" in
		yes|all) local EXPORT="output-all"
		;;
		txt) local EXPORT="output-txt"
		;;
		ant) local EXPORT="output-ant"
		;;
		no) return 0
		;;
	esac
	if [ "${DSED}" != "no" ] ; then
		local TARGET="${FILE/.djvu/.dsed}"
		if [ -f "${TARGET}" ] ; then
			if [ "${FORCE}" == "yes" ] ; then
				${DJVUSED} "${1}" -e "${EXPORT}" > "${TARGET}"
			elif [ "${FORCE}" == "skip" ] ; then
				log warn "exportdsedbundle() Soubor ${TARGET} již v adresáři ${3} existuje."
			else
				echo "exportdsedbundle: Soubor ${TARGET} již v adresáři ${3} existuje.." >> /dev/stderr
				potvrdit && ${DJVUSED} "${1}" -e "${EXPORT}" > "${TARGET}"
			fi
		else
			${DJVUSED} "${1}" -e "${EXPORT}" > "${TARGET}"
		fi
	fi
	popd
}

function exportxmlbundle {
	# $1 - DjVu file - full path
	# $2 - targetdir - full path
	local FILE="${1##*/}"
	pushd "${2}"
	case "${XML}" in
		yes|all) local EXPORT="--with-text --with-anno"
		;;
		txt) local EXPORT="--with-text --without-anno"
		;;
		ant) local EXPORT="--without-text --with-anno"
		;;
		no) return 0
		;;
	esac
	if [ "${XML}" != "no" ] ; then
		local TARGET="${FILE/.djvu/.xml}"
		if [ -f "${TARGET}" ] ; then
			if [ "${FORCE}" == "yes" ] ; then
				${DJVUTOXML} "${1}" "${TARGET}"
			elif [ "${FORCE}" == "skip" ] ; then
				log warn "exportxmlbundle() Soubor ${TARGET} již v adresáři ${3} existuje."
			else
				echo "exportxmlbundle: Soubor ${TARGET} již v adresáři ${3} existuje.." >> /dev/stderr
				potvrdit && ${DJVUTOXML} "${1}" "${TARGET}"
			fi
		else
			${DJVUTOXML} "${1}" "${TARGET}"
		fi
	fi
	popd
}

#/ OBSOLETE
#/ nahrazeno funkcí fromdjvu
function exportpage2img {
	# $1 - DjVu file - full path
	# $2 - identificator - page name
	# $3 - targetdir - full path
	pushd "${3}"
	case "${IMG}" in
		yes) local EXPORT="-mode=color"
		;;
		color|black|foreground|background|mask) local EXPORT="-mode=${IMG}"
		;;
		no) return 0
		;;
	esac
	echo "$EXPORT" >> /dev/stderr
	echo "$PNMTOPNG" >> /dev/stderr
	if [ "${IMG}" != "no" ] ; then
		local PAGE=$(identifypage order "${1}" "${2}")
		local TARGET="${2/.djvu/.png}"
		if [ -f "${TARGET}" ] ; then
			if [ "${FORCE}" == "yes" ] ; then
				${DDJVU} -format=pnm "${EXPORT}" -page="${PAGE%%(*}" "${1}" | ${PNMTOPNG} > "${TARGET}"
			elif [ "${FORCE}" == "skip" ] ; then
				log warn "exportpage2img() Soubor ${TARGET} již v adresáři ${3} existuje."
			else
				echo "exportpage2img: Soubor ${TARGET} již v adresáři ${3} existuje.." >> /dev/stderr
				potvrdit && ${DDJVU} -format=pnm "${EXPORT}" -page="${PAGE%%(*}" "${1}" | ${PNMTOPNG} > "${TARGET}"
			fi
		else
			echo "${DDJVU} -format=pnm ${EXPORT} -page=${PAGE%%(*} ${1} | ${PNMTOPNG} > ${TARGET}"
			${DDJVU} -format=pnm "${EXPORT}" -page="${PAGE%%(*}" "${1}" | ${PNMTOPNG} > "${TARGET}"
		fi
	fi
	popd
}

function exportxmlpage {
	# $1 - DjVu file - full path
	# $2 - identificator - page name
	# $3 - targetdir - full path
	pushd "${3}"
	case "${XML}" in
		yes|all) local EXPORT="--with-text --with-anno"
		;;
		txt) local EXPORT="--with-text --without-anno"
		;;
		ant) local EXPORT="--without-text --with-anno"
		;;
		no) return 0
		;;
	esac
	if [ "${XML}" != "no" ] ; then
		local PAGE=$(identifypage order "${1}" "${2}")
		local TARGET="${2/.djvu/.xml}"
		if [ -f "${TARGET}" ] ; then
			if [ "${FORCE}" == "yes" ] ; then
				${DJVUTOXML} --page "${PAGE}" ${EXPORT} "${1}" "${TARGET}"
			elif [ "${FORCE}" == "skip" ] ; then
				log warn "exportxmlpage() Soubor ${TARGET} již v adresáři ${3} existuje."
			else
				echo "Soubor ${TARGET} již v adresáři ${3} existuje.." >> /dev/stderr
				potvrdit && ${DJVUTOXML} --page "${PAGE}" ${EXPORT} "${1}" "${TARGET}"
			fi
		else
			${DJVUTOXML} --page "${PAGE}" ${EXPORT} "${1}" "${TARGET}"
		fi
	fi
	popd
}

function importmetapage {
	# $1 - soubor se stránkou
	# $2 - identifikátor stránky
	# $3 - soubor s meta atributy
	echo "importmetapage: Importuji meta atributy do jedné stránky" >> /dev/stderr
	${DJVUSED} "${1}" -e "select '${2}'; set-meta ${3}; save"
}

function importmetaall {
	# $1 - soubor se stránkou
	# $2 - soubor s meta atributy
	echo "importmetaall: Importuji meta atributy pro celý svazek" >> /dev/stderr
	${DJVUSED} "${1}" -e "select; set-meta ${2}; save"
}

# ### <span id="writefile">writefile()</span> ([top](#FUNCTIONS))
# Funkce průběžně konvertuje stream unicode znaků do jejich číselné podoby
# Velmi důležitá funkce!!!
writefile() {
    if [ -t 0 ]; then
        log info "writefile() Empty stdin"
        return 1
    else
        tee $1 >> /dev/null
        return 0
    fi
}

# ### <span id="decode">decode()</span> ([top](#FUNCTIONS))
# Funkce průběžně konvertuje číselnou podobu unicode znaků ve streamu  do UTF-8
# Velmi důležitá funkce!!!
decode() {
    sed 's/\\/\\0/g' | tr '\000' '\\'
}

# ### <span id="encode">encode()</span> ([top](#FUNCTIONS))
# Funkce průběžně konvertuje stream unicode znaků do jejich číselné podoby
# Velmi důležitá funkce!!!
encode() {
    while read -n 1 a
    do
    CHAR=($( echo "$a" | od -A n -t c ))
    if [ "${#CHAR[@]}" -gt "2" ] ; then 
        echo -n "\\${CHAR[0]}\\${CHAR[1]}"
    elif [ "${#CHAR[@]}" == "1" ] ; then 
        echo -n " "
    else
        if [ "${#CHAR[0]}" == "0" ] ; then
            echo -n " "
        else
            echo -n "${CHAR[0]}"
        fi
    fi
    done
}

# ### <span id="encodefile">encodefile()</span> ([top](#FUNCTIONS))
# Konvertuje bitmapový soubor v PAM formátu, předaný jako __$1__ do
# DjVu souboru __$2__
# Základním předpokladem je, že pro tento PAM soubor (s příponou `.pam`)
# existuje minimálně jeden soubor ve formátu PBM pro vygenerování masky.
#
# Přednost má přitom soubor s příponou `.text`, který (pokud existuje)
# obsahuje vyseparované textové bloky.
#
# V případě že neexistuje, je automaticky vyžadován soubor s příponou
# `.fore`, který byl vygenerován funkcí [separatemask](#separatemask)
encodefile() {
    log goto "encodefile() Use $1 –> $2"
    if [ -f "${1/.pam/.text}" ] ; then
        ${CJB2} -lossy -clean "${1/.pam/.text}" "${1}.mask";
    else
        ${CJB2} -lossy -clean "${1/.pam/.fore}" "${1}.mask";
    fi
    ${DJVUMAKE} "${2}" Sjbz="${1}.mask" PPM="${1}";
}

# ### <span id="separatemask">separatemask()</span> ([top](#FUNCTIONS))
# Z bitmapového souboru ve formátu PAM, který je předán jako __$1__
# generuje černobílou masku __$2__ ve formátu PBM.
# Jako parametr __$3__ se předává buď algoritmus s parametry, nebo hodnota
# `none` s nastavením prahové hodnoty
#
# shading-subtraction - k od 3 (málo šumu) do 12 (hodně šumu),
# šum lze odstranit nastavením prahu (hodnota float)
# Výsledek je přesně opačný než při nastavení prahu - čím vyšší hodnota,
# tím míň toho proleze
separatemask() {
    log goto "separatemask() Use $3 for $1 –> $2"
    case "${3%:*}" in
        none) if [ "${3#*:}" == "none" ] ; then
                log info "${PAMTOPNM} ${1} | ${PPMTOPGM} | ${PGMTOPBM} -threshold -value 0.5 | ${PNMTOPLAINPNM} > ${2}"
                ${PAMTOPNM} ${1} | ${PPMTOPGM} | ${PGMTOPBM} -threshold -value 0.5 | ${PNMTOPLAINPNM} > ${2}
            else
                log info "${PAMTOPNM} ${1} | ${PPMTOPGM} | ${PGMTOPBM} -threshold -value 0.${3#*:} | ${PNMTOPLAINPNM} > ${2}"
                ${PAMTOPNM} ${1} | ${PPMTOPGM} | ${PGMTOPBM} -threshold -value 0.${3#*:} | ${PNMTOPLAINPNM} > ${2}
            fi
            while [ ! -f "${2}" ] ; do
                sleep 0.1
            done
        ;;
        *) if [ -f "${HOME}/.config/${NAME}/${3}.conf" ] ; then
                local PARAMS=$(grep -v '^#' "${HOME}/.config/${NAME}/${3}.conf" | awk '{print "--param", $1}' | tr '\n' ' ')
            fi
            if [[ "${3}" =~ ":" ]] ; then
                local TEMPORAR="${3#*:}"
                local PARAMS=$(printf "xxx %s" ${TEMPORAR//,/ })
            fi
            ${DIDJVU} separate -o "${2}.png" ${LEVEL} -m "${3%:*}" ${PARAMS//xxx/ -x} "${1}"
            while [ ! -f "${2}.png" ] ; do
                sleep 0.1
            done
            pngtopam "${2}.png" > "${2}"
        ;;
    esac
    return $?
}

# ### <span id="bookmarktooutline">bookmarktooutline()</span> ([top](#FUNCTIONS))
# Funkce zpracovává záložky z DjVu souboru do formátu s odsazením
bookmarktooutline() {
    local TARGET="$1"
    local BEGIN=""
    local TAB=0
    ${DJVUSED} "${1}" -e 'print-outline' | sed -n '
    s|(|\n(\n|g
    s|)|\n)\n|g
    s|\\|\\\\0|g
    p
    ' |	while read y
    do
        case "$y" in
            \)) local TAB=$((TAB - 1))
            ;;
            \() local TAB=$((TAB + 1))
            ;;
            \"*) if [ "${BEGIN}" == "" ] ; then
                    local TEXT="$y"
                    local BEGIN="yes"
                else
                    for i in $(seq $((TAB-2))) ; do echo -en '\t' ; done
                    echo -e "${TEXT} ${y}"
                    local BEGIN=""
                fi
            ;;
        esac
    done
}

function outlineunset {
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .outline)
	local CHARSET="$(( $2 + 1 ))"
	bookmarktooutline "${SOURCE}" >> "${TEMPFILE}"
	if [ "${CHARSET//+([[:digit:]])}" == "" ] ; then
		ed ${TEMPFILE} 2>/dev/null <<-EOF
${CHARSET}d
w
q
EOF
		outlinetodsed "${TEMPFILE}" | encode > "${TEMPFILE/.outline/.temp}"
		${DJVUSED}  "${SOURCE}" -e "set-outline ${TEMPFILE/.outline/.temp}; save"
	fi
}

# ### <span id="outlineset">outlineset()</span> ([top](#FUNCTIONS))
# Funkce ukládá outline do souboru
# $1 - DjVu soubor
#
# Používá funkce:
# * xtabs
# * bookmarktooutline
# * outlinetodsed
function outlineset {
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .outline)
	local CHARSET="${2}"
	bookmarktooutline "${SOURCE}" >> "${TEMPFILE}"
	local ORDER="${CHARSET%% *}"
	local BOOKMARKTARGET="${CHARSET##* }"
	local TEMP="${CHARSET#${ORDER} *}"
	local BOOKMARKITEM="${TEMP%* ${BOOKMARKTARGET}}"
	case ${ORDER:$((${#ORDER}-1))} in
		+) if [ -z ${ORDER%:+} ] ; then
				local TEMP=$(tail -1 ${TEMPFILE})
				local TABS="${TEMP%%\"*}"
				local ITEM="$(xtabs $((${#TABS} + 1)))\"${BOOKMARKITEM}\" \"#${BOOKMARKTARGET}\""
				ed ${TEMPFILE} 2>/dev/null <<-EOF
a
${ITEM}
.
w
q
EOF
			else
				local TEMP=$(head -$((${ORDER%:+*}+1)) ${TEMPFILE} | tail -1)
				local TABS="${TEMP%%\"*}"
				local ITEM="$(xtabs $((${#TABS} + 1)))\"${BOOKMARKITEM}\" \"#${BOOKMARKTARGET}\""
				ed ${TEMPFILE} 2>/dev/null <<-EOF
${ORDER%:+}a
${ITEM}
.
w
q
EOF
			fi
			;;
		-) if [ -z ${ORDER%:-*} ] ; then
				local TEMP=$(tail -1 ${TEMPFILE})
				local TABS="${TEMP%%\"*}"
				local MINUS="${ORDER#:}"
				if [ ${#TABS} -ge ${#MINUS} ] ; then
					local ITEM="$(xtabs $((${#TABS} - ${#MINUS})))\"${BOOKMARKITEM}\" \"#${BOOKMARKTARGET}\""
				else
					local ITEM="\"${BOOKMARKITEM}\" \"#${BOOKMARKTARGET}\""
				fi
				ed ${TEMPFILE} 2>/dev/null <<-EOF
a
${ITEM}
.
w
q
EOF
			else
				local TEMP=$(head -$((${ORDER%:-*}+1)) ${TEMPFILE} | tail -1)
				local TABS="${TEMP%%\"*}"
				local MINUS="${ORDER#*:}"
				if [ ${#TABS} -ge ${#MINUS} ] ; then
					local ITEM="$(xtabs $((${#TABS} - ${#MINUS})))\"${BOOKMARKITEM}\" \"#${BOOKMARKTARGET}\""
				else
					local ITEM="\"${BOOKMARKITEM}\" \"#${BOOKMARKTARGET}\""
				fi
				ed ${TEMPFILE} 2>/dev/null <<-EOF
${ORDER%:-*}a
${ITEM}
.
w
q
EOF
			fi
			;;
		:) if [ -z ${ORDER%:} ] ; then
				local TEMP=$(tail -1 ${TEMPFILE})
				local TABS="${TEMP%%\"*}"
				local ITEM="$(xtabs ${#TABS})\"${BOOKMARKITEM}\" \"#${BOOKMARKTARGET}\""
				ed ${TEMPFILE} 2>/dev/null <<-EOF
a
${ITEM}
.
w
q
EOF
			else
				local TEMP=$(head -$((${ORDER%:}+1)) ${TEMPFILE} | tail -1)
				local TABS="${TEMP%%\"*}"
				local ITEM="$(xtabs ${#TABS})\"${BOOKMARKITEM}\" \"#${BOOKMARKTARGET}\""
				ed ${TEMPFILE} 2>/dev/null <<-EOF
${ORDER%:}a
${ITEM}
.
w
q
EOF
			fi
			;;
		[[:digit:]]) local TEMP=$(head -$((${ORDER}+1)) ${TEMPFILE} | tail -1)
			local TABS="${TEMP%%\"*}"
			local ITEM="$(xtabs ${#TABS})\"${BOOKMARKITEM}\" \"#${BOOKMARKTARGET}\""
				ed ${TEMPFILE} 2>/dev/null <<-EOF
${ORDER}a
${ITEM}
.
w
q
EOF
			;;
		*) echo "outlineset: Sem bys nikdy neměl dojít" && exit 1
			;;
	esac
	outlinetodsed "${TEMPFILE}" | encode > "${TEMPFILE/.outline/.temp}"
	${DJVUSED}  "${SOURCE}" -e "set-outline ${TEMPFILE/.outline/.temp}; save"
}

# ### <span id="outlinetodjvu">outlinetodjvu()</span> ([top](#FUNCTIONS))
# Funkce převádí obsah .outline souboru na formát .dsed
# a výsledek zapisuje do djvu souboru
# $1 - DjVu file
# $2 - soubor ve formátu .outline
outlinetodjvu() {
    log goto "outlinetodjvu() From $2 into $1"
    local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .bookmarks)
    if [ -f "${2}" ] ; then
        outlinetodsed "${2}" | encode > "${TEMPFILE}"
        ${DJVUSED}  "${1}" -e "set-outline ${TEMPFILE}; save"
    else
        log err "outlinetodjvu() Not any outline file"
        return 1
    fi
    return $?
}

# ### <span id="outlinetodjvu">outlinetodjvu()</span> ([top](#FUNCTIONS))
# Funkce převádí obsah ve formátu .outline na formát .dsed
# $1 - .outline file with TAB syntax
# Output is txt stream
outlinetodsed() {
    local TARGET="$1"
    # Remove comment from .outline file
    sed --in-place '/^#/d ; /^;/d' "${TARGET}"
    [ $(grep -c ^ "${TARGET}") -eq "0" ] && return 1
    local LEVEL="1"
    IFS=''
    echo -n "(bookmarks "
    CONTENT=$(sed '
        s/\ \ \ \ /\t/g
        s/^/\t/
        ' "${TARGET}" | while read line ; do
        local SPACE="${line%%\"*}"
        if [ "${#SPACE}" -gt "${LEVEL}" ] ; then
            local PREV="${PREV%)} ( ${line} )"
            local LEVEL=$((${LEVEL} + 1))
        elif [ "${#SPACE}" -eq "${LEVEL}" ] ; then
            local PREV="${PREV} ( ${line} )"
        elif [ "${#SPACE}" -lt "${LEVEL}" ] ; then
            local ROZDIL=$((${LEVEL} - ${#SPACE}))
            local ZAV=$(seq  -f "%1.0f" -s '' ${ROZDIL})
            local PREV="${PREV} ${ZAV//[[:digit:]]/)} ( $line )"
            local LEVEL=$((${LEVEL} - ${ROZDIL}))
        fi
        echo "${PREV}"
        echo "-----${LEVEL}"
    done | sed 's/\t/\ /g' | tail -2)
    TEST="${CONTENT##*-----}"
    echo -n "${CONTENT%-----*}"
    local ZAV=$(seq  -f "%1.0f" -s '' ${TEST})
    echo "${ZAV//[[:digit:]]/)}"
    return 0
}


function importdsedall {
	case "${DSED}" in
		# Vytvořit dočasný soubor s následující hlavičkou...
		# -e "select '${2}'; remove-ant; remove-txt"
		# -------------------------
		# time awk '/^set-ant$/{flag=1;next} ; /^.$/{flag=0}; flag' vysledek.dsed 
		all|yes) # nejprve ant, pak text..
		${DJVUSED} "${1}" -f "${2}" -s
		;;
		no)
		;;
	esac
}

function importdsedpage {
	# $1 - DjVu file - full path
	# $2 - identificator - page name
	# $3 - source DSED file - full path
	case "${DSED}" in
		# Vytvořit dočasný soubor s následující hlavičkou...
		# -e "select '${2}'; remove-ant; remove-txt"
		# -------------------------
		# time awk '/^set-ant$/{flag=1;next} ; /^.$/{flag=0}; flag' vysledek.dsed 
		all|yes) awk '/^set-ant$/{flag=1;next} ; /^.$/{flag=0}; flag' "${3}" > ${TEMPDIR}/${2}.ant
			${DJVUSED} "${1}" -e "select '${2}'; set-ant ${TEMPDIR}/${2}.ant ; save"
			awk '/^set-txt$/{flag=1;next} ; /^.$/{flag=0}; flag' "${3}" > ${TEMPDIR}/${2}.txt
			${DJVUSED} "${1}" -e "select '${2}'; set-txt ${TEMPDIR}/${2}.txt ; save"
		;;
		ant) awk '/^set-ant$/{flag=1;next} ; /^.$/{flag=0}; flag' "${3}" > ${TEMPDIR}/${2}.ant
			${DJVUSED} "${1}" -e "select '${2}'; set-ant ${TEMPDIR}/${2}.ant ; save"
		;;
		txt) awk '/^set-txt$/{flag=1;next} ; /^.$/{flag=0}; flag' "${3}" > ${TEMPDIR}/${2}.txt
			${DJVUSED} "${1}" -e "select '${2}'; set-txt ${TEMPDIR}/${2}.txt ; save"
		;;
		no) echo "K importu textových dat ze souboru ${3} se přistoupí pouze bude-li uvedena volba -d" >> /dev/stderr
		;;
	esac
}

function importmeta {
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .meta)
	local FROM=$(${REALPATH} -m -P "${2}")
	local FROMFILE="${FROM##*/}"
	grep '^#' "${FROM}" | while read line ; do
		echo "$line" >> /dev/stderr
		local NAMEPAGE=( $line )
		case "${#NAMEPAGE[@]}" in
			2) local PAGENAME=$(identifypage name "${SOURCE}" "${NAMEPAGE[1]//\'/}")
				if [ -z "${PAGENAME}" ] ; then
					echo "importmeta: FAIL - for ${FILE} is identificator ${NAMEPAGE[1]} not valid" >> /dev/stderr
				else
					awk "/.\ '${PAGENAME}'$/{flag=1;next} ; /^.$/{flag=0}; flag" "${FROM}" > ${TEMPFILE}
					${DJVUSED} "${1}" -e "select ${PAGENAME}; set-meta ${TEMPFILE}" -s
				fi
			;;
			1) if [ "${NAMEPAGE[0]}" == "#" ] ; then
					awk "/^#$/{flag=1;next} ; /^.$/{flag=0}; flag" "${FROM}" > ${TEMPFILE}
					${DJVUSED} "${1}" -e "select ; set-meta ${TEMPFILE}" -s
				else
					local PAGENAME=$(identifypage name "${SOURCE}" "${NAMEPAGE[0]:1}")
					if [ -z "${PAGENAME}" ] ; then
						echo "importmeta: FAIL - for ${FILE} is identificator ${NAMEPAGE[0]:1} not valid" >> /dev/stderr
					else
						awk "/^#${NAMEPAGE[0]:1}$/{flag=1;next} ; /^.$/{flag=0}; flag" "${FROM}" > ${TEMPFILE}
						${DJVUSED} "${1}" -e "select ${PAGENAME}; set-meta ${TEMPFILE}" -s
					fi
				fi
			;;
		esac
	done
}

function importmeta1 {
	# $1 - DjVu file - full path
	# $2 - identificator - page name
	# $3 - source DSED file - full path
	if [ -f "${2}" ] ; then
		if [ "${3}" ] ; then
			local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .meta)
			# Zpracování gobálních metadat
			awk '/^# select '${i}'$/{flag=1;next} ; /^.$/{flag=0}; flag' "${2}" > ${TEMPFILE}
			${DJVUSED} "${1}" -e "select ${3}; set-meta ${TEMPFILE}" -s
		else
			for i in $(seq $(lastpage ${1})) ; do
				awk '/^# select '${i}'$/{flag=1;next} ; /^.$/{flag=0}; flag' "${2}" > ${TEMPFILE}
				if [ "${TEMPFILE}" ] ; then
					${DJVUSED} "${1}" -e "select ${i}; set-meta ${TEMPFILE}" -s
				fi
			done
		fi
	else
		importmeta "${1}" "${3}" 
	fi
}

function importoutline {
	# Import outline in dsed format
	${DJVUSED}  "${1}" -e "set-outline ${2}" -s
}

function importxmlpage {
	# $1 - DjVu file - full path
	# $2 - source XML file - full path
	# INFO: XML file has name of target page in self.
	case "${XML}" in
		no) echo "K importu textových dat ze souboru ${2} se přistoupí pouze bude-li uvedena volba -x" >> /dev/stderr
		;;
		*) ${DJVUXMLPARSER} -o "${1}" "${2}"
		;;
	esac
}

# TODO - meta - Nepoužitá funkce
function exportmetabundle {
	# $1 - DjVu file - full path
	# $2 - targetdir - full path
	local FILE="${1##*/}"
	pushd "${2}"
	if [ "${META}" != "no" ] ; then
		local TARGET="${FILE/.djvu/.meta}"
		if [ -f "${TARGET}" ] ; then
			if [ "${FORCE}" == "yes" ] ; then
				${DJVUSED} "${1}" -e "print-meta" > "${TARGET}"
			elif [ "${FORCE}" == "skip" ] ; then
				log warn "exportmetabundle() Soubor ${TARGET} již v adresáři ${2} existuje."
			else
				echo "Soubor ${TARGET} již v adresáři ${2} existuje.." >> /dev/stderr
				potvrdit && ${DJVUSED} "${1}" -e "print-meta" > "${TARGET}"
			fi
		else
			${DJVUSED} "${1}" -e "print-meta" > "${TARGET}"
		fi
	fi
	popd
}

# OBSOLETE
# TODO - meta - Nepoužitá funkce
function exportmetapage {
	# $1 - DjVu file - full path
	# $2 - identificator - page name
	# $3 - targetdir - full path
	pushd "${3}"
	if [ "${META}" != "no" ] ; then
		local TARGET="${2/.djvu/.meta}"
		if [ -f "${TARGET}" ] ; then
			if [ "${FORCE}" == "yes" ] ; then
				${DJVUSED} "${1}" -e "select '${2}'; print-meta" > "${TARGET}"
			elif [ "${FORCE}" == "skip" ] ; then
				log warn "exportmetapage() Soubor ${TARGET} již v adresáři ${3} existuje."
			else
				echo "Soubor ${TARGET} již v adresáři ${3} existuje.." >> /dev/stderr
				potvrdit && ${DJVUSED} "${1}" -e "select '${2}'; print-meta" > "${TARGET}"
			fi
		else
			${DJVUSED} "${1}" -e "select '${2}'; print-meta" > "${TARGET}"
		fi
	fi
	popd
}

function exportdsedpage {
	# $1 - DjVu file - full path
	# $2 - identificator - page name
	# $3 - targetdir - full path into dir for file
	pushd "${3}"
	case "${DSED}" in
		yes|all) local EXPORT="output-all"
		;;
		txt) local EXPORT="output-txt"
		;;
		ant) local EXPORT="output-ant"
		;;
		no) return 0
		;;
	esac
	if [ "${DSED}" != "no" ] ; then
		local TARGET="${2/.djvu/.dsed}"
		if [ -f "${TARGET}" ] ; then
			if [ "${FORCE}" == "yes" ] ; then
				${DJVUSED} "${1}" -e "select '${2}'; ${EXPORT}" > "${TARGET}"
			elif [ "${FORCE}" == "skip" ] ; then
				log warn "exportdsedpage() Soubor ${TARGET} již v adresáři ${3} existuje."
			else
				echo "Soubor ${TARGET} již v adresáři ${3} existuje.." >> /dev/stderr
				potvrdit && ${DJVUSED} "${1}" -e "select '${2}'; ${EXPORT}" > "${TARGET}" 2>${LOG}
			fi
		else
#			echo "select '${2}'; ${EXPORT} > ${TARGET}" >> /dev/stderr
#			echo $(pwd) >> /dev/stderr
			${DJVUSED} "${1}" -e "select '${2}'; ${EXPORT}" > "${TARGET}" 2>${LOG}
			return $?
		fi
	fi
	popd
}

function exportdjvupage {
	# $1 - DjVu file - full path
	# $2 - identificator - page name
	# $3 - targetdir - full path
	log info "exportdjvupage() -${1}- -${2}- ${3}"
	pushd "${3}"
	if [ "${PAGE}" == "yes" ] ; then
		if [ -f "${2}" ] ; then
			if [ "${FORCE}" == "yes" ] ; then
				${DJVUSED} -e "select '${2}'; save-page-with '${2}'" "${1}"
			elif [ "${FORCE}" == "skip" ] ; then
				log warn "exportdjvupage() Soubor ${2} již v adresáři ${3} existuje."
			else
				echo "Soubor ${2} již v adresáři ${3} existuje.." >> /dev/stderr
				potvrdit && ${DJVUSED} -e "select '${2}'; save-page-with '${2}'" "${1}"
			fi
		else
			${DJVUSED} -e "select '${2}'; save-page-with '${2}'" "${1}"
		fi
	fi
	popd
}

function getocr {
    log goto "getocr() OCR ${OCR} –> ${1}"
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	if [ "${OCR}" ] ; then
		${OCRODJVU} --in-place -l "${OCR}" "${SOURCE}"
		[ "$?" ] && log info "getocr() OCR was applicated on ${FILE}" 
	fi
}

# ### <span id="mimefile">mimefile()</span> ([top](#FUNCTIONS))
# Function return type file by MIME
#
# $1 - jméno testovaného souboru se kterým se pracuje
mimefile() {
    local SOURCE=$(${REALPATH} -m -P "${1}")
    local FILE="${SOURCE##*/}"
    if [ -f "${SOURCE}" ] ; then
        local TYPE=$(${MIME} -dbM "${SOURCE}" | awk '{print $1}')
    else
        log err "File ${1} is NOT valid."
        return 1
    fi
    log info "${1} –> ${TYPE,,}"
    echo "${TYPE,,}"
    return 0
}

function targetdir {
	# Function return path into existing directory
	# $1 - path
	if [ -z "${1}" ] ; then
		log err "targetdir() NOT PATH"
		exit 1
	else
		local TARGETDIR=$(${REALPATH} -m -P "${1}")
		if [ -d "${TARGETDIR}" ] ; then
			echo -n "${TARGETDIR}"
		else
			mkdir -p "${TARGETDIR}"
			if [ $? -gt "0" ] ; then
				log err "targetdir() Could not create target directory ${TARGETDIR}"
				exit 1
			else
				echo -n "${TARGETDIR}"
			fi
		fi
	fi
}

# ### <span id="isbundle">isbundle()</span> ([top](#FUNCTIONS))
# Function for test type file. For DjVu bundle (0), single (1), or another (1)
# $1 - file path
isbundle() {
    if [ $(mimefile "${1}") == "djvu" ] ; then
        ${DJVM} -l "${1}" &>/dev/null
        [ $? -eq 1 ] && log info "${1} –> DjVu single file" && return 2
    else
        log err "${1} –> NOT DjVu file"
        return 1
    fi
    log info "${1} –> DjVu bundle file"
    return 0
}

function comparedjvu {
	#  Function do test two DjVu files and return (0) if is not any page in conflict or (1)
	# $1 - Djvu full path
	# $2 - Djvu full path
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	local FROMPATH=$(${REALPATH} -m -P "${2}")
	local FROM="${FROMPATH##*/}"
	if isbundle ${SOURCE} ; then
		${DJVM} -l "${SOURCE}" | grep PAGE\ # | awk '{print $4}' | while read x ; do
		if isbundle ${FROMPATH} ; then
			${DJVM} -l "${FROMPATH}" | grep PAGE\ # | awk '{print $4}' | while read y ; do
				if [ "${x}" == "${y}" ] ; then
					echo "comparedjvu: WARNING Page with name ${x} from file ${FILE} is in ${FROM} too." >> /dev/stderr
					break
				fi
			done
		else
			${DJVUSED} "${FROMPATH}" -e dump | grep FORM:DJVU | awk -F'[{}]' '{print $2}' | while read y ; do
				if [ "${x}" == "${y}" ] ; then
					echo "comparedjvu: WARNING Page with name ${x} from file ${FILE} is in ${FROM} too." >> /dev/stderr
					break
				fi
			done
		fi
		done
	else
		${DJVUSED} "${SOURCE}" -e dump | grep FORM:DJVU | awk -F'[{}]' '{print $2}' | while read x ; do
		if isbundle ${FROMPATH} ; then
			${DJVM} -l "${FROMPATH}" | grep PAGE\ # | awk '{print $4}' | while read y ; do
				if [ "${x}" == "${y}" ] ; then
					echo "comparedjvu: WARNING Page with name ${x} from file ${FILE} is in ${FROM} too." >> /dev/stderr
					break
				fi
			done
		else
			${DJVUSED} "${FROMPATH}" -e dump | grep FORM:DJVU | awk -F'[{}]' '{print $2}' | while read y ; do
				if [ "${x}" == "${y}" ] ; then
					echo "comparedjvu: WARNING Page with name ${x} from file ${FILE} is in ${FROM} too." >> /dev/stderr
					break
				fi
			done
		fi
		done
	fi
	potvrdit && return 0 || return 1
}

function splitxcf {
	# vrátí seznam
#	echo ${RANGE[@]} >> /dev/stderr
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	pushd ${TEMPDIR}
		i=0
		${XCFINFO} ${SOURCE} | grep -v Version | cut -d ' ' -f5- | while read line
		do i=$((i+1))
			if [ -z ${RANGE} ] ; then
				${XCF2PNM} ${SOURCE} -o "${line%.pnm}.pnm" "$line"
			else
				for x in ${RANGE[@]}
					do if [ "$x" -eq "$i" ] ; then
						${XCF2PNM} ${SOURCE} -o "${line%.pnm}.pnm" "$line"
					fi
				done
			fi
		done
	popd
}

# ### <span id="istarget">istarget()</span> ([top](#FUNCTIONS))
# Funkce nastavuje TARGETDIR a TARGETSAMPLE
istarget() {
    log goto "istarget() –> $1"
    case "${1:$((${#1}-1)):1}" in
        /) TARGETSAMPLE="ORIGINAL"
            TARGETDIR=$(${REALPATH} -m -P "${1}")
            log info "targets() Export pages with a original names into –> ${TARGETDIR}"
            [ ! -d "${TARGETDIR}" ] && mkdir -p "${TARGETDIR}"
        ;;
        *) if [[ "${1}" =~ "/" ]] ; then
                #/ obsahuje cestu
                local TEMPORARY=$(${REALPATH} -m -P "${1}")
                TARGETDIR="${TEMPORARY%/*}"
                TARGETSAMPLE="${TEMPORARY##*/}"
                log info "targets() Export pages a named by sample ${TARGETSAMPLE} –> ${TARGETDIR}"
                [ ! -d "${TARGETDIR}" ] && mkdir -p "${TARGETDIR}"
            else
                #/ jde o vzorek
                TARGETDIR="$(pwd)/"
                TARGETSAMPLE="${1}"
                log info "targets() Export pages a named by sample ${TARGETSAMPLE} into actual directory"
            fi
        ;;
    esac
    return 0
}

# ### <span id="isrange">isrange()</span> ([top](#FUNCTIONS))
# Testuje, jestli předaný řetězec __$1__ nezačíná rozsahem (RANGE).
isrange() {
    local PARAMS=($1)
    case "${PARAMS[0]}" in
        +([0-9\-,]))
            log info "OK range –> ${PARAMS[0]}"
            echo "${PARAMS[0]}"
            ;;
        *) log info "NOT range –> ${PARAMS[0]}"
            return 1
            ;;
    esac
    return 0
}

# ### <span id="isscale">isscale()</span> ([top](#FUNCTIONS))
# Zjišťuje, zda-li předaný řetězec začíná kódem podporovaného formátu
isformat() {
    log goto "isformat() string –> $1"
    local PARAMS=($1)
    case "${PARAMS[0]}" in
        all)  #/ Volba pro DjVu
            #/ Vyexportuje všechno
            ;;
        ant) #/ Volba pro DjVu
            #/ Poznámky
            ;;
        meta) #/ Volba pro DjVu
            ;;
        line|word|para) #/ Volby pro djvutxt
            ;;
        outline) #/ Volba pro DjVu
            #/ Obsah
            ;;
        bookmark) #/ Volba pro DjVu
            #/ Záložky
            ;;
        dsed-*) #/ Volba pro DjVu
            #/ Export textové vrstvy v dsed formátu
            #/ dsed-ant
            #/ dsed-all
            #/ dsed-txt
            ;;
        djvu) #/ Bitmapový soubor bude konvertován do djvu
            #/ U DjVu souboru budou vyexportované stránky složené opět
            #/ do DjVu souboru
            ;;
        txt|text) #/ V případě DjVu či PDF souborů bude exportován text
            #/ V ostatních případech se stránka prožene přes OCR
            ;;
        image*) #/ akceptováno u PDF a DjVu
            #/ Výsledkem exporu bude obrázek stránky (u DjVu) nebo extrahované
            #/ obrázky z PDF
            ;;
        orig*) #/ původní formát
            ;;
        jpg|jpeg|jp2)
            ;;
        pnm|pam)
            ;;
        mask|black|background|foreground|color) #/ Typ exportované obrazové vrstvy
            ;;
        xcf|gimp)
            ;;
        xml-*) #/ Volba pro DjVu
            #/ export XML vrstvy
            #/ xml-ant
            #/ xml-all
            #/ xml-txt
            ;;
        *) return 1
            ;;
    esac
    log value "isformat() OK –> ${PARAMS[0]}"
    echo "${PARAMS[0]}"
    return 0
}

# ### <span id="parsecut">parsecut()</span> ([top](#FUNCTIONS))
# Parsuje předaný řetězec, který můře být buď ve formě:
# * LEFT,TOP,SIRKA,VYSKA
# * SIRKAxVYSKA+LEFT+TOP
#
# a vrací hodnoty v daném pořadí: W H X Y
#
# * W - (weight) šířka boxu
# * H - (height) výška boxu
# * X - horizontální vzdálenost od levého okraje
# * Y - vertikální vzdálenost od horního okraje
parsecut() {
    log goto "parsecut() $1"
    case ${1} in
                +([0-9])x+([0-9])|+([0-9])x+([0-9])[+]+([0-9])[+]+([0-9]))
                    local W="${1%%x*}"
                    local TEMPORAR="${1#*x}"
                    local H="${TEMPORAR%%+*}"
                    local TEMPORAR="${1#*+}"
                    local X="${TEMPORAR%+*}"
                    local Y="${1##*+}"
                ;;
                +([0-9]),+([0-9]),+([0-9]),+([0-9]))
                    local TEMPORAR=( ${1//,/ } )
                    local X="${TEMPORAR[0]}"
                    local Y="${TEMPORAR[1]}"
                    local W="${TEMPORAR[2]}"
                    local H="${TEMPORAR[3]}"
                ;;
                *) echo "Neplatné nastavení pro cut –> ${1}" >> /dev/stderr
                    return 1
                ;;
    esac
    echo "$W $H $X $Y"
}

# ### <span id="imgcut">imgcut()</span> ([top](#FUNCTIONS))
# Funkce zpracovává řetězec, kterým je identifikována oblast vyžadující
# speciální ošetření. Ta může být nastavena dvěma možnými způsoby:
# LEFT,TOP,SIRKA,VYSKA nebo SIRKAxVYSKA+LEFT+TOP
# Za tímto řetězcem může následovat dvojtečka, která specifikuje typ rámce
# T - vymezená textová oblast se nakopíruje na prázdnou plochu `.text`
# I - vymezená oblast bude na masce `.fore` začerněná
# M - vymezená oblast bude na masce `.fore` zabílená
# G - grafika (čáry a linky)
# bez specifikace typu rámce se předpokládá že se má "zamaskovat" obrázek
#
# Pro zjištění souřadnic lze použít kupř. geeqie Zobrazit –> Zobrazit informace o pixelech
#
# Pro nastavení oblastí lze použít i nástroj djvusmooth, ale souřadnice se musí přepočítat
# rect 225 0 804 61
#     LEFT,BOTTOM, LEFT+WIDTH,HEIGHT
imgcut() {
    log goto "imgcut() $1 –> $2"
    local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .pam)
    local SIZE=(${1/:/ })
    local W=($(parsecut ${SIZE[0]}))
    [ $? -eq 1 ] && return 1
    if [ "${W[0]}" -eq "0" ] || [ "${W[1]}" -eq "0" ] || [ "${W[0]:0:1}" == "-" ] || [ "${W[1]:0:1}" == "-" ] ; then
        echo "${W[2]},${W[3]},[1m${W[0]}[0m,[1m${W[1]}[0m –> Šířka a výška plochy musí mít nenulovou velikost" >> /dev/stderr
        return 1
    fi
    local Y="${W[3]}"
    local X="${W[2]}"
    local H="${W[1]}"
    local W="${W[0]}"
    log info "imgcut W $W H $H X $X Y $Y"
    local FILENAME="${2%.*}"
    case ${#SIZE[@]} in
        1) #/ Vyjme vybranou oblast za černou plochu
            ${PBMMAKE} -black ${W} ${H} > ${TEMPFILE}
            log info "imgcut() ${FILENAME}.fore –> ${FILENAME}.temp"
            ${PAMTOPNM} "${FILENAME}.fore" | ${PNMPASTE} ${TEMPFILE} "${X}" "${Y}" > "${FILENAME}.temp"
            mv -f "${FILENAME}.temp" "${FILENAME}.fore"
            rm -f ${TEMPFILE}
            log info "imgcut() Plocha $1 byla zamaskována"
        ;;
        2) case ${SIZE[1]} in
            M) #/ Nahradí oblast za bílou plochu (ve výsledku dojde k rozmazání
                ${PBMMAKE} -white ${W} ${H} > ${TEMPFILE}
                ${PAMTOPNM} "${FILENAME}.fore" | ${PNMPASTE} ${TEMPFILE} "${X}" "${Y}" > "${FILENAME}.temp"
                mv -f "${FILENAME}.temp" "${FILENAME}.fore"
                log info "imgcut() Plocha $1 byla odmaskována"
            ;;
            T) #/ Text - vybraná plocha z fore je naklíčovaná na bílou plochu
                #/ maska bude mít příponu text
                ${PAMTOPNM} "${FILENAME}.fore" | ${PAMCUT} -left ${X} -top ${Y} -width ${W} -height ${H} > ${TEMPFILE}
                [ ! -f "${FILENAME}.text" ] && \
                    ${PBMMAKE} -white $(head -2 "${FILENAME}.fore" |tail -1) > "${FILENAME}.text"
                ${PAMTOPNM} "${FILENAME}.text" | ${PNMPASTE} ${TEMPFILE} "${X}" "${Y}" > "${FILENAME}.temp"
                mv -f "${FILENAME}.temp" "${FILENAME}.text"
                log info "imgcut() Plocha textu $1 byla vyseparovaná"
            ;;
            I) #/ Obrázek - vybraná plocha je na masce začerněná
                ${PBMMAKE} -black ${W} ${H} > ${TEMPFILE}
                ${PAMTOPNM} "${FILENAME}.fore" | ${PNMPASTE} ${TEMPFILE} "${X}" "${Y}" > "${FILENAME}.temp"
                mv -f "${FILENAME}.temp" "${FILENAME}.fore"
                log info "imgcut() Plocha $1 byla zamaskována"
            ;;
            G) #/ Grafika - v rámci vybrané plochy zredukuje barvy a pak ji naklíčuje do barevného pozadí
            ;;
            *) echo "Neimplemnetováno {SIZE[1]}" >> /dev/stderr
                return 1
            ;;
            esac
        ;;
        *) echo "Neplatné nastavení pro cut –> $1" >> /dev/stderr
        ;;
    esac
}

# ### <span id="iscut">iscut()</span> ([top](#FUNCTIONS))
# Ověřuje, zda-li následuje řetězec pro specifikaci oblastí pro zvláštní
# zacházení. Těchto oblastí může být specifikováno více, v takovém případě
# však musí být odděleny středníkem a uzavřeny v uvozovkách
iscut() {
    log goto "iscut() string –> $1"
    local PARAMS=($1)
    log info "vysledek ${PARAMS[0]}"
    case "${PARAMS[0]}" in
        -cut) echo "${PARAMS[1]}"
        ;;
    esac
}

# ### <span id="isscale">isscale()</span> ([top](#FUNCTIONS))
# Nastavuje proměnnou SCALE a vrací ořezaný řetězec
isscale() {
    log goto "isscale() string –> $1"
    local PARAMS=($1)
    log info "vysledek ${PARAMS[0]}"
    case "${PARAMS[0]}" in
        [1-9]+([0-9])x[1-9]+([0-9]))
            case "${PARAMS[1]}" in
                -xyfit|-xyfill|-xysize)
                    SCALE="${PARAMS[1]} ${PARAMS[0]/x/ }"
                    local TEMPORAR=${1#*${PARAMS[1]}}
                ;;
                *) echo """Při škálování na fixní rozmět musí být nastaven jeden z následujících parametrů: 
  -xyfit
  -xyfill
  -xysize
                """
                    echo false
                ;;
            esac
        ;;
        0.|0.0|0.00) echo "Chybně nastavena hodnota škálování: ${PARAMS[0]}" >> /dev/stderr
            echo false
        ;;
        [1-9]+([0-9])x|x[1-9]+([0-9])) echo "Chybně nastavený škálovací box: ${PARAMS[0]}" >> /dev/stderr
            echo false
        ;;
        [0-9].[0-9]?([0-9])|+([0-9]))
            SCALE="${PARAMS[0]}"
            local TEMPORAR=${1#*${PARAMS[0]}}
        ;;
        *) return 1
            ;;
    esac
    if [[ "${TEMPORAR}" =~ "-filter=" ]] ; then
        local PARAMS=(${TEMPORAR#*-filter=})
        if [[ "${FILTERS[@]}" =~ "${PARAMS[0]}" ]] ; then
            echo "${SCALE} -filter=${PARAMS[0]}"
        else
            echo "Neplatný škálovací filtr: ${PARAMS[0]}" >> /dev/stderr
            echo false
        fi
    else
        echo "${SCALE}"
    fi
}

# ### <span id="fromdjvu">fromdjvu()</span> ([top](#FUNCTIONS))
# Na rozdíl od funkce exportimg, se zde zpracovávají předané parametry
# __$1__ je cesta ke kontejneru ze kterého se exportuje stránka
# __$2__ obsahuje parametry
#
# * ant - Exportuje hyperlinky a meta atributy ve formátu .ant
# * meta - Exportuje meta informace stránky, její rozměry a stav rotace
# * djvu - Exportuje DjVu stránky
# * mask|background|foreground|color|black - oxportuje obrázek pozadí
# * dsed-*
# * xml-*
fromdjvu() {
    log goto "fromdjvu() ${FILETYPE} $1 –> $2"
    local INTO=$(isformat "${2}")
    if [ -n "${INTO}" ] ; then
        local TEMPORAR="${2#*${INTO}}"
    else
        echo "Cílový formát musí být vždy uveden!" >> /dev/stderr
        return 1
    fi

    local RANGE=$(isrange "${TEMPORAR}")
    if [ -n "${RANGE}" ] ; then
        local TEMPORAR="${TEMPORAR#*${RANGE}}"
    fi

    case "${TEMPORAR:$((${#TEMPORAR}-1)):1}" in
        /) TARGETDIR=$(${REALPATH} -m -P "${TEMPORAR## }")
            log info "fromdjvu() Export pages with a original names into –> ${TARGETDIR}"
            [ ! -d "${TARGETDIR}" ] && mkdir -p "${TARGETDIR}"
        ;;
        *) if [[ "${TEMPORAR}" =~ "/" ]] ; then
                #/ obsahuje cestu
                local TEMPORARY=$(${REALPATH} -m -P "${TEMPORAR## }")
                TARGETDIR="${TEMPORARY%/*}"
                TARGETSAMPLE="${TEMPORARY##*/}"
                log info "fromdjvu() Export pages a named by sample ${TARGETSAMPLE} –> ${TARGETDIR}"
                [ ! -d "${TARGETDIR}" ] && mkdir -p "${TARGETDIR}"
            else
                #/ jde o vzorek
                TARGETDIR="$(pwd)"
                TARGETSAMPLE="${TEMPORAR## }"
                log info "targets() Export pages a named by sample ${TARGETSAMPLE} into actual directory"
            fi
        ;;
    esac
    echo """
    RANGE ${RANGE}
    INTO ${INTO}
    TARGETDIR ${TARGETDIR}
    TARGETSAMPLE ${TARGETSAMPLE}
    TEMPORAR ${TEMPORAR}
    Můžeme přikročit k akci
    """ >> /dev/null
    mapfile -t ARRAY <<< $($0 "${1}" info list)
    case "${ARRAY:0:1}" in
        0) mapfile -t LISTPAGES <<< $(printf "%s\n" "${ARRAY[@]}")
        ;;
        *) LISTPAGES="0 none"
        mapfile -O 1 -t LISTPAGES <<< $(printf "%s\n" "${ARRAY[@]}")
        ;;
    esac
#/    echo "ARRAY ${#ARRAY[@]} ${ARRAY[@]}" >> /dev/stderr
#/    echo "LISTPAGES ${#LISTPAGES[@]} ${LISTPAGES[@]}" >> /dev/stderr
    case "${INTO}" in
        djvu|ant|meta|mask|background|foreground|color|black|dsed-*|xml-*|\
        line|word|para)
            if [ -n "${RANGE}" ] ; then
                local PAGES=($(range "${RANGE}"))
            else
                case "${TEMPORAR//+([[:blank:]])/}" in
                    '') # jenom příkaz
                        local PAGES=($(range "0-${#LISTPAGES[@]}"))
                    ;;
                    *) # seznam stránek oddělených čárkou
                        local IFS_BAK=$IFS
                        local IFS=$','
                        local SEZNAM=($TEMPORAR)
                        local IFS=$IFS_BAK
                        for i in "${LISTPAGES[@]}" ; do
                            if [[ "${SEZNAM[@]}" =~ "${i##+([[:digit:]])+([[:blank:]])}" ]] ; then
                                local TEMP="$TEMP${i%% *} "
                            fi
                            x=$((x + 1))
                        done
                        local PAGES=($TEMP)
                    ;;
                esac
            fi
#/            echo "PAGES ${#PAGES[@]} ${PAGES[@]}" >> /dev/stderr
            for i in ${PAGES[@]} ; do
                local PAGENAME="${LISTPAGES[$i]##+([[:digit:]])+([[:blank:]])}"
                local PAGEORDER="${LISTPAGES[$i]%% *}"
                case "${PAGEORDER}" in
                    0) case "${PAGENAME}" in
                            none)
                            ;;
                            *) case ${INTO} in
                                line|word|para)
                                ;;
                                ant) printf "# 'shared_anno.iff'\n"
                                    ${DJVUSED} "${1}" -e "select 'shared_anno.iff'; print-ant" | formatdsed
                                ;;
                                meta) printf "# 'shared_anno.iff'\n"
                                    local META=$(${DJVUSED} "${1}" -e "select 'shared_anno.iff'; print-meta" | decode)
                                echo -e "${META}"
                                ;;
                                dsed-*) local EXPORT="output-ant"
                                    local TARGET=$(${REALPATH} -m -P "${TARGETDIR}/${PAGENAME}.dsed")
                                    if [ -f "${TARGET}" ] ; then
                                        anone "Soubor ${TARGET##*/} již existuje a může obsahovat změny. Mám ho přepsat?"
                                        [ $? -eq 1 ]&& return 1
                                    fi
                                    printf "select '${PAGENAME}' ; remove-ant\n" > "${TARGET}"
                                    ${DJVUSED} "${1}" -e "select 'shared_anno.iff'; ${EXPORT}" >> "${TARGET}"
                                    [ $? -eq 1 ] && return 1
                                    echo "Soubor ${TARGET} byl zapsán" >> /dev/stderr
                                ;;
                            esac
                            ;;
                        esac
                    ;;
                    '') echo ""
                    ;;
                    *) local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .ant)
                        case ${INTO} in
                            line|word|para)  printf "# '${PAGENAME}' # page ${PAGEORDER}\n"
                                ${DJVUTXT} -page="${PAGEORDER}" -detail="${INTO}" "${FILE}" 
                                ;;
                            ant) printf "# '${PAGENAME}' # page ${PAGEORDER}\n"
                                ${DJVUSED} "${1}" -e "select ${PAGEORDER}; print-ant" | formatdsed
                            ;;
                            meta) printf "# '${PAGENAME}' # page ${PAGEORDER} "
                                ${DJVUSED} "${1}" -e "select ${PAGEORDER}; size"
                                local META=$(${DJVUSED} "${1}" -e "select ${PAGEORDER}; print-meta" | decode)
                                [ -n "${META}" ] && echo -e "${META}"
                            ;;
                            djvu) local TARGET=$(${REALPATH} -m -P "${TARGETDIR}/${PAGENAME}")
                                if [ -f "${TARGET}" ] ; then
                                    anone "Soubor ${TEMPORAR} již existuje. Mám ho přepsat?"
                                    [ $? -eq 1 ]&& return 1
                                fi
                                ${DJVUSED} "${1}" -e "select ${PAGEORDER}; save-page-with '${TARGET}'"
                                echo "Exportuji stránku Zapisuji do souboru ${TARGET}" >> /dev/stderr
                            ;;
                            mask|background|foreground|color|black)
                                local TARGET=$(${REALPATH} -m -P "${TARGETDIR}/${PAGENAME/.djvu/.png}")
                                ${DDJVU} -format=pnm -mode=${INTO} -page="${PAGEORDER}" "${1}" | ${PNMTOPNG} > "${TARGET}"
                                [ $? -eq 1 ] && return 1
                                echo "Soubor ${TARGET} byl zapsán" >> /dev/stderr
                            ;;
                            dsed-*)
                                case ${INTO} in
                                    dsed-all) local EXPORT="output-all"
                                        local IMPORT="remove-ant; remove-txt"
                                        local TARGET=$(${REALPATH} -m -P "${TARGETDIR}/${PAGENAME/.djvu/.dsed}")
                                    ;;
                                    dsed-txt) local EXPORT="output-txt"
                                        local IMPORT="remove-txt"
                                        local TARGET=$(${REALPATH} -m -P "${TARGETDIR}/${PAGENAME/.djvu/.txt.dsed}")
                                    ;;
                                    dsed-ant) local EXPORT="output-ant"
                                        local IMPORT="remove-ant"
                                        local TARGET=$(${REALPATH} -m -P "${TARGETDIR}/${PAGENAME/.djvu/.ant.dsed}")
                                    ;;
                                    *) return 1
                                    ;;
                                esac
                                if [ -f "${TARGET}" ] ; then
                                    anone "Soubor ${TARGET##*/} již existuje a může obsahovat změny. Mám ho přepsat?"
                                    [ $? -eq 1 ]&& return 1
                                fi
                                printf "select '${PAGENAME}' ; ${IMPORT}\n" > "${TARGET}"
                                ${DJVUSED} "${1}" -e "select ${PAGEORDER}; ${EXPORT}" >> "${TARGET}"
                                [ $? -eq 1 ] && return 1
                                echo "Soubor ${TARGET} byl zapsán" >> /dev/stderr
                            ;;
                            xml-*) local TARGET=$(${REALPATH} -m -P "${TARGETDIR}/${PAGENAME/.djvu/.xml}")
                                case ${INTO} in
                                    xml-all) local EXPORT="--with-text --with-anno"
                                    ;;
                                    xml-txt) local EXPORT="--with-text --without-anno"
                                    ;;
                                    xml-ant) local EXPORT="--without-text --with-anno"
                                    ;;
                                    *) return 1
                                    ;;
                                esac
                                if [ -f "${TARGET}" ] ; then
                                    anone "Soubor ${PAGENAME/.djvu/.xml} již existuje a může obsahovat změny. Mám ho přepsat?"
                                    [ $? -eq 1 ]&& return 1
                                fi
                                ${DJVUTOXML} --page "${PAGEORDER}" ${EXPORT} "${1}" "${TARGET}"
                                [ $? -eq 1 ] && return 1
                                echo "Soubor ${TARGET} byl zapsán" >> /dev/stderr
                            ;;
                        esac
                    ;;
                esac
            done
            ;;
        outline) # Export obsahu ve formátu .outline
            printoutline "${1}"
            ;;
        bookmark) # Export obsahu ve formátu .bookmarks
            local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .outline)
            printoutline "${1}" > ${TEMPFILE}
            outlinetodsed ${TEMPFILE} | encode
            printf "\n"
            ;;
        *) echo "Nedělám nic ${INTO}" >> /dev/stderr
            ;;
    esac
}

# ### Původní zpracování - očekává parametry ze startu message
# Zpracovává stream. pokud se vyskytne, vrátí parametr a zbytek řetězce
#
# Funkce je závislá na obsahu lokální proměnné ELEMENT z funkce setdjvu
object() {
    # Je tady - vrátí parametr, řetězec a 0
    # Není tady nic - vrátí řetězec a 1
    log goto "object() ${ELEMENT} –> $@"
    while [ $# -gt 0 ]
    do
        case ${1} in
            border_avis|none|xor) case ${ELEMENT} in
                rect|oval|text) echo -e "\t$1" && shift
                ;;
                *) return 1
                ;;
            esac
            ;;
            pushpin) case ${ELEMENT} in
                text) echo -e "\t$1" && shift
                ;;
                *) return 1
                ;;
            esac
            ;;
            hilite) case ${ELEMENT} in
                rect) local PROPERTY="${1}" && shift
                    case "${1}" in
                        [0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F]) echo -e "\t${PROPERTY} #$1" && shift
                        ;;
                        *) help set-${PROPERTY}
                            return 1
                        ;;
                    esac
                ;;
                line|oval|text|arrow) shift
                    case "${1}" in
                        [0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F]) shift
                            echo "Nastavení parametru border (barva okraje) u objektu ${ELEMENT} nedává smysl, proto ho ignoruji" >> /dev/stderr
                            echo "Barvu linky lze změnit parametrem lineclr" >> /dev/stderr
                            return 1
                        ;;
                        *) help set-line
                            return 1
                        ;;
                    esac
                ;;
                *) return 1
                ;;
            esac
            ;;
            textclr|backclr|lineclr) case ${ELEMENT} in
                rect|oval|text|arrow) local PROPERTY="${1}" && shift
                    case "${1}" in
                        [0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F]) echo -e "\t${PROPERTY} #$1" && shift
                        ;;
                        *) help set-${PROPERTY}
                            return 1
                        ;;
                    esac
                ;;
                line) shift
                    case "${1}" in
                        [0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F]) shift
                            echo "Nastavení parametru border (barva okraje) u objektu ${ELEMENT} nedává smysl, proto ho ignoruji" >> /dev/stderr
                            echo "Barvu linky lze změnit parametrem lineclr" >> /dev/stderr
                            return 1
                        ;;
                        *) help set-line
                            return 1
                        ;;
                    esac
                ;;
                *) return 1
                ;;
            esac
            ;;
            _blank) echo -e "$1" && shift
                # Kvůli url
            ;;
            border) case "${ELEMENT}" in
                rect|oval) local PROPERTY="${1}" && shift
                    case "${1}" in
                        [0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F]) echo -e "\t${PROPERTY} #$1" && shift
                        ;;
                        *) echo "xxxxx ${1}" >> /dev/stderr
                            help set-${PROPERTY}
                            return 1
                        ;;
                    esac
                ;;
                line) shift
                    case "${1}" in
                        [0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F]) shift
                            echo "Nastavení parametru border (barva okraje) u objektu ${TYPE} nedává smysl, proto ho ignoruji" >> /dev/stderr
                            echo "Barvu linky lze změnit parametrem lineclr" >> /dev/stderr
                            return 1
                        ;;
                        *) help set-line
                            return 1
                        ;;
                    esac
                ;;
                *) return 1
                ;;
            esac
            ;;
            shadow_+(in|out|ein|eout)) case ${ELEMENT} in
                rect) local PROPERTY="${1}" && shift
                    case "${1}" in
                        [1-9]|[1-9][0-9]) echo -e "\t${PROPERTY} $1" && shift
                        ;;
                        *) help set-${PROPERTY}
                            return 1
                        ;;
                    esac
                ;;
                text) echo "Nastavení stínovaného okraje by zobrazování objektu ${TYPE} znemožnilo, proto ho ignoruji" >> /dev/stderr
                    case "${1}" in
                        [1-9]|[1-9][0-9]) shift
                            echo "Nastavení stínovaného okraje by zobrazování objektu ${TYPE} znemožnilo, proto ho ignoruji" >> /dev/stderr
                        ;;
                        *) help set-${PROPERTY}
                            return 1
                        ;;
                    esac
                ;;
                *) return 1
                ;;
            esac
            ;;
            opacity) case ${ELEMENT} in
                rect|oval) local PROPERTY="${1}" && shift
                    case "${1}" in
                        [1-9]|[1-9][0-9]) echo -e "\t${PROPERTY} $1" && shift
                        ;;
                        *) help set-${PROPERTY}
                            return 1
                        ;;
                    esac
                ;;
                *) return 1
                ;;
            esac
            ;;
            width) case ${ELEMENT} in
                line|arrow) local PROPERTY="${1}" && shift
                    case "${1}" in
                        [1-9]|[1-9][0-9]) echo -e "\t${PROPERTY} $1" && shift ;;
                        *) help set-${PROPERTY} ; return 1 ;;
                    esac
                ;;
                rect|text|oval|poly)
                    case "${1}" in
                        [1-9]|[1-9][0-9]) shift ;;
                        *) help set-${PROPERTY} ; return 1 ;;
                    esac
                ;;
                *) return 1
                ;;
            esac
            ;;
            *) # echo "$@"
                break
            ;;
        esac
    done
    return 0
}

# ### <span id="setdjvu">setdjvu()</span> ([top](#FUNCTIONS))
# Na rozdíl od funkce exportimg, se zde zpracovávají předané parametry
# __$1__ je cesta ke kontejneru ze kterého se exportuje stránka
# __$2__ obsahuje parametry
#
# * ant - Exportuje hyperlinky a meta atributy ve formátu .ant
# * meta - Exportuje meta informace stránky, její rozměry a stav rotace
# * djvu - Exportuje DjVu stránky
# * mask|background|foreground|color|black - oxportuje obrázek pozadí
# * dsed-*
# * xml-*#
#
# Akce set je určena pro primární nastavení odkazů v obsahu, či poznámek v textu
# Souřadnice se při ní přepočítávají podle velikosto stránky
# a zároveň se kontroluje syntaxe.
# Dodatečné úpravy lze pak provádět buď přes djvusmooth, nebo editací vrstvy .ant
# set outline : "#cíl" "popis"
# set meta RANGE : key "Popis"
# set note RANGE : key "Obsah skryté poznámky"
# set poly RANGE : "" "" {none|xor|border} [border_avis] x1 y1 x2 y2 …
# set rect : "" {none|xor|border c} [hilite c] [border_avis] x1 y1 x2 y2
# set oval : "" {none|xor|border} [border_avis] x1 y1 x2 y2
# set line : 
# Jak upravit line - nejprve někam nastavit a pak přes djvusmooth upravit odkud kam
# set text : x1 y1 x2 x3
# URL
# maparea
setdjvu() {
    log goto "$1 –> $2"
    local RANGE=$(isrange "${2}")
    if [ ! -n "${RANGE}" ] ; then
        local RANGE="${2%%+([[:blank:]])*}"
    fi

    local TEMPORAR="${2#*${RANGE}+([[:blank:]])}"
    [ ! -n "${TEMPORAR##+([[:blank:]])}" ] && return 1

    case "${RANGE}" in
        global|all|\
        mode|align|background|zoom|note|key) echo """
Pokud chcete nastavit element, či parametr, tak aby ho obsahovala každá
stránka, tak máte dvě možnosti:
  1, Buď nastavíte RANGE na hodnotu 0 (nula). V takovém případě se prvek
     vloží mezi sdílená metadata.
  2, Nebo nastavíte RANGE na rozsah od první do poslední stránky (např. 1-99)
     Prvek se pak nastaví pro každou z nich samostatně.
""" >> /dev/stderr
        ;;
        outline)
            [ "${ACTION}" == "unset" ] && echo "Nastavené záložky lze odstraňovat jedině při akci edit" && return 1
            local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .outline)
            $0 "${FILE}" export outline > "${TEMPFILE}"
            local TEMP="${TEMPORAR#+([[:blank:]])}"
            case "${TEMP}" in
                +([[:digit:]])+([[:blank:]])*) echo "\"${TEMP#+([[:digit:]])+([[:blank:]])}\" \"#${TEMP%%+([[:blank:]])*}\"" >> "${TEMPFILE}"
                ;;
                http*)  echo "\"${TEMP#http*+([[:blank:]])}\" \"${TEMP%%+([[:blank:]])*}\"" >> "${TEMPFILE}"
                ;;
                *) local TARGET="${TEMP%%+([[:blank:]])*}"
                    if [[ "${TARGET}" =~ ".djvu" ]] ; then
                        echo "\"${TEMP#${TARGET}+([[:blank:]])}\" \"${TARGET}\"" >> "${TEMPFILE}"
                    else
                        echo "Neplatná záložka –> z${TEMPORAR}z x${TEMP}x" >> /dev/stderr
                        return 1
                    fi
                ;;
            esac
            outlinetodjvu "${FILE}" "${TEMPFILE}"
            if [ $? -eq 1 ] ; then
                echo "Při importu záložek se vyskytla chyba" >> /dev/stderr
                return 1
            else
                echo "Pozici a zanoření záložky v obsahu můžete upravit přes akci edit" >> /dev/stderr
            fi
            return $?
        ;;
        *) local TEST=($($0 "${1}" info list))
            local STRING="${TEMPORAR#+([[:blank:]])}"
            local ELEMENT="${STRING%%+([[:blank:]])*}"
            case "${ELEMENT}" in
                note|\
                key)
                    local TEMP=(${STRING//+([[:blank:]])/ })
                    case "${TEMP[0]}" in
                        note) local KEY="${TEMP[0]}"
                            local VALUE="${STRING#${TEMP[0]}+([[:blank:]])}"
                        ;;
                        key) local KEY="${TEMP[1]}"
                            local VALUE="${STRING#${TEMP[0]}+([[:blank:]])${TEMP[1]}+([[:blank:]])}"
                        ;;
                        *) #/ ještě nevím
                            return 1
                        ;;
                    esac
                    if [ "${RANGE}" == "0" ] ; then
                        if [ "${TEST[0]}" -eq "0" ] ; then
                            local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .ant)
                            log info "From shared_ant –> $i"
                            $0 "${1}" export ant 0 > "${TEMPFILE}"
                            mapfile -d\: -t -c1 LINE <<< $(grep -n "${KEY} \"${VALUE}\"" "${TEMPFILE}")
                            echo "${LINE[0]}" >> /dev/stderr
                            case "${ACTION}" in
                                unset) case "${LINE[0]}" in
                                        +([[:digit:]])) #/ vyskytuje se
                                            echo "Ruším \t${KEY}" >> /dev/stderr
                                            setmeta "${TEMPFILE}" "${KEY} \"${VALUE}\""
                                        ;;
                                        *) #/ nevyskytuje se
                                        ;;
                                    esac
                                ;;
                                set) case "${LINE[0]}" in
                                        +([[:digit:]])) #/ vyskytuje se nedělám nic
                                        ;;
                                        *) #/ nevyskytuje se
                                            case "${KEY}" in
                                                note) echo -e "${KEY} \"${VALUE}\"\n" >> "${TEMPFILE}"
                                                ;;
                                                *) echo "metadata" >> "${TEMPFILE}"
                                                    echo -e "\t${KEY} \"${VALUE}\"\n" >> "${TEMPFILE}"
                                                ;;
                                            esac
                                        ;;
                                    esac
                                ;;
                            esac
                            cat "${TEMPFILE}" | $0 "${1}" import ant
                        else
                            case "${ACTION}" in
                                set) ${DJVUSED} "${1}" -e 'create-shared-ant ; set-ant' -s
                                    ( $0 "${1}" export ant 0
                                        case "${KEY}" in
                                            note) echo -e "${KEY} \"${VALUE}\"\n"
                                            ;;
                                            *) echo "metadata" >> "${TEMPFILE}"
                                                echo -e "\t${KEY} \"${VALUE}\"\n"
                                            ;;
                                        esac
                                    ) | $0 "${1}" import ant
                                ;;
                            esac
                        fi
                    else
                        local PAGES=($(range ${RANGE}))
                        for i in ${PAGES[@]} ; do
                            local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .ant)
                            log info "From page –> $i"
                            $0 "${1}" export ant $i > "${TEMPFILE}"
                            echo "" >> "${TEMPFILE}"
                            mapfile -d\: -t -c1 LINE <<< $(grep -n "${KEY} \"${VALUE}\"" "${TEMPFILE}")
                            case "${ACTION}" in
                                unset) case "${LINE[0]}" in
                                        +([[:digit:]])) #/ vyskytuje se
                                            log info "Odstraňuji ${KEY} –> ${KEY} \"${VALUE}\""
                                            setmeta "${TEMPFILE}" "${KEY} \"${VALUE}\""
                                        ;;
                                        *) #/ nevyskytuje se
                                            case "${KEY}" in
                                                note) #/ jiná poznámka, kterou ignoruji
                                                    log warn "Poznámka odpovídající parametrům na stránce neexistuje –> ${KEY} \"${VALUE}\""
                                                ;;
                                                *) #/ zjistit jestli se vyskytuje klíč
                                                    log info "Testuji zda-li se v souboru vyskytuje klíč ${KEY}"
                                                    mapfile -d\: -t -c1 ITEMKEY <<< $(grep -n "${KEY}" "${TEMPFILE}")
                                                    case "${ITEMKEY[0]}" in
                                                        +([[:digit:]])) #/ vyskytuje se, je třeba odstranit, ovšem pozor!
                                                            log info "Klíč se vyskytuje na řádku ${ITEMKEY[0]}"
                                                            setmeta "${TEMPFILE}" "${KEY}"
                                                            echo "${TEMPFILE}" >> /dev/stderr
                                                        ;;
                                                        *) #/ nevyskytuje se
                                                            log warn "Neexistující klíč –> ${KEY}"
#                                                            echo "metadata" >> "${TEMPFILE}"
#                                                            echo -e "\t${KEY} \"${VALUE}\"\n" >> "${TEMPFILE}"
                                                        ;;
                                                    esac
                                                ;;
                                            esac
                                        ;;
                                    esac
                                ;;
                                set) case "${LINE[0]}" in
                                        +([[:digit:]])) #/ vyskytuje se
                                            log info "Na stránce $i řádek vyhovující parametrům již existuje ${LINE[0]} –> ${KEY} \"${VALUE}\""
                                            cat "${TEMPFILE}" >> /dev/stderr
                                        ;;
                                        *) #/ nevyskytuje se
                                            case "${KEY}" in
                                                note) log info "Přidávám poznámku –> ${KEY} \"${VALUE}\""
                                                    echo -e "${KEY} \"${VALUE}\"\n" >> "${TEMPFILE}"
                                                ;;
                                                *) #/ zjistit jestli se vyskytuje klíč
                                                    log info "Testuji zda-li se v souboru vyskytuje klíč ${KEY}"
                                                    mapfile -d\: -t -c1 ITEMKEY <<< $(grep -n "${KEY}" "${TEMPFILE}")
                                                    case "${ITEMKEY[0]}" in
                                                        +([[:digit:]])) #/ vyskytuje se, nahradit
                                                            log info "Aktualizuji klíč –> ${KEY} \"${VALUE}\""
                                                            setmeta "${TEMPFILE}" "${KEY}" "${KEY} \"${VALUE}\""
                                                        ;;
                                                        *) #/ nevyskytuje se
                                                            log info "Přidávám nový klíč –> ${KEY} \"${VALUE}\""
                                                            echo "metadata" >> "${TEMPFILE}"
                                                            echo -e "\t${KEY} \"${VALUE}\"\n" >> "${TEMPFILE}"
                                                        ;;
                                                    esac
                                                ;;
                                            esac
                                        ;;
                                    esac
                                ;;
                            esac
                            cat "${TEMPFILE}" | $0 "${1}" import ant
                        done
                    fi
                    return $?
                ;;
                align|\
                background|\
                mode|\
                pfoot|\
                phead|\
                zoom) #/ Metadata co se mohou vyskytovat vždy pouze jednou
                    local KEY="${ELEMENT}"
                    case "${ACTION}" in
                        unset)
                        ;;
                        set)
                            local VALUE="${STRING#${KEY}+([[:blank:]])}"
                            case "${KEY}" in
                                align) case "${VALUE}" in
                                    +(left|center|right)+([[:blank:]])+(top|center|bottom))
                                        ;;
                                        *) log err "align invalid value –> #${VALUE}#"
                                            help set-align
                                            return 1
                                        ;;
                                    esac
                                    ;;
                                background) case "${VALUE}" in
                                        [0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F]) # Mohu nastavit
                                        local VALUE="#${VALUE}"
                                        ;;
                                        *) log err "background invalid value –> ${VALUE}#"
                                            help set-background
                                            return 1
                                        ;;
                                    esac
                                    ;;
                                mode) case "${VALUE}" in
                                        color|bw|fore|black) # Mohu nastavit
                                        ;;
                                        *) log err "mode invalid value –> #${VALUE}#"
                                            help set-mode
                                            return 1
                                        ;;
                                    esac
                                    ;;
                                pfoot|phead) case "${VALUE}" in
                                        '') log err "${KEY} invalid value –> #${VALUE}#"
                                            help set-${KEY}
                                            return 1
                                        ;;
                                        *) echo "Záhlaví a zápatí není ve většině prohlížečů, proto ani nedává smysl ho nastavovat, ale když chcete…"
                                            local VALUE="\"${VALUE}\""
                                        ;;
                                    esac
                                    ;;
                                zoom) case "${VALUE}" in
                                    stretch|one2one|width|page|d+([[:digit:]]))
                                        ;;
                                        *) log err "zoom invalid value –> #${VALUE}#"
                                            help set-zoom
                                            return 1
                                        ;;
                                    esac
                                    ;;
                                *) #/ ještě nevím
                                    return 1
                                    ;;
                            esac
                        ;;
                    esac
                    if [ "${RANGE}" == "0" ] ; then
                        if [ "${TEST[0]}" -eq "0" ] ; then
                            local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .ant)
                            log info "From shared_ant –> $i"
                            $0 "${1}" export ant 0 > "${TEMPFILE}"
                            [ -n "${VALUE}" ] && setmeta "${TEMPFILE}" "${KEY}" "${KEY} ${VALUE}" || setmeta "${TEMPFILE}" "${KEY}"
                            cat "${TEMPFILE}" | $0 "${1}" import ant
                        else
                            if [ -n "${VALUE}" ] ; then
                                ${DJVUSED} "${1}" -e 'create-shared-ant ; set-ant' -s
                                ( $0 "${1}" export ant 0
                                    echo "${KEY} ${VALUE}"
                                ) | $0 "${1}" import ant
                            fi
                        fi
                    else
                        local PAGES=($(range ${RANGE}))
                        for i in ${PAGES[@]} ; do
                            local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .ant)
                            log info "From page –> $i"
                            $0 "${1}" export ant $i > "${TEMPFILE}"
                            [ -n "${VALUE}" ] && setmeta "${TEMPFILE}" "${KEY}" "${KEY} ${VALUE}" || setmeta "${TEMPFILE}" "${KEY}"
                            cat "${TEMPFILE}" | $0 "${1}" import ant
                        done
                    fi
                    return $?
                ;;
                *) # Prvky vyžadující koordináty
                   # link, oval, rect, text, ram, line, arrow a poly
                    local TEMP="${STRING#${ELEMENT}+([[:blank:]])}"
                    # odfiltrováná koordinátů
                    local MESSAGE="${TEMP//+([[:digit:]])+([[:blank:]])+([[:digit:]])+([[:blank:]])/}"
                    local COORDS="${TEMP%${MESSAGE}}"
                    # další parametry následují za dvojtečkou
                    if [[ "${MESSAGE}" =~ ":" ]] ; then
                        mapfile PARAMS < <( object ${MESSAGE##*:+([[:blank:]])} )
                        #object "${MESSAGE##*:+([[:blank:]])}"
                        local MESSAGE="${MESSAGE%+([[:blank:]]):*}"
                    fi
                    if [[ ${MESSAGE:0:1} =~ [0-9] ]] ; then
                        echo "Chyba v počtu koordinátů –> ${MESSAGE}" >> /dev/stderr
                        return 1
                    else
                        # Většina typů ploch může mít pouze 4 souřadnice
                        local TEST=(${COORDS})
                        case "${ELEMENT}" in
                            link|oval|rect|text|ram|line|arrow) [ ${#TEST[@]} -ge 5 ] && help set-${ELEMENT} && return 1
                        esac
                        echo "MESSAGE ${MESSAGE%+([[:blank:]]):*}" >> /dev/stderr
                        echo "COORDS ${COORDS}" >> /dev/stderr
                        printf "%s" "${PARAMS[@]}" >> /dev/stderr
                        #return 0
                        local PAGES=($(range ${RANGE}))
                        for i in ${PAGES[@]} ; do
                            (
                            # co mohu mměnit - buď souřadnice, nebo cílovou message
                            local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .ant)
                            local INCFILE=$(tempfile -d ${TEMPDIR} -s .inc)
                            $0 "${1}" export ant $i > "${TEMPFILE}"
                            case "${ACTION}" in
                                set) (
                                    echo "maparea"
                                    case "${MESSAGE}" in
                                        +([a-Z0-9])\.djvu+([[:blank:]])*)
                                            case "${ELEMENT}" in
                                                arrow) echo "U prvku typu arrow a line odkazy nelze použít, proto link na #${MESSAGE%%+([[:blank:]])*} ignoruji" >> /dev/stderr
                                                    echo -e "\t\"\" \"${MESSAGE#*+([[:blank:]])}\""
                                                    if [ "${ELEMENT}" == "arrow" ] ; then
                                                        echo -e "\tline ${COORDS}"
                                                        echo -e "\tarrow"
                                                        printf "%s" "${PARAMS[@]/_blank}"
                                                    elif [ "${ELEMENT}" == "line" ] ; then
                                                        echo -e "\tline ${COORDS}"
                                                        printf "%s" "${PARAMS[@]/_blank}"
                                                    else
                                                        echo -e "\t${ELEMENT} ${COORDS}"
                                                        printf "%s" "${PARAMS[@]}"
                                                        printf "%s" "${PARAMS[@]/_blank}"
                                                    fi
                                                ;;
                                                *) echo -e "\t\"#${MESSAGE%%+([[:blank:]])*}\" \"${MESSAGE#*+([[:blank:]])}\""
                                                    echo -e "\t${ELEMENT} ${COORDS}"
                                                    #printf "%s" "${PARAMS[@]/_blank}"
                                                    printf "%s" "${PARAMS[@]}"
                                                ;;
                                            esac
                                        ;;
                                        http\:\/\/*) # link na www stránku
                                            case "${ELEMENT}" in
                                                arrow|line) echo "U prvku typu arrow a line odkazy nelze použít, proto link na URL ${MESSAGE%%+([[:blank:]])*} ignoruji" >> /dev/stderr
                                                    echo -e "\t\"\" \"${MESSAGE}\""
                                                    if [ "${ELEMENT}" == "arrow" ] ; then
                                                        echo -e "\tline ${COORDS}"
                                                        echo -e "\tarrow"
                                                        printf "%s" "${PARAMS[@]/_blank}"
                                                    elif [ "${ELEMENT}" == "line" ] ; then
                                                        echo -e "\tline ${COORDS}"
                                                        printf "%s" "${PARAMS[@]/_blank}"
                                                    else
                                                        echo -e "\t${ELEMENT} ${COORDS}"
                                                        printf "%s" "${PARAMS[@]}"
                                                        printf "%s" "${PARAMS[@]/_blank}"
                                                    fi
                                                ;;
                                                *) if [[ "${PARAMS}" =~ "_blank" ]] ; then
                                                        echo -e "\turl \"${MESSAGE%%+([[:blank:]])*}\" \"_blank\" \"${MESSAGE#*+([[:blank:]])}\""
                                                        echo -e "\t${ELEMENT} ${COORDS}"
                                                        printf "%s" "${PARAMS[@]/_blank}"
                                                    else
                                                        echo -e "\t\"${MESSAGE%%+([[:blank:]])*}\" \"${MESSAGE#*+([[:blank:]])}\""
                                                        echo -e "\t${ELEMENT} ${COORDS}"
                                                        printf "%s" "${PARAMS[@]}"
                                                    fi
                                                ;;
                                            esac
                                        ;;
                                        *)  # bez linku
                                            echo -e "\t\"\" \"${MESSAGE}\""
                                            if [ "${ELEMENT}" == "arrow" ] ; then
                                                echo -e "\tline ${COORDS}"
                                                echo -e "\tarrow"
                                                printf "%s" "${PARAMS[@]}"
                                            elif [ "${ELEMENT}" == "line" ] ; then
                                                echo -e "\tline ${COORDS}"
                                                printf "%s" "${PARAMS[@]}"
                                            else
                                                echo -e "\t${ELEMENT} ${COORDS}"
                                                printf "%s" "${PARAMS[@]}"
                                            fi
                                        ;;
                                    esac
                                    echo -e "\n"
                                    ) > "${INCFILE}"
                                    local INC=$(cat "${INCFILE}")
                                    local ADRESA=$(infile "${TEMPFILE}")
                                    case "${ADRESA}" in
                                    +([[:digit:]])\ +([[:digit:]]))
                                            # echo "${ADRESA/ /,}c" >> /dev/stderr
                                            ed "${TEMPFILE}" 2>/dev/null <<-EOF
${ADRESA/ /,}c
${INC}

.
w
q
EOF
                                            echo "" >> "${TEMPFILE}"
                                        ;;
                                        *) echo "${INC}" >> "${TEMPFILE}"
                                            echo "" >> "${TEMPFILE}"
                                        ;;
                                    esac
                                ;;
                                unset) local ADRESA=$(infile "${TEMPFILE}")
                                    case "${ADRESA}" in
                                        +([[:digit:]])\ +([[:digit:]]))
                                            # echo "${ADRESA/ /,}d" >> /dev/stderr
                                            ed "${TEMPFILE}" 2>/dev/null <<-EOF
${ADRESA/ /,}d
w
q
EOF
                                            echo "" >> "${TEMPFILE}"
                                        ;;
                                        *) echo "Pokoušíte se odstranit neexistující položku" >> /dev/stderr
                                        ;;
                                    esac
                                ;;
                            esac
                            #echo "---------"  >> /dev/stderr
                            case ${DEBUG} in
                                -d1|-d3|-d4|-d6|-d7|-d9) cat "${TEMPFILE}" >> /dev/stderr
                            esac
                            cat "${TEMPFILE}" ) | $0 "${1}" import ant
                        done
                    fi
                ;;
        esac
        case ${ACTION} in
            set) echo "Nastavuji informaci pro sdílenou stránku - pozici v obsahu upravte přes akci edit" >> /dev/stderr
        esac
        ;;
    esac
}

# ### <span id="fromcontainer">fromcontainer()</span> ([top](#FUNCTIONS))
# Na rozdíl od funkce exportimg, se zde zpracovávají předané parametry
# __$1__ je cesta ke kontejneru ze kterého se exportuje stránka
# __$2__ obsahuje parametry
#
# Rozdíl oproti podobné funkci fromfile je ve zpracování výstupu
# Cílem téhle funkce je nahradit funkce fromfile() a extractionpage() a filters()
fromcontainer() {
    log goto "fromcontainer() $1 –> $2"

    local INTO=$(isformat "${2}")
    if [ -n "${INTO}" ] ; then
        local TEMPORAR="${2#*${INTO}}"
    else
        echo "Cílový formát musí být vždy uveden!" >> /dev/stderr
        return 1
    fi

    local RANGE=$(isrange "${TEMPORAR}")
    if [ -n "${RANGE}" ] ; then
        local TEMPORAR="${TEMPORAR#*${RANGE}}"
    fi

    local CUT=$(iscut "${TEMPORAR}")
    if [ -n "${CUT}" ] ; then
        local TEMPORAR="${TEMPORAR#*${CUT}}"
    fi

    local SCALE=$(isscale "${TEMPORAR}")
    if [ -n "${SCALE}" ] ; then
        [ "${SCALE}" == "false" ] && return 1
        local PARAM=(${SCALE})
        case "${PARAM[$((${#PARAM[@]}-1))]}" in
            -filter=*)
                log info "fromcontainer()" \
                "Scale use any resize filter –> ${PARAM[$((${#PARAM[@]}-1))]}"
                local TEMPORAR="${TEMPORAR#*${PARAM[$((${#PARAM[@]}-1))]}}"
            ;;
            [0-9]*)
                case ${#PARAM[@]} in
                1) log info "fromcontainer()" \
                    "Only resize scale –> ${PARAM[$((${#PARAM[@]}-1))]}"
                    local TEMPORAR="${TEMPORAR#*${PARAM[$((${#PARAM[@]}-1))]}}"
                ;;
                2) echo \
                    "Někde je chyba v nastavení škálování –> ${SCALE}" >> /dev/stderr
                    return 1
                ;;
                *) #/ 3 a více položek
                    case "${PARAM[0]}" in
                        -xy*) local TEMPORAR="${TEMPORAR#*${PARAM[0]}}"
                        ;;
                        *) echo \
                            "Někde je chyba v nastavení škálování –> ${SCALE}" >> /dev/stderr
                            return 1
                        ;;
                    esac
                ;;
            esac
            ;;
            *) echo "${PARAM[$((${#PARAM[@]}-1))]}"
            ;;
        esac
    fi
    case "${TEMPORAR:$((${#TEMPORAR}-1)):1}" in
        /) TARGETDIR=$(${REALPATH} -m -P "${TEMPORAR## }")
            log info "targets() Export pages with a original names into –> ${TARGETDIR}"
            [ ! -d "${TARGETDIR}" ] && mkdir -p "${TARGETDIR}"
        ;;
        *) if [[ "${TEMPORAR}" =~ "/" ]] ; then
                #/ obsahuje cestu
                local TEMPORARY=$(${REALPATH} -m -P "${TEMPORAR## }")
                TARGETDIR="${TEMPORARY%/*}"
                TARGETSAMPLE="${TEMPORARY##*/}"
                log info "targets() Export pages a named by sample ${TARGETSAMPLE} –> ${TARGETDIR}"
                [ ! -d "${TARGETDIR}" ] && mkdir -p "${TARGETDIR}"
            else
                #/ jde o vzorek
                TARGETDIR="$(pwd)"
                TARGETSAMPLE="${TEMPORAR## }"
                log info "targets() Export pages a named by sample ${TARGETSAMPLE} into actual directory"
            fi
        ;;
    esac
    echo "RANGE ${RANGE}"
    echo "INTO ${INTO}"
    echo "CUT ${CUT}"
    echo "SCALE ${SCALE}"
    echo "TARGETDIR ${TARGETDIR}"
    echo "TARGETSAMPLE ${TARGETSAMPLE}"
    echo "TEMPORAR ${TEMPORAR}"
    echo "Můžeme přikročit k akci ${FILETYPE}"
    echo "DPI ${DPI}"
    echo "ALG ${ALG[@]}"
    # exit 33
    case ${FILETYPE} in
        pbm|pgm|ppm) log info "fromcontainer() Export from ${FILETYPE^^}"
            if [ -n "${RANGE}" ] && [ ! ${RANGE} -eq 1 ] ; then
                echo "Formát ${FILETYPE} podporuje pouze jednu stránku" >> /dev/stderr
                return 1
            fi
            local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .pam)
            #/ Nejdřív je třeba obrázek nakopírovat do pracovního prostoru
            cp "${FILE}" "${TEMPFILE}"
            #/ Pak je třeba vyseparovat výchozí masku
            if [ ${#ALG[@]} -gt 1 ] ; then
                cp "${TEMPFILE}" "${TEMPFILE}.in"
                COUNT=1
                for i in ${ALG[@]} ; do
                    separatemask "${TEMPFILE}.in" "${TEMPFILE}.${COUNT}" "$i"
                    while [ ! -f "${TEMPFILE}.${COUNT}" ] ; do
                        sleep 0.1
                    done
                    ${PAMARITH} -divide "${TEMPFILE}" "${TEMPFILE}.${COUNT}" > "${TEMPFILE}.in"
                    COUNT=$((COUNT + 1))
                done
                echo "Je třeba složit ${COUNT} masek"
                case ${COUNT} in
                    1) #/ Pouze jedna maska 
                        echo "Došlo k nějaké chybě při zpracování cyklu!" >> /dev/stderr
                        return 1 
                    ;;
                    *) #/ Více masek
                        #cp "${TEMPFILE}.1" "${TEMPFILE}.in"
                        while [ ! ${COUNT} -eq 2 ] ; do
                            log info "Slučuji ${TEMPFILE}.$((COUNT - 1)) ${TEMPFILE}.$((COUNT - 2))"
                            ${PAMARITH} -and "${TEMPFILE}.$((COUNT - 1))" "${TEMPFILE}.$((COUNT - 2))" > "${TEMPFILE/.pam/.fore}"
                            COUNT=$((COUNT - 1))
                        done
                    ;;
                esac
                log ok "Masky sloučeny"
            else
                separatemask "${TEMPFILE}" "${TEMPFILE/.pam/.fore}" "${ALG}"
            fi
            if [ -n "${CUT}" ] ; then
                #/ Na masku se aplikují vybrané rámečky
                local BOX=( "${CUT//;/ }" )
                echo "${CUT}" >> /dev/stderr
                for i in ${BOX[@]} ; do
                    imgcut "${i}" "${TEMPFILE}"
                done
            fi
            #exit 33
            if [ -n "${TARGETSAMPLE}" ] ; then
                # jedu podle vzorku
                local TARGET="${TARGETDIR}/${TARGETSAMPLE}.${INTO}"
            else
                local TARGET="${TARGETDIR}/${FILE##*/}.${INTO}"
            fi
            case "${INTO}" in
                djvu) #/ V tomto bodě se v případě DjVu provede konverze
                    encodefile ${TEMPFILE} "${TARGET}"
                    # na anglicke texty dává lepší výsledky cuneiform
                ;;
                mask|pbm) #/ Výsledkem je soubor s cílovým názvem, ale příponou pbm
                    if [ -f "${TEMPFILE/.pam/.text}" ] ; then
                        cp "${TEMPFILE/.pam/.text}" "${TARGET/.mask/.pbm}"
                    else
                        cp "${TEMPFILE/.pam/.fore}" "${TARGET/.mask/.pbm}"
                    fi
                ;;
                back) #/ Výsledkem je PNG soubor pozadí s cílovým názvem, a příponou back.png
                    if [ -f "${TEMPFILE/.pam/.text}" ] ; then
                        ${PAMTOPNG} -alpha="${TEMPFILE/.pam/.text}" "${TEMPFILE}" > "${TARGET}.png"
                    else
                        ${PAMTOPNG} -alpha="${TEMPFILE/.pam/.fore}" "${TEMPFILE}" > "${TARGET}.png"
                    fi
                ;;
                png) #/ konvertuji pozadí
                    if [ -n "${SCALE}" ] ; then
                        ${PAMTOPNM} ${TEMPFILE} | ${PAMSCALE} ${SCALE} | ${PAMTOPNG} > "${TARGET}"
                    else
                        ${PAMTOPNG} ${TEMPFILE} > "${TARGET}"
                    fi
                ;;
                jpg|jpeg)
                    if [ -n "${SCALE}" ] ; then
                        ${PAMTOPNM} ${TEMPFILE} | ${PAMSCALE} ${SCALE} | ${PNMTOJPEG} > "${TARGET}"
                    else
                        ${PNMTOJPEG} ${TEMPFILE} > "${TARGET}"
                    fi
                ;;
                jp2)
                    if [ -n "${SCALE}" ] ; then
                        ${PAMTOPNM} ${TEMPFILE} | ${PAMSCALE} ${SCALE} | ${PAMTOJPEG2K} > "${TARGET}"
                    else
                        ${PAMTOJPEG2K} ${TEMPFILE} > "${TARGET}"
                    fi
                ;;
                *) log info "Konverze do výchozího formátu ${FILETYPE} není nutná"
                    cp "${TEMPFILE}" "${TARGET%.}.pam"
                ;;
            esac
        ;;
        jpeg) log info "fromcontainer() Export from JPEG into ${INTO}"
            #exit 33
            local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .pam)
            if [ -n "${TARGETSAMPLE}" ] ; then
                # jedu podle vzorku
                local TARGET="${TARGETDIR}/${TARGETSAMPLE}.${INTO}"
            else
                local TARGET="${TARGETDIR}/${FILE##*/}.${INTO}"
            fi
            case "${INTO}" in
                djvu) #/ V tomto bodě se v případě DjVu provede konverze
                    encodefile ${TEMPFILE} "${TARGET}"
                    # na anglicke texty dává lepší výsledky cuneiform
                ;;
                mask|pbm) #/ Výsledkem je soubor s cílovým názvem, ale příponou pbm
                    $0 ${FILE} export 1 mask ${TEMPFILE}
                    #if [ -f "${TEMPFILE/.pam/.text}" ] ; then
                    #    cp "${TEMPFILE/.pam/.text}" "${TARGET/.mask/.pbm}"
                    #else
                    #    cp "${TEMPFILE/.pam/.fore}" "${TARGET/.mask/.pbm}"
                    #fi
                ;;
                back) #/ Výsledkem je PNG soubor pozadí s cílovým názvem, a příponou back.png
                    $0 ${FILE} export 1 back ${TEMPFILE}
                ;;
                pnm) echo "POZOR! Při konverzi do PNM formátu dojde ke ztrátě meta informací a tím i k anonymizaci obrázku" >> /dev/stderr
                    ${JPEGTOPNM} -dct float -dumpexif -exif="${TEMPFILE/.pam/.exif}" -repair "${FILE}" > ${TEMPFILE}
                    if [ -n "${SCALE}" ] ; then
                        ${PAMTOPNM} ${TEMPFILE} | ${PAMSCALE} ${SCALE} > "${TARGET}"
                    else
                        cp ${TEMPFILE} "${TARGET}"
                    fi
                ;;
                png) log info "export do PNG"
                    if [ -n "${SCALE}" ] ; then
                        $0 ${FILE} export 1 png ${TEMPFILE}
                    else
                        $0 ${FILE} export 1 png ${TEMPFILE}
                    fi
                ;;
                jpg|jpeg) 
                    if [ -n "${SCALE}" ] ; then
                        $0 ${FILE} export 1 pnm ${TEMPFILE}
                        ${PAMTOPNM} ${TEMPFILE} | ${PAMSCALE} ${SCALE} | ${PNMTOJPEG} > "${TARGET}"
                    else
                        log info "export do výchozího formátu ${FILETYPE} má smysl pouze při přeškálování"
                    fi
                ;;
                jp2)
                    if [ -n "${SCALE}" ] ; then
                        ${PAMTOPNM} ${TEMPFILE} | ${PAMSCALE} ${SCALE} | ${PAMTOJPEG2K} > "${TARGET}"
                    else
                        ${PAMTOJPEG2K} ${TEMPFILE} > "${TARGET}"
                    fi
                ;;
                *) log info "Konverze do výchozího formátu ${FILETYPE} má smysl pouze při škálování"
                    return 1
                ;;
            esac
        ;;
        png)   log info "fromcontainer() Export from PNG"
            case "${INTO}" in
                images) echo "Parametr použitelný pouze u PDF - exportují se obrázky místo stránek" >> /dev/stderr
                    return 1
                ;;
                ocr) echo "TODO Aplikace OCR na konverovaný originální soubor" >> /dev/stderr
                ;;
                txt|text) echo "Parametr použitelný pouze u PDF - exportují se text místo stránky" >> /dev/stderr
                    return 1
                ;;
                *)
                    log info "fromcontainer() Original file is exported from container without conversion"
                    local PAGES=($(range "${RANGE}"))
                    local LISTPAGES=($(listpng "${FILE}"))
                    #/ echo "${LISTPAGES[-1]}"
                    #/ echo "${PAGES[@]}"
                    for i in ${PAGES[@]} ; do
                        local PAGE="${LISTPAGES[$((i-1))]}"
                        case "${INTO}" in
                            png|orig*)
                                if [ -n "${TARGETSAMPLE}" ] ; then
                                    # jedu podle vzorku
                                    local TEMPORAR=$(printf "${TARGETSAMPLE}" $i)
                                    local TARGET="${TARGETDIR}/${TEMPORAR// /0}.png"
                                else
                                    local TARGET="${TARGETDIR}/${PAGE}.png"
                                fi
                                local TEMPFILE=$(tempfile)
                                if [ -n "${SCALE}" ] ; then
                                    local FORSCALE=$(tempfile)
                                    $(itempng "${FILE}" "${PAGE}" > "${FORSCALE}")
                                    pamscale ${SCALE} ${FORSCALE} > ${TEMPFILE}
                                    rm ${FORSCALE}
                                else
                                    $(itempng "${FILE}" "${PAGE}" > "${TEMPFILE}")
                                fi
                                convertovergimp png "${TEMPFILE}"
                                mv -i "${TEMPFILE}.png" "${TARGET}"
                                [ -f "${TEMPFILE}" ] && rm "${TEMPFILE}"
                            ;;
                                pnm|pam)
                                    if [ -n "${TARGETSAMPLE}" ] ; then
                                        # jedu podle vzorku
                                        local TEMPORAR=$(printf "${TARGETSAMPLE}" $i)
                                        local TARGET="${TARGETDIR}/${TEMPORAR// /0}.${INTO}"
                                    else
                                        local TARGET="${TARGETDIR}/${PAGE}.${INTO}"
                                    fi
                                    local TEMPFILE=$(tempfile)
                                    if [ -n "${SCALE}" ] ; then
                                        local FORSCALE=$(tempfile)
                                        $(itempng "${FILE}" "${PAGE}" > "${FORSCALE}")
                                        pamscale ${SCALE} ${FORSCALE} > ${TEMPFILE}
                                        rm ${FORSCALE}
                                    else
                                        $(itempng "${FILE}" "${PAGE}" > "${TEMPFILE}")
                                    fi
                                    case "${INTO}" in
                                        pnm|pam)
                                            mv -i "${TEMPFILE}" "${TARGET}"
                                        ;;
                                        *) echo "Unsupported format –> ${INTO}" >> /dev/stderr
                                            return 1
                                        ;;
                                    esac
                                    [ -f "${TEMPFILE}" ] && rm "${TEMPFILE}"
                                ;;
                                *) echo "U XCF souborů je třeba uvést typ cílového souboru" >> /dev/stderr
                                    return 1
                                ;;
                            esac
                        done
                ;;
            esac
        ;;
        pdf)  log info "fromcontainer() Export from PDF"
            case "${INTO}" in
                images) log info "exportuji pouze obrázky z ředaného rozsahu"
                ;;
                ocr) log info "exportuji stránku jako obrázek a aplikuji OCR"
                ;;
                txt|text) log info "exportuji stránku jako text"
                ;;
                pdf) 
                    if [ -n "${TARGETSAMPLE}" ] ; then
                        # jedu podle vzorku
                        local TEMPORAR=$(printf "${TARGETSAMPLE}" $i)
                        local TARGET="${TARGETDIR}/${TARGETSAMPLE}_${RANGE}.pdf"
                    else
                        local TARGET="${TARGETDIR}/${FILE##*/}"
                        pdftopdf "${FILE}" "${TARGET/.pdf/${RANGE}}.pdf"
                    fi
                ;;
                *) if [ "${INTO}" == "" ] ; then
                        echo "Neuvedený formát. " >> /dev/stderr
                        if [ -n "${TARGETSAMPLE}" ] ; then
                            # jedu podle vzorku
                            local TEMPORAR=$(printf "${TARGETSAMPLE}" $i)
                            local TARGET="${TARGETDIR}/${TEMPORAR// /0}.${INTO}"
                        else
                            local TARGET="${TARGETDIR}/${FILE##*/}"
                            pdftopdf "${FILE}" "${TARGET/.pdf/_${RANGE}}.pdf"
                        fi
                    else
                        echo "Unsupported format –> ${INTO}" >> /dev/stderr
                        return 1
                    fi
                ;;
            esac
        ;;
        gimp|xcf) log info "fromcontainer() Export from XCF"
            case "${INTO}" in
                images) echo "Parametr použitelný pouze u PDF - exportují se obrázky místo stránek" >> /dev/stderr
                    return 1
                ;;
                ocr) echo "TODO Aplikace OCR na konverovaný originální soubor" >> /dev/stderr
                ;;
                txt|text) echo "Parametr použitelný pouze u PDF - exportují se text místo stránky" >> /dev/stderr
                    return 1
                ;;
                *)
                    log info "fromcontainer() Original file is exported from container without conversion"
                    local PAGES=($(range "${RANGE}"))
                    local LISTPAGES=($(listxcf "${FILE}"))
                    #/ echo "${LISTPAGES[-1]}"
                    #/ echo "${PAGES[@]}"
                    for i in ${PAGES[@]} ; do
                        local PAGE="${LISTPAGES[$((i-1))]}"
                        case "${INTO}" in
                            xcf|orig*)
                                if [ -n "${TARGETSAMPLE}" ] ; then
                                    # jedu podle vzorku
                                    local TEMPORAR=$(printf "${TARGETSAMPLE}" $i)
                                    local TARGET="${TARGETDIR}/${TEMPORAR// /0}.xcf"
                                else
                                    local TARGET="${TARGETDIR}/${PAGE}.xcf"
                                fi
                                local TEMPFILE=$(tempfile)
                                if [ -n "${SCALE}" ] ; then
                                    local FORSCALE=$(tempfile)
                                    $(itemxcf "${FILE}" "${PAGE}" > "${FORSCALE}")
                                    pamscale ${SCALE} ${FORSCALE} > ${TEMPFILE}
                                    rm ${FORSCALE}
                                else
                                    $(itemxcf "${FILE}" "${PAGE}" > "${TEMPFILE}")
                                fi
                                convertovergimp xcf "${TEMPFILE}"
                                mv -i "${TEMPFILE}.xcf" "${TARGET}"
                                [ -f "${TEMPFILE}" ] && rm "${TEMPFILE}"
                            ;;
                                pnm|pam)
                                    if [ -n "${TARGETSAMPLE}" ] ; then
                                        # jedu podle vzorku
                                        local TEMPORAR=$(printf "${TARGETSAMPLE}" $i)
                                        local TARGET="${TARGETDIR}/${TEMPORAR// /0}.${INTO}"
                                    else
                                        local TARGET="${TARGETDIR}/${PAGE}.${INTO}"
                                    fi
                                    local TEMPFILE=$(tempfile)
                                    if [ -n "${SCALE}" ] ; then
                                        local FORSCALE=$(tempfile)
                                        $(itemxcf "${FILE}" "${PAGE}" > "${FORSCALE}")
                                        pamscale ${SCALE} ${FORSCALE} > ${TEMPFILE}
                                        rm ${FORSCALE}
                                    else
                                        $(itemxcf "${FILE}" "${PAGE}" > "${TEMPFILE}")
                                    fi
                                    case "${INTO}" in
                                        pnm|pam)
                                            mv -i "${TEMPFILE}" "${TARGET}"
                                        ;;
                                        *) echo "Unsupported format –> ${INTO}" >> /dev/stderr
                                            return 1
                                        ;;
                                    esac
                                    [ -f "${TEMPFILE}" ] && rm "${TEMPFILE}"
                                ;;
                                *) echo "U XCF souborů je třeba uvést typ cílového souboru" >> /dev/stderr
                                    return 1
                                ;;
                            esac
                        done
                ;;
            esac
        ;;
        zip|tar) log info "fromcontainer() Export from archive"
            case "${INTO}" in
                images) echo "Parametr použitelný pouze u PDF - exportují se obrázky místo stránek" >> /dev/stderr
                    return 1
                ;;
                ocr) echo "TODO Aplikace OCR na konverovaný originální soubor" >> /dev/stderr
                ;;
                txt|text) echo "Parametr použitelný pouze u PDF - exportují se text místo stránky" >> /dev/stderr
                    return 1
                ;;
                *) local PAGES=($(range "${RANGE}"))
                    local LISTPAGES=($(listzip "${FILE}"))
                    #echo "${LISTPAGES[-1]}"
                    #echo "${PAGES[@]}"
                    for i in ${PAGES[@]} ; do
                        local PAGE="${LISTPAGES[$((i-1))]}"
                        case "${INTO}" in
                            pnm|pam|png|jpg|tiff|jp2) local SUFFIX="${PAGE##*.}"
                                case ${SUFFIX} in
                                    jp2) $(itemzip "${FILE}" "${PAGE}" |\
                                        ${JPEG2KTOPAM} > "${TEMPFILE}")
                                    ;;
                                    jpg) $(itemzip "${FILE}" "${PAGE}" |\
                                        ${JPEGTOPNM} > "${TEMPFILE}")
                                    ;;
                                    png) $(itemzip "${FILE}" "${PAGE}" |\
                                        ${PNGTOPNM} > "${TEMPFILE}")
                                    ;;
                                    tiff) $(itemzip "${FILE}" "${PAGE}" |\
                                        ${TIFFTOPNM} > "${TEMPFILE}")
                                    ;;
                                    *) echo "Nepodporovaný formát ${SUFFIX}"
                                        return 1
                                    ;;
                                esac
                                if [ -n "${TARGETSAMPLE}" ] ; then
                                    # jedu podle vzorku
                                    local TEMPORAR=$(printf "${TARGETSAMPLE}" $i)
                                    local TARGET="${TARGETDIR}/${TEMPORAR// /0}.${INTO}"
                                else
                                    local TEMPORAR="${PAGE#*/}"
                                    local TARGET="${TARGETDIR}/${TEMPORAR%.*}.${INTO}"
                                fi
                                case ${INTO} in
                                    jp2) if [ -n "${SCALE}" ] ; then
                                            $(${PAMTOPNM} ${TEMPFILE} |\
                                                ${PAMSCALE} ${SCALE} |\
                                                ${PAMTOJPEG2K} > "${TARGET}")
                                        else
                                            $(${PAMTOPNM} ${TEMPFILE} |\
                                                ${PAMTOJPEG2K} > "${TARGET}")
                                        fi
                                    ;;
                                    jpg)if [ -n "${SCALE}" ] ; then
                                            $(${PAMTOPNM} ${TEMPFILE} |\
                                                ${PAMSCALE} ${SCALE} |\
                                                ${PNMTOJPEG} > "${TARGET}")
                                        else
                                            $(${PAMTOPNM} ${TEMPFILE} |\
                                                ${PNMTOJPEG} > "${TARGET}")
                                        fi
                                    ;;
                                    tiff) if [ -n "${SCALE}" ] ; then
                                            $(${PAMTOPNM} ${TEMPFILE} |\
                                                ${PAMSCALE} ${SCALE} |\
                                                ${PAMTOTIFF} > "${TARGET}")
                                        else
                                            $(${PAMTOPNM} ${TEMPFILE} |\
                                                ${PAMTOTIFF} > "${TARGET}")
                                        fi
                                    ;;
                                    png) if [ -n "${SCALE}" ] ; then
                                            $(${PAMTOPNM} ${TEMPFILE} |\
                                                ${PAMSCALE} ${SCALE} |\
                                                ${PAMTOPNG} > "${TARGET}")
                                        else
                                            $(${PAMTOPNM} ${TEMPFILE} |\
                                                ${PAMTOPNG} > "${TARGET}")
                                        fi
                                    ;;
                                    pnm|pam) if [ -n "${SCALE}" ] ; then
                                            $(${PAMTOPNM} ${TEMPFILE} |\
                                                ${PAMSCALE} ${SCALE} > "${TARGET}")
                                        else
                                            $(${PAMTOPNM} ${TEMPFILE} > "${TARGET}")
                                        fi
                                    ;;
                                esac
                                echo "Page $i saved as ${TARGET}" >> /dev/stderr
                                ;;
                            *) local SUFFIX="${PAGE##*.}"
                                if [ -n "${TARGETSAMPLE}" ] ; then
                                    # jedu podle vzorku
                                    local TEMPORAR=$(printf "${TARGETSAMPLE}" $i)
                                    local TARGET="${TARGETDIR}/${TEMPORAR// /0}.${SUFFIX}"
                                else
                                    local TARGET="${TARGETDIR}/${PAGE#*/}"
                                fi
                                if [ -n "${SCALE}" ] ; then
                                    anone "Při přeškálování do původního formátu dojde k degradaci kvality obrazu mám pokračovat?"
                                    [ $? -eq 1 ] && return 1
                                    case ${SUFFIX} in
                                        jp2) $(itemzip "${FILE}" "${PAGE}" |\
                                                ${JPEG2KTOPAM} |\
                                                ${PAMSCALE} ${SCALE} |\
                                            ${PAMTOJPEG2K} > "${TARGET}")
                                        ;;
                                        jpg) $(itemzip "${FILE}" "${PAGE}" |\
                                            ${JPEGTOPNM} |\
                                            ${PAMSCALE} ${SCALE} |\
                                            ${PNMTOJPEG} > "${TARGET}")
                                        ;;
                                        png) $(itemzip "${FILE}" "${PAGE}" |\
                                            ${PNGTOPNM} |\
                                            ${PAMSCALE} ${SCALE} |\
                                            ${PAMTOPNG} > "${TARGET}")
                                        ;;
                                        tiff) $(itemzip "${FILE}" "${PAGE}" |\
                                            ${TIFFTOPNM} |\
                                            ${PAMSCALE} ${SCALE} |\
                                            ${PAMTOTIFF} > "${TARGET}")
                                        ;;
                                    esac
                            else
                                log info "fromcontainer() Original file ${PAGE} is exported from container without conversion"
                                $(itemzip "${FILE}" "${PAGE}" > "${TARGET}")
                            fi
                            echo "Page $i saved as ${TARGET}" >> /dev/stderr
                            ;;
                        esac
                    done
                ;;
            esac
        ;;
    esac
    return 0
}

# ### <span id="exportimg">exportimg()</span> ([top](#FUNCTIONS))
# Funkce exportuje ze souboru stránky jako obrázky.
# Vstupními parametry jsou globální proměnné:
# * FILE - Soubor ze kterého se stránka exportuje.
# * CHARSTRING - Proměnná, která obsahuje další parametry:
# ** Rozsah exportovaných stránek. Není-li uveden, budou exportovány
#    všechny stránky ze souboru.
# ** Formát cílového souboru
# ** Velikost cílového souboru, nastavená buď formou XxY, nebo procetuálně Z%
#
# Místo parametrů může být také předána také cesta k souboru, ve kterém
# mohou být parametry nastaveny specificky pro každou stránku (rozsah)
# zvlášť. Tento soubor __musí__ mít příponu `.list`
#
# Za parametry, nebo cestou k souboru s příponou `.list` může následovat
# cílový adresář, resp. vzor pro pojmenování stránek
#
#     example/example
#
# Při exportu jpeg souborů z archívu uloží do podadresáře example
# exportované stránky pod názvy: example_00001.jpg, example_00002.jpg, …
#
# #### export
# Operace export slouží k extrakci stránek (vrstev)
# z formátů, které mohou obsahovat více stránek, případně
# k jejich transormaci na jiný rozměr či konverzi do
# jiného formát. Viz příklad:
#
#      djvutool soubor.jpg export 1 jpg 30%
#
# Vygeneruje JPEG obrázek s názvem soubor_30%.jpg jehož
# obsahem bude původní obrázek, zmenšený na 30% velikost
#
# U kontejnerů, které mají uloženy v sobě obrázky,
# lze provést export pouze s uvedením rozsahu. Cílové
# soubory se pak budou jmenovat stejně, jako v archívu:
#
# djvutool soubor.zip export 2-7
# 
# U formátů s podporou více stránek, které mají
# uložen název vrstvy či stránky, je vhodné uvést
# cílový formát souboru. Jméno cílového souboru pak
# bude stejné jako název příslušné vrstvy či stránky:
# 
# djvutool soubor.xcf export 2-7
#
# V případě PDF souborů, které mohou obsahovat mix textu
# a obrázků volbou přípony sdělíte, že chcete vyexportovat
# pouze obrázky:
#
# djvutool soubor.pdf export 1 jpg
#
# V tomto případě se budou jmenovat soubory bůhví jak.
# Je tedy v tomto případě žádoucí uvést případně jméno
# a případně i výchozí cestu:
#
# djvutool soubor.pdf export 1 jpg 30% example/
#
# V tomto případě se obrázky nasypou do adresáře example.
# Pokud neexistuje, tak se založí.
#
#  djvutool soubor.pdf export 1 jpg 30% example
#
# Pokud nekončí řádek lomítkem, použije se celý zbytek
# řetězce jako výchozí vzor pro pojmenování stránky
# (obrázku) cílový soubor se tedy bude v tomto případě
# jmenovat example_30%_001.jpg
exportimg() {
    log goto "exportimg() ${FILE} –> ${CHARSTRING}"
    if [[ "${CHARSTRING}" =~ "?" ]] ||\
        [[ "${CHARSTRING}" =~ "-h" ]] ||\
        [[ "${CHARSTRING}" =~ "help" ]] ; then
        help bitmap-export
    elif [[ "${CHARSTRING}" =~ ".list" ]] ; then
        local SOURCE=$(${REALPATH} -m -P "${CHARSTRING%.list*}.list" 2>/dev/null)
        if [ -f "${SOURCE}" ] ; then
            log info "exportimg() Read params from –> ${SOURCE}"
            local TARGET="${CHARSTRING#*.list}"
            while read line ; do
                CHARSTRING="$line ${TARGET}"
                fromcontainer "${FILE}" "${CHARSTRING}"
            done < "${SOURCE}"
        else
            return 1
        fi
    else
        fromcontainer "${FILE}" "${CHARSTRING}"
    fi
    return $?
}

# ### <span id="viewimg">viewimg()</span> ([top](#FUNCTIONS))
#
viewimg() {
    log info "viewimg() open –> ${FILE}"
    case ${FILETYPE} in
        pnm|ppm|pgm|pbm|pam|\
        png|jpg|jpeg|bmp|gif|tiff) if [ -n "${FEH}" ] ; then
                local TEMPORARY=($(parsecut $(xrandr | grep '[ ]connected' | head -1 | cut -d' ' -f3)))
                echo "${TEMPORARY[@]}" >> /dev/stderr
                local W=$(( ${TEMPORARY[0]} / 2 ))
                local H=$(( ${TEMPORARY[1]} / 2 ))
                local X=50
                local Y=50
                echo "${W}x${H}+${X}+${Y}" >> /dev/stderr
                ${FEH} --scale-down --auto-zoom --geometry "${W}x${H}+${X}+${Y}" "${FILE}"
            else
                ${GEEQIE} "${FILE}"
            fi
        ;;
        plain|jpeg-2000) local TEMPFILE="${TEMPDIR}/${FILE##*/}"
            ${JPEG2KTOPAM} ${FILE} > ${TEMPFILE}
            #opj_decompress -i ${FILE} -o ${TEMPFILE} -l 1
            ls -alh ${TEMPFILE}
            exiftool ${TEMPFILE}
            $0 ${TEMPFILE} view
        ;;
#        gimp|pdf|xcf|eps|psd|tga|ps)
#            ${GIMP} "${FILE}"
#        ;;
        gimp) isrange ${CHARSTRING}
            if [ $? -eq 0 ] ; then
                local PAGES=($(range "${CHARSTRING}"))
                local LISTPAGES=($(listxcf "${FILE}"))
                #echo "${LISTPAGES[-1]}"
                #echo "${PAGES[@]}"
                for i in ${PAGES[0]} ; do
                    local PAGE="${LISTPAGES[$((i-1))]}"
                    $(itemxcf "${FILE}" "${PAGE}" > "${TEMPDIR}/${PAGE##*/}.pam")
#                    exit 33
                    $0 view "${TEMPDIR}/${PAGE##*/}.pam"
                done
            else
                echo "V případě xcf souboru musí být uvedeno číslo stránky" >> /dev/stderr
                return 1
            fi
        ;;
        zip) isrange ${CHARSTRING}
            if [ $? -eq 0 ] ; then
                local PAGES=($(range "${CHARSTRING}"))
                local LISTPAGES=($(listzip "${FILE}"))
                #echo "${LISTPAGES[-1]}"
                #echo "${PAGES[@]}"
                for i in ${PAGES[0]} ; do
                    local PAGE="${LISTPAGES[$((i-1))]}"
                    $(itemzip "${FILE}" "${PAGE}" > "${TEMPDIR}/${PAGE##*/}")
                    $0 view "${TEMPDIR}/${PAGE##*/}"
                done
            else
                echo "V případě kontejneru musí být uvedeno číslo stránky" >> /dev/stderr
                return 1
            fi
        ;;
        *) echo "Nepodporovaný formát ${FILETYPE}" >> /dev/stderr
            return 1
        ;;
    esac
}

# ### <span id="infoimg">infoimg()</span> ([top](#FUNCTIONS))
# Funkce vypisuje info o bitmapových souborech a případně vicestránkových
# formátů i jejich stránkách.
# Vstupními parametry jsou globální proměnné:
# * FILE - Soubor ze kterého se stránka exportuje.
# * CHARSTRING - Proměnná, která obsahuje další parametry:
# ** typ zobrazované informace
# ** a případně číslo konkrétní stránky (vrstvy)
infoimg() {
    log goto "infoimg() ${FILE} –> ${CHARSTRING}"
    if [[ "${CHARSTRING}" =~ "?" ]] ||\
        [[ "${CHARSTRING}" =~ "-h" ]] ||\
        [[ "${CHARSTRING}" =~ "help" ]] ; then
        help bitmap-info
    else
        case ${FILETYPE} in
            gif) # GIF je grafický formát, s bezztrátovou kompresí, který
                # má podporu pro animace.
                # Je omezený především v tom, že má k dispozici pouze 256
                # barev. Za určitých okolností může fungovat i jako
                # kontejner pro více stránkové dokumenty (co vrstva, to stránka).
                #
                # Výhodou GIF formátu oproti MNG či (AP)NG je především
                # to, že má širokou podporu u webových prohlížečů. Proto
                # se vyžívá především pro náhledy vícestránkových dokumentů.
                # Kdy se náhledy vybraných stránek, uložené jako jednotlivé
                # snímky přehrávají v nekonečné smyčce.
                # Počet snímků (stránek) udává exif tag 'Animation frames'
                #
                # .gif
                case ${CHARSTRING} in
                    meta*) ${EXIFTOOL} "${FILE}"
                    ;;
                    pages) echo "Zjistit počet vrstev"
                    ;;
                    *) local INFO=($(cat "${FILE}"|infoitem))
                        echo "${INFO[@]}"
                    ;;
                esac
            ;;
            jpg|jpeg) # JPEG je grafický formát se ztrátovou kompresí, který
                # podporuje pouze jednu vrstvu
                #
                # .jpg, .jpeg, .jpe, .jif, .jfif, .jfi
                case ${CHARSTRING} in
                    meta*) ${EXIFTOOL} "${FILE}"
                    ;;
                    pages) echo "1"
                    ;;
                    *) local INFO=($(cat "${FILE}"|infoitem))
                        echo "${INFO[@]}"
                    ;;
                esac
            ;;
            jpeg-2000) # JPEG 2000 je grafický formát, který pracuje se
                # ztrátovou, ale i bezeztrátovou wavelet kompresí. To je
                # klíčovým rozdílem oproti DjVu, protože u DjVu z principu
                # vždy dojde k částečné ztrátě grafické informace.
                # Oproti bezeztrátovému PNG má lepší kompresní poměr. A
                # při ztrátové kompresi je výsledek po dekompresi vždy
                # lepší než u JPEG formátu.
                # Nevýhodou je zdlouhavá dekomprese a tím i pomalejší
                # zobrazování v prohlížeči. Proto se využívá především
                # pro archivaci původního skenu.
                #
                # Nepodporuje více vrstev! Proto se naskenované soubory
                # obvykle zabalí do `.zip` kontejneru
                #
                # .jp2, .j2k, .jpf, .jpx, .jpm, .mj2
                case ${CHARSTRING} in
                    meta*) ${EXIFTOOL} "${FILE}"
                    ;;
                    pages) echo "1"
                    ;;
                    *) local INFO=($(cat "${FILE}"|infoitem))
                        echo "${INFO[@]}"
                    ;;
                esac
            ;;
            pnm|pgm|pbm|ppm) # Formát se kterým přišel projekt Netpbm.
                # Nepodporuje více vrstev!!!
                # PNM formát (portable anymap) zastupuje následující formáty:
                # * PBM - portable bitmap (černobílé obrázky)
                #   V hlavičce má P1 (P4 - binární formát)
                # * PGM - portable graymap (obrázky ve stupních šedi)
                #   V hlavičce má P2 (P5 - binární formát)
                # * PPM - portable pixmap (RGB obrázky)
                #   V hlavičce má P3 (P6 - binární formát)
                # * PAM - portable anymap, zastupuje podobně jako PNM
                #   všechny formáty a v má hlavičce P7. Je schopen zachytit
                #   barvy stejně jako CMYK
                #
                # Rozdíly jsou především v popdpoře bitové hloubky barev:
                # 48-bitů podporuje pouze PPM (rgb48be)
                # 32-bitů podporuje plain PNM a plain PAM - binární verze nikoliv!!!
                # 24-bitová podopora je u všech formátů
                # 16-bitů PGM a PAM bez průhlednosti (grap16be)
                #
                # https://en.wikipedia.org/wiki/Netpbm_format
                case ${CHARSTRING} in
                    meta*) ${EXIFTOOL} "${FILE}"
                    ;;
                    pages) echo "1"
                    ;;
                    *) local INFO=($(cat "${FILE}"|infoitem))
                        echo "${INFO[@]}"
                    ;;
                esac
            ;;
            mng) # MNG je formát pro animace, založený na PNG, podobně
                # jako (A)PNG. Není moc rozšířený.
                # Počet vrstev udává v exifu 'Animation frames'
                #
                # .mng
                case ${CHARSTRING} in
                    meta*) ${EXIFTOOL} "${FILE}"
                    ;;
                    pages) local SUMPAGES=$(${IDENTIFY} "${FILE}" | wc -l)
                        echo "${SUMPAGES}"
                    ;;
                    *) local INFO=($(cat "${FILE}"|infoitem))
                        local SUMPAGES=$(${IDENTIFY} "${FILE}" | wc -l)
                        echo "${INFO[@]} ${SUMPAGES}"
                    ;;
                esac
            ;;
            png) # PNG je formát, u kterého se původně vůbec nepočítalo,
                # že by mohl mít více než jednu vrstvu. Protože ale formát
                # GIF, který animace podporuje, má svá omezení (nepodporuje
                # průhlednost a má k dispozici pouze 256 barev), vzniklo
                # jako alternativa APNG – což je svým způsobem video
                # kontejner, který obsahuje řadu po sobě jdoucích PNG obrázků.
                #
                # Oproti podobnému MNG formátu však umožňuje zpětnou
                # kompatibilitu, kdy se v prohlížečích co animace nepodporují,
                # zobrazuje pouze první snímek. Soubory mají stejnou příponu
                # .png, jako klasické PNG
                #
                # Počet vrstev udává exif tag 'Animation frames'
                #
                # .png
                case ${CHARSTRING} in
                    meta*) ${EXIFTOOL} "${FILE}"
                    ;;
                    pages) echo "Zjistit počet vrstev"
                    ;;
                    *) local INFO=($(cat "${FILE}"|infoitem))
                        echo "${INFO[@]}"
                    ;;
                esac
            ;;
            gimp|xcf) # Nativní formát Gimpu může mít více vrstev
                case ${CHARSTRING} in
                    meta*)  ${EXIFTOOL} "${FILE}"
                    ;;
                    pages\ +([0-9])|pages\ all|pages)
                        local TEMPORAR=(${CHARSTRING})
                        case ${TEMPORAR[1]} in
                            all) ${XCFINFO} -u "${FILE}"
                            ;;
                            +([0-9])) ${XCFINFO} -u "${FILE}" | \
                                grep -m ${TEMPORAR[1]} '^+.*RGB.*Normal' | \
                                tail -1
                            ;;
                            *) local SUMPAGES=$(${XCFINFO} "${FILE}" | wc -l)
                                echo "${SUMPAGES}"
                            ;;
                        esac
                    ;;
                    *) local INFO=($(cat "${FILE}"|infoitem))
                        local SUMPAGES=$(${XCFINFO} "${FILE}" | wc -l)
                        echo "${INFO[@]} ${SUMPAGES}"
                    ;;
                esac
            ;;
            tiff) # Formát TIFF může mít více stránek
                case ${CHARSTRING} in
                    meta*) ${EXIFTOOL} "${FILE}"
                    ;;
                    pages) local SUMPAGES=$(${TIFFINFO} "${FILE}" | grep "TIFF Directory" | wc -l)
                        echo "${SUMPAGES}"
                    ;;
                    *) local INFO=($(cat "${FILE}"|infoitem))
                        local SUMPAGES=$(${TIFFINFO} "${FILE}" | grep "TIFF Directory" | wc -l)
                        echo "${INFO[@]} ${SUMPAGES}"
                    ;;
                esac
            ;;
            stl|pcd) # PCD je rastrový formát fy. Kodak
                # Starší formát, pro jehož konverzi lze použít ImageMagick,
                # ale lepší výsledky dává již delší dobu neudržovaná konverzní
                # utilita pcdtojpeg.
                # http://pcdtojpeg.sourceforge.net/Download.html
                #
                # Formát je podobný formátu Tiled Multi-Resolution TIFF
                # …
                # Obrázek je v kontejneru uložen v 6
                # velikostech:
                # Suffix [1] produces an image 192 by 128 ("Base/16")
                # Suffix [2] produces an image 384 by 256 ("Base/4")
                # Suffix [3] produces an image 768 by 512 ("Base")
                # Suffix [4] produces an image 1536 by 1024 ("4 Base")
                # Suffix [5] produces an image 3072 by 2048 ("16 Base")
                # Suffix [6] produces an image 6144 by 4096 ("64 Base")
                #
                # Poznámka: Když použijete číslo 7 a vyšší tak to má stejný
                # efekt jako když se použije 6
                #
                # Při konverzi vychází obrázek moc tmavý to lze pořešit buď
                # nastavením barevného profilu, nebo gammy
                # Resolutin
                # Contrast
                # Saturation
                # Red
                # Green
                # Nepodporuje více stránek
                #
                # https://en.wikipedia.org/wiki/Photo_CD
                case ${CHARSTRING} in
                    meta*) ${EXIFTOOL} "${FILE}"
                    ;;
                    pages) echo "1"
                    ;;
                    *) local INFO=($(cat "${FILE}"|infoitem))
                        echo "${INFO[@]}"
                    ;;
                esac
            ;;
            psd|psb) # Proprietární formát Photoshopu
                # PSB je PSD rozšířené na podporu obrázků o velikosti
                # 300 tis. pixelů. Standardní PSD podporuje max. 30 tis.
                # pixelů. Pracuje s vrstvami
                # .psd .psb
            ;;
            pdf) # PDF - portable document format, je do učité míry
                # alternativou k DjVu. Nebyl ale navržen pro rychlé
                # prohlížení (jako DjVu) ale pro lepší přenositelnost mezi
                # operačními systémy. Z toho plynou i jeho nevýhody.
                # Především zdlouhavá dekomprese.
                #
                # Z principu má podporu pro více stránek
                case ${CHARSTRING} in
                    meta*) pdfinfo -box "${FILE}"
                    ;;
                    *) local INFO=($(cat "${FILE}"|infoitem))
                        local SUMPAGES=$(${EXIFTOOL} -s3 -PageCount "${FILE}")
                        echo "${INFO[@]} ${SUMPAGES}"
                    ;;
                esac
            ;;
            sgi) #
                # https://en.wikipedia.org/wiki/Silicon_Graphics_Image
            ;;
            tga) # 
                # https://en.wikipedia.org/wiki/Truevision_TGA
            ;;
            webp) #
                # https://en.wikipedia.org/wiki/WebP
            ;;
            xbm) #
                # https://en.wikipedia.org/wiki/X_BitMap
            ;;
            xpm) #
                # https://en.wikipedia.org/wiki/X_PixMap
            ;;
            xwd) # Formát do kterého ukládá screenshoty obrazovky X Windows systems
                # https://en.wikipedia.org/wiki/Xwd
            ;;
            tar|zip) # Nejde o grafické formáty, ale kontejnery, co můžou
                # obsahovat různé typy souborů. Na serveru archive.org se
                # využívají pro zabalení souborů skenů ve formátu jp2, jpeg aj.
                case ${CHARSTRING} in
                    list) listzip "${FILE}"
                    ;;
                    meta*) #/ může být archiv s obrázky
                        local LISTPAGES=($(listzip "${FILE}"))
                        local PAGE="${CHARSTRING#meta }"
                        case ${PAGE} in
                            meta) log info "main() Exif info for first file ${LISTPAGES[0]} from archive ${FILE}"
                                echo $(itemzip "${FILE}" "${LISTPAGES[0]}" | infoitem)
                            ;;
                            *) if [ "${PAGE}" -ge "0" ] && [ "${PAGE}" -lt "${#LISTPAGES[@]}" ] ; then
                                    log info "main() Exif info for ${PAGE} file: ${LISTPAGES[${PAGE}]} from archive ${FILE}"
                                    itemzip "${FILE}" "${LISTPAGES[${PAGE}]}" | ${EXIFTOOL} -
                                else
                                    echo "Ivalid value ${PAGE}" >> /dev/stderr
                                    return 1
                                fi
                            ;;
                        esac
                    ;;
                    pages\ +([0-9])|pages\ all|pages) local TEMPORAR=(${CHARSTRING})
                        case ${TEMPORAR[1]} in
                            all) local LISTPAGES=($(listzip "${FILE}"))
                                printf "%s\n" ${LISTPAGES[@]}
                            ;;
                            +([0-9])) local LISTPAGES=($(listzip "${FILE}"))
                                printf "%s\n" ${LISTPAGES[@]} | \
                                grep -m ${TEMPORAR[1]} -v /$ | tail -1
                            ;;
                            *) local SUMPAGES=$(listzip "${FILE}" | wc -l)
                                echo "${SUMPAGES}"
                            ;;
                        esac
                    ;;
                    *) # zjistit jakého typu jsou obrázky v archivu
                        local SUMPAGES=$(listzip "${FILE}" | wc -l)
                        echo "${FILETYPE^^} ${SUMPAGES}"
                    ;;
                esac
            ;;
        esac
    fi
    return $?
}

# ### <span id="jp2to">jp2to()</span> ([top](#FUNCTIONS))
# Konvertuje obrázky z formátu JPEG-2000 do bitmapových formátů:
# `.bmp`, `.pgm`, `.pgx`, `.png`, `.pnm`, `.ppm`, `.raw`, `.tga`, `.tif`.
# Využívá se při tom nástroj libopenjp2-tools
# Při konverzi do PNG je vyžadována knihovna libpng a při konverzi do
# formátu TIFF zase knihovna libtiff.
#
# Srovnání: Cca 4,1M jp2 ve stupních šedi, mizerné kvality má po konverzi
# do DjVu při použití výchozího algoritmu (`djvu`) 1,1M. O něco lepší výsledek
# jak z hlediska vizuálního, tak velikosti souboru nabídnul algoritmus
# `otsu` – 0.7MB
# Stejný soubor nekomprimovaný zabral 33M a v PNG 21M
jp2to() {
    log goto "jp2to() $1 –> $2"
    ${PAMTO} -i "${1}" -o "${2}"
    return $?
}

# ### <span id="jp2in">jp2in()</span> ([top](#FUNCTIONS))
# Konvertuje obrázky do formátu JPEG-2000
# `.bmp`, `.pgm`, `.pgx`, `.png`, `.pnm`, `.ppm`, `.raw`, `.tga`, `.tif`.
# Využívá se při tom nástroj libopenjp2-tools.
# Při konverzi z PNG je vyžadována knihovna libpng a při konverzi z
# formátu TIFF zase knihovna libtiff.
#
# Konverze již zpracovaného obrázku už není tak dobrá jako z originálu 8-/
jp2in() {
    log goto "jp2in() $1 –> $2"
    
    ${JP2IN} -i "${1}" -o "${2}"
    return $?
}


# ### <span id="listpdf">listpdf()</span> ([top](#FUNCTIONS))
# Funkce vrací seznam stránek v PDF souboru.
#
# pdftk soubor.pdf dump_data | grep PageMedia
#
# PageMediaNumber: 5
# PageMediaRotation: 0
# PageMediaRect: 0 0 533 838
# PageMediaDimensions: 533 838
#
# Důležité jsou rozměry, rotace a číslo
#     + 2451x3363+0+0 RGB-alpha Normal 46
#
# 1, položka viditelnost vrstvy (+|-)
# 2, položka rozměry vrstvy
# 3, 
# 4, typ vrstvy - by měly být typu Normal 
# 5, jméno vrstvy
#
# Pokud se u některé z viditelných vrstev vyskytuje jiný typ, než Normal,
# pak se vrací upozornění, že jde o rozpracovaný soubor a výsledek nemusí
# odpovídat požadovku
#
# Pořadové číslo souboru tak odpovídá číslu stránky
listpdf() {
    log goto "listpdf() From "
    ${PDFTK} "${1}" dump_data | awk '/^PageMediaNumber/ {print $2}'
}

# ### <span id="pdftopdf">pdftopds()</span> ([top](#FUNCTIONS))
# Export rozsahu ${RANGE} stránek z pdf souboru $1 do nového pdf souboru $2
pdftopdf() {
    log goto "pdftopdf() From pdf $1 range ${RANGE}"
    local TEMPORAR=(${RANGE//,/ })
    local RANGE=$(printf "A%s " ${TEMPORAR[@]})
    ${PDFTK} A="${1}" cat ${RANGE} output "${2}"
}

# ### <span id="itemxcf">itemxcf()</span> ([top](#FUNCTIONS))
# Funkce vyblije na standardní výstup stránku __$2__ z PDF souboru __$1__
itempdf() {
    ${PDFTOPPM} -f ${2} -l ${2} < "${1}"
}

# ### <span id="listxcf">listxcf()</span> ([top](#FUNCTIONS))
# Funkce vrací seznam vrstev v XCF souboru.
#
# Ovšem tento vstupní XCF soubor musí být připraven ke konverzi a to tak,
# že vrstvy, které mají být považovány za stránky, musí být typu Normal a
# viditelné. 
#
#     + 2451x3363+0+0 RGB-alpha Normal 46
#
# 1, položka viditelnost vrstvy (+|-)
# 2, položka rozměry vrstvy
# 3, 
# 4, typ vrstvy - by měly být typu Normal 
# 5, jméno vrstvy
#
# Pokud se u některé z viditelných vrstev vyskytuje jiný typ, než Normal,
# pak se vrací upozornění, že jde o rozpracovaný soubor a výsledek nemusí
# odpovídat požadovku
#
# Pořadové číslo souboru tak odpovídá číslu stránky
listxcf() {
    local TEST=$( ${XCFINFO} "${1}" | grep ^+ | awk '{print $4}' | grep -v Normal )
    ${XCFINFO} -u "${1}" | while read line ; do
        case "${line:0:1}" in
            +) echo "${line#*RGB* Normal }"
            ;;
        esac
    done
    [ -n "${TEST}" ] && return 1 || return 0
}

# ### <span id="itemxcf">itemxcf()</span> ([top](#FUNCTIONS))
# Funkce vyblije na standardní výstup z XCF __$1__ vrstvu __$2__
itemxcf() {
    log goto "itemxcf() From $1 flush –> $2"
    ${XCF2PNM} "${1}" "${2}"
}

# ### <span id="itempng">itempng()</span> ([top](#FUNCTIONS))
# Funkce vyblije na standardní výstup z XCF __$1__ vrstvu __$2__
itempng() {
    log goto "itempng() From $1 flush –> $2"
    # ${XCF2PNM} "${1}" "${2}"
}

# ### <span id="listpng">listpng()</span> ([top](#FUNCTIONS))
# Vrací pořadové číslo vrstvy, které odpovídá číslu stránky
listpng() {
    local TEMPORARY="${1##*/}"
    mkdir ${TEMPORARY}
    # ${ZIP} l -so "${1}" | awk '{print $6}' | grep '/' | sort -t _
}

# ### <span id="listdjvu">listdjvu()</span> ([top](#FUNCTIONS))
# Vrací seznam stránek v DjVu souboru
listdjvu() {
    #${ZIP} l -so "${1}" | awk '{print $6}' | grep '/' | sort -t _
    echo nil
}

# ### <span id="listzip">listzip()</span> ([top](#FUNCTIONS))
# Vrací setříděný seznam souborů v ZIP archivu - je založen na syntaxi
# používané u souborů archive.org, kdy číslování stránek je před příponou
# souboru, oddělené od jména adresáře podtržítkem
#
#         pg35600_jp2/pg35600_0158.jp2
#
# Pořadové číslo souboru tak odpovídá číslu stránky
listzip() {
    ${ZIP} l -so "${1}" | awk '{print $6}' | grep '/' | sort -t _
}

# ### <span id="itemzip">itemzip()</span> ([top](#FUNCTIONS))
# Funkce vyblije na standardní výstup ze zazipovaného archívu __$1__
# soubor __$2__
itemzip() {
    log goto "itemzip() From $1 flush –> $2"
    ${ZIP} e -so "${1}" "${2}"
}

# ### <span id="infile">infile()</span> ([top](#FUNCTIONS))
# Vrací adresy počátečního a poslední řádku bloku, který vyhovuje odpovídajícímu vzorku
# $1 - jméno souboru
# $COORDS
# $MESSAGE
infile() {
    log goto "infile() $1 –> ${COORDS}"

    mapfile -d\: -t -c1 CORDANT <<< $(grep -n "${COORDS%+([[:blank:]])}" "${1}")
    mapfile -d\: -t -c1 MESANT <<< $(grep -n "${MESSAGE}" "${1}")
    #echo "${MESSAGE}" >> /dev/stderr
    #echo "${MESANT}" >> /dev/stderr
    mapfile -t TEMP <<< $(grep -n '^[a-Z#]' "${1}")
    local POLEOBJEKTU=(${TEMP[@]%:*})
    local RADKYCELKEM=$(wc -l < ${1})

    _f() {
        local z i
        for i in ${POLEOBJEKTU[@]} ; do [ $i -gt $1 ] && break || ((++z)) ; done
        if [ $i -lt $1 ] ; then
            log info "_f() Za řádkem $1 už nebyl žádný objekt"
            echo "$i" "${RADKYCELKEM}"
        else
            log info "_f() Za řádkem $1 začínal další objekt na $i"
            echo "${POLEOBJEKTU[$((z - 1))]}" "$((i - 1))"
        fi
    }
    
    case "${MESANT}" in
        +([[:digit:]])) #/ jenom MESANT
            _f "${MESANT}"
        ;;
        *) case "${CORDANT}" in
            +([[:digit:]]))
                _f  "${CORDANT}"
            ;;
            *) return 1
            ;;
        esac
        ;;
    esac
    return 0
}

# ### <span id="infoitem">infoitem()</span> ([top](#FUNCTIONS))
# Na vstupu je stream a výstupem je sada hodnot
infoitem() {
    ${EXIFTOOL} -s3 -FileType -ImageSize -Compression -AnimationFrames -FrameCount -
}

# ### <span id="infoitem">infoitem()</span> ([top](#FUNCTIONS))
# Na vstupu je soubor $1, a případně identifikátor stránky $2
rotateinfo() {
    local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .bin)
    case ${2} in
        +([[:digit:]])) #/ pořadí stránky
            ${DJVUEXTRACT} "${1}" -page=${2} INFO=${TEMPFILE} 2>/dev/null
        ;;
        '') #/ globální
            ${DJVUEXTRACT} "${1}" INFO=${TEMPFILE} 2>/dev/null
        ;;
        *) #/ jméno stránky
            ${DJVUEXTRACT} "${1}" -page="${2}" INFO=${TEMPFILE} 2>/dev/null
        ;;
    esac
    [ $? -eq 1 ] && return 1
    local ROTATION=$(dd if=${TEMPFILE} bs=1 skip=9 2>/dev/null | od -A none -b)
    case ${ROTATION} in
        001) # 0°
            echo "0"
        ;;
        005) # 270°
            echo "3"
        ;;
        002) # 180°
            echo "2"
        ;;
        006) # 90°
            echo "1"
        ;;
        *) return 1
        ;;
    esac
    return 0
}

# ### <span id="convertovergimp">convertovergimp()</span> ([top](#FUNCTIONS))
# Bitmapový editor gimp lze rovněž využívat ke konverzi bitmapových souborů
#
# $1 - výstupní formát
convertovergimp() {
    # Start gimp with python-fu batch-interpreter
    gimp -i --batch-interpreter=python-fu-eval -b - << EOF
import gimpfu

def convert(filename):
    img = pdb.gimp_file_load(filename, filename)
    new_name = filename.rsplit(".",1)[0] + ".$1"
    layer = pdb.gimp_image_merge_visible_layers(img, 1)

    pdb.gimp_file_save(img, layer, new_name, new_name)
    pdb.gimp_image_delete(img)

convert('${2}')

pdb.gimp_quit(1)
EOF
}

# ### <span id="identifypage">identifypage()</span> ([top](#FUNCTIONS))
# Function return DjVu page actual ORDER in DjVu bundle
# $1 type (order|name)
# $2 DjVu file
# $3 Page identificator (order or name)
identifypage() {
    log goto "identifypage() ${1} page ${3} from ${2}"
    case "${3}" in
        +([[:digit:]])) #/ Identifikace podle čísla stránky
            local PAGE=$(${DJVUSED} "${2}" -e dump | grep "\[P${3}\]")
        ;;
        *) #/ Identifikace podle názvu stránky
            local PAGE=$(${DJVUSED} "${2}" -e dump | grep "\{${3}\}")
        ;;
    esac
    [ ! -n "${PAGE}" ] && \
        log err "identifypage() Invalid identificator ${1} for ${2}" && \
        return 1
    case "${1}" in
        name) local TEMPORAR="${PAGE##*\{}"
            echo "${TEMPORAR%%\}*}"
        ;;
        order) local TEMPORAR="${PAGE##*\[P}"
            echo "${TEMPORAR%%\]*}"
        ;;
        *) log err "identifypage() Invalid type –> ${1}"
            return 1
        ;;
    esac
    return 0
}

# ### <span id="lastpage">lastpage()</span> ([top](#FUNCTIONS))
# Function return count of all pages in DjVu bundle
# $1 DjVu file
lastpage() {
    log goto "lastpage() –> ${1}"
    local SOURCE=$(${REALPATH} -m -P "${1}")
    local FILE="${SOURCE##*/}"
    [ "$(mimefile ${SOURCE})" == "djvu" ] || return 1
    local OUTPUT=$(${DJVUSED} "${SOURCE}" -e n)
    log info "lastpage() Count of all pages in ${FILE} –> ${OUTPUT}"
    echo -n "${OUTPUT}"
    return 0
}

# ### <span id="deletepage">deletepage()</span> ([top](#FUNCTIONS))
# Odstraňuje z DjVu svazku stránky, pokud jejich celkový počet je > 1
#
# $1 - jméno DjVu svazku se kterým se pracuje
# $2 - číslo, nebo název strany co se má odstranit
#
# Pokud je stránka úspěšně odstraněna, vrací __0__
# Pokud se stránka ve svazku nevyskytuje, vrací __1__
# Pokud není DjVu soubor typu bundle, vrací __2__
deletepage() {
    log goto "deletepage() From ${1} –> ${2}"
    [ -z ${2} ] && return 1
    local SUMPAGE=$(${DJVUSED} "${1}" -e 'n')
    [ $? -eq 1 ] && return 1
    case $SUMPAGE in
        1) echo "Single page DjVu file –> ${FILE}" >> /dev/stderr
            return 0
            ;;
        *) local PAGE=$(identifypage order "${1}" "${2}")
            if [ ! -z "${PAGE}" ] ; then
                ${DJVM} -d "${1}" "${PAGE}"
                echo "Page ${2} from ${1} was removed" >> /dev/stderr
            else
                return 1
            fi
            ;;
    esac
    return $?
}

# ### <span id="djvurotate">djvurotate()</span> ([top](#FUNCTIONS))
# $1 - soubor se kterým se pracuje
# $2 - číslo, nebo název strany která se má rotovat
# $3 - hodnota rotace
#	echo "$*" >> /dev/stderr
function djvurotate {
    log goto "$1 –> $2"
    local INFO="""
Uvedenou hodnotu rotace nelze akceptovat. Rotaci lze nastavit buď 
absolutně, a nebo relativně (pootočit o 90°). AKceptované hodnoty:

      0 - výchozí pozice
      1 - natočení vpravo
      2 - otočení  vzhůru nohama
      3 - natočení vlevo
   left - rotace směrem doleva
  right - rotace směrem doprava).
    180 - přetočení o 180°

Každá jiná hodnota parametru je ignorována."""

    local ROTATE="${2%%+([[:blank:]])*}"
    case "${ROTATE}" in
        0|1|2|3|180|left|right)
            local TEMPORAR="${2#${ROTATE}+([[:blank:]])}"
            mapfile -t ARRAY <<< $($0 "${1}" info list)
            case "${ARRAY:0:1}" in
                0) mapfile -t LISTPAGES <<< $(printf "%s\n" "${ARRAY[@]}")
                ;;
                *) LISTPAGES="0 none"
                    mapfile -O 1 -t LISTPAGES <<< $(printf "%s\n" "${ARRAY[@]}")
                ;;
            esac
            RANGE=$(isrange "${TEMPORAR}")
            if [ -n "${RANGE}" ] ; then
                local PAGES=($(range "${RANGE}"))
            else
                case "${TEMPORAR//+([[:blank:]])/}" in
                    '') echo "${INFO}" >> /dev/stderr
                        return 1
                    ;;
                    *) # seznam stránek oddělených čárkou
                        local IFS_BAK=$IFS
                        local IFS=$','
                        local SEZNAM=($TEMPORAR)
                        local IFS=$IFS_BAK
                        for i in "${LISTPAGES[@]}" ; do
                            if [[ "${SEZNAM[@]}" =~ "${i##+([[:digit:]])+([[:blank:]])}" ]] ; then
                                local TEMP="$TEMP${i%% *} "
                            fi
                            x=$((x + 1))
                        done
                        local PAGES=($TEMP)
                    ;;
                esac
            fi
            echo "ROTATE ${ROTATE} PAGES ${#PAGES[@]} ${PAGES[@]}" >> /dev/stderr
            for i in ${PAGES[@]} ; do
                local PAGENAME="${LISTPAGES[$i]##+([[:digit:]])+([[:blank:]])}"
                local PAGEORDER="${LISTPAGES[$i]%% *}"
                case "${PAGEORDER}" in
                    0) case "${PAGENAME}" in
                            none)
                            ;;
                            *) # globální rotace
                                case "${ROTATE}" in
                                    0|1|2|3)  ${DJVUSED} -e "set-rotation ${ROTATE}; save" "${1}"
                                    ;;
                                    left) ${DJVUSED} -e "set-rotation +1; save" "${1}"
                                    ;;
                                    right) ${DJVUSED} -e "set-rotation -1; save" "${1}"
                                    ;;
                                    180) ${DJVUSED} -e "set-rotation +2; save" "${1}"
                                    ;;
                                    *) echo "${INFO}" >> /dev/stderr
                                    ;;
                                esac
                            ;;
                        esac
                    ;;
                    '') #/ nic
                    ;;
                    *) #/ stránky dle rozsahu či seznamu
                        case "${ROTATE}" in
                            0|1|2|3)  ${DJVUSED} -e "select '${PAGEORDER}'; set-rotation ${ROTATE}; save" "${1}"
                            ;;
                            left) ${DJVUSED} -e "select '${PAGEORDER}'; set-rotation +1; save" "${1}"
                            ;;
                            right) ${DJVUSED} -e "select '${PAGEORDER}'; set-rotation -1; save" "${1}"
                            ;;
                            180) ${DJVUSED} -e "select '${PAGEORDER}'; set-rotation +2; save" "${1}"
                            ;;
                            *) echo "${INFO}" >> /dev/stderr
                            ;;
                        esac
                    ;;
                esac
            done
        ;;
        *) printf "%s - is not valid rotate VALUE" "${ROTATE}" >> /dev/stderr
            return 1
        ;;
    esac
}

function djvumove {
	# $1 - DjVu file
	# $2 - Parametry
	#	zdroj : identifikátor pozice
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"

	local VSTUP="${2}"
	local COUNT=${#VSTUP}
	local POS=0
	local START=0
	while [ $POS -lt $COUNT ]
	do local POS=$((POS+1))
#		echo "${VSTUP:$START:$POS}" >> /dev/stderr
		case "${VSTUP:$START:$POS}" in
			*.[dD][jJ][vV][uU]|*.[gG][iI][fF]|*.[jJ][pP][gG]|*.[mM][nN][gG]|*.[pP][dD][fF]|*.[pP][nN][gG]|*.[pP][nN][mM]|*.[tT][iI][fF][fF]|*.[xX][cC][fF]) 
				local SOUBOR="${VSTUP:0:$POS}"
				log info "move() Zachycen soubor $SOUBOR - ${SOUBOR:$((${#SOUBOR} - 4)):4}"
				if [ "${SOUBOR:$((${#SOUBOR} - 4)):4}" == "djvu" ] ; then
#					echo "Před testem.. '${SOUBOR##+([[:blank:]])}'" >> /dev/stderr
					local TESTORDER=$(identifypage order "${SOURCE}" "${SOUBOR##+([[:blank:]])}")
#					echo "Po testu.." >> /dev/stderr
					if [ -z "${TESTORDER}" ] ; then
						if [ -f "${SOUBOR}" ] ; then
							local FROM="${SOUBOR}"
							local VSTUP="${VSTUP#${SOUBOR} }"
							local COUNT=${#VSTUP}
							local POS=0
							echo "move: OK - jde o DjVu soubor ${SOUBOR} co se má vložit" >> /dev/stderr
							local ANAME="${SOUBOR}"
							##### Ve zbytku musí být identifikátor
							# ....
#							echo "Insert djvu file yet not implemented!!!" >> /dev/stderr
#							return 0
						else
							local TEST=( ${SOUBOR} )
							if [ "${#TEST}" -gt "0" ] ; then
								local A="${TEST[0]}"
								if [ "${A%%+([[:digit:]])}" == "" ] ; then
									local BTEST="${SOUBOR##${A}+([[:blank:]])}"
									local B=$(identifypage order "${SOURCE}" "${BTEST}")
									if [ -z "${B}" ] ; then
										echo "move: FAIL - for DjVu file ${FILE} identificator target page ${BTEST} is not valid." >> /dev/stderr
										exit 1
									else
										#FINITO### tady budu realizovat přesun...?
										local ANAME=$(identifypage name "${SOURCE}" "${A}")
										local BNAME=$(identifypage name "${SOURCE}" "${B}")
										if [ "${ANAME}" == "${BNAME}" ] ; then
											echo "move: FAIL - If you want move page on position ${A}, which is the same page as target. If you want moved page from position ${2} before actual position, use command without identification of target position." >> /dev/stderr
											exit 1
										fi
										if [ "${MOVE}" == "fore" ] ; then
											if [ "$A" == "1" ] ; then
												echo "move: INFO - page ${ANAME} is on first position in ${FILE}." >> /dev/stderr
												return 1
											elif [ "$A" == "$((${B} - 1))" ] ; then
												echo "move: INFO - page ${ANAME} is on previous position (${A}) in ${FILE} before page ${BNAME} (position ${B})." >> /dev/stderr
												return 1
											else
												PAGE="yes"
												exportdjvupage "${SOURCE}" "${ANAME}" "${TEMPDIR}"
												deletepage "${SOURCE}" "${ANAME}"
												if [ "${A}" -gt "${B}" ] ; then
													${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "${B}"
												else
													${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "$((${B} - 1))"
												fi
												return 0
											fi
										elif [ "${MOVE}" == "back" ] ; then
											local TEST=$(lastpage "${1}")
											if [ "$A" == "${TEST}" ] ; then
												echo "move: INFO - page ${ANAME} is on last position in ${FILE}." >> /dev/stderr
												return 1
											elif [ "$A" == "$((${B} + 1))" ] ; then
												echo "move: INFO - page ${ANAME} is on next position in ${FILE} after page ${BNAME}." >> /dev/stderr
												return 0
											else
												PAGE="yes"
												exportdjvupage "${SOURCE}" "${ANAME}" "${TEMPDIR}"
												deletepage "${SOURCE}" "${ANAME}"
												if [ "${A}" -lt "${B}" ] ; then
													${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "${B}"
												else
													${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "$((${B} - 1))"
												fi
												return 0
											fi
										else
											echo "move: Nedělám nic" >> /dev/stderr
										fi
									fi
								else
									echo "move: FAIL - identificator '${SOUBOR##+([[:blank:]])}' for file ${FILE} is not valid. Pay attention to the gap - are treacherous!" >> /dev/stderr
									exit 1
								fi
							else
								echo "move: S názvem souboru není něco v pořádku" >> /dev/stderr
							fi
						fi
					else
						if [ -z "${ANAME}" ] ; then
							# Nenastavené ANAME 
							local ANAME="${SOUBOR}"
							local A="${TESTORDER}"
							local VSTUP="${VSTUP#${SOUBOR}}"
							if [ "${VSTUP##+([[:blank:]])}" == "" ] ; then
								#FINITO### tady budu realizovat přesun...?
								if [ "${MOVE}" == "fore" ] ; then
									if [ "$A" == "1" ] ; then
										echo "move: INFO - page ${ANAME} is on first position in ${FILE}." >> /dev/stderr
										return 1
									else
										PAGE="yes"
										exportdjvupage "${SOURCE}" "${ANAME}" "${TEMPDIR}"
										deletepage "${SOURCE}" "${ANAME}"
										${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "$((${A} - 1))"
										return 0
									fi
								elif [ "${MOVE}" == "back" ] ; then
									local TEST=$(lastpage "${1}")
									if [ "$A" == "${TEST}" ] ; then
										echo "move: INFO - page ${ANAME} is on last position in ${FILE}." >> /dev/stderr
										return 1
									else
										PAGE="yes"
										exportdjvupage "${SOURCE}" "${ANAME}" "${TEMPDIR}"
										deletepage "${SOURCE}" "${ANAME}"
										${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "$((${A}+1))"
										return 0
									fi
								else
									echo "move: Nedělám nic" >> /dev/stderr
								fi
							else
								local TEST="${VSTUP##+([[:blank:]])}"
								if [ "${TEST##+([[:digit:]])}" == "" ] ; then
#									# Pořadové číslo - budu přesouvat..
									local B=$(identifypage order "${SOURCE}" "${TEST}")
									if [ -z "${B}" ] ; then
										echo "move: ERROR - target position is not valid for file ${FILE}" >> /dev/stderr
										exit 1
									else
										#FINITO## Budu přesouvat
										if [ "${A}" == "${B}" ] ; then
											echo "move: FAIL - If you want move page on position ${A}, which is the same page as target. If you want moved page from position ${2} before actual position, use command without identification of target position." >> /dev/stderr
											exit 1
										fi
										if [ "${MOVE}" == "fore" ] ; then
											if [ "${A}" == "$((${B} - 1))" ] ; then
												echo "move: INFO - page ${ANAME} is on previous position (${A}) in ${FILE} before page with position ${B}." >> /dev/stderr
												return 1
											else
												PAGE="yes"
												exportdjvupage "${SOURCE}" "${ANAME}" "${TEMPDIR}"
												deletepage "${SOURCE}" "${ANAME}"
												if [ "${A}" -gt "${B}" ] ; then
													${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "${B}"
												else
													${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "$((${B} - 1))"
												fi
												return 0
											fi
										elif [ "${MOVE}" == "back" ] ; then
											local TEST=$(lastpage "${SOURCE}")
											if [ "$A" == "${TEST}" ] ; then
												echo "move: INFO - page ${ANAME} is on last position in ${FILE}." >> /dev/stderr
												return 1
											elif [ "$A" == "$((${B} + 1))" ] ; then
												echo "move: INFO - page ${ANAME} is on next position in ${FILE} after page which is target (${B})." >> /dev/stderr
												return 0
											else
												PAGE="yes"
												exportdjvupage "${SOURCE}" "${ANAME}" "${TEMPDIR}"
												deletepage "${SOURCE}" "${ANAME}"
												if [ "${A}" -lt "${B}" ] ; then
													${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "${B}"
												else
													${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "$((${B} - 1))"
												fi
												return 0
											fi
										else
											echo "move: Nedělám nic" >> /dev/stderr
										fi
										return 0
									fi
								else
									local COUNT=${#VSTUP}
									local POS=0
									log warn "move() INFO - page ${ANAME} has order ${A}. What is the identificator of target page from bundle -$VSTUP-?"
								fi
							fi
						elif [ "${ANAME}" == "none" ] ; then
#							# ANAME je none
							local B=$(identifypage order "${1}" "${SOUBOR}")
							if [ -z "${B}" ] ; then
								echo "move: ERROR - Chybné jméno stránky před kterou se má stránka přesunout" >> /dev/stderr
								exit 1
							else
								local A=""
								local BNAME="${SOUBOR}"
								log warn "move() Vkládá se konvertovaná stránka ${FROM} před stránu -${BNAME}- na pozici ${B}"
								break
							fi
						else
#							#FINITO### Budu přesouvat..
#							echo "move: ${A} ${TESTORDER}" >> /dev/stderr
							if [ "${A}" == "${TESTORDER}" ] ; then
								echo "move: FAIL - If yu want move page ${ANAME} in ${FILE} about one position. You must for it use action ${MOVE} only with identificator of page to move." >> /dev/stderr
								exit 1
							else
								local B=$(identifypage order "${1}" "${SOUBOR}")
								if [ -z "${B}" ] ; then
									echo "move: FAIL - Chybné jméno stránky před kterou se má stránka přesunout" >> /dev/stderr
									exit 1
								else
									local A=$(identifypage order "${1}" "${ANAME}")
									if [ -z "${A}" ] ; then
										echo "move: file ${ANAME} je djvu soubor?" >> /dev/stderr
#										exit 1
									else
										echo "move: ANAME je soubor ${ANAME}.." >> /dev/stderr
									local BNAME="${SOUBOR}"
#									#FINITO## Budu přesouvat ####
									if [ "${ANAME}" == "${BNAME}" ] ; then
										echo "move: FAIL - If you want move page on position ${A}, which is the same page as target. If you want moved page from position ${2} before actual position, use command without identification of target position." >> /dev/stderr
										exit 1
									fi
									if [ "${MOVE}" == "fore" ] ; then
										if [ "$A" == "1" ] ; then
											echo "move: INFO - page ${ANAME} is on first position in ${FILE}." >> /dev/stderr
											return 1
										elif [ "$A" == "$((${B} - 1))" ] ; then
											echo "move: INFO - page ${ANAME} is on previous position (${A}) in ${FILE} before page ${BNAME} (position ${B})." >> /dev/stderr
											return 1
										else
											PAGE="yes"
											exportdjvupage "${SOURCE}" "${ANAME}" "${TEMPDIR}"
											deletepage "${SOURCE}" "${ANAME}"
											if [ "${A}" -gt "${B}" ] ; then
												${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "${B}"
											else
												${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "$((${B} - 1))"
											fi
											return 0
										fi
									elif [ "${MOVE}" == "back" ] ; then
										local TEST=$(lastpage "${1}")
										if [ "$A" == "${TEST}" ] ; then
											echo "move: INFO - page ${ANAME} is on last position in ${FILE}." >> /dev/stderr
											return 1
										elif [ "$A" == "$((${B} + 1))" ] ; then
											echo "move: INFO - page ${ANAME} is on next position in ${FILE} after page ${BNAME}." >> /dev/stderr
											return 0
										else
											PAGE="yes"
											exportdjvupage "${SOURCE}" "${ANAME}" "${TEMPDIR}"
											deletepage "${SOURCE}" "${ANAME}"
											if [ "${A}" -lt "${B}" ] ; then
												${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "${B}"
											else
												${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "$((${B} - 1))"
											fi
											return 0
										fi
									else
										echo "move: Nedělám nic" >> /dev/stderr
									fi
									fi
								fi
							fi
						fi
					fi
				else
					if [ -f "${SOUBOR}" ] ; then
						local FROM="${SOUBOR}"
						##### KONVERZE #######
						local ANAME="none"
						local VSTUP="${VSTUP#${SOUBOR}}"
						local COUNT=${#VSTUP}
						local POS=0
						echo "move: INFO file ${SOUBOR} id not DjVu; must be converted" >> /dev/stderr
						local ANAME="${TEMPDIR}/${SOUBOR%.*}.djvu"
						#/ filetodjvu "${SOUBOR}" "${ANAME}"
                        echo "Tato funkce zatím nebyla nahrazena!" >> /dev/stderr
                        exit 33
						if [ ! -f "${ANAME}" ] ; then
							echo "move: ERROR - file ${ANAME} not exists. Probably any problem with conversion." >> /dev/stderr
							exit 1
						fi
					else
						echo "move: ERROR - Soubor ${SOUBOR} neexistuje" >> /dev/stderr
						exit 1
					fi
				fi
			;;
		esac
	done

	if [ -f "${ANAME}" ] ; then
		echo "Sem to propadne je-li ANAME -${ANAME}- již existující soubor" >> /dev/stderr
		if [ -z "${BNAME}" ] ; then
			echo "move: Musím získat pozici ze zbytku ${VSTUP}" >> /dev/stderr
			local TEST="${VSTUP##+([[:blank:]])}"
			if [ "${TEST##+([[:blank:]])}" == "" ] ; then
				## Budu soubor připojovat na konec DjVu svazku...
				# Není třeba nic víc řešit...
				echo "Budu soubor připojovat na konec DjVu svazku. Není třeba řešit nic víc, nežli to zda není nějaká stránka v konfliktu.."
				if comparedjvu "${SOURCE}" "${ANAME}" ; then
					echo "move: APPEND - content of file ${ANAME} to ${MOVE} ${SOURCE}" >> /dev/stderr
					if [ "${MOVE}" == "fore" ] ; then
						${DJVM} -i "${SOURCE}" "${ANAME}" 1
					elif [ "${MOVE}" == "back" ] ; then
						${DJVM} -i "${SOURCE}" "${ANAME}"
					else
						echo "Nedělám nic" >> /dev/stderr
					fi
					return 0
				else
					echo "Stránka je v konfliktu" >> /dev/stderr
					exit 1
				fi
			else
				local B=$(identifypage order "${SOURCE}" "${TEST}")
				if [ -z "${B}" ] ; then
					echo "move: identificator -${TEST} is not valid." >> /dev/stderr
					exit 1
				else
					echo "move: APPEND - content of file ${ANAME} to ${SOURCE} ${MOVE} page ${B}" >> /dev/stderr
					if comparedjvu "${SOURCE}" "${ANAME}" ; then
						if [ "${MOVE}" == "fore" ] ; then
							${DJVM} -i "${SOURCE}" "${ANAME}" "${B}"
						elif [ "${MOVE}" == "back" ] ; then
							${DJVM} -i "${SOURCE}" "${ANAME}" "$((${B} + 1))"
						else
							echo "Nedělám nic" >> /dev/stderr
						fi
						return 0
					else
						echo "Stránka je v konfliktu" >> /dev/stderr
						exit 1
					fi
				fi 
			fi
		fi
	else
		if [ -z "${ANAME}" ] ; then
			local TEST=( ${VSTUP} )
			if [ "${#TEST}" -gt "0" ] ; then
				local ANAME=$(identifypage name "${SOURCE}" "${TEST[0]}")
				if [ -z "${ANAME}" ] ; then
					echo "move: FAIL - for DjVu file ${FILE} identificator ${TEST[0]} is not valid." >> /dev/stderr
					exit 1
				else
					if [ "${TEST[1]##+([[:blank:]])}" != "" ] ; then
						local BNAME=$(identifypage name "${SOURCE}" "${TEST[1]}")
						if [ -z "${BNAME}" ] ; then
							echo "move: FAIL - for DjVu file ${FILE} identificator ${TEST[1]} is not validxxx." >> /dev/stderr
							exit 1
						else
							echo "move: INFO - page ${ANAME} has order ${A}. Do move ${MOVE} ${BNAME}." >> /dev/stderr
							### budu přesouvat stránku na pozici..
						fi
					else
						echo "move: page ${ANAME} move ${MOVE}" >> /dev/stderr
						### budu přesouvat stránku o jednu pozici..
					fi

				fi
			fi 
		fi
	fi

	echo "move - jsem za tim" >> /dev/stderr

	if [ -z "${BNAME}" ] ; then
		if [ -z "{ANAME}" ] ; then
			echo "move: Neplatná cílová stránka ${BNAME}, i stránka ${ANAME} která se má přesouvat" >> /dev/stderr
			exit 1
		else
			local TEST=( ${VSTUP} )
			if [ "${#TEST}" -gt "0" ] ; then
				local BNAME=$(identifypage name "${SOURCE}" "${TEST[0]}")
				if [ -z "${BNAME}" ] ; then
					echo "move: FAIL - identificator ${TEST[0]} is not valid for DjVu file ${FILE}" >> /dev/stderr
					exit 1
				else
#					#FINITO## Zpracovávám přesun..
					if [ "${ANAME}" == "${BNAME}" ] ; then
						local A=$(identifypage order "${SOURCE}" "${ANAME}")
						if [ "${MOVE}" == "fore" ] ; then
							if [ "$A" == "1" ] ; then
								echo "move: INFO - page ${ANAME} is on first position in ${FILE}." >> /dev/stderr
								return 1
							else
								PAGE="yes"
								exportdjvupage "${SOURCE}" "${ANAME}" "${TEMPDIR}"
								deletepage "${SOURCE}" "${ANAME}"
								${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "$((${A} - 1))"
								return 0
							fi
						elif [ "${MOVE}" == "back" ] ; then
							local TEST=$(lastpage "${1}")
							if [ "$A" == "${TEST}" ] ; then
								echo "move: INFO - page ${ANAME} is on last position in ${FILE}." >> /dev/stderr
								return 1
							else
								PAGE="yes"
								exportdjvupage "${SOURCE}" "${ANAME}" "${TEMPDIR}"
								deletepage "${SOURCE}" "${ANAME}"
								${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "$((${A}+1))"
								return 0
							fi
						else
							echo "move: Nedělám nic" >> /dev/stderr
						fi
					else
#						echo "move: INFO - move page -${ANAME}- -${A}- ${MORE} page -${BNAME}- -${B}-" >> /dev/stderr
#						#FINITO## Zpracovávám přesun..
						local B=$(identifypage order "${SOURCE}" "${BNAME}")
						if [ "${ANAME}" == "${BNAME}" ] ; then
							echo "move: FAIL - If you want move page on position ${A}, which is the same page as target. If you want moved page from position ${2} before actual position, use command without identification of target position." >> /dev/stderr
							exit 1
						fi
						if [ "${MOVE}" == "fore" ] ; then
							if [ "$A" == "1" ] ; then
								echo "move: INFO - page ${ANAME} is on first position in ${FILE}." >> /dev/stderr
								return 1
							elif [ "$A" == "$((${B} - 1))" ] ; then
								echo "move: INFO - page ${ANAME} is on previous position (${A}) in ${FILE} before page ${BNAME} (position ${B})." >> /dev/stderr
								return 1
							else
								PAGE="yes"
								exportdjvupage "${SOURCE}" "${ANAME}" "${TEMPDIR}"
								deletepage "${SOURCE}" "${ANAME}"
								if [ "${A}" -gt "${B}" ] ; then
									${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "${B}"
								else
									${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "$((${B} - 1))"
								fi
								return 0
							fi
						elif [ "${MOVE}" == "back" ] ; then
							local TEST=$(lastpage "${SOURCE}")
							if [ "$A" == "${TEST}" ] ; then
								echo "move: INFO - page ${ANAME} is on last position in ${FILE}." >> /dev/stderr
								return 1
							elif [ "$A" == "$((${B} + 1))" ] ; then
								echo "move: INFO - page ${ANAME} is on next position in ${FILE} after page ${BNAME}." >> /dev/stderr
								return 0
							else
								PAGE="yes"
								exportdjvupage "${SOURCE}" "${ANAME}" "${TEMPDIR}"
								deletepage "${SOURCE}" "${ANAME}"
								if [ "${A}" -lt "${B}" ] ; then
									${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "${B}"
								else
									${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "$((${B} - 1))"
								fi
								return 0
							fi
						else
							echo "move: Nedělám nic" >> /dev/stderr
						fi
					fi
				fi
			else
				echo "move: FAIL ANAME -${ANAME}-, VSTUP -${VSTUP}- je buď prázdný, nebo obsahuje pouze číselnou identifikaci cílové pozice" >> /dev/stderr
				exit 1
			fi 
		fi
	else
		if [ -z "${FROM}" ] && [ -z "${ANAME}" ] ; then
			echo "move: Neplatná identifikace stránky se kterou se má pracovat" >> /dev/stderr
			exit 1
		fi
	fi

	echo "FROM - ${FROM}" >> /dev/stderr
	echo "A - ${A}" >> /dev/stderr
	echo "ANAME - ${ANAME}" >> /dev/stderr
	echo "B - ${B}" >> /dev/stderr
	echo "BNAME - ${BNAME}" >> /dev/stderr
	echo "MOVE - ${MOVE}" >> /dev/stderr

# Do tohoto místa probíhá zpracování stejně pro fore i back
# Následuje další zpracování parametrů - především porovnání ..

# 1, je-li ANAME, stejné jako BNAME, přesun A o jednu pozici vřed či vzad..
#
# 2, je-li FROM stejné jako BNAME, vyhodit dotaz: 
#		Nahradit? nebo akci přerušit?
# Pro MOVE=fore...
# 3f, je-li pozice A o 1 větší než B - skončit 
# 4f, je-li pozice A = 1 skončit 
# 
# Pro MOVE=back...
# 3b, je-li pozice A o 1 menší než B - skončit
# 4b, le-li pozice A = lastpage skončit
#
# Má se přesouvat kupředu
}

# ### <span id="range">range()</span> ([top](#FUNCTIONS))
# Funkce, která zpracuje předaný řetězec do sekvence čísel
# 1,2,3-9,10-20
# Pokud zpracování řetězce proběhne v pořádku je návratový kód __0__,
# v opačném případě __1__.
range() {
    log goto "range() –> ${@}"
    case "${1:0:1}" in
        [[:digit:]]) local INPUTARRAY=( ${1//,/ } )
            for i in ${INPUTARRAY[@]} ; do
                if [[ "$i" =~ "-" ]] ; then
                    seq ${i//-/ }
                else
                    seq ${i} ${i}
                fi
            done | sort -nu
            return 0
        ;;
        *) printf "range: FAIL - range of pages must be set only from order numbers, commas and hyphens.\n" >> /dev/stderr
            return 1
        ;;
    esac
}

function changemeta {
	# Funkce která modifikuje soubor pro vložení meta atributů
	# AUTHOR
	# TITLE
	# SUBJECT
	# NOTE
	# ANNOTATION
	# URL
	# CREATOR
	[ $(grep -c '^CreationDate' ${1}) -eq 0 ] && printf "CreationDate \"%s\"\n" "$(date -u +%FT%T%:z)" >> ${1}
	if [ $(grep -c '^Producer' ${1}) -eq 1 ] ; then
		sed --in-place '/^Producer/,/$/d' ${1}
		printf 'Producer "djvutool 0.1 alpha (http://www.thewoodcraft.org)"\n' >> ${1}
	elif  [ $(grep -c '^Producer' ${1}) -eq 0 ] ; then
		printf 'Producer "djvutool 0.1 alpha (http://www.thewoodcraft.org)"\n' >> ${1}
	fi
	if [ $(grep -c '^ModDate' ${1}) -eq 1 ] ; then
		sed --in-place '/^ModDate/,/$/d' ${1}
		printf "ModDate \"%s\"\n" "$(date -u +%FT%T%:z)" >> ${1}
	elif  [ "$(grep -c ^ModDate $1)" == "0" ] ; then
		printf "ModDate \"%s\"\n" "$(date -u +%FT%T%:z)" >> ${1}
	fi
	printf '##' >> ${1}
	printf '## Toto jsou nejčastěji používané atributy. Budete-li je chtít použít,' >> ${1}
	printf '## stačí zrušit znak # na začátku řádky a doplnit do uvozovek obsah\n' >> ${1}
	printf '## Pokud budete mít nastavenou odpovídající proměnnou, tak se některé doplní.\n' >> ${1}
	[ $(grep -c '^Title' ${1}) -eq 0 ] && printf '#Title "%s"\t# - název zpracovávaného dokumentu\n' "${TITLE}" >> ${1}
	[ $(grep -c '^Author' ${1}) -eq 0 ] && printf '#Author "%s"\t# - jméno autora původního dokumentu, je-li znám\n' "${AUTHOR-unknown}" >> ${1}
	[ $(grep -c '^Subject' ${1}) -eq 0 ] && printf '#Subject "%s"\t# - stručné info o čem to je\n' "${SUBJECT}" >> ${1}
	[ $(grep -c '^Keywords' ${1}) -eq 0 ] && printf '#Keywords " "\t# - klíčová slova, která se vztahují k dokumentu, oddělená čárkou\n' >> ${1}
	[ $(grep -c '^note' ${1}) -eq 0 ] && printf '#note "%s"\t# - poznámka ke stránce\n' "${NOTE}" >> ${1}
	[ $(grep -c '^annote' ${1}) -eq 0 ] && printf '#annote "%s"\t# - stručná anotace obsahu\n' "${ANNOTATION}" >> ${1}
	[ $(grep -c '^url' ${1}) -eq 0 ] && printf '#url "%s"\t# - URL vašeho webu\n' "${URL}" >> ${1}
	[ $(grep -c '^Trapped' ${1}) -eq 0 ] && printf '#Trapped "FALSE"\t# - indikační klíč, který oznamuje zda-li je úprava stránky tímto dokončena (TRUE), nebo ne (FALSE)\n' >> ${1}
	[ $(grep -c '^Creator' ${1}) -eq 0 ] && printf '#Creator "%s"\t# - uvádí se jméno autora, nebo název aplikace ve které vytvořil původní dokument.\n' "${CREATOR}" >> ${1}
	return 0
}

# ### <span id="setmeta">setmeta()</span> ([top](#FUNCTIONS))
# V souboru $1 najít $2, pokud se vyskytuje, tak ho nahradit za $3,
# pokud nevyskytuje, přidat $3 na konec
setmeta() {
    mapfile -d\: -t -c1 ITEM <<< $(grep -n "${2}" "${1}")
    case "${ITEM[0]}" in
        +([[:digit:]])) #/ vyskytuje se
            case "${3}" in
                '') log info "Delete –> $2"
                    ed "${1}" 2>/dev/null <<-EOF
${ITEM[0]}
d
w
q
EOF
                ;;
                *) #/ nahrazuji
                    log info "Replace $2 –> $3"
                    log info "${ITEM[0]}c"
                    ed "${1}" 2>/dev/null <<-EOF
${ITEM[0]}c
${3}
.
w
q
EOF
                ;;
            esac
        ;;
        *) #/ nevyskytuje se
            case "${3}" in
                '')
                ;;
                *) #/ přidám na konec
                    echo "${3}" >> "${1}"
                    log info "Add $3 to end"
                ;;
            esac
        ;;
    esac
    return $?
}

# ### <span id="djvuinfo">djvuinfo()</span> ([top](#FUNCTIONS))
# Prvním parametrem __$1__ je cesta k DjVu souboru a druhým $2 požadovaná
# informace:
#
# * list
# * exif
# * meta
# * pages
# * grep
#
# Pokud není předaná platná hodnota , vrací funkce pouze informaci o typu
# souboru, ev. doplněnou o počet stran či vrstev
djvuinfo() {
    log goto "$1 –> $2"
    case ${2} in
        '') local INFO=($(cat "${1}"|infoitem))
            isbundle "${1}"
            case $? in
                0) local SUMPAGES=$(${DJVM} -l "${1}" | grep PAGE\ # | wc -l)
                 local TEMP=$(${DJVM} -l "${1}" | grep SHARED_ANNO)
                ;;
                2) local SUMPAGES=1
                ;;
                *) local SUMPAGES=error
                ;;
            esac
            if [ -n "${TEMP}" ] ; then
                echo "${INFO[@]} ${SUMPAGES} shared_anno"
            else
                echo "${INFO[@]} ${SUMPAGES}"
            fi
        ;;
        pages) isbundle "${1}"
            case $? in
                0) ${DJVM} -l "${1}" | grep PAGE\ # | wc -l
                ;;
                2) echo 1
                ;;
                *) echo error
                ;;
            esac
        ;;
        list) isbundle "${1}"
            case $? in
                0) ${DJVM} -l "${1}" |\
                    sed -E 's/SHARED_ANNO/#0/ ; s/[[:alnum:][:blank:]]+#// ; /^Size/d ; /^\-/d' | sort -n
                ;;
                2) ${DJVUSED} "${1}" -e 'dump' | grep '{' | grep -v INCL |\
                    awk -F'}' '{print $2,$1}' | \
                    sed -E 's/][[:blank:]]+[[:alnum:]:]+[[:blank:]]+\[[[:digit:]]+\][[:blank:]]+\{/ / ; s/ \[// ; s/^P// ; s/^S/0/' | sort -n
                ;;
                *) echo error
                ;;
            esac
        ;;
        exif) ${EXIFTOOL} "${1}"
        ;;
        meta) $0 "${1}" export meta | awk -F'#' '{print $4,$3}' | grep -v ^\ 
        ;;
        dsed*) log dsed "djvuinfo() –> ${2#dsed+([[:blank:]])}"
            ${DJVUSED} "${1}" -e "${2#dsed+([[:blank:]])}"
        ;;
        grep*) log grep "grep –> ${2#grep+([[:blank:]])}"
            $0 "${1}" info list | \
            while read line ; do
                case "${line%% *}" in
                    O)
                    ;;
                    '') return 1
                    ;;
                    *) local PAGE="${line#* }"
                        local ORDER="${line%% *}"
                        local TEMPORAR=$(${DJVUTXT} "${1}" -page=${ORDER} | ${2} 2>1)
                        if [ -n "${TEMPORAR}" ] ; then
                            echo "# ${PAGE} #[P${ORDER}]"
                            printf "%s\n" "${TEMPORAR}"
                        fi
                    ;;
                esac
            done
        ;;
        *) return 1
        ;;
    esac
    return $?
}

# ### <span id="help">help()</span> ([top](#FUNCTIONS))
#
help() {
    log info "$1"
	case "$1" in
        actions) echo """Implementované akce: """
        ;;
		algorithm) echo """

Binarizační algoritmy ovliňují vygenerování optimální černobílé masky
Utilita DiDjVu podporuje tyto algoritmy:

abutaleb
bernsen
  - region-size=N (1 .. 50, default: 11)
  - contrast-limit=N (0 .. 255, default: 80)
  - doubt-to-black
brink
djvu (default) (vhodný pro černobílé obrázky)
  - smoothness=X (0.0 .. 1.0, default: 0.2)
  - max-block-size=N (default: 512)
  - min-block-size=N (default: 64)
  - block-factor=N (1 .. 8, default: 2)
global
  - threshold=N
niblack
  - region-size=N (default: 15)
  - sensitivity=X (default: -0.2)
  - lower-bound=N (0 .. 255, default: 20)
  - upper-bound=N (0 .. 255, default: 150)
otsu (vhodný pro černobílé obrázky, lepší komprese než u výchozího djvu)
sauvola
  - region-size=N (default: 15)
  - sensitivity=X (default: 0.5)
  - dynamic-range=N (1 .. 255, default: 128)
  - lower-bound=N (0 .. 255, default: 20)
  - upper-bound=N (0 .. 255, default: 150)
shading-subtraction
  - k=N (default: 7)
  - threshold=N
tsai
white-rohrer
  - x-lookahead=N (default: 8)
  - y-lookahead=N (default: 1)
  - bias-mode=N (default: 0)
  - bias-factor=N (default: 100)
  - f-factor=N (default: 100)
  - g-factor=N (default: 100)

Výchozí nastavení algoritmů lze upravit 
		"""
		;;
        bitmap) echo """
        """
        ;;
		bitmap-export) echo """
U bitmapových souborů, které mají podporu pro více stránek (či vrstev)
lze využít export k jejich extrakci a případně i transformaci na jiný
rozměr či konverzi do jiného formátu – včetně DjVu. Viz příklad:

    ${APP} soubor.jpg export jpg 1 30%

Vygeneruje JPEG obrázek s názvem soubor_30%.jpg jehož obsahem bude původní
obrázek ze souboru soubor.jpg, zmenšený na 30% původní velikosti.

U kontejnerů typu zip či tar, které mohou obsahovat obrázky v různých formátech,
lze provést export pouze s uvedením rozsahu. Cílové soubory se pak budou
jmenovat stejně, jako ty v archívu:

    ${APP} soubor.zip export orig 2-7

U bitmapových formátů s podporou více stránek, které mají v sobě uložen
také název vrstvy či stránky, bude mít vyexportovaný soubor stejné jméno
jako byl název příslušné vrstvy či stránky.

    ${APP} soubor.xcf export 2-7

V tomto případě tedy bude výsledkem série šesti souborů ve formátu .xcf,
vytvořených z druhé až sedmé vrstvy souboru soubor.xcf pojmenovaných podle
jejich názvů.

Pokud se mají soubory jmenovat podle jiného vzoru, musí být uveden výchozí
vzorek. Viz příklad:

    ${APP} soubor.xcf export 2-7 soubor

V takovém případě se budou vyexportované soubory jmenovat soubor_00002.xcf
až soubor_00007.xcf

Akci export lze využít i ke konverzi do jiného formátu:

    ${APP} soubor.pdf export 1 jpg

V případě PDF souborů, které mohou obsahovat mix textu a obrázků bude v tomto
případě výstupem jako bitmapový obrázek celá stránka. Pokud však chcete,
aby výstupem byly pouze vložené obrázky (nebo text), je třeba jako výstupní
formát uvést co chcete:

    ${APP} soubor.pdf export 1 images

Není-li řečeno jinak, jsou výsledné soubory v původním rozlišení. Ovšem
při konverzi lze velikost cílového obrázku rovnou přeškálovat:

    ${APP} soubor.pdf export 1 jpg 0.5 example

Tímto způsobem zvolíte, že cílová velikost bude obrázku bude 50% původní
velikosti.

Velikost výsledného souboru také můžete uvést uvedením rozměru cílového
obrázku. V takovém případě ale musíte použít i jeden z následujících
parametrů, kterým určíte jak se má při škálování postupovat:

-xysize přeškáluje obrázek tím způsebem, že použije kratší rozměr a ten
        co bude přesahovat ořízne tak aby výsledek odpovídal velikosti
        vymezeného prostoru a zároveň zůstal zachován poměr stran výchozího
        obrázku
-xyfit  roztáhne obrázek tak aby vyplnil celý uvedený rozměr, poměr stran
        tedy nebude zachován
-xyfill přeškáluje obrázek podle většího rozměru, tak aby se vešel do
        vymezeného prostoru celý a poměr stran při tom zůstal zachován.

Viz příklad:

    ${APP} soubor.pdf export 1 jpg 250x300 -xysize example

Při škálování se automaticky použije volba -nomix, můžete ji ale zaměnit
za konkrétní škálovací filtr. Viz příklad:

    ${APP} soubor.pdf export 1 jpg 250x300 -filter=box example
"""
        echo "Seznam použitelných škálovacích filtrů:"
        printf "\t%s\n" ${FILTERS[@]}
echo """
Ve všech uvedených příkladech jsou výsledné soubory uloženy do adresáře,
ve kterém se ${APP} spouští. Pokud se mají uložit jinam, je třeba uvést
i cílovou  cestu:

    djvutool soubor.pdf export 1 jpg 0.33 example/

V tomto případě se vyexportované stránky nasypou do podadresáře example.
Pokud neexistuje, tak se vytvoří. Pokud se mají soubory při exportu také
přejmenovat, je třeba za lomítkem uvést také příslušný vzor:

    djvutool soubor.pdf export 1 jpg 0.33 example/example

V tomto případě by se tedy výsledný soubor jmenoval example_30%_00001.jpg

Pokud má být číslování jiné než výchozí pětimístné, vypadá vzorek takto:

    djvutool soubor.pdf export 1 jpg 30% example/example_XX
"""
		;;
        bitmap-info) echo """
  ACTION [1minfo[0m

  If isn't subkey, return basic informations about file: Format, dimensions
  of page and for file in multipage format summary count of pages.

  [1m${0##*/}[0m info <file> [ pages | list | meta <num> ]

         num  - order of page (or layer) in file

  SUBKEYS:
         [3mlist[23m - (only multipage file) return list names, or numbers of
                pages from multipage file, or from container 
         [3mmeta[23m - return exif info about page from container or file
        [3mpages[23m - return only sumary count of pages as number

[3mNotice:[23m
  * For [3m'meta'[23m [2minfo[22m different from [2mexport[22m in that output is purified from syntax chars, whose is required for [2mimport[22m.
  * When is passed subkey [3m'exif'[23m with an identificator of page, be export a page into temporary dir and view info only about this page.
  * Subkey [3m'pages'[23m with an identificator of page return only item for this.
        """
        ;;
		bundle) echo """Nápověda pro volbu typu svazku.. ToDo
		"""
		;;
		dpi) echo """
[1mOption:[0m --dpi  <[2mčíslo[22m> Hodnota DPI, která se má použít při zpracování obrázku.
                               při konverzi. Optimální je zjistit hodnotu přímo ze vstupního
                               obrázku. Před nastavením této hodnoty pro finální konverzi. lze vyzkoušet
                               optimální nastavení na některém ze souborů s využitím parametru
                               --test

  Rozsah číselné hodnoty je od 72 do 6000 dpi. Výchozí hodnota 300 se použije 
  v případě, že parametr --dpi není vůbec uveden.
  Vliv dpi na zpracování obrazu..
"""
		;;
		dsed) echo """Option [1m-d[0m ([1m--dsed[0m)

  Extrakce skryté textové vrstvy DjVu stránky ve formátu pro djvused.
  Parametrem lze zvolit, co se má při akci [2mexport[22m uložit.

  [1m${0##*/}[0m ... {-d|--dsed} [yes|no|all|txt|ant] ...
  
         yes - stejný efekt jako volba all
         no  - textová vrstva se neexportuje (default)
         all - exportuje se celý obsah skryté textové vrstvy
         txt - exportuje se pouze obsah stránky
         ant - exportují se meta atributy stránky, hyperlinky, atp.

[4mPoznámka:[24m
  * Pokud za volbou není uveden žádný další parametr, tak se automaticky
    předpokládá - yes.
  * Výchozí parametr - no - lze implicitně změnit nastavením proměnné
    DSED do souboru v adresáři ${HOME}/.config/${NAME}/
  * Exportovaná data se ukládají do souborů s příponou [3m.dsed[23m.
"""
		;;
		existed) echo """
  Soubor $2 existuje. Pokud se má přepsat, musí být
  uveden parametr -f (--force)
"""
		;;
		exporttometa) echo """volba [1m-m[0m ([1m--meta[0m)

  Extrakce DjVu stránky ze svazku

  [1m${0##*/}[0m ... {-x|--xml} [yes|no] ...
  
  Prostřednictvím této volby lze zvolit zda se má, nebo nemá při akci
  [3mexport[23m z DjVu svazku exportovat i celá DjVu stránka. Pokud za volbou
  nenásleduje parametr, pak se automaticky předpokládá že ano (yes).
  Výchozí nastavení (no), lze implicitně změnit prostřednictvím
  uživatelského konfiguračního souboru umístěného v v adresáři:

    ${HOME}/.config/${NAME}/
"""
		;;
		exporttothumb) echo """volba [1m-t[0m ([1m--thumb[0m)

  Extrakce DjVu stránky ze svazku

  [1m${0##*/}[0m ... {-t|--thumb} [yes|no] ...
  
  Prostřednictvím této volby lze zvolit zda se má, nebo nemá při akci
  [3mexport[23m z DjVu svazku exportovat i celá DjVu stránka. Pokud za volbou
  nenásleduje parametr, pak se automaticky předpokládá že ano (yes).
  Výchozí nastavení (no), lze implicitně změnit prostřednictvím
  uživatelského konfiguračního souboru umístěného v v adresáři:

    ${HOME}/.config/${NAME}/
"""
		;;
		force) echo """volba [1m-f[0m ([1m--force[0m)

  Nastavením této volby si lze vynutit výchozí chování k souborům při
  akci [2mexport[22m. Není-li uvedena, tak se skript před každým
  přepsáním již existujícího souboru zeptá, zda-li má, nebo nemá
  pokračovat.

  [1m${0##*/}[0m ... {-f|--force} [yes|no|skip] ...
  
         yes  - všechny soubory se budou bez keců přepisovat.
         no   - skript se před přepsáním souboru bude dotazovat, zda-li
                má soubor přepsat.
         skip - pokud bude cílový soubor existovat, tak se akce přeskočí.

[4mPoznámka:[24m
  * Pokud za volbou není uveden žádný další parametr, tak se automaticky
    předpokládá - skip.
  * Výchozí parametr hodnotu parametru  (skip) - lze implicitně změnit
    nastavením proměnné FORCE v uživatelském konfiguračním souboru.
"""
		;;
		image) echo """volba [1m-i[0m ([1m--img[0m)

  [4mExtrakce obrazové vrstvy[24m DjVu stránky do bitmapového souboru

  [1m${0##*/}[0m ... {-i|--img} [yes|no|<layer>] ...

  Je-li parametrem volby [3myes[23m, tak se bude při akci [2mexport[22m generovat z DjVu
  stránky plnobarevný bitmapový obrázek ve formátu PNG.
  V ostatních případech bude ve formátu PNM.

      [1m${0##*/}[0m --img background svazek.djvu export stranka.djvu
 
Použitelné parametry:
                 color - plnobarevná stránka
                 black - černobílá kresba
            foreground - vrstva popředí
            background - vrstva pozadí
                  mask - maska
  Je-li místo [3m'yes'[23m uvedeno [3m'background'[23m, bude při exportu stránky
  strana.djvu uložen obrázek pozadí pod jménem strana.background.pnm
  Výchozí nastavení lze implicitně změnit nastavením proměnné IMGPAGE
"""
		;;
		indirect) echo"""
[1mVolba[0m
         --indirect Volba, kterou lze změnit výchozí typ vícestránkového 
                    DjVu svazku (bundeled)

  Volbu je třeba aplikovat pokud chcete rozbalit stvávající DjVu svazek 
  do podoby volného svazku, nebo pokud chcete při konverzi bitmapových
  souborů rovnou sestavit DjVu svazek jako volný

  Výhodou volného svazku je, že lze dodatečně upravovat jednotlivé stránky
  jako samostatné DjVu soubory, aniž by je bylo nutné exportovat.

  Pro finalizaci DjVu svazku je pak lepší svazek překonvertovat na typ
  bundled, kdy je vše zabaleno v jednom souboru
"""
		;;
		key) echo """    KEY - name of meta attribute, single word without diacritical chars
          and spaces. Example commonly used keys:
                 [3mTitle[23m - Title of DjVu page or bundle
               [3mCreator[23m - Creator DjVu bundle or DjVu page from scan
          [3mCreationDate[23m - Creation date of DjVu bundle or page
              [3mKeywords[23m - Keywords for indexation DjVu file
                [3mannote[23m - Notes about origin of document & etc."""
		;;
        '') help keywords && help options
        ;;
        keywords) echo """
 DJVUTOOL - nástroj pro práci s obrázky a DjVu soubory

       [1m${0##*/}[0m [volby] {AKCE} [SOUBOR] …
  resp.
       [1m${0##*/}[0m [volby] [SOUBOR] {AKCE} …

Pro podrobnější informace o volbě, akci či atributu, můžete vždy použít volbu [2m-h[22m
Viz příklad, demonstrující výpis nápovědy k volbě -v (verbose):

   [1m${0##*/}[0m -v -h

AKCE
    export - export a konverze bitmapových souborů, jejich vrstev či stránek
             do jiných formátů, včetně DjVu. V případě DjVu souborů lze
             vyexportovat buď obrazovou vrstvu, ve formě bitmapového obrázku,
             nebo obsah textové, či metadatové vrstvy.
      info - zjištuje informace o souboru či stránce
      view - zobrazuje obrazový soubor či některou z jeho stránek.

AKCE specifické pro práci s DjVu soubory:
      edit - editace textové vrstvy DjVu souboru
    delete - odstranění stránky z DjVu svazku
? fore, back - přesuny a import stránek v rámci DjVu svazku
     rotate - změna rotace stránky v DjVu souboru
    import - import do textové vrstvy DjVu svazku (obsah, metadata, text)
? indirect,bundle - mění typ DjVu svazku
?    rename - přejmenování stránek v DjVu svazku dle vzorku
       set - jednorázové nastavení meta atributu
?    unset - zrušení meta atributu

AKCE které nevyžadují žádný soubor:
    coords - přepočítává koordináty .dsed souborů
      help - vypisuje nápovědu
"""
		;;
    keywords-delete) echo """
  ACTION: [1mdelete[0m

  [1m${0##*/}[0m [volby] <svazek> delete RANGE

  Odstraňuje stránky z DjVu svazku. Pozor, akce je [4mnevratná[24m!
"""
        help range
        echo """[4mPoznámky:[24m
  * Při odstraňování stránek je uvedený rozsah setříděn tak, aby se stránky
    odstraňovaly postupně odzadu, tak aby se během odstraňování neměnilo
    jejich pořadové číslo.
  * K odstranění stránky dojde pouze v případě že DjVu soubor tvoří víc než
    jedna stránka.
  * Při odstraňování stránek je bezpečnější používat k identifikaci jména
    stránek, neboť pozice stránky se může v průběhu zpracování DjVu svazku
    měnit, kdežto jméno zůstává vždy v rámci svazku jedinečné.
"""
    ;;
    delete-*) help keywords-delete
        ;;
		keywords-fore) help move
		;;
		keywords-fore1) echo """
  ACTION [1mfore[0m

  Umístění nové stránky, nebo stránky v rámci DjVu svazku již existující před stránku identifikovanou jménem, nebo aktuální pozicí. o pozici vpřed. [4mPřed stránku, která[24m
  [4mji má následovat[24m. V případě, už přesouvaná stránka je na první pozici,
  se nestane nic.

  [1m${0##*/}[0m [volby] <svazek> fore {<num>|<name>|<file>} [<num>|<name>]

         num  - pořadové číslo stránky v DjVu svazku
         name - jméno stránky v DjVu svazku
         file - DjVu soubor nebo naskenovaná stránka v bitmapovém formátu

  Je doporučeno použít jako identifikátor jména stránek, místo jejich 
  aktuální pozice. A to z toho důvodu, že se pozice stránek mohou v průběhu
  zpracování DjVu svazku měnit, kdežto její jméno stránky je vždy v rámci
  svazku jedinečné.
"""
		;;
		keywords-back) echo """
  ACTION [1mback[0m

  Přesun stránky v rámci DjVu svazku o pozici zpět. [4mZa stránku, která[24m
  [4mji má následovat[24m. V případě, už je přesouvaná stránka na poslední pozici,
  se nestane nic.

  [1m${0##*/}[0m [volby] <svazek> back {<num>|<name>} [<num>|<name>]

         num  - pořadové číslo stránky v DjVu svazku
         name - jméno stránky v DjVu svazku

  Je doporučeno použít jako identifikátor jména stránek, místo jejich 
  aktuální pozice. A to z toho důvodu, že se pozice stránek mohou v průběhu
  zpracování DjVu svazku měnit, kdežto její jméno stránky je vždy v rámci
  svazku jedinečné.
"""
		;;
		keywords-edit) echo """
  ACTION [1medit[0m

  Editace textový informací DjVu svazku - meta informace, bookmarks,outline

  [1m${0##*/}[0m <DjVu> edit outline

  [1m${0##*/}[0m <DjVu> edit ant [<num>|<name>|<RANGE>]

         outline - výpis aktuálního obsahu DjVu svazku ve formátu .outline
         meta  - vygenerování šablony pro .outline formát s adresováním
                 stránek podle jejich názvů

         num  - pořadové číslo stránky v DjVu svazku
         name - jméno stránky v DjVu svazku

[3mPoznámka:[23m
  Vygenerovanou šablonu .outline formátu lze upravit editací v libovolném
  textovém editoru. Řádky s nevyužitými položkami je třeba smazat.
  Do dalších úrovní lze položky obsahu zanořit pomocí odsazení řádku
                   1 úroveň = 1 tabulátor = 8 mezer
  Aktuální obsah lze vyexportovat v .outline formátu parametrem print
  Upravený obsah lze do DjVu svazku naimportovat ze souboru přes akci [2mimport[22m,
[1mPozor:[0m Soubor ve formátu .outline musí mít (až na příponu) stejné jméno,
  jako má DjVu svazek do kterého se má vložit, jinak se nenaimportuje!
"""
    help range
    ;;
    keywords-export) echo """
  ACTION: [1mexport[0m

  [1m${0##*/}[0m [volby] <DjVu svazek> export {FORMAT} [RANGE] [TARGET]

FORMAT
      ant - poznámky
      xml - na výstup bude vypsán XML obsah vybraného rozsahu stránek
     dsed - na výstup bude vypsán obsah vybraného rozsahu stránek v dsed formátu
  outline - na výstup bude vypsán obsah DjVu svazku ve formátu pro import
     meta - na výstup budou vypsány meta atributy svazku ve formátu pro import

     color - plnobarevná stránka
     black - černobílá kresba
foreground - vrstva popředí
background - vrstva pozadí
      mask - maska

RANGE
      num - pořadové číslo stránky v DjVu svazku
     name - jméno stránky v DjVu svazku
TARGET
      dir - adresář do kterého má být výstup uložen
      all - předmětem exportu bude obsah celého DjVu svazku

  O tom co bude předmětem exportu rozhoduje typ vstupního souboru, a další 
  volby.

  Je-li je vstupním souborem jiný formát souboru než DjVu, umožňuje export:
  * u vícestránkových dokumentů extrakci jednotlivých stránek
  * jejich konverzi do jiných bitmapových formátů, včetně přeškálování
  * i konverzi do DjVu
  
  Je-li vstupním souborem DjVu dokument, jsou výsledkem exportu soubory,
  které lze po úpravě importovat zpět a tak provádět kupř. textovou korekturu
  jeho původního obsahu, či doplňovat obsah a další metadata.
  
  Export textové vrstvy zajistí volby [3m-x[23m a [3m-d[23m, náhled obrazové vrstvy
  se generuje při volbě [3m-i[23m, a celá stránka v DjVu formátu se exportuje
  při volbě [3m-p[23m.

[4mPoznámky:[24m
  * Pro zpracování single-page DjVu stránek je parametr [3mall[23m doporučený
  * Není-li uveden cílový adresář, budou soubory exporované do adresáře,
    kde byl [1m${0##*/}[0m spuštěn.
  * Přepsání již existujících souborů si lze vynutit volbou [3m--force yes[23m
    Výchozí chování je - [3mskip[23m (existující soubory se znovu neexportují)
"""
    ;;
    export-ant) echo """
Nápověda pro export metainformacé
"""
    ;;
    export-meta) echo """
ACTION [1mexport[0m –> meta

  [1m${0##*/}[0m [volby] <DjVu soubor> export meta [RANGE]

  Vypisuje meta informace z DjVu souboru, včetně jmen a pořadí stránek,
  jejich rozměrů a případně aktuální stav rotace. Viz ukázka výstupu:

   # 'shared_anno.iff' #[S]
   Creator    \"Zpracovatel DjVu svazku\"
   # 'w01.djvu' #[P1] #width=4019 height=4910
   # 'další stránka.djvu' #[P2] #width=3972 height=4904 rotation=2
   CreatorPage2    \"Zpracovatel stránky č. 2\"

SEE ALSO
    [1mexport[0m –> ant, [1minfo[0m –> exif, [1minfo[0m –> meta
"""
    help range
    ;;
    export-outline) echo """
Nápověda pro export obsahu
"""
    ;;
    export-dsed-*) echo """
Nápověda pro export metainformacé
"""
    ;;
    export-xml-*) echo """
Nápověda pro export metainformacé
"""
    ;;
    export-color|\
    export-black|\
    export-background|\
    export-foreground|\
    export-mask) echo """
Nápověda pro export grafické vrstvy
    """
    ;;
    export-line|\
    export-word|\
    export-para) echo """
Nápověda pro export textové vrstvy
    """
    ;;
    export-grep|export-pages|export-exif) help keywords-export
    ;;
		keywords-import) echo """
   ACTION: [1mimport[0m
  [4mImport obsahu textové vrstvy[24m do DjVu souboru

  [1m${0##*/}[0m [volby] <svazek> import [<file>|<dir>]

         file - soubor s obsahem skryté textové vrstvy
         dir  - adresář se soubory s obsahem skryté textové vrstvy

[3mPoznámky:[23m
  * Parametrem akce [2mimport[22m může být buď adresář se soubory, nebo soubor s
    daty k importu
  * Název souboru musí odpovídat názvu svazku (pro gobální metadata), nebo
    názvu stránky, kterou obsahuje, s tím rozdílem, že jeho přípona odpovídá
    typu dat které obsahuje:
          [3m.meta[23m - meta atributy
           [3m.xml[23m - skrytý text obsahu
          [3m.dsed[23m - poznámky, meta atributy a skrytý text obsahu
       [3m.outline[23m - obsah svazku; Pozor! Obsah je součást celého svazku, nemá
                  tedy smysl ho vkládat do single-page DjVu dokumentu.
    K formátu těchto souborů více viz manuál
  * Není-li uveden žádný adresář, ani soubor, tak se předpokládá že se budou
    zpracovávat soubory z aktuálního adresáře
"""
		;;
    keywords-info) echo """
  ACTION [1minfo[0m

  [1m${0##*/}[0m [volby] <DjVu soubor> info [SUBKEY] [-h]

  Vypisuje informace o DjVu souboru. Není-li uveden žádný SUBKEY, vypadá
  výstup jako u následujících ukázek:

  A, DjVu Bundle o 3 stránkách, ovšem bez sdílených metainformací.

        DJVU (multi-page) 3983x4874 3

  B, DjVu Bundle o jedné straně, se sdílenými metainformacemi.

        DJVU (multi-page) 4007x4867 1 shared_anno

  C, DjVu Single.

        DJVU 4019x4910 1

SUBKEY
    pages - vrací celkový počet stran v DjVu svazku
     list - vrací setříděný seznam stránek DjVu svazku
     exif - vypisuje exif informace k DjVu souboru, včetně meta informací
            ze stránek
     meta - vypisuje rozměry stránek DjVu souboru a info o případné rotaci
     dsed - aplikuje nad soubor příkaz předaný utilitě [1mdjvused[0m
     grep - aplikuje na plain textový výstup z DjVu souboru příkaz [1mgrep[0m
            s předanými parametry

[3mPoznámka:[23m
  * Výstupy lze dále zpracovávat přes rouru, nebo používat ve skriptech
"""
    ;;
    info-dsed) echo """
  ACTION [1minfo[0m –> dsed

  [1m${0##*/}[0m [volby] <DjVu soubor> info dsed …

  Řetězec se předá k dalšímu zpracování utilitě djvused
"""
    ;;
    info-exif) echo """
  ACTION [1minfo[0m –> exif

  [1m${0##*/}[0m [volby] <DjVu soubor> info exif

  Vrací exif informace o DjVu souboru – včetně metainformací, pokud je
  obsahuje.
"""
    ;;
    info-grep) echo """
  ACTION [1minfo[0m –> grep

  [1m${0##*/}[0m [volby] <DjVu soubor> info grep …

  Aplikuje příkazy utility grep na výstup textového obsahu DjVu souboru,
  pokud nějaký obsahuje. V případě že nalezený vzorek podmínce příkazu
  vyhoví, tak se – kromě nalezeného vzorku – vypíše také jméno a pořadové
  číslo příslušné stránky v DjVu svazku.
"""
    ;;
    info-list) echo """
  ACTION [1minfo[0m –> list

  [1m${0##*/}[0m [volby] <DjVu soubor> info list

  Vrací seznam všech stránek v DjVu souboru, včetně speciální stránky
  shared_anno.iff, která (pokud se ve svazku vyskytuje) je vždy označena
  jako stránka 0. Výpis pak vypadá takto:

0     shared_anno.iff
1     w03.djvu
2     Příliš žluťoučký kůň.djvu
3     w02.djvu
"""
    ;;
    info-meta) echo """
  ACTION [1minfo[0m –> meta

  [1m${0##*/}[0m [volby] <DjVu soubor> info meta

  Vrací informace o velikosti stránek DjVu souboru, podle pořadí, včetně
  informace o jejich případné rotaci.
"""
    ;;
    info-pages) echo """
  ACTION [1minfo[0m –> pages

  [1m${0##*/}[0m [volby] <DjVu soubor> info pages

  Vrací celkový počet stran v DjVu souboru. V případě DjVu single vrací 1,
  stejně jako v případě DjVu svazku s jednou stránkou.
"""
    ;;
    #/OBSOLETE
    keywords-print) echo """
   Action [1mprint[0m

   Action [2mprint[22m meta attribute keys or outline into stdout

  [1m${0##*/}[0m <DjVu> print outline

  [1m${0##*/}[0m <DjVu> print meta

  [1m${0##*/}[0m <svazek> print <attr>
  [1m${0##*/}[0m <svazek> print {<num>|<name>} [all]
  [1m${0##*/}[0m <svazek> print {<num>|<name>} <attr>

         num  - pořadové číslo stránky v DjVu svazku
         name - jméno stránky v DjVu svazku
         attr - jméno atributu
         all  - klíčové slovo (vypsat vše)

[3mPoznámka:[23m
  Jednotlivé atributy lze nastavovat přes [2mset[22m, více atributů najednou
  lze do DjVu stránky či svazku importovat z externího souboru při
  akci [2mimport[22m. Metadata lze z DjVu souborů také exportovat ([2mexport[22m).
"""
		;;
    keywords-rotate) echo """
  AKCE [1mrotate[0m

  Mění výchozí orientaci stránek v DjVu souboru.

  [1m${0##*/}[0m [option] <DjVu> rotate {VALUE} {RANGE}

Pro nastavení orientace všech stránek na výchozí hodnotu, použijte: 0

  [1m${0##*/}[0m [option] <DjVu> rotate 0 0

  VALUE:
             0 - výchozí orientace (0°)
             1 - otočit stránku o 90° doprava
             2 - otočit stránku o 180° (vzhůru nohama)
             3 - otočit stránku o 90° doleva (na 270°)
          left - rotovat stránku o 90° směrem doleva
         right - rotovat stránku o 90° směrem doprava
           180 - otočit stránku opačně než aktuálně je

Pozor! Je-li uvedeno pouze jedno číslo, je aplikováno zároveň jako nastavení
       rotace i rozsah RANGE.

"""
    help range
    ;;
		keywords-set) echo """
  AKCE [1mset[0m

  Akce je určena pro nastavení metadat a dalších elementů v DjVu souboru
  z příkazové řádky. Přes [2mset[22m lze také dodatečně vlastnosti ELEMENTU
  a jeho ATRIBUTY změnit, ale odstranit se dá pouze při akci [2medit[22m!

  [1m${0##*/}[0m [volby] <DjVu svazek> set [RANGE] {METADATA} …

  [1m${0##*/}[0m [volby] <DjVu svazek> set [RANGE] {ELEMENT} … [: ATRIBUTY ]

METADATA:       
      *key - metadatový klíč (vypisuje se přes exiftools)
     *note - skrytá poznámka v metadatové vrstvě DjVu dokumentu
   outline - položka aktivního obsahu DjVu dokumentu (záložka)
      mode - výchozí zobrazovací mód obrazové vrstvy
background - barva pozadí okna prohlížeče DjVu souboru (djview)
      zoom - výchozí velikost zobrazení stránky

ELEMENTY:
  Jsou prvky, jimiž lze uživatelsky doplnit informační hodnotu původního
  obsahu stránky. Jde kupř. o hyperlinky v textu, zvýrazněné oblasti,
  poznámky, upozornění atp.

     arrow - šipka
      line - čára
      oval - oválné ohraničení oblasti
      poly - ohraničení oblasti polygonem
      rect - ograničení oblasti rámcem
      text - textová poznámka
            
Každý z elementů má své výchozí vlastnosti, které lze v případě modifikovat
nastavením dalších  atributů. Tyto atributy jsou při nastavení elementu od
základních parametrů  odděleny dvojtečkou. Viz příklad:

   … set oval 123 123 123 123 Popis oblasti : border FF0000

ATRIBUTY elementů:
    align               lineclr               textclr
    backclr             none                  width
    border              pushpin               xor
    border_avis         shadow_*

[3mPoznámka:[23m
  Více informací o každém z atributů a použití elemntů či metadat lze
  vypsat tak, že se bezprostředně za ně napíše volba -h.
"""
#		help key
#		help value
#		help range
		;;
    set-arrow) echo """
  ELEMENT [1m${1#set-}[0m

  Šipka, je ve skutečnosti element line, s nastaveným atributem arrow,
  která se pak na stránce zobrazuje jako šipka.

   … set arrow X1 Y1 X2 Y2 DESC : [lineclr COLOR] [width SIZE]

X1 Y1
  Současnice bodu, ze kterého bude šipka vycházet
X2 Y2
  Souřadnice bodu do kterého bude šipka ukazovat

DESC
  Popis k šipce

Použitelné atributy:
  linecrl - barva šipky v RGB
    width - tloušťka čáry šipky
"""
    ;;
    set-backclr) echo """
ATRIBUT [1m${1#set-}[0m
(volitelný prvek)
Barva pozadí prvku. Dává smysl pouze u typu:
    rect - barva orámované plochy a
    text - barva pozadí textu

V případě prvků typu oval, poly, line nebo arrow, se vybarví pravoúhlá plocha
"""
    ;;
    set-background) echo """
  METADATA [1m${1#set-}[0m

  Meta atribut background nastavuje barvu pozadí okna prohlížeče, ve kterém
  se zobrazuje příslušná stránka. Smysl dává především tehdy. je-li vhodné
  barvu pozadí změnit vůči stránce tak, aby dávala lepší barevný kontrast.
  Většinou se nastavuje globálně, ale je možné ho nastavit také pro konkrétní
  stránky.

  [1m${0##*/}[0m [volby] <DjVu svazek> set {RANGE} background {COLOR}

     COLOR - Barva v RGB

Příklad:
 … set set 0 background F8F8F8
 … set set 1,5,10-25 background FF0000

[3mPoznámka:[23m
  Pro globální nastavení barnu pozadí použijte hodnota RANGE nula – 0.
"""
    ;;
    set-+(border|xor|none)) echo """
ELEMENT [1m${1#set-}[0m
Nastavení okraje rámečku

  border <BARVA> - nastaví jinou barvu rámečku (výchozí je černá)
             xor - rámeček je tvořen přerušovanou linkou
            none - vypne zobrazování rámečku úplně

Okraj je zobrazen tenkou linkou, jejíž tloušťku nelze změnit!!!
"""
    ;;
    set-border_avis) echo """
ELEMENT [1m${1#set-}[0m
(volitelný prvek)
border_avis - nastavení viditelnosti prvku

Není-li řečeno jinak, zůstávají elementy typu rect na DjVu stránce skryté – zobrazují se teprve v okamžiku, kdy nad ně najedete myší.
Ovšem v případě prvku, co má být ihned viditelný se takové chování nehodí. Proto existuje tento parametr, kterým se nastaví aby byl
prvek viditelný stále
"""
    ;;
    set-key) echo """
  METADATA [1m${1#set-}[0m



Nastavení, resp. přenastavení klíče:

  [1m${0##*/}[0m <DjVu> set {RANGE} key {KEY} [VALUE]

Zrušení klíče:

  [1m${0##*/}[0m <DjVu> uset {RANGE} key {KEY}

KEY
  Řetězec znaků bez mezer a diakritiky, který nesmí začínat číslem

VALUE
  Hodnota klíče. Vyvarujte se pokud možno použití kulatých závorek!

Příklad použití:

    [1m${0##*/}[0m soubor.djvu set 1,3,7-12 key Creator Thomas Jefferson


[3mPoznámka:[23m
  * I když je to technicky možné, deden klíč nelze na stránce vícekrát než
    jednou. Při pokusu o nastavení klíče s jinou hodnotou VALUE, dojde k
    nahrazení obsahu klíče stávajícího
  * Nastavené klíče se zobrazují jako EXIF informace, proto je doporučeno
    používat jako klíče standardizované exif tagy

Nejčastěji používané exif tagy:
        [3mTitle[23m - Název dokumentu
      [3mCreator[23m - Osoba, která zpracovala sken do DjVu stránky
 [3mCreationDate[23m - Datum pořízení skenu
     [3mKeywords[23m - Klíčová slova pro indexaci DjVu souboru
       [3mannote[23m - Poznámka o původu dokumentu & etc.
  [3mDescription[23m - Popis obsahu dokumentu
       [3mAuthor[23m - Autor dokumentu
     [3mNickname[23m - Přezdívka
  [3mContactInfo[23m - Kontaktní informace na zpracovatele dokumentu
Producer - Zařízení či software na kterém byl spracován sken
CreatorTool - (Zařízení na kterém byl sken či snímek pořízen; případně )
ModDate "" (Čas zpracování do DjVu)
ModifyDate (Čas zpracování do DjVu)
MetadataDate (Čas poslední úpravy metadat v DjVu)

"""
		;;
    set-line) echo """
  ELEMENT [1m${1#set-}[0m

  Linka která se zobrazuje na stránce. Od prvku arrow (šipka) se liší tím,
  nemá nastaveno aby se na jejím konci zobrazovala šipka.

   … set line X1 Y1 X2 Y2 DESC : [lineclr COLOR] [width SIZE]

X1 Y1
  Současnice bodu, ze kterého bude linka vycházet
X2 Y2
  Souřadnice bodu ve kterém bude linka končit

DESC
  Popis k lince

Použitelné atributy:
  linecrl - barva čáry v RGB
    width - tloušťka čáry
"""
    ;;
    set-lineclr) echo """
ATRIBUT [1m${1#set-}[0m
(volitelný prvek)
Nastavení barvy vykreslené čáry. Dává smysl pouze u typu
     line - linka
    arrow - šipka

U prvků rect, oval, poly a text se nastavuje barva linky, co ohraničuje plochu volitelným parametrem border
"""
    ;;
    set-metadata) echo """
METADATA [1m${1#set-}[0m
Nastavení metadatového klíče
"""
    ;;
    set-mode) echo """
  METADATA [1m${1#set-}[0m

 Meta atribut mode umožňuje změnit výchozí zobrazení stránky. Dá se nastavit
 jak globálně pro všechny stránky najednou, tak pro konkrétní stránky.
 Hodí se obzvlástě v situaci, kdy jsou v rámci jednoho DjVu svazku
 zkombinovány stránky zpracované různým způsobe - černobílé i barevné.
 Uživatel si pak nemusí při prohlížení přepínat mód zobrazení manuálně.

 Použít lze buď akci set:

  [1m${0##*/}[0m <DjVu svazek> set [RANGE] mode MODE

MODE
   color - normální barevné zobrazení
      bw - černobílé zobrazení masky
    fore - zobrazení popředí
   black - černobílé zobrazení

Pokud se místo rozsahu, či seznamu stránek RANGE uvede klíčové slovo
'global', bude nastaven tento meta atribut do sdílené metadatové vrstvy.
Tím se zapne nastavená volba jako výchozí pro všechny stránky, u kterých
nebude nastavená jinak. Atribut lze nastavit také při přímé editaci metadat:

  [1m${0##*/}[0m <DjVu svazek> edit ant

Do bloku příslušné stránky přidejte následující řádek
    …
    mode bw
    …
"""
    ;;
    set-note) echo """
ATRIBUT [1m${1#set-}[0m
(volitelný prvek)
none - vypne zobrazování okraje plochy

Anuluje nastavení hodnoty border i boorder_avis
"""
    ;;
    set-none) echo """
ATRIBUT [1m${1#set-}[0m
(volitelný prvek)
none - vypne zobrazování okraje plochy

Anuluje nastavení hodnoty border i boorder_avis
"""
    ;;
    set-outline) echo """
  METADATA [1m${1#set-}[0m

 Záložky (outline), patří mezi metadata. V prohlížeči DjVu souborů se zobrazují
 jako rozbalovací víceúrovňové menu odkazů na interní stránky resp. externí linky.
 Jednotlivou záložku lze nastavit prostřednictvím akce set:

  [1m${0##*/}[0m [volby] <DjVu svazek> set outline {TARGET} {DESC}

    TARGET - Cíl záložky. Externí link (řetězec začínající http://…), pořadí (číslo),
             či jméno stránky v DjVu souboru (např. p0003.djvu)
      DESC - Popis záložky

Příklady:
 … set outline 1 Záložka odkazující na stránku č. 1
 … set outline jmeno_stranky.djvu Záložka odkazující na interní stránku jménem
 … set outline http://example.org Záložka odkazující na externí web

[3mPoznámka:[23m
 * Záložky, jejich pořadí či úroveň zanoření lze upravit při akci [2medit[22m.
 * Záložky lze přes akci [2mexport[22m vyexportovat v [3m.outline[23m či [3m.dsed[23m formátu
 * Soubor v [3m.outline[23m formátu lze upravit editací v libovolném textovém editoru.
   Prázdné řádky je třeba smazat. Na rozdíl od nastavení záložky přes akci set,
   je v .outline formátu na řádce vždy nejprve uveden popis (DESC) a teprve pak
   následuje cíl (TARGET), kterému předchází znak #
   Každá z nich je uzavřena v závorkách. Do nižsí úrovně vůči předchozí záložce
   lze záložku zanořit odsazení celého obsahu řádku tabulátorem:
                   1 úroveň = 1 tabulátor = 8 mezer
 * Záložky lze naimportovat buď ze souboru ve formátu [3m.outline[23m přes akci [2mimport[22m,
  nebo přes [1mdjvused[0m (formát  [3m.dsed[23m)
"""
    ;;
    set-oval) echo """
ELEMENT [1m${1#set-}[0m
Nastavení oválné (kruhové) plochy
Default:

barva a typ okraje - černá, přerušovaná linka (xor) 
barvu a průhlednost plochy - průhledná (nelze změnit) 
URL - aktivní

    oval 0 0 50 50

Nakreslí kružnici o poloměru 50 pixelů, která bude umístěna v levém dolním
rohu.
První souřadnice udávají x,y souřadnice výchozího bodu, od kterého se pak
odměří X,Y součadnice středu kružnice.

    oval 350 125 100 100

Vykreslí kružnici o poloměru 100px, co bude mít střed na absolutních
souřadnicích 450 225

"""
    ;;
    set-+(pfoot|phead)) echo """
METADATA [1m${1#set-}[0m
Záhlaví a zápatí

Většina prohlížečů je neumí zobrazit. Je tedy zbytečné je nastavovat.
"""
    ;;
    set-poly) echo """
ELEMENT [1m${1#set-}[0m
Polynomický obrys plochy
Default:
barva a průhlednost plochy - průhledná. Obarvit lze pouze pravoúhlou plochu ve které je polynom vepsaný

Použitelné parametry:
  [border_avis]
  [none|border c] 
"""
    ;;
    set-rect) echo """
ELEMENT [1m${1#set-}[0m
Nastavení pravoúhlé plochy
    rect 0 0 50 50

Nakreslí čtverec o straně 50x50 pixelů, jehož levý dolní roh bude na souřadnicích
x,y a pravý horní se odměří jako vzdálenost X,Y

    rect 350 125 100 100

Vykreslí čtverec o straně 100x100 pixelů, co bude mít střed na absolutních
souřadnicích 450 225

Vykreslení pomocí djvutxt:
want@schroeder:~$ djvutxt -detail=line -page=1 b.djvu | grep SEIFERT
  (line 281 498 776 535 \"MILOŠ SEIFERT \")

 ­… set 1 area rect 281 498 $((535-281)) $((776-498)) Miloš Seifert, zakladatel LLM

Nejdřív přes info grep zjistit souřadnice textu

"""
    ;;
    set-shadow_+(in|out|ein|eout)) echo """
ATRIBUT [1m${1#set-}[0m

Nastavení velikosti stínu u pravoúhlého rámečku

  shadow_in - vnitřní plocha rámečku vypadá jako zahloubená dovnitř
 shadow_out - vnitřní plocha rámečku vypadá jako vystouplá ven
 shadow_ein - vnější okraj rámečku vypadá jako zahloubený dovnitř
shadow_eout - vnější okraj rámečku vypadá jako vystouplý ven

Nastavení libovolného parametru okraje (none, xor, nebo border) aplikaci stínu vyloučí!!!
"""
    ;;
    set-text)  echo """
ELEMENT [1m${1#set-}[0m
Nastavení pravoúhlé plochy
    text 0 0 50 50
         X Y W H
Do obdélníku o rozměrech WxH, s levým dolním rohem na souřadnicích XxY
vepíše text. Velikost písma upraví dle množství textu v rámci
"""
    ;;
    set-textclr) echo """
ATRIBUT [1m${1#set-}[0m
(volitelný prvek)
Barva textu - Dává smysl pouze u typu text

V případě prvků rect, oval, poly, line a arrow je tento parametr zbytečný, protože se u nich žádný text nezobrazuje
"""
    ;;
    set-width) echo """
ATRIBUT [1m${1#set-}[0m
    (volitelný prvek)
width - Nastavení šířky čáry (šipky). Celé číslo od 1 do 999
"""
    ;;
    set-zoom) echo """
  METADATA [1m${1#set-}[0m

  Meta atribut zoom umožňuje změnit výchozí velikost zobrazovaných stránek.
  Většinou se nastavuje globálně, ale je možné ho nastavit také pro konkrétní
  stránky. To se může hodit, pokud jsou v rámci jednoho DjVu svazku umístěné
  různě velké stránky.

  Meta atribut background nastavuje barvu pozadí okna prohlížeče, ve kterém
  se zobrazuje příslušná stránka. Smysl dává především tehdy. je-li vhodné
  barvu pozadí změnit vůči stránce tak, aby dávala lepší barevný kontrast.
  Většinou se nastavuje globálně, ale je možné ho nastavit také pro konkrétní
  stránky.

  [1m${0##*/}[0m [volby] <DjVu svazek> set {RANGE} zoom {SIZE}

SIZE
  stretch - roztáhne stránku podle okna
  one2one - zobrazení 1:1
    width - na maximální šířku stránky
     page - celá stránka
 d1-99999 - velikost stránky v procentech
     

Příklad:
 … set set 0 zoom stretch
 … set set 1,5,10-25 zoom 150d

[3mPoznámka:[23m
  * Pro globální nastavení velikosti stránky použijte hodnotu RANGE nula – 0.
  * Bohužel většina prohlížečů s tímto parametrem (ani djview), ale plugin
    založený na djvulibre ano.
"""
    ;;
		level) echo """
[1mParametr[0m
         -l|--level  <[2mčíslo[22m> Hodnota akceptovatelných ztrát u černobílé kresby
                               při konverzi. Před nastavením této hodnoty vyzkoušejte
                               optimální nastavení na některém ze souborů a s parametrem
                               --test

  Kromě číselné hodnoty, která musí být menší než 200 lze úroveň ztrát
  nastavit i pomocí některého z následujících parametrů - v případě že 
  jich bude uvedeno víc, má prioritu poslední z nich.

        --lossless     0 - žádné ztráty (default)
        --clean        1 - ignorují se body o velikosti 1 pixelu
        --lossy        100 - ignorují se plochy
"""
		;;
		move) echo """akce [1mfore[0m a [1mback[0m
  [4mUmožňují přesunout stránku v rámci DjVu svazku [24m na jinou pozici, či
  [4mvložit[24m na tuto pozici  [4mstránku novou [24m, je-li prvním parametrem akce
  místo identifikátoru stránky v DjVu svazku soubor.

  [1m${0##*/}[0m [volby] <svazek> {fore|back} {<num>|<name>|<file>} [<num>|<name>]

         num  - pořadové číslo stránky v DjVu svazku
         name - jméno stránky v DjVu svazku
         file - jméno DjVu souboru, nebo skenu

[3mPoznámka:[23m
  * Je-li souborem nekonvertovaný bitmapový obrázek, určí co vše bude
    obnášet konverze předané volby.
  * Není-li určena indentifikátorem cílová pozice, bude stránka přesunuta
    při akci [2mfore[22m o pozici vpřed, nebo vzad - při akci [2mback[22m.
  * Je-li při akci [2mfore[22m vložena ze souboru nová stránka a není uveden
    identifikátor cílové pozice, bude stránka vložena na první pozici
    DjVu svazku. Při akci [2mback[22m) se připojí na konec.
  * Pokud se již v DjVu svazku nalézá stránka se stejným názvem jako má
    vkládaný soubor, vyskytuje, dojde při jeho vložení automaticky k
    přejmenování - za název se přidá podtržítko a pořadové číslo.
"""
		;;
		ocr) echo "Nápověda k OCR - ToDo"
		;;
		options) echo """Options:
    -a|--algorithm Algorithm for separating mask of image (fore or back)
xx  -b|--bundle    Setting type of DjVu bundle
    -d|--dsed      Export hiddent text layer in native code for DjVused
       --dpi       DPI input image for import (actions fore or back)
    -f|--force     Force action
       --clean     Params for convert image to DjVu with separate layers
       --lossy
       --lossless
       --level
    -h|--help      Main options for help about option, or action
    -i|--image     Export .png image of page for use with DjVuWebEd
??  -m|--meta      Export meta attributes from DjVu file
    -o|--ocr       Application OCR
    -p|--page      Export single DjVu page from bundle
    -r|--rename    Pattern for action rename 
xx  -t|--thumb     Creating thumbnails in DjVu bundle
    -v|--verbose   
    -x|--xml       Export hiddent text layer (XML) for use with DjVuWebEd"""
		;;
		page) echo """volba [1m-p[0m ([1m--page[0m)

  Extrakce DjVu stránky ze svazku při akci [2mexport[22m

  [1m${0##*/}[0m ... {-p|--page} [yes|no] ...
  
[4mPoznámka:[24m
  * Pokud za volbou není uveden žádný další parametr, tak se automaticky
    předpokládá - yes.
  * Výchozí parametr - no - lze implicitně změnit nastavením proměnné
    PAGE do souboru v adresáři ${HOME}/.config/${NAME}/
  * Exportované stránky se ukládají pod svým původním názvem.
"""
		;;
    range) echo """RANGE
    Stránky lze identifikovat buď jménem nebo aktuální pozicí v rámci DjVu
    souboru. Pokud chceme identifikovat více stránek najednou, lze použít
    buď seznam jmen stránek, oddělených čárkou:

                        … 'name_1.djvu,name_23.djvu,name_4.djvu'

    Nebo seznam jejich pořadových čísel v souboru. Přičemž pomlčka
    identifikuje rozsah od-do:
                        … 1,10,4-5
[4mPoznámka:[24m
  * Před realizací akce se na základě jmen v seznamu vytvoří rozsah pořadí
    stránek v souboru, který se následně setřídí. Nezáleží tedy na tom, v
    jakém pořadí byly stránky, či jejich pořadová čísla předány.
  * Jména stránek co v DjVu svazku neexistují se při zpracování ignorují
"""
        ;;
		rename) echo """ volba [1m-r[0m, [1m--rename[0m
 Nastavení vzorku, podle jakého se mají pojmenovat, nebo přejmenovat DjVu soubory v DjVu svazku.

Lze využít parametr %01d pro nastavení počtu znaků v číslování stránky, při konverzi vícestránkových bitmapových souborů (tiff, png, xcf)

[4mPopis:[24m
  Pomocí [2mvzoru[22m lze upravit názvy zkonvertovaných DjVu souborů
  před jejich sestavením do DjVu svazku. [2mVzor[22m může být tvořen:
    1, Pouze jednou, nebo více nulami - 000
    2, Nebo řetězcem, následovaným nulami - soubor_00

[3mPoznámka:[23m
  Je-li uvedena pouze jedna nula, budou stránky očíslovány [4mnumericky[24m,
  t.j. od čísla 1 dále. Je-li nul více, pak bude číslo interpretováno
  jako [4mřetězec[24m. tedy 001 a dále. Pokud by číslování stránek přesáhlo
  nastavený počet čísel, bude upraven dle maximálního čísla.

[3mUkázkové vzory : a výsledný efekt..[23m
   soubor-0000 : soubor-0001.djvu .. soubor-0123.djvu
   soubor_0    : soubor_1.djvu    .. soubor_123.djvu
   soubor000   : soubor0001.djvu  .. soubor1234.djvu
"""
			;;
		suffix) echo """
[1mParametr[0m
         -e|--ext  <[2msuffix[22m>  Přípona souborů, ze kterých se má sestavit 
                                DjVu soubor.
[4mPopis:[24m
  [2mSuffix[22m je nutné uvést pouze v případě, že soubory s názvem odpovídajícím
  vzorku dosud nebyly do DjVu zkonvertovány. Jinak se vždy předpokládá, že
  se bude pracovat s již konvertovanými DjVu soubory.

  Je-li [2msuffix[22m uveden, budou konvertovány soubory vyhovující vzorku.
  Pokud některé z nich již konvertovány byly, tak se se fáze konverze
  přeskočí. Pracuje se pak s již existujícím DjVu souborem.

  Konvertovány jsou pouze soubory, které chybí. Kvalitu konverze lze
  ovlivnit  dalšími parametry. Mají-li být soubory překonvertovány znovu,
  lze si to vynutit parametrem -f (--force) a stávající soubory  přepsat.

  Akceptované sufixy: 
     djvu (default), jpg, gif, png, bmp, pnm, pbm, pgm.
  Vícevrstvé soubory:
     xcf, tiff, pdf 
"""
			;;
		value) echo """  VALUE - is normal text string in quotes"""
		;;
		verbose) echo """volbu [1m-v[0m ([1m--verbose[0m)
  Prostřednictvím této volby si lze přesměrovat výstup doplňujících
  informačních výpisů na konzoli. Díky nim pak lze podrobně sledovat
  postup skriptu při zpracování souboru

  [1m${0##*/}[0m ... {-v|--verbose} ...
"""
		;;
		xml) echo """volba [1m-x[0m ([1m--xml[0m)

  Extrakce skryté textové vrstvy DjVu stránky ve formátu XML.
  Parametrem lze zvolit, co se má při akci [2mexport[22m uložit.

  [1m${0##*/}[0m ... {-d|--dsed} [yes|no|all|txt|ant] ...
  
         yes - stejný efekt jako volba all
         no  - textová vrstva se neexportuje (default)
         all - exportuje se celý obsah skryté textové vrstvy
         txt - exportuje se pouze obsah stránky
         ant - exportují se meta atributy stránky

[4mPoznámka:[24m
  * Pokud za volbou není uveden žádný další parametr, tak se automaticky
    předpokládá - yes.
  * Výchozí parametr - no - lze implicitně změnit nastavením proměnné
    XML do souboru v adresáři ${HOME}/.config/${NAME}/
  * Exportovaná data se ukládají do souborů s příponou [3m.xml[23m.

[1mPozor:[0m  Při exportu do XML nelze podchytit všechny meta atributy!!!
"""
		;;
        *) echo "Nápověda pro $1 nebyla dosud implementována" >> /dev/stderr
            return 1
        ;;
	esac
}

# ### <span id="djvuview">djvuview()</span> ([top](#FUNCTIONS))
# Funkce na základě předaného jména (parametr __$1__) a zvolených
# enkodovacích algoritmů otevře prohlížeč DjVu souborů, aby bylo možné
# provést vizuální srovnání kvality zkonvertovaných souborů
djvuview() {
    log goto "djvuview() Open –> $@"
    while [ $# -gt 0 ] ; do
        local TYPE=$(mimefile "${1}")
        case "${TYPE}" in
            djvu) (${DJVIEW} "${1}" &) ;;
            *) echo "File ${1} is not DjVu file" >> /dev/stderr ;;
        esac
        shift
    done
}

# TODO - insert
function todjvuclassic {
    RANDOMKEY=$[ 8000 + $[ RANDOM % 1000 ]]
    TEMP_DIR="${TEMPDIR}/$WINDOWID$BASHPID$RANDOMKEY"
    mkdir $TEMP_DIR
    TEMP_IMG="$TEMP_DIR/temp.ppm"
    TEMP_MASK="$TEMP_DIR/mask.pbm"
    DJVU_MASK="$TEMP_DIR/mask.djvu"

    case ${1##*.} in
        tiff|tif) KONVERT="${TIFFTOPNM}";;
        png) KONVERT="${PNGTOPNM}";;
        jpg) KONVERT="${JPEGTOPNM}" ;;
    esac

    $KONVERT $1 | tee $TEMP_IMG | ${PPMTOPGM} | ${PGMTOPBM} -threshold -value 0.${3-5} | ${PNMTOPLAINPNM} > $TEMP_MASK;
    ${CJB2} -lossy -clean $TEMP_MASK $DJVU_MASK;
    ${DJVUMAKE} ${1/.png/.djvu} Sjbz=$DJVU_MASK PPM=$TEMP_IMG;
    getocr ${1/.png/.djvu}
    rm -rf $TEMP_DIR
}

# Zpracování parametrů předaných při startu skriptu
main() {
case $# in
    0) help  && return 0
esac
while [ $# -gt 0 ]
do
    case ${1} in
        coords) case "$@" in
                coords+([[:blank:]])+([[:digit:]])+([[:blank:]])+([[:digit:]])+([[:blank:]])+([[:digit:]])+([[:blank:]])+([[:digit:]]))
                echo "${2} ${3} $((${4} - ${2})) $((${5} - ${3}))"
                ;;
                coords+([[:blank:]])+([[:digit:]]),+([[:digit:]]),+([[:digit:]]),+([[:digit:]]))
                # LEFT,TOP,SIRKA,VYSKA
                local TEMP=(${@//,/ })
                echo "${TEMP[3]},${TEMP[4]},${TEMP[1]#*+([[:blank:]])},${TEMP[2]}"
                ;;
                coords+([[:blank:]])+([[:digit:]])x+([[:digit:]])\++([[:digit:]])\++([[:digit:]]))
                #SIRKAxVYSKA+LEFT+TOP
                local TEMP=(${@//[x+]/ })
                echo "${TEMP[3]},${TEMP[4]},${TEMP[1]#*+([[:blank:]])},${TEMP[2]}"
                ;;
            esac
            return 0
            ;;
        help) echo "Otevřít ke čtení externí manuál"
            return 0
        ;;
        -a|--algorithm) #/ Volba pro akci insert
            #/ Není-li uveden žádný kompresní algoritmus, je aplikováno
            #/ výchozí nastavení proměnné $ALG z konfigurace"
            case ${2} in
                -h|--help) help algorithm
                    exit 0
                    ;;
                *) for i in ${2//;/ } ; do
                    if [[ ${ALGORITHM[@]} =~ (^|[^[:alpha:]])${i%:*}([^[:alpha:]]|$) ]] ; then
                        log info "main() Verify algorithm $i –> OK"
                    else
                        printf "Algorithm %s isn't supported\n" "$i" 1>&2
                        exit 0
                    fi
                    done
                    ALG=(${2//;/ })
                    log set "main() Compression algorithm –> ${ALG[@]}"
                    shift && shift
                    ;;
            esac
            ;;
        -d|--dsed) # Volba pro akci export
            case ${2} in
                -h*|--help*) help dsed && exit 0
                    ;;
                yes|no|txt|ant|all) DSED=${2}
                    log info "main() Aplikuji pro DSED parametr - ${DSED}"
                    shift && shift
                    ;;
                *) log warn "main() Nebyl uveden žádný parametr, aplikuji pro DSED parametr - yes"
                    DSED="yes"
                    shift
                    ;;
            esac
            ;;
        --dpi) # Volba pro akci insert
            case ${2} in
                -h*|--help*) help dpi && exit 0
                    ;;
                [[:digit:]])
                    if [ "${2}" -ge "72" ] && [ "${2}" -le "6000" ] ; then
                        DPI="${2}"
                        log info "main() Aplikuji pro DPI parametr - ${DPI}"
                        shift && shift
                    else
                        echo "Hodnota u volby --dpi se musí pohybovat v rozmezí od 72 do 6000" >> /dev/stderr
                        exit 1
                    fi
                    ;;
                *) echo "Nebyla uvedena hodnota dpi. Pokud chcete volbou --dpi změnit výchozí hodnotu (300), musíte ji uvést jako číselný parametr" >> /dev/stderr
                    exit 1
                    ;;
            esac
            ;;
        -f|--force)
            case ${2} in
                -h*|--help*) help force && exit 0
                    ;;
                yes|no|skip) FORCE=${2}
                    log info "main() Aplikuji pro FORCE parametr - ${FORCE}"
                    shift && shift
                    ;;
                *) log warn "main() Nebyl uveden žádný parametr, aplikuji pro FORCE parametr - skip"
                    FORCE="yes"
                    shift
                    ;;
            esac
            log set "main() FORCE –> ${FORCE}"
            ;;
        --clean) LEVEL="--loss-level=1" && shift
            ;;
        --lossy) LEVEL="--loss-level=100" && shift
            ;;
        --lossless) LEVEL="--loss-level=0" && shift
            ;;
        --level) # Volba pro akci insert
            case ${2} in
                -h*|--help*) help force && exit 0
                    ;;
                [[:digit:]])
                    if [ "${2}" -ge "0" ] && [ "${2}" -lt "200" ] ; then
                        LEVEL="--loss-level=${2}"
                        log info "main() Aplikuji pro LEVEL hodnotu - ${LEVEL}"
                        shift && shift
                    else
                        help level && exit 0
                    fi
                    ;;
                *) echo "main() Volba --loss-level musí mít vždy uvedenou číselnou hodnotu v rozmezí 0-199" >> /dev/stderr
                    exit 1
                    ;;
            esac
            log info "main() Úroveň ztrátovosti při kompresi ${LEVEL}"
            ;;
        -i|--image) # Volba pro akci export
            case "${2}" in
                -h*|--help*) help image && exit 0
                    ;;
                yes|no|color|black|foreground|background|mask)
                    IMG="${2}"
                    log info "main)) Aplikuji pro IMG parametr - ${IMG}"
                    shift && shift
                    ;;
                *) log warn "main() Nebyl uveden žádný parametr, aplikuji pro IMG parametr - yes"
                    IMG="yes"
                    shift
                    ;;
            esac
            ;;
        -m|--meta) # Volba pro akci export
            case "${2}" in
                -h*|--help*) help meta && exit 0
                    ;;
                yes|no) META="${2}"
                    log info "main() Aplikuji pro META parametr - ${META}"
                    shift && shift
                    ;;
                *) META="yes"
                    log warn "main() Nebyl uveden žádný parametr, aplikuji pro META parametr - yes"
                    shift
                    ;;
            esac
            ;;
        -o|--ocr) # Volba pro akci insert
            case "${2}" in
                -h*|--help*) help ocr
                    ${TESSERACT} --list-langs 2>&1 | sed -n '1!p'
                    exit 0
                    ;;
                *)
#			echo $(${TESSERACT} --list-langs 2>&1 | sed '1d;x') >> /dev/stderr
                for i in ${2//+/ } ; do
                    local TEST="no"
                    local OCR=(${i//:/\ })
                    if [ "${#OCR[@]}" -eq 2 ] ; then
                        # ${OCR[0]} engine
                        # ${OCR[1]} jazyk
                        case "${OCR[0]:0:1}" in
                            c) CUNEIFORM=$(command -v cuneiform)
                                [ ! -x "${CUNEIFORM}" ] && exit 31
                                if [ "${OCR[1]}" == "?" ] ; then
                                    ${CUNEIFORM} -l
                                    exit 0
                                else
                                    local LANGUAGES=($(${CUNEIFORM} -l | grep languages | sed 's/^[a-Z ]*://'))
                                    if [[ ${LANGUAGES[@]} =~ (^|[^[:alpha:]])$y([^[:alpha:]]|$) ]] ; then
                                        OCRLANG=$y && local TEST="yes"
                                        log info "main() OCR lang –> $y"
                                    fi
                                fi
                                ;;
                            t) TESSERACT=$(command -v tesseract)
                                [ ! -x "${TESSERACT}" ] && exit 31
                                if [ "${OCR[1]}" == "?" ] ; then
                                    ${TESSERACT} --list-langs
                                    exit 0
                                else
                                    local LANGUAGES=($(${TESSERACT} --list-langs 2>&1 | sed -n '1!p'))
                                    if [[ ${LANGUAGES[@]} =~ (^|[^[:alpha:]])$y([^[:alpha:]]|$) ]] ; then
                                        OCRLANG=$y && local TEST="yes"
                                        log info "main() OCR lang –> $y"
                                    fi
                                fi
                                ;;
                            *) help keywords-convert-ocr
                                exit 0
                                ;;
                        esac
                    elif [ "${#OCR[@]}" -eq 1 ] ; then
                        # ${OCR[0]} jazyk
                        # výchozí engine je tesseract
                        TESSERACT=$(command -v tesseract)
                        [ ! -x "${TESSERACT}" ] && exit 31
                        if [ "${OCR[0]}" == "?" ] ; then
                            ${TESSERACT} --list-langs
                            exit 0
                        else
                            local LANGUAGES=($(${TESSERACT} --list-langs 2>&1 | sed -n '1!p'))
                            if [[ ${LANGUAGES[@]} =~ (^|[^[:alpha:]])$y([^[:alpha:]]|$) ]] ; then
                                OCRLANG=$y && local TEST="yes"
                                log info "main() OCR lang –> $y"
                            fi
                        fi
                    else
                        help keywords-convert-ocr
                        exit 0
                    fi
                    echo "OCR ${#OCR[@]}" >> /dev/stderr
                    echo "OCRLANG ${OCRLANG}" >> /dev/stderr
                    echo "TESSERACT ${TESSERACT}" >> /dev/stderr
                    echo "CUNEIFORM ${CUNEIFORM}" >> /dev/stderr
                    if [ "${TEST}" == "no" ] ; then
                        echo "Pro OCR engine $i není nainstalovanájazyková podpora" >> /dev/stderr
#					exit 1
                    fi
                done

                if [ "${TEST}" == "yes" ] ; then
                    OCR="${2%%+([[:blank:]])}"
                    log info "main() Aplikuji pro OCR parametr - ${OCR}"
                    shift && shift
                else
                    OCR="${OCR=ces}"
                    echo "Nebyl uveden žádný parametr, pro OCR použiji výchozí jazyk - ${OCR}" >> /dev/stderr
#				exit 1
                    shift
                fi
                ;;
            esac
            ;;
        -p|--page) # Volba pro akci export
            case "${2}" in
                -h*|--help*) help page && exit 0
                    ;;
                yes|no) PAGE="${2}"
                    log info "main() Aplikuji pro PAGE parametr - ${PAGE}"
                    shift && shift
                    ;;
                *) log warn "main() Nebyl uveden žádný parametr, aplikuji pro PAGE parametr - yes"
                    PAGE="yes"
                    shift
                    ;;
            esac
            ;;
        -r|--rename) # Nastavení vzoru pro pojmenování stránek při akcích rename, fore a back
            case "${2}" in
                -h*|--help*) help rename && exit 0
                ;;
                *) if [ "${2##+([[:alnum:]%_-])}" == "" ] ; then
                    RENAME="${2}"
                    log info "main() Aplikuji pro RENAME parametr - ${RENAME}"
                    shift && shift
                else
                    echo "main() FAIL - pattern '${VALUE}' for rename is is not acceptable." >> /dev/stderr
                    exit 1
                fi
            ;;
            esac
        ;;
        -t|--thumb) # Volba pro akci insert
            case "${2}" in
                -h*|--help*) help thumb && exit 0
                    ;;
                *) if [ "${2//+([[:digit:]])}" == "" ] ; then
                        if [ "${2}" -ge "32" ] && [ "${2}" -le "256" ] ; then
                            THUMB="${2%%+([[:blank:]])}"
                            log info "main() Aplikuji pro THUMB parametr - ${DPI}"
                            shift && shift
                        else
                            echo "Hodnota u volby --thumb se musí pohybovat v rozmezí od 32 do 256" >> /dev/stderr
                            exit 1
                        fi
                    else
                        echo "Nebyla uvedena hodnota velikosti náhledu. Pokud chcete volbou --thumb nastavit výchozí hodnotu, musíte ji uvést jako číselný parametr" >> /dev/stderr
                        exit 1
                    fi
                    ;;
            esac
            ;;
        -v*|--verbose*) #/ Změna výchozí hodnoty proměnné $DEBUG
            case ${1} in
                -v|--verbose)
                    case ${2} in
                        -h|--help|help|\?)
                            help verbose && exit 0
                            ;;
                        [0-9])
                            DEBUG="-d${2}"
                            shift && shift
                            ;;
                        *) DEBUG="-d1"
                            shift
                            ;;
                    esac
                    ;;
                -v[0-9])
                    DEBUG="-d${1:2}"
                    shift
                    ;;
                *=*)
                    case "${1#*=}" in
                        0) shift
                            ;;
                        [1-9]) DEBUG="-d${1#*=}"
                            shift
                            ;;
                        *) help_debug "${1#*=}" && exit 1
                            ;;
                    esac
                    ;;
            esac
            log set "DEBUG –> ${DEBUG}"
            ;;
        -x|--xml) # Volba pro akci export
            case "${2}" in
                -h*|--help*) help xml && exit 0
                    ;;
                yes|no|txt|ant|all) XML="${2%%+([[:blank:]])}"
                    log info "main() Aplikuji pro XML parametr - ${XML}"
                    shift && shift
                    ;;
                *) log warn "main() Nebyl uveden žádný parametr, aplikuji pro XML parametr - yes"
                    XML="yes"
                    shift
                    ;;
            esac
            ;;
            *.[dD][jJ][vV][uU]|\
            *.[gG][iI][fF]|\
            *.[jJ][pP][gG]|\
            *.[jJ][pP]2|\
            *.[zZ][iI][pP]|\
            *.[pP][nN][gG]|\
            *.[pP][nNpPgGaAbB][mM]|\
            *.fore|\
            *.[pP][cC][dD]|\
            *.[mM][nN][gG]|\
            *.[pP][dD][fF]|\
            *.[tT][aA][rR]|\
            *.[tT][iI][fF][fF]|\
            *.[tT][iI][fF]|\
            *.[xX][cC][fF])
                local FILE=$(realpath -P "${1}")
                [ ! -n "${FILE}" ] && echo "Invalid filepath ${1}" && exit 1
                shift
                if [[ ${ACTIONS[@]} =~ (^|[^[:alpha:]])${1}([^[:alpha:]]|$) ]] && [ "?" != "${1}" ]; then
                    ACTION=${1}
                    shift
                    local CHARSTRING="$@"
                    log info "ACTION –> ${ACTION}"
                    log info "CHARSTRING –> ${CHARSTRING}"
                    break
                else
                    case ${1} in
                        -h|--help|help|?) help actions
                            printf "\t"
                            printf "%s " ${ACTIONS[@]}
                            help keywords
                            return 0
                        ;;
                        *) echo "Neimplementovaný parametr" >> /dev/stderr
                            return 1
                        ;;
                    esac
                fi
                ;;
        *) if [[ ${ACTIONS[@]} =~ (^|[^[:alpha:]])${1}([^[:alpha:]]|$) ]] && [ "?" != "${1}" ]; then
                ACTION=${1}
                shift
                case ${1} in
                    *.[dD][jJ][vV][uU]|\
                    *.[gG][iI][fF]|\
                    *.[jJ][pP][gG]|\
                    *.[jJ][pP]2|\
                    *.[zZ][iI][pP]|\
                    *.[pP][nN][gG]|\
                    *.[pP][nNpPgGaAbB][mM]|\
                    *.fore|\
                    *.[pP][cC][dD]|\
                    *.[mM][nN][gG]|\
                    *.[pP][dD][fF]|\
                    *.[tT][aA][rR]|\
                    *.[tT][iI][fF][fF]|\
                    *.[tT][iI][fF]|\
                    *.[xX][cC][fF])
                        local FILE=$(realpath -P "${1}")
                        [ ! -n "${FILE}" ] && echo "Invalid filepath ${1}" && exit 1
                        shift
                        local CHARSTRING="$@"
                        log info "main() ACTION –> ${ACTION}"
                        log info "main() CHARSTRING –> ${CHARSTRING}"
                        break
                    ;;
                    *) echo "${1} – Nepodporovaný typ souboru" >> /dev/stderr
                        return 1
                    ;;
                esac
            else
# Smyčka se přeruší, pokud není předaná žádná známá akce, ani parametr,
# který by byl ošetřen pomocí voleb. Další paramtery jsou pak již číslovány
# 1, 2, 3 atd..
                case ${1} in
                    -h|--help|help|?) help actions
                        printf "\t"
                        printf "%s " ${ACTIONS[@]}
                        help keywords
                        return 0
                    ;;
                    *) log warn "Neimplementovaný parametr ${1}"
                        help options
                        return 1
                    ;;
                esac
            fi
            ;;
    esac
done


# echo "${ACTION}" >> /dev/stderr
# echo "$@" >> /dev/stderr

FILETYPE=$(mimefile "${FILE}")
if [[ "${CHARSTRING}" =~ "-h" ]] ; then
        if [ -n "${ACTION}" ] ; then
            case ${FILETYPE} in
                djvu) case "${CHARSTRING%%+([[:blank:]])*}" in
                        ant|dsed|meta) help "${ACTION}-${CHARSTRING%%+([[:blank:]])*}"
                        ;;
                        exif|grep|list|pages) help "info-${CHARSTRING%%+([[:blank:]])*}"
                        ;;
                        *) local TEMP=(${CHARSTRING%%+(-)h*})
                            local PROPERTY="${TEMP[@]: -1}"
                            case "${PROPERTY}" in
                                align|\
                                arrow|\
                                backclr|\
                                background|\
                                border|\
                                border_avis|\
                                key|\
                                line|\
                                lineclr|\
                                mode|\
                                none|\
                                outline|\
                                oval|\
                                poly|\
                                pushpin|\
                                rect|\
                                shadow_*|\
                                text|\
                                textclr|\
                                width|\
                                xor|\
                                zoom) help set-${PROPERTY}
                                ;;
                                *) help "keywords-${ACTION}"
                                ;;
                            esac
                        ;;
                    esac
                ;;
                *) help "bitmap-${ACTION}"
                ;;
            esac
        else
            help
        fi
        exit 0
fi

case ${FILETYPE} in
    '') echo "${FILE} –> invalid path!" >> /dev/stderr
        return 1
    ;;
    djvu) #/ Pracuji se souborem v DjVu formátu
        log goto "Actions for DjVu file"
        case "${ACTION}" in
            delete) local TEST=$(isrange "${CHARSTRING}")
                if [ -n "${TEST}" ] ; then
                    #/ Rozsah stránek identifikovaných pořadím
                    RANGE=$(range ${TEST})
                else
                    #/ Seznam stránek oddělených čárkami
                    x=0
                    for i in ${CHARSTRING//,/ } ; do
                       RANGE[$x]=$(identifypage order "${FILE}" "${i}")
                    done
                fi
                #/ Setřídění RANGE pozpátku, 
                for i in $(printf "%d\n" ${RANGE[@]} | sort -nr) ; do
                    deletepage "${FILE}" "${i}"
                    [ $? -eq 1 ] && echo "Page isn't in ${FILE} –> $i" >> /dev/stderr && return 1
                done
                return 0
            ;;
            fore) #/ Přesouvám stránku kupředu
                MOVE="fore"
                djvumove "${FILE}" "${CHARSTRING}"
                return 0
            ;;
            back) #/ Přesouvám stránku dozadu
                MOVE="back"
                djvumove "${FILE}" "${CHARSTRING}"
                return 0
            ;;
            rotate) #/ Otáčím stránku
                djvurotate "${FILE}" "${CHARSTRING}"
                return 0
            ;;
            export) #/ Exportuji stránku
                log info "main() export from page ${CHARSTRING}"
                fromdjvu "${FILE}" "${CHARSTRING}"
                return 0
            ;;
            import|edit) #/ Import předhozeného souboru a případná editace jeho obsahu
                # Před editací meta informací, je doporučeno zkontrolovat a případně 
                # vyexportovat aktuální stav, příkazem
                #
                # djvutool <DJVU soubor> export ant [> aktualni_stav.ant]
                #
                # Pokud chcete mít obarvený výstup a zároveň ho uložit obvarvený do souboru, použijte následující kombinaci:
                #
                # ( grc djvutool soubor.djvu export ant | tee >(sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})*)?m//g" > soubor.ant) )
                case "${CHARSTRING}" in
                    ant*) #/ Importuji obsah .ant souboru
                        local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .ant)
                        local ANTFILE="${CHARSTRING#ant+([[:blank:]])}"
                        #/ ořezat mezery před a za
                        if [ -f "${ANTFILE}" ] ; then
                            cat "${ANTFILE}" > "${TEMPFILE}"
                        else
                            writefile "${TEMPFILE}"
                            if [ $? -eq 1 ] ; then
                                printf '; Pravidla pro obsah souboru .ant :\n' >> "${TEMPFILE}"
                                printf '; * Globální meta informace se píší jako součást stránky "shared_anno.iff" \n' >> "${TEMPFILE}"
                                printf '; * Stránka může být identifikována buď pořadovým číslem, nebo jménem\n' >> "${TEMPFILE}"
                                printf '; * Blok meta informací vždy začíná řádkem uvozeným znakem # za kterým následuje identifikátor stránky (číslo, nebo jméno)\n' >> "${TEMPFILE}"
                                printf '; * Text záložky i její cíl musí být v uvozovkách\n' >> "${TEMPFILE}"
                                printf '; * Veškerý text na řádcích začínajících středníkem je považován za komentář\n' >> "${TEMPFILE}"
                                printf '; * Při importu souboru bude zakomentovaný obsah odfiltrován\n' >> "${TEMPFILE}"
                                printf '; * Soubor nesmí končit prázdným řádkem!\n' >> "${TEMPFILE}"
                                printf '; * Pokud se do soubory změny neuloží, tak se vloží zpět původní obsah.\n' >> "${TEMPFILE}"
                                printf ';\n' >> "${TEMPFILE}"
                                printf ';Author "Aleš Novák"\n' >> "${TEMPFILE}"
                                printf ';\n' >> "${TEMPFILE}"
                                printf ';; Aktivní link bez bubliny"\n' >> "${TEMPFILE}"
                                printf ';maparea "https://www.thewoodcraft.org/" ""\n' >> "${TEMPFILE}"
                                printf ';rect 225 0 804 61\n' >> "${TEMPFILE}"
                                printf ';xor\n' >> "${TEMPFILE}"
                                printf ';\n' >> "${TEMPFILE}"
                                printf ';; Aktivní link s bublinou"\n' >> "${TEMPFILE}"
                                printf ';URL ("https://www.thewoodcraft.org/" "_blank" ) "Odkaz na stránky Thewoodcraft.org"\n' >> "${TEMPFILE}"
                                printf ';        (rect 225 0 804 61 )\n' >> "${TEMPFILE}"
                                printf ';        (xor )\n' >> "${TEMPFILE}"
                                printf ';; Aktivní link s bublinou u textu přes dva řádky"\n' >> "${TEMPFILE}"
                                printf ';URL ("https://www.thewoodcraft.org/" "_blank" ) "Odkaz na stránky Thewoodcraft.org"\n' >> "${TEMPFILE}"
                                printf ';        ("https://www.thewoodcraft.org/" "_blank" ) "Odkaz na stránky Thewoodcraft.org"\n' >> "${TEMPFILE}"
                                $0 "${FILE}" export ${CHARSTRING} >> "${TEMPFILE}"
                            fi
                        fi
                        case ${ACTION} in
                            edit)
                                editor "${TEMPFILE}"
                                anone "Uložit změny?"
                                [ $? -eq 1 ] && return 1
                            ;;
                        esac
                        local DSEDFILE=$(tempfile -d ${TEMPDIR} -s .dsed)
                        testsyntaxant "${TEMPFILE}" > "${DSEDFILE}"
                        if [ $? -eq 1 ] ; then
                            echo "V importovaném souboru ${TEMPFILE} je syntaktická chyba" >> /dev/stderr
                            exit 33
                        fi
                        ${DJVUSED} "${FILE}" -f "${DSEDFILE}" -s
                        return $?
                    ;;
                    meta*) echo "import from meta file to ${FILE}"
                        echo nil
                        ;;
                    outline*) echo "Importuji záložky"
                        echo "Přijato k importu ${CHARSTRING}"
                        #/ Může být předaný i soubor
                        #/ Není-li předaný soubor, zkus načíst stdin
                        local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .outline)
                        local OUTLINEFILE="${CHARSTRING#outline+([[:blank:]])}"
                        #/ ořezat mezery před a za
                        if [ -f "${OUTLINEFILE}" ] ; then
                            log info "main() Importuji .outline soubor ${OUTLINEFILE}"
                            cat "${OUTLINEFILE}" > "${TEMPFILE}"
                        else
                            writefile "${TEMPFILE}"
                            if [ $? -eq 1 ] ; then
                                log info "main() Na stdin nebylo nic, přidám záhlaví a vytáhnu stávající záložky"
                                printf '; Pravidla pro obsah souboru .outline :\n' >> "${TEMPFILE}"
                                printf '; * Text záložky i její cíl musí být v uvozovkách\n' >> "${TEMPFILE}"
                                printf ';  * Cíl může být identifikován buď pořadovým číslem stránky, nebo jejím jménem\n' >> "${TEMPFILE}"
                                printf ';  * Identifikátor vždy začíná znakem #\n' >> "${TEMPFILE}"
                                printf ';  * Úroveň zanoření záložky je daná odsazením pomocí tabelátoru\n' >> "${TEMPFILE}"
                                printf ';  * Veškerý text na řádcích začínajících středníkem je považován za komentář\n' >> "${TEMPFILE}"
                                printf ';  * Při importu souboru bude zakomentovaný obsah odfiltrován\n' >> "${TEMPFILE}"
                                printf ';  * Soubor nesmí končit prázným řádkem!\n' >> "${TEMPFILE}"
                                printf ';  * Pokud se do soubory změny neuloží, tak se vloží zpět původní obsah.\n' >> "${TEMPFILE}"
                                printf ';\n' >> "${TEMPFILE}"
                                printf ';"Link první úrovně" "#1"\n' >> "${TEMPFILE}"
                                printf ';      "Link druhé úrovně" "#strana-001.djvu"\n' >> "${TEMPFILE}"
                                $0 "${FILE}" info list | sed 's/^/; /' >> "${TEMPFILE}"
                                $0 "${FILE}" export outline >> "${TEMPFILE}"
                            fi
                        fi
#                        echo "Obsah záložek byl zapsán do souboru ${TEMPFILE}" >> /dev/stderr
                        case ${ACTION} in
                            edit) editor "${TEMPFILE}"
                            ;;
                        esac
#                        lig info "main() Importuji soubor .outline ${TEMPFILE} do ${FILE}"
#                        local DSEDFILE=$(tempfile -d ${TEMPDIR} -s .dsed)
                        outlinetodjvu "${FILE}" "${TEMPFILE}"
                        if [ $? -eq 1 ] ; then
                            echo "V importovaném souboru ${TEMPFILE} je syntaktická chyba" >> /dev/stderr
                            exit 33
                        else
                            echo "Záložky byly aktualizovány" >> /dev/stderr
                        fi
                        return 0
                    ;;
                    page*) echo "Importuji do svazku DjVu stránku"
                    ;;
                    *) help keyword-${CHARSTRING%% *}
                    #djvuimport "${FILE}" "${CHARSTRING}"
                    ;;
                esac
                return 33
            ;;
            info) djvuinfo "${FILE}" "${CHARSTRING}"
                return 0
            ;;
            rename) log info "main() Rename pages in ${FILE} by TEMPLATE –> ${CHARSTRING}"
                #/ TODO!
                return 1
            ;;
            set|unset) setdjvu  "${FILE}" "${CHARSTRING}"
                return 0
            ;;
            view) log info "View –> ${FILE}"
                (${DJVIEW} "${FILE}" &)
                return 0
            ;;
        esac
    ;;
    *) log info "Input bitmap file (or archive) ${FILE} in format –> ${FILETYPE}"
        case ${ACTION} in
            export) exportimg
            ;;
            info) infoimg
            ;;
            view) viewimg
            ;;
            set) log info "main() set exif tag in img ${FILE} –> ToDo"
            ;;
            unset) log info "main() unset exif tag in ${FILE} –> ToDo"
            ;;
            rotate) log info "main() rotate ${FILE}"
            ;;
            rename) log info "main() rename ${FILE}"
            ;;
            import) echo '''Pokud následuje djvu soubor'''
                echo '''Pokud následuje adresář'''
                echo '''to je existující soubor typu bundle a:
- nenásleduje žádný další existující soubor typu djvu, nebo adresář
    a zároveň existuje $DIRECTORY, pak to znamená že se má rozbalit
    - pokud následuje další soubor, pak to znamená že se má nějakým způsobem s tímto dalším souborem naložit. Je-li to:
    - djvu soubor, má se připojit
    - xml soubor, má se vložit
    - soubor typu dsed má se zpracovat
    - jiný soubor - obrázek, který se má převést a vložit
    '''
                log info "main() import ${FILE} into DjVu"
                case ${FILETYPE} in
                    djvu) echo "Konvertovat vstupní soubor a vložit do předchozeného DjVu souboru - TODO" >> /dev/stderr
                        #/ Sestavit z nich soubor typu bundle
                        ;;
                    gif) #/ může být mít více vrstev 'Animation frames
                        ;;
                    mng) #/ může být mít více vrstev 'Animation frames'
                        ;;
                    png) #/ může být mít více vrstev 'Animation frames'
                        ;;
                    gimp|xcf) #/může mít více vrstev
                        ;;
                    tiff) #/ může mít více stránek
                        ;;
                    pdf) #/ může mít více stránek
                        ;;
                    xml|XML) #/ imporuji soubor s textovou vrstvou
                        ;;
                    unknown) echo "Pokud je soubor ${1} typu DjVU, může jít o tzv. SecureDjVu formát, který má kryptované vrstvy. S takovým souborem nelze s opensource nástroji pracovat." >> /dev/stderr
                        exit 1
                        ;;
                    *) echo "Záleží na typu " >> /dev/stderr
                    ;;
                esac
            ;;
        esac
    ;;
esac
}

main "$@"

exit 0
