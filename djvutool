#!/bin/bash
# -*- mode: sh -*-

# https://‚Ä¶
# djvutool - tool for conversion and work with DjVu files
#
# Author: Ale≈° Kapica <kapica@fel.cvut.cz>, 2015-2017
#
shopt -s extglob

# Changelog
# * implementov√°na akce 'rename'
# * akce 'info' - umo≈æ≈àuje z√≠sk√°vat r≈Øzn√© u≈æiteƒçn√© informace
# * akce 'export' funguje z√°rove≈à jako konverzn√≠ n√°stroj
# * implementov√°na akce 'rotate'
# * akce 'delete' odstra≈àuje str√°nky
# * akce 'edit', 'export', 'import'
# * akce 'fore' a 'back' pro p≈ôesun str√°nek v DjVu souboru

# Otestovat
# - export ze single-page dokumentu
#
# ## Pozn√°mky:
#
# ### Jak vypsat obsah ≈ô√°dku 3 ze souboru test.txt:
#
#   sed -n 3p test.txt
#
# ### Jak vypsat posledn√≠ hodnotu pole
#
#    echo ${pole[@]: -1}

# ToDo
# Zmƒõna bundle na unbundle a naopak
#
# - implementov√°no generov√°n√≠ n√°hled≈Ø do exportu
#
# OCR
# - o≈°et≈ôena situace, kdy nen√≠ nainstalov√°n ocrodjvu
# - upraveny funkce pro export n√°hled≈Ø a soubor≈Ø textov√© vrstvy
#
# D√≠lƒç√≠ √∫pravy str√°nek DjVu svazku - velmi n√≠zk√° priorita
# - Odstranƒõn√≠ vrstvy ze str√°nky
# - Odstranƒõn√≠ sd√≠len√©ho chunku
# Doplnit nov√© funkce do wiki souboru
# implementovat kontrolu p≈ôi importu, aby nedoch√°zelo k nekontrolovateln√©mu vkl√°d√°n√≠ ji≈æ existuj√≠c√≠ch str√°nek
# - p≈ôidat kontrolu do akce insert na duplicitn√≠ soubory p≈ôi vkl√°d√°n√≠
#   v√≠cestr√°nkov√Ωch DjVu soubor≈Ø. to ov≈°em bude vy≈æadovat samostatnou
#   funkci...
NAME="djvutool"
[ -d "${HOME}/.config/${NAME}" ] &&	. ${HOME}/.config/${NAME}/* &>>/dev/null

DEBUG="-d0"
LOG="${LOG=/dev/null}"
XML="${XML=no}"
DPI="${DPI=300}"
DSED="${DSED=no}"
PAGE="${PAGE=no}"
META="${META=no}"
IMG="${IMG=no}"
INDIRECT="${INDIRECT=no}"
FORCE="${FORCE=skip}"
RENAME="no"
EXTENSION=".djvu"
THUMBNAIL="${THUMBNAIL=no}"
INSERTTEXT="${INSERTTEXT=no}"
ALG="${ALG=none}"
EXTRACTPAGE="${EXTRACTPAGE=no}"
IMGPAGE="${IMGPAGE=no}"
ALGORITHM=( none abutaleb bernsen brink djvu niblack otsu sauvola shading-subtraction tsai white-rohrer )

trap '''CHYBA=$? ;
case $CHYBA in
 10) echo "≈Ω√°dn√° sd√≠len√° metadata"
 ;;
 20) echo "Nen√≠ nainstalov√°n bal√≠k poppler-utils"
 ;;
 19) echo "Nen√≠ nainstalov√°n bal√≠k pdftk"
 ;;
 20) echo "Nen√≠ nainstalov√°n bal√≠k djvu-tools"
 ;;
 21) echo "ERROR: mimetype - tool for detection type of image"
 ;;
 22) echo "ERROR: readlink - tool for detection absolute path of directory"
 ;;
 23) echo "ERROR: netpbm-sf - pack of utilities for image conversions not installed "
 ;;
 24) echo "ERROR: imagemagick - tool for image convert is not installed"
 ;;
 25) echo "ERROR: xmlstarlet - tool for work with xml not installed"
 ;;
 26) echo "ERROR: xcftools - tool for work with xcf file (GIMP) not installed"
 ;;
 27) echo "ERROR: libtiff-tools - tool for work with tiff file not installed"
 ;;
 28) echo "ERROR: libopenjp2-tools - tool for work with jp2 file not installed"
 ;;
 29) echo "ERROR: 7z - tool for work with compressed archives is not installed"
 ;;
 30) echo "ERROR: PDF viewer not installed"
 ;;
 31) echo "Nen√≠ nainstalov√°n bal√≠k ocrodjvu, na djvu soubory nelze aplikovat OCR. Buƒèto jej doinstalujte, nebo odstra≈àte z p≈ô√≠kazov√© ≈ô√°dky parametr -o (--ocr)" >> /dev/stderr
 ;;
 32) echo "Pokud m√° p≈ôi operaci zpracovat do DjVu bitmapov√Ω soubor, je t≈ôeba uv√©st na p≈ô√≠kazov√© ≈ô√°dce parametrem -a jak√Ω se m√° pou≈æ√≠t algoritmus. Jak√© parametry lze pou≈æ√≠t se dozv√≠te pokud m√≠sto jm√©na algoritmu nap√≠≈°ete znak ?" >> /dev/stderr
 ;;
 33) NORMDIR=yes
 ;;
 38) echo "ERROR - identifik√°tor str√°nky nen√≠ platn√Ω!" >> /dev/stderr
 ;;
esac
[ $NORMDIR ] || rm -rf -- "$TEMPDIR"
exit $CHYBA
''' EXIT

TEMPDIR=$(mktemp -d -p /tmp ${NAME}-XXX) || exit 1

#=== testy z√°vislost√≠ ===
# Dependencies:
#   * feh      ( http://feh.finalrewind.org/ )
#   * exiftool ( http://www.sno.phy.queensu.ca/~phil/exiftool ) in Debian package: libimage-exiftool-perl 
#   * yad      ( http://sourceforge.net/projects/yad-dialog )
REALPATH=$(command -v realpath)
[ ! ${REALPATH} ] && exit 1
REALPATH="$REALPATH -e "
if ! command -v ed >/dev/null 2>&1 ; then
    echo "Mus√≠ b√Ωt nainstalov√°n editor ed" >> /dev/stderr
    exit 1
fi
FEH=$(command -v feh)
[ ! ${FEH} ] && exit 18
GEEQIE=$(command -v geeqie)
[ ! ${GEEQIE} ] && exit 18
DIDJVU=$(command -v didjvu)
[ ! ${DIDJVU} ] && echo 'Nen√≠ nainstalov√°n bal√≠k didjvu, nebude mo≈æn√© aplikovat pokroƒçil√© algoritmy pro separaci pop≈ôed√≠ p≈ôi konverzi do DjVu' >> /dev/stderr && DIDJVU=false
OCRODJVU=$(command -v ocrodjvu)
[ ! ${OCRODJVU} ] && OCRODJVU=31
DJVIEW=$(command -v djview)
[ ! ${DJVIEW} ] && echo 'Nen√≠ nainstalov√°n bal√≠k djview, nebude fungovat testovac√≠ zobrazen√≠ djvu.soubor≈Ø' >> /dev/stderr && DJVIEW=false
DDJVU=$(command -v ddjvu)
[ ! ${DDJVU} ] && exit 20
DJVUTXT=$(command -v djvutxt)
[ ! ${DJVUTXT} ] && exit 20
DJVUSED=$(command -v djvused)
[ ! ${DJVUSED} ] && exit 20
DJVUTOXML=$(command -v djvutoxml)
[ ! ${DJVUTOXML} ] && exit 20
DJVUXMLPARSER=$(command -v djvuxmlparser)
[ ! ${DJVUXMLPARSER} ] && exit 20
DJVMCVT=$(command -v djvmcvt)
[ ! ${DJVMCVT} ] && exit 20
DJVUEXTRACT=$(command -v djvuextract)
[ ! ${DJVUEXTRACT} ] && exit 20
DJVM=$(command -v djvm)
[ ! ${DJVM} ] && exit 20
CJB2=$(command -v cjb2)
[ ! ${CJB2} ] && exit 20
DJVUMAKE=$(command -v djvumake)
[ ! ${DJVUMAKE} ] && exit 20
#YAD=$(command -v yad)
#[ ! ${YAD} ] && echo 'Nen√≠ nainstalov√°n bal√≠k yad' && exit 1
MIME=$(command -v mimetype)
[ ! -x "${MIME}" ] && exit 21
STAT=$(command -v readlink)
[ ! -x "${STAT}" ] && exit 22
EXIFTOOL=$(command -v exiftool)
[ ! -x "${EXIFTOOL}" ] && exit 23
# P≈ôesunuto do funkce main k volbƒõ -o|--ocr
#TESSERACT=$(command -v  tesseract)
#[ ! -x "${TESSERACT}" ] && exit 31
IDENTIFY=$(command -v identify)
[ ! -x "${IDENTIFY}" ] && echo exit 24
CONVERT=$(command -v convert)
[ ! -x "${CONVERT}" ] && echo exit 24
IMGVIEW=$(command -v display)
[ ! -x "${IMGVIEW}" ] && echo exit 24
XCFINFO=$(command -v xcfinfo)
[ ! -x "${XCFINFO}" ] && echo exit 26
XCF2PNM=$(command -v xcf2pnm)
[ ! -x "${XCF2PNM}" ] && echo exit 26
TIFFINFO=$(command -v tiffinfo)
[ ! -x "${TIFFINFO}" ] && echo exit 27
PDFVIEW=$(command -v xpdf)
if [ ! -x "${PDFVIEW}" ] ; then
    PDFVIEW=$(command -v evince)
    if [ ! -x "${PDFVIEW}" ] ; then
        if [ ! -x "${xournal}" ] ; then
            echo exit 30
        fi
    fi
fi
PDFTK=$(command -v pdftk)
[ ! -x "${PDFTK}" ] && echo exit 19
PDFTOPPM=$(command -v pdftoppm)
[ ! -x "${PDFTOPPM}" ] && echo exit 18

# Konverze z form√°tu JPEG2000 (jp2)
JP2TO=$(command -v opj_decompress)
[ ! ${JP2TO} ] && exit 28
JP2IN=$(command -v opj_compress)
[ ! ${JP2IN} ] && exit 28
# N√°stroje pro konverzi animovan√Ωch gif≈Ø a png soubor≈Ø
# apng2gif, gif2apng, 

ZIP=$(command -v 7z)
[ ! -x "${ZIP}" ] && echo exit 29

# ## Implementovan√© akce
#
ACTIONS=(
    delete
    fore
    back
    rotate
    export
    import
    convert
    edit
    info
    rename
    insert
    set
    unset
    sign
    view
    )

# ## Akceptovan√© form√°ty bitmapov√Ωch soubor≈Ø
#
# Neztr√°tov√© form√°ty 
FORMATS_FULL=(
    bmp
    pnm
    png
    tif
)
# Form√°ty, kter√© mohou m√≠t ztr√≠tovou kompresi
FORMATS_MISS=(
    jpg
    xcf
    jp2
)
# Kontejnerov√© form√°ty
FORMATS_CONT=(
    pdf
    zip
    tar
)
FORMATS=(${FORMATS_FULL[@]} ${FORMATS_MISS[@]} ${FORMATS_CONT[@]})

PGMTOPBM=$(command -v pgmtopbm)
[ ! -x "${PGMTOPBM}" ] && exit 23
BMPTOPNM=$(command -v bmptopnm)
[ ! -x "${BMPTOPNM}" ] && exit 23
JPEGTOPNM=$(command -v jpegtopnm)
[ ! -x "${JPEGTOPNM}" ] && exit 23
GIFTOPNM=$(command -v giftopnm)
[ ! -x "${GIFTOPNM}" ] && exit 23
PNGTOPNM=$(command -v pngtopnm)
[ ! -x "${PNGTOPNM}" ] && exit 23
PNMTOJPEG=$(command -v pnmtojpeg)
[ ! -x "${PNMTOJPEG}" ] && exit 23
TIFFTOPNM=$(command -v tifftopnm)
[ ! -x "${TIFFTOPNM}" ] && exit 23
PNMTOPNG=$(command -v pnmtopng)
[ ! -x "${PNMTOPNG}" ] && exit 23
PAMTOJPEG2K=$(command -v pamtojpeg2k)
[ ! -x "${PAMTOJPEG2K}" ] && exit 23
JPEG2KTOPAM=$(command -v jpeg2ktopam)
[ ! -x "${JPEG2KTOPAM}" ] && exit 23
PNMTOJPEG=$(command -v pnmtojpeg)
[ ! -x "${PNMTOJPEG}" ] && exit 23
PNMTOPLAINPNM=$(command -v pnmtoplainpnm)
[ ! -x "${PNMTOPLAINPNM}" ] && exit 23
#/ Konvertuje barvy na stupnƒõ ≈°edi
PPMTOPGM=$(command -v ppmtopgm)
#/ Konvertuje stupnƒõ ≈°edi na ƒçernob√≠lou mmasku
[ ! -x "${PPMTOPGM}" ] && exit 23
#/ Konvertuje bin√°rn√≠ form√°t PAM do PNM
PAMTOPNM=$(command -v pamtopnm)
[ ! -x "${PAMTOPNM}" ] && exit 23
#/ Vysekne oblast z obr√°zku dle sou≈ôadnic
PAMCUT=$(command -v pamcut)
[ ! -x "${PAMCUT}" ] && exit 23
#/ Odseparuje masku
PAMARITH=$(command -v pamarith)
[ ! -x "${PAMARITH}" ] && exit 23
#/ gener√°tor pr√°zdn√Ωch ploch pro masku
PBMMAKE=$(command -v pbmmake)
[ ! -x "${PBMMAKE}" ] && exit 23
#/ integruje plochy do masky
PNMPASTE=$(command -v pnmpaste)
[ ! -x "${PNMPASTE}" ] && exit 23
NETPBMSCALE=$(command -v pamscale)
if [ -x "${NETPBMSCALE}" ] ; then
    # Akceptovan√© ≈°k√°lovac√≠ filtry
    FILTERS=(
    point
    box
    triangle
    quadratic 
    cubic 
    catrom 
    mitchell 
    gauss 
    sinc 
    bessel 
    hanning 
    hamming 
    blackman 
    kaiser 
    normal 
    hermite 
    lanczos
    )
    NETPBM=0
else
    exit 23
fi

#=== konec testu z√°vislost√≠ ===

# ### <span id="log">log()</span> ([top](#FUNCTIONS))
# Je-li pou≈æita volba `-d` nebo `--debug`, nastav√≠ funkce [main](#main)
# do glob√°ln√≠ promƒõnn√© [$DEBUG](#$DEBUG) ≈ôetƒõzcovou hodnotu, kter√° urƒçuje
# kam se budou zpr√°vy p≈ôedan√© t√©to funkci pos√≠lat. Ta je tvo≈ôen√° ≈ôetƒõzcem
# `-d` a ƒç√≠slem. Jak≈æ bude m√≠t toto ƒç√≠slo efekt viz
# [Parametry pro debug](#debug-levels).
#
# Prvn√≠ polo≈æka, p≈ôedan√° t√©to funkci jako parametr __$1__, urƒçuje
# z√°va≈ænost zpr√°vy. Ostatn√≠ p≈ôedan√© polo≈æky pak jsou ji≈æ souƒç√°st√≠
# vypisovan√© zpr√°vy.
#
#     log info "Zpr√°va s informativn√≠ hodnotou"
# Informaƒçn√≠ zpr√°vy obsahuj√≠ kontroln√≠ v√Ωpisy, kter√© informuj√≠ o pr≈Øbƒõhu
# zpracov√°n√≠ akce skriptem
#
#     log warn "Zpr√°va, co upozor≈àuje ≈æe by nƒõco nemuselo klapnout"
# Upozor≈àuj√≠c√≠ zpr√°vy se pou≈æ√≠vaj√≠ p≈ôi operac√≠ch, kter√© mohou p≈ôedstavovat
# probl√©m. Kup≈ô. kdy≈æ skript realizuje nevratn√Ω krok. Modelov√Ωm p≈ô√≠kladem
# takov√© situace je zpracov√°n√≠ p≈ô√≠kazu [___delete___](#delete-command-config)
# p≈ôi akci [__config__](#config), p≈ôi kter√©m se odstra≈àuj√≠ v≈°echny
# konfiguraƒçn√≠ soubory pro VM, ze v≈°ech hostitel≈Ø.
#
#     log err "Zpr√°va, kter√° oznamuje chybu"
# Chybov√© zpr√°vy popisuj√≠ stavy, kter√© maj√≠ n√°vratov√Ω k√≥d __1__
#
# #### <span id="debug-levels">Parametry pro debug</span>
# V√Ωchoz√≠ hodnota pro [$DEBUG](#$DEBUG) je __0__ p≈ôi kter√© se nevypisuje
# nic. Doporuƒçen√° √∫rove≈à pro ladƒõn√≠ skriptu je __7__. A pro norm√°ln√≠
# pou≈æit√≠, v p≈ô√≠padƒõ ≈æe je skript spravov√°n kup≈ô. p≈ôes `cron` __5__.
#
# 1. Vypisuje pouze chybov√© (ERR) zpr√°vy pouze na standardn√≠ chybov√Ω v√Ωstup
# 2. Zapisuje pouze do logu a pouze chybov√© (ERR) zpr√°vy
# 3. Vypisuje chybov√© (ERR) zpr√°vy na standardn√≠ v√Ωstup a z√°rove≈à je
#    zapisuje do logu
# 4. Vypisuje chybov√© (ERR) a varovn√© (WARN) zpr√°vy pouze na standardn√≠
#    chybov√Ω v√Ωstup
# 5. Zapisuje chybov√© (ERR) a varovn√© (WARN) zpr√°vy pouze do logu
# 6. Zapisuje chybov√© (ERR) a varovn√© (WARN) zpr√°vy na standardn√≠ v√Ωstup
#    a z√°rove≈à je zapisuje do logu
# 7. Vypisuje v≈°echny zpr√°vy pouze na standardn√≠ chybov√Ω v√Ωstup
# 8. Zapisuje v≈°echny zpr√°vy pouze do logu
# 9. Vypisuje v≈°echny zpr√°vy na standardn√≠ v√Ωstup a z√°rove≈à je zapisuje do logu
#
# #### Kde se rozhodnƒõ nesm√≠ pou≈æ√≠t parametr $DEBUG
# Parametr $DEBUG rozhodnƒõ nepou≈æ√≠vejte tam, kde se mus√≠ zavolat akce na
# vzd√°len√©m stroji p≈ôes $SSH a navr√°cen√Ω v√Ωstup se m√° d√°le zpracov√°vat.
# Probl√©m spoƒç√≠v√° v tom, ≈æe SSH s parametrem -t, kter√© se pou≈æ√≠v√° pro
# interaktivn√≠ pr√°ci, p≈ôetoƒç√≠ chybov√Ω v√Ωstup na standardn√≠ v√Ωstup a t√≠m
# p√°dem se m≈Ø≈æe vr√°tit neplatn√Ω v√Ωsledek.
#
# Typick√Ωm p≈ô√≠kladem budi≈æ vol√°n√≠ akce master. Je-li zavol√°no s parametrem
# DEBUG, je v√Ωsledek pro dal≈°√≠ zpracov√°n√≠ nepou≈æiteln√Ω!
#
#      local MASTER=$($0 ${DEBUG} master ${PROCESS})
#
# Spr√°vnƒõ:
#
#      local MASTER=$($0 master ${PROCESS})
#
# #### M√≠sto zpracov√°n√≠ ve skriptu
# P≈ôi testov√°n√≠ je t≈ôeba vlo≈æit do vypisovan√©ho ≈ôetƒõzce promƒõnnou $LINENO
# ta vyp√≠≈°e ƒç√≠slo ≈ô√°dku zpracov√°van√©ho skriptu, kde se zrovna nach√°z√≠
# Je-li to m√≠sto ve funkci, tak promƒõnn√° ${BASH_LINENO[0]} vyp√≠≈°e ƒç√≠slo
# ≈ô√°dku, ze kter√©ho byla tato funkce zavolan√°, a ve ${BASH_LINENO[1]} je ulo≈æen
# index jej√≠ho jm√©na v poli ${FUNCNAME[@]}
log() {
    local TIMESTAMP="$(date +%T.%N)"
    local LOG="${LOGDIR}/messages"
    if [ -n "${DEBUG}" ] ; then
        case ${DEBUG} in
            -d0) ;;
            -d1) [ "${1^^}" == "ERR" ] && \
                echo -e "${TIMESTAMP} ${ACTION} ${1^^} ${FUNCNAME[1]}:${BASH_LINENO[0]} ${@:2}" >> /dev/stderr
                ;;
            -d2) [ "${1^^}" == "ERR" ] && \
                echo -e "${TIMESTAMP} ${ACTION} ${1^^} ${FUNCNAME[1]}:${BASH_LINENO[0]} ${@:2}" >> ${LOG}
                ;;
            -d3) [ "${1^^}" == "ERR" ] && \
                echo -e "${TIMESTAMP} ${ACTION} ${1^^} ${FUNCNAME[1]}:${BASH_LINENO[0]} ${@:2}" | \
                tee ${LOG} >> /dev/stderr
                ;;
            -d4) [ "${1^^}" == "ERR" ] || [ "${1^^}" == "WARN" ] && \
                echo -e "${TIMESTAMP} ${ACTION} ${1^^} ${FUNCNAME[1]}:${BASH_LINENO[0]} ${@:2}" >> /dev/stderr
                ;;
            -d5) [ "${1^^}" == "ERR" ] || [ "${1^^}" == "WARN" ] && \
                echo -e "${TIMESTAMP} ${ACTION} ${1^^} ${FUNCNAME[1]}:${BASH_LINENO[0]} ${@:2}" >> ${LOG}
                ;;
            -d6) [ "${1^^}" == "ERR" ] || [ "${1^^}" == "WARN" ] && \
                echo -e "${TIMESTAMP} ${ACTION} ${1^^} ${FUNCNAME[1]}:${BASH_LINENO[0]} ${@:2}" | \
                tee ${LOG} >> /dev/stderr
                ;;
            -d7) echo -e "${TIMESTAMP} ${ACTION} ${1^^} ${BASH_LINENO[0]}:${FUNCNAME[1]}()\t${@:2}" >> /dev/stderr
                ;;
            -d8) echo -e "${TIMESTAMP} ${ACTION} ${1^^} ${FUNCNAME[1]}:${BASH_LINENO[0]} ${@:2}" >> ${LOG}
                ;;
            -d9) echo -e "${TIMESTAMP} ${ACTION} ${1^^} ${FUNCNAME[1]}:${BASH_LINENO[0]} ${@:2}" | \
                tee ${LOG} >> /dev/stderr
                ;;
            *) help_debug && exit 1
                ;;
        esac
    fi
}
# <span id="help_debug" /> ([top](#FUNCTIONS))
help_debug() {
    echo """Chybn√© nastaven√≠ pro debug ‚Äì> $1

Pro debug lze pou≈æ√≠t pouze ƒç√≠sla od 1 do 9. Nastaven√≠ lze prov√©st tƒõmito zp≈Øsoby:

    ‚Ä¶ -d2 ‚Ä¶
    ‚Ä¶ -d 2 ‚Ä¶
    ‚Ä¶ -d=2 ‚Ä¶
    ‚Ä¶ --debug 2 ‚Ä¶
    ‚Ä¶ --debug=2 ‚Ä¶

  0 Je v√Ωchoz√≠ stav, p≈ôi kter√©m se logovac√≠ zpr√°vy nevypisuj√≠ nikam.
  1 Vypisuje pouze chybov√© (ERR) zpr√°vy pouze na standardn√≠ chybov√Ω
    v√Ωstup.
  2 Zapisuje pouze do logu a pouze chybov√© (ERR) zpr√°vy.
  3 Vypisuje chybov√© (ERR) zpr√°vy na standardn√≠ v√Ωstup a z√°rove≈à je
    zapisuje do logu.
  4 Vypisuje chybov√© (ERR) a varovn√© (WARN) zpr√°vy pouze na standardn√≠
    chybov√Ω v√Ωstup.
  5 Zapisuje chybov√© (ERR) a varovn√© (WARN) zpr√°vy pouze do logu.
  6 Zapisuje chybov√© (ERR) a varovn√© (WARN) zpr√°vy na standardn√≠ v√Ωstup
    a z√°rove≈à je zapisuje do logu.
  7 Vypisuje v≈°echny zpr√°vy pouze na standardn√≠ chybov√Ω v√Ωstup.
  8 Zapisuje v≈°echny zpr√°vy pouze do logu.
  9 Vypisuje v≈°echny zpr√°vy na standardn√≠ v√Ωstup a z√°rove≈à je zapisuje
    do logu.
"""
}

# OBSOLETE
# Pomocn√° funkce, kter√° odfiltruje p≈ôi pou≈æit√≠ funkce pushd v√Ωstup
function pushd {
    command pushd "$@" > /dev/null
}
function popd {
    command popd "$@" > /dev/null
}

# ### <span id="anone">anone()</span> ([top](#FUNCTIONS))
# Ovƒõ≈ôovac√≠ funkce.
# V p≈ô√≠padƒõ, ≈æe se lze pokraƒçovat v realizaci akce vrac√≠ __0__,
# v opaƒçn√©m p≈ô√≠padƒõ __1__.
anone() {
    if [ -n "${1}" ] ; then
        if [ "${FORCE}" != "yes" ] ; then
            echo "$1"
            while true ; do
#                read -p "(ANO/NE) : " yn
                read -er yn
                case $yn in
                    [AaYy]*) break;;
                    [Nn]*) return 1;;
                    *) echo "Napi≈°te ANO ƒçi NE:";;
                esac
            done
        fi
        return 0
    else
        log warn "anone() Not value"
        return 1
    fi
}

function escape_path {
# Zat√≠m nepou≈æit√°
	echo "escape_path $*" >> /dev/stderr
	echo "$*" | sed \
  -e 's/\ /\\\ /g'
}

# ###  <span id="ant2dsed">ant2dsed()</span> ([top](#FUNCTIONS))
# Tato funkce se star√° o zpracov√°n√≠ .ant form√°tu do form√°tu .dsed
# Je opakem funkce dsed2ant
#
#    # 'shared_anno.iff' ; remove-ant
#    set-ant
#    metadata
#        Author "jm√©no a p≈ô√≠jmen√≠"
#        Exif.Image.DateTime "2017:11:27 17:05:21"
#    background #000000
#    zoom d50
# 
# A v√Ωstup takto:
#
#    # ------------------------- 
#    select "shared_anno.iff"
#    set-ant
#    (metadata (Author "jm√©no a p≈ô√≠jmen√≠") (Exif.Image.DateTime "2017:11:27 17:05:21"))
#    (background #000000 ) (zoom d50 ) 
#    .
#
ant2dsed() {
    local OK="OK ‚Äì> ${line}"
    local ERR="ERR ‚Äì> Chyb√≠ typ datov√©ho bloku"
    local INVALID="INVALID ‚Äì> Neplatn√Ω typ datov√©ho bloku"
    local START="yes"
    while read -r line ; do
    log info "textsyntax() ‚Äì> ${line}"
        case "${line}" in
            \#+([[:blank:]])+([[:digit:]]))
                if [ -n "${START}" ] ; then
                    unset START
                else
                    case "${META}" in
                        metadata)  case "${KEYS}" in
                            '') continue ;;
                            *) printf "(${META} ${KEYS})\n" ;;
                            esac
                        ;;
                        xmp) case "${XMP}" in
                            '') continue ;;
                            *) printf "(${META} \"${XMP//\"/\\\\\"}\")\n" ;;
                            esac
                        ;;
                        maparea) echo "(${META} ${URL} ${BORDER} ${KEYS})"
                        ;;
                    esac
                    unset XMP
                    unset KEYS
                    unset BORDER
                    unset URL
                    unset META
                    printf "\n."
                fi
                printf "\n# ------------------------- \n"
                case "${line#\#+([[:blank:]])}" in
                    0*) printf "select 'shared_anno.iff' ; remove-ant\n"
                    ;;
                    *) printf "select %d\n" "${line#\#+([[:blank:]])}"
                    ;;
                esac
                printf "remove-ant ; set-ant\n"
            ;;
            \#+([[:blank:]])*) 
                if [ -n "${START}" ] ; then
                    unset START
                else
                    case "${META}" in
                        metadata)  case "${KEYS}" in
                            '') continue ;;
                            *) printf "(${META} ${KEYS})\n" ;;
                            esac
                        ;;
                        xmp) case "${XMP}" in
                            '') continue ;;
                            *) printf "(${META} \"${XMP//\"/\\\\\"}\")\n" ;;
                            esac
                        ;;
                        maparea) echo "(${META} ${URL} ${BORDER} ${KEYS})"
                        ;;
                    esac
                    unset XMP
                    unset KEYS
                    unset BORDER
                    unset URL
                    unset META
                    printf "\n."
                fi
                printf "\n# ------------------------- \n"
                local TEMPORAR="${line#\#+([[:blank:]])}"
                case "${TEMPORAR}" in
                    'shared_anno.iff'*|\
                    shared_anno.iff*|\
                    0) printf "select 'shared_anno.iff' ; remove-ant\n"
                    ;;
                    +([[:digit:]])*) printf "select %s; remove-ant\n" "${TEMPORAR%%+([[:blank:]])*}"
                    ;;
                    *)  printf "select %s; remove-ant\n" "${TEMPORAR%%#*}"
                    ;;
                esac
                printf "set-ant\n"
            ;;
            \<*) local XMP="${XMP}${line}"
            ;;
            metadata) case "${META}" in
                        metadata) case "${KEYS}" in
                            '') continue ;;
                            *) printf "(${META} ${KEYS})\n" ;;
                            esac
                        ;;
                        xmp) case "${XMP}" in
                            '') continue ;;
                            *) printf "(${META} \"${XMP//\"/\\\\\"}\")\n" ;;
                            esac
                        ;;
                        maparea) printf "(${META} ${URL} ${BORDER} ${KEYS})\n"
                        ;;
                esac
                unset XMP
                unset KEYS
                unset BORDER
                unset URL
                META='metadata'
            ;;
            maparea) case "${META}" in
                        metadata)  case "${KEYS}" in
                            '') continue ;;
                            *) printf "(${META} ${KEYS})\n" ;;
                            esac
                        ;;
                        xmp) case "${XMP}" in
                            '') continue ;;
                            *) printf "(${META} \"${XMP//\"/\\\\\"}\")\n" ;;
                            esac
                        ;;
                        maparea) echo "(${META} ${URL} ${BORDER} ${KEYS})"
                        ;;
                esac
                unset XMP
                unset KEYS
                unset BORDER
                unset URL
                META='maparea'
            ;;
            xmp) case "${META}" in
                        metadata) case "${KEYS}" in
                            '') continue ;;
                            *) printf "(${META} ${KEYS})\n" ;;
                            esac
                        ;;
                        xmp) case "${XMP}" in
                            '') continue ;;
                            *) printf "(${META} \"${XMP//\"/\\\\\"}\")\n" ;;
                            esac
                        ;;
                        maparea) printf "(${META} ${URL} ${BORDER} ${KEYS})\n"
                        ;;
                esac
                unset XMP
                unset KEYS
                unset BORDER
                unset URL
                META='xmp'
            ;;
            align+([[:blank:]])+(left|center|right)+([[:blank:]])+(top|center|bottom)|\
            background+([[:blank:]])\#[0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F]|\
            mode+([[:blank:]])+(color|bw|fore|black)|\
            pfoot+([[:blank:]])*|\
            phead+([[:blank:]])*|\
            zoom+([[:blank:]])d+([[:digit:]])|\
            zoom+([[:blank:]])+(stretch|one2one|width|page)|\
            note*)
                case "${META}" in
                        metadata)  case "${KEYS}" in
                            '') continue ;;
                            *) printf "(${META} ${KEYS})\n" ;;
                            esac
                        ;;
                        xmp) case "${XMP}" in
                            '') continue ;;
                            *) printf "(${META} \"${XMP//\"/\\\\\"}\")\n" ;;
                            esac
                        ;;
                        maparea) echo "(${META} ${URL} ${BORDER} ${KEYS})"
                        ;;
                esac
                printf "($line) "
                unset XMP
                unset KEYS
                unset BORDER
                unset URL
                unset META
            ;;
            +([[:digit:]])+([[:blank:]])*)
                echo "Kl√≠ƒç tvo≈ôen√Ω pouze ƒç√≠slem nen√≠ p≈ô√≠pustn√Ω ‚Äì> ${line}" >> /dev/stderr
                return 1
            ;;
            [[:digit:]]+([[:alnum:]])+([[:blank:]])\"*) #/ kl√≠ƒç zaƒç√≠naj√≠c√≠ ƒç√≠slem sice se≈æere, ale nezobraz√≠
                echo "Kl√≠ƒç zaƒç√≠naj√≠c√≠ ƒç√≠slem nen√≠ p≈ô√≠pustn√Ω ‚Äì> ${line}" >> /dev/stderr
                return 1               
            ;;
            url+([[:blank:]])\"*\"+([[:blank:]])\"*\")
                [ -n "${META}" ] || echo "${ERR}" >> /dev/stderr
                [ -n "${URL}" ] && echo "URL u≈æ je nastaveno!" >> /dev/stderr && return 1
                local TEMPORAR=(${line})
                if [ ${#TEMPORAR[@]} -eq 4 ] ; then
                    local URL="(${line[0]} ${line[1]} ${line[2]}) ${line[3]}"
                else
                    echo "Neplatn√© nastaven√≠ URL ‚Äì> ${line}"
                    return 1
                fi
            ;;
            \"*\"+([[:blank:]])\"*\")  #maparea bez URL
                [ -n "${META}" ] || echo "${ERR}" >> /dev/stderr
                [ -n "${URL}" ] && echo "URL u≈æ je nastaveno!" >> /dev/stderr && return 1
                local URL="${line}"
            ;;
            +(rect|oval|poly|line|text)+([[:blank:]])+([[:digit:]])+([[:blank:]])+([[:digit:]])+([[:blank:]])+([[:digit:]])+([[:blank:]])+([[:digit:]])*)
                [ -n "${META}" ] || echo "${ERR}" >> /dev/stderr
                [ -n "${BORDER}" ] && echo echo "BORDER u≈æ je nastaveno! ‚Äì> ${BORDER}" >> /dev/stderr && return 1
                local BORDER="(${line}) "
            ;;
            #shadow_*) # st√≠nov√°n√≠ - ƒç√≠slem uveden√° tlou≈°≈•ka
            #;;
            #hilite+([[:blank:]])\#+([[:digit:]])) # barva vysv√≠cen√≠
            #;;
            pushpin) # ≈°pendl√≠k
                [ -n "${META}" ] || echo "${ERR}" >> /dev/stderr
                [ "${META}" == "maparea" ] || echo "${INVALID}" >> /dev/stderr
                [ -n "${BORDER}" ] || echo "${ERR}" >> /dev/stderr
                case "${BORDER%% *}" in
                    \(text) local KEYS="${KEYS} (${line})"
                    ;;
                    *) echo "Atribut pushpin lze pou≈æ√≠t pouze je-li maparea typu text ‚Äì> ${BORDER}" >> /dev/stderr
                        return 1
                    ;;
                esac
            ;;
            arrow) # ≈°ipka
                [ -n "${META}" ] || echo "${ERR}" >> /dev/stderr
                [ "${META}" == "maparea" ] || echo "${INVALID}" >> /dev/stderr
                [ -n "${BORDER}" ] || echo "${ERR}" >> /dev/stderr
                case "${BORDER%% *}" in
                    \(line) local KEYS="${KEYS} (${line})"
                    ;;
                    *) echo "Atribut arrow lze pou≈æ√≠t pouze u typu 'line' proto se u ostan√≠ch typ≈Ø ignoruje ‚Äì> ${BORDER}." >> /dev/stderr
                    ;;
                esac
            ;;
            border_avis)
                [ -n "${META}" ] || echo "${ERR}" >> /dev/stderr
                [ "${META}" == "maparea" ] || echo "${INVALID}" >> /dev/stderr
                [ ! -n "${BORDER}" ] && echo "Nejprve mus√≠ b√Ωt nastavena oblast!" >> /dev/stderr
                case "${BORDER%% *}" in
                    \(line) echo "Atribut border_avis typ 'line' nepou≈æ√≠v√°, proto p≈ôi importu ignoruje." >> /dev/stderr
                    ;;
                    *) local KEYS="${KEYS} (${line})"
                    ;;
                esac
            ;;
            xor|none)
                [ -n "${META}" ] || echo "${ERR}" >> /dev/stderr
                [ "${META}" == "maparea" ] || echo "${INVALID}" >> /dev/stderr
                [ ! -n "${BORDER}" ] && echo "Nejprve mus√≠ b√Ωt nastavena oblast!" >> /dev/stderr
                local KEYS="${KEYS} (${line})"
            ;;
            +(opacity|width|shadow_+(in|out|ein|eout))+([[:blank:]])+([[:digit:]]))
                [ -n "${META}" ] || echo "${ERR}" >> /dev/stderr
                [ "${META}" == "maparea" ] || echo "${INVALID}" >> /dev/stderr
                [ ! -n "${BORDER}" ] && echo "Nejprve mus√≠ b√Ωt nastavena oblast!" >> /dev/stderr
                local KEYS="${KEYS} (${line})"
            ;;
            +(backclr|textclr|line_clr|lineclr|border|hilite)+([[:blank:]])\#[0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F])
                [ -n "${META}" ] || echo "${ERR}" >> /dev/stderr
                [ "${META}" == "maparea" ] || echo "${INVALID}" >> /dev/stderr
                [ ! -n "${BORDER}" ] && echo "Nejprve mus√≠ b√Ωt nastavena oblast!" >> /dev/stderr
                local KEYS="${KEYS} (${line})"
            ;;
            '') #echo "Pr√°zdn√Ω ≈ô√°dek - vyp√≠≈°e polo≈æku a vypne p≈ôechoz√≠ volbu"
                if [ "${META}" == "metadata" ] ; then
                    echo -e "(${META} ${KEYS})\n"
                    unset META
                    unset XMP
                    unset KEYS
                    unset BORDER
                    unset URL
                elif [ "${META}" == "xmp" ] ; then
                    echo -e "(${META} \"${XMP//\"/\\\\\"}\")\n"
                    unset META
                    unset XMP
                    unset KEYS
                    unset BORDER
                    unset URL
                elif [ "${META}" == "maparea" ] ; then
                    echo -e "(${META} ${URL} ${BORDER} ${KEYS})\n"
                    unset META
                    unset XMP
                    unset KEYS
                    unset BORDER
                    unset URL
                fi
            ;;
            \;*) #/ koment√°≈ôe
            ;;
            +([[:alpha:]])+([[:alnum:]])+([[:blank:]])\"*\") #/ Metadatov√© kl√≠ƒçe
                [ -n "${META}" ] || echo "${ERR}" >> /dev/stderr
                local KEYS="${KEYS} (${line})"
            ;;
            +([[:alpha:]])+([[:blank:]])\"*\") #/ Metadatov√© kl√≠ƒçe
                [ -n "${META}" ] || echo "${ERR}" >> /dev/stderr
                local KEYS="${KEYS} (${line})"
            ;;
            *) echo "Na ≈ô√°dku je chyba ‚Äì> ${line}" >> /dev/stderr
                return 1
            ;;
        esac
    done < $1
    printf "\n.\n"
}

# ###  <span id="dsed2ant">dsed2ant()</span> ([top](#FUNCTIONS))
# Tato funkce se star√° o zpracov√°n√≠ streamu v .dsed form√°tu do form√°tu .ant
# Je opakem funkce ant2dsed(). Vstup vypad√° takto:
#
#    # ------------------------- 
#    select "shared_anno.iff"
#    set-ant
#    (metadata (Author "jm√©no a p≈ô√≠jmen√≠") (Exif.Image.DateTime "2017:11:27 17:05:21"))
#    (background #000000 ) (zoom d50 ) 
#    .
# 
# A v√Ωstup takto:
#
#    # 'shared_anno.iff' ; remove-ant
#    set-ant
#    metadata
#        Author "jm√©no a p≈ô√≠jmen√≠"
#        Exif.Image.DateTime "2017:11:27 17:05:21"
#    background #000000
#    zoom d50
#
dsed2ant() {
    sed 's/\t/\n/g ; s/(/\n(/g ; s/("/\n\t"/g ; ' | grep -v ^$ | \
    sed '/^(m[ea][tp]a[dr][ae][ta]/! s/^(/\t(/ ; /^\t($/d ; s/) ) )/) )/ ; s/\\/\\\\0/g ; s/</\n</g' | \
    while read line ; do
        #/echo "zpracov√°v√°m ${line}" >> /dev/stderr
        case ${line} in
            \(metadata) echo -e "metadata"
                local TAB=""
            ;;
            \(xmp*) echo -e "xmp"
                local XMP="y"
                local TAB="\t"
            ;;
            \(maparea+([[:blank:]])\") echo -e "\n"
                local TAB="\t"
            ;;
            \(note+([[:blank:]])\"*) local TEMPORAR="${line#(}"
                echo -e "${TEMPORAR%\)}"
                unset TEMPORAR
                unset TAB
            ;;
            set-ant|set-txt)
            ;;
            *) if [ "${TAB}" == "\t" ] ; then
                    case "${line:0:2}" in
                        "(u") local TEMPORAR="${line#(}"
                            echo "maparea"
                            echo -e "${TAB}${TEMPORAR//\) /}"
                            unset TEMPORAR
                        ;;
#                        \#*) echo -n "# "
#                            unset TAB
#                        ;;
                        *) if [ -n "${XMP}" ] ; then
                                case "${line: -2}" in
                                    \"\)) local LINE="${line%>*}>"
                                        echo -e "${TAB}${LINE}" | sed 's/\x00//g'
                                        unset XMP
                                        unset LINE
                                    ;;
                                    *) local LINE="${line}"
                                        # local LINE=$(echo "${line}" | decode)
                                        echo -e "${TAB}${LINE}" | sed 's/\x00//g'
                                        unset LINE
                                    ;;
                                esac
                            else
                                local TEMPORAR="${line#(}"
                                echo -e "${TAB}${TEMPORAR// \)/}"
                                unset TEMPORAR
                            fi
                        ;;
                    esac
                else
                    local TEMPORAR="${line//[)(]/}"
                    case "${TEMPORAR}" in
                        maparea*) echo -e "${TEMPORAR/ /\\\n\\\t}"
                            unset TEMPORAR
                        ;;
                        background*|zoom*|mode*|align*|phead*|pfoot*)
                            #local TEMPORAR="${line#(}"
                            #echo -e "${TEMPORAR// \)/}"
                            echo "${TEMPORAR}"
                            unset TEMPORAR
                            unset TAB
                        ;;
                        \#*) echo -n "# "
                            unset TAB
                        ;;
                        select*) echo "${TEMPORAR}"
                        ;;
                        *) echo -e "\t${TEMPORAR}"
                            unset TEMPORAR
                        ;;
                    esac
                fi
            ;;
        esac
    done  | sed 's/) )/)/ ; /^$/d '
}

# ### <span id="printoutline">printoutline()</span> ([top](#FUNCTIONS))
# V p≈Øvodn√≠ podobƒõ byl v√Ωsledek zaps√°n do souboru s p≈ô√≠ponou .outline
# Vyu≈æ√≠v√° se p≈ôi akc√≠ch export a edit
# $1 - DjVu file
# $2 - c√≠l
printoutline() {
    log goto "printoutline() $1 ‚Äì> $2"
    bookmarktooutline "${1}"
    return 0
    # bookmarktooutline "${1}" | awk '{print i++ "\t|" $0}'
}

# ### <span id="writefile">writefile()</span> ([top](#FUNCTIONS))
# Funkce pr≈Øbƒõ≈ænƒõ konvertuje stream unicode znak≈Ø do jejich ƒç√≠seln√© podoby
# Velmi d≈Øle≈æit√° funkce!!! Vyu≈æ√≠v√° se p≈ôi akc√≠ch outline, import a edit.
writefile() {
    if [ -t 0 ]; then
        log info "writefile() Empty stdin"
        return 1
    else
        tee $1 >> /dev/null
        return 0
    fi
}

# ### <span id="decode">decode()</span> ([top](#FUNCTIONS))
# Funkce pr≈Øbƒõ≈ænƒõ konvertuje ƒç√≠selnou podobu unicode znak≈Ø ve streamu  do UTF-8
# Velmi d≈Øle≈æit√° funkce!!!
decode() {
    sed 's/\\/\\0/g' | tr '\000' '\\'
}

# ### <span id="encode">encode()</span> ([top](#FUNCTIONS))
# Funkce pr≈Øbƒõ≈ænƒõ konvertuje stream unicode znak≈Ø do jejich ƒç√≠seln√© podoby
# Velmi d≈Øle≈æit√° funkce!!!
encode() {
    while read -n 1 a
    do
    CHAR=($( echo "$a" | od -A n -t c ))
    if [ "${#CHAR[@]}" -gt "2" ] ; then 
        echo -n "\\${CHAR[0]}\\${CHAR[1]}"
    elif [ "${#CHAR[@]}" == "1" ] ; then 
        echo -n " "
    else
        if [ "${#CHAR[0]}" == "0" ] ; then
            echo -n " "
        else
            echo -n "${CHAR[0]}"
        fi
    fi
    done
}

# ### <span id="encodefile">encodefile()</span> ([top](#FUNCTIONS))
# Konvertuje bitmapov√Ω soubor v PAM form√°tu, p≈ôedan√Ω jako __$1__ do
# DjVu souboru __$2__
# Z√°kladn√≠m p≈ôedpokladem je, ≈æe pro tento PAM soubor (s p≈ô√≠ponou `.pam`)
# existuje minim√°lnƒõ jeden soubor ve form√°tu PBM pro vygenerov√°n√≠ masky.
#
# P≈ôednost m√° p≈ôitom soubor s p≈ô√≠ponou `.text`, kter√Ω (pokud existuje)
# obsahuje vyseparovan√© textov√© bloky.
#
# V p≈ô√≠padƒõ ≈æe neexistuje, je automaticky vy≈æadov√°n soubor s p≈ô√≠ponou
# `.fore`, kter√Ω byl vygenerov√°n funkc√≠ [separatemask](#separatemask)
encodefile() {
    log goto "encodefile() Use $1 ‚Äì> $2"
    if [ -f "${1/.pam/.text}" ] ; then
        ${CJB2} -lossy -clean "${1/.pam/.text}" "${1}.mask";
    else
        ${CJB2} -lossy -clean "${1/.pam/.fore}" "${1}.mask";
    fi
    ${DJVUMAKE} "${2}" Sjbz="${1}.mask" PPM="${1}";
}

# ### <span id="separatemask">separatemask()</span> ([top](#FUNCTIONS))
# Z bitmapov√©ho souboru ve form√°tu PAM, kter√Ω je p≈ôed√°n jako __$1__
# generuje ƒçernob√≠lou masku __$2__ ve form√°tu PBM.
# Jako parametr __$3__ se p≈ôed√°v√° buƒè algoritmus s parametry, nebo hodnota
# `none` s nastaven√≠m prahov√© hodnoty
#
# shading-subtraction - k od 3 (m√°lo ≈°umu) do 12 (hodnƒõ ≈°umu),
# ≈°um lze odstranit nastaven√≠m prahu (hodnota float)
# V√Ωsledek je p≈ôesnƒõ opaƒçn√Ω ne≈æ p≈ôi nastaven√≠ prahu - ƒç√≠m vy≈°≈°√≠ hodnota,
# t√≠m m√≠≈à toho proleze
separatemask() {
    log goto "separatemask() Use $3 for $1 ‚Äì> $2"
    case "${3%:*}" in
        none) if [ "${3#*:}" == "none" ] ; then
                log info "${PAMTOPNM} ${1} | ${PPMTOPGM} | ${PGMTOPBM} -threshold -value 0.5 | ${PNMTOPLAINPNM} > ${2}"
                ${PAMTOPNM} ${1} | ${PPMTOPGM} | ${PGMTOPBM} -threshold -value 0.5 | ${PNMTOPLAINPNM} > ${2}
            else
                log info "${PAMTOPNM} ${1} | ${PPMTOPGM} | ${PGMTOPBM} -threshold -value 0.${3#*:} | ${PNMTOPLAINPNM} > ${2}"
                ${PAMTOPNM} ${1} | ${PPMTOPGM} | ${PGMTOPBM} -threshold -value 0.${3#*:} | ${PNMTOPLAINPNM} > ${2}
            fi
            while [ ! -f "${2}" ] ; do
                sleep 0.1
            done
        ;;
        *) if [ -f "${HOME}/.config/${NAME}/${3}.conf" ] ; then
                local PARAMS=$(grep -v '^#' "${HOME}/.config/${NAME}/${3}.conf" | awk '{print "--param", $1}' | tr '\n' ' ')
            fi
            if [[ "${3}" =~ ":" ]] ; then
                local TEMPORAR="${3#*:}"
                local PARAMS=$(printf "xxx %s" ${TEMPORAR//,/ })
            fi
            ${DIDJVU} separate -o "${2}.png" ${LEVEL} -m "${3%:*}" ${PARAMS//xxx/ -x} "${1}"
            while [ ! -f "${2}.png" ] ; do
                sleep 0.1
            done
            pngtopam "${2}.png" > "${2}"
        ;;
    esac
    return $?
}

# ### <span id="bookmarktooutline">bookmarktooutline()</span> ([top](#FUNCTIONS))
# Funkce zpracov√°v√° z√°lo≈æky z DjVu souboru do form√°tu s odsazen√≠m
bookmarktooutline() {
    local TARGET="$1"
    local BEGIN=""
    local TAB=0
    ${DJVUSED} "${1}" -e 'print-outline' | sed -n '
    s|(|\n(\n|g
    s|)|\n)\n|g
    s|\\|\\\\0|g
    p
    ' |	while read y
    do
        case "$y" in
            \)) local TAB=$((TAB - 1))
            ;;
            \() local TAB=$((TAB + 1))
            ;;
            \"*) if [ "${BEGIN}" == "" ] ; then
                    local TEXT="$y"
                    local BEGIN="yes"
                else
                    for i in $(seq $((TAB-2))) ; do echo -en '\t' ; done
                    echo -e "${TEXT} ${y}"
                    local BEGIN=""
                fi
            ;;
        esac
    done
}

# ### <span id="outlinetodjvu">outlinetodjvu()</span> ([top](#FUNCTIONS))
# Funkce p≈ôev√°d√≠ obsah .outline souboru na form√°t .dsed
# a v√Ωsledek zapisuje do djvu souboru
# $1 - DjVu file
# $2 - soubor ve form√°tu .outline
outlinetodjvu() {
    log goto "outlinetodjvu() From $2 into $1"
    local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .bookmarks)
    if [ -f "${2}" ] ; then
        outlinetodsed "${2}" | encode > "${TEMPFILE}"
        ${DJVUSED}  "${1}" -e "set-outline ${TEMPFILE}; save"
    else
        log err "outlinetodjvu() Not any outline file"
        return 1
    fi
    return $?
}

# ### <span id="outlinetodjvu">outlinetodjvu()</span> ([top](#FUNCTIONS))
# Funkce p≈ôev√°d√≠ obsah ve form√°tu .outline na form√°t .dsed
# $1 - .outline file with TAB syntax
# Output is txt stream
outlinetodsed() {
    local TARGET="$1"
    # Remove comment from .outline file
    sed --in-place '/^#/d ; /^;/d' "${TARGET}"
    [ $(grep -c ^ "${TARGET}") -eq "0" ] && return 1
    local LEVEL="1"
    IFS=''
    echo -n "(bookmarks "
    CONTENT=$(sed '
        s/\ \ \ \ /\t/g
        s/^/\t/
        ' "${TARGET}" | while read line ; do
        local SPACE="${line%%\"*}"
        if [ "${#SPACE}" -gt "${LEVEL}" ] ; then
            local PREV="${PREV%)} ( ${line} )"
            local LEVEL=$((${LEVEL} + 1))
        elif [ "${#SPACE}" -eq "${LEVEL}" ] ; then
            local PREV="${PREV} ( ${line} )"
        elif [ "${#SPACE}" -lt "${LEVEL}" ] ; then
            local ROZDIL=$((${LEVEL} - ${#SPACE}))
            local ZAV=$(seq  -f "%1.0f" -s '' ${ROZDIL})
            local PREV="${PREV} ${ZAV//[[:digit:]]/)} ( $line )"
            local LEVEL=$((${LEVEL} - ${ROZDIL}))
        fi
        echo "${PREV}"
        echo "-----${LEVEL}"
    done | sed 's/\t/\ /g' | tail -2)
    TEST="${CONTENT##*-----}"
    echo -n "${CONTENT%-----*}"
    local ZAV=$(seq  -f "%1.0f" -s '' ${TEST})
    echo "${ZAV//[[:digit:]]/)}"
    return 0
}

#/ OBSOLETE
function importxmlpage {
	# $1 - DjVu file - full path
	# $2 - source XML file - full path
	# INFO: XML file has name of target page in self.
	case "${XML}" in
		no) echo "K importu textov√Ωch dat ze souboru ${2} se p≈ôistoup√≠ pouze bude-li uvedena volba -x" >> /dev/stderr
		;;
		*) ${DJVUXMLPARSER} -o "${1}" "${2}"
		;;
	esac
}

function getocr {
    log goto "getocr() OCR ${OCR} ‚Äì> ${1}"
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	if [ "${OCR}" ] ; then
		${OCRODJVU} --in-place -l "${OCR}" "${SOURCE}"
		[ "$?" ] && log info "getocr() OCR was applicated on ${FILE}" 
	fi
}

# ### <span id="mimefile">mimefile()</span> ([top](#FUNCTIONS))
# Function return type file by MIME
#
# $1 - jm√©no testovan√©ho souboru se kter√Ωm se pracuje
mimefile() {
    local SOURCE=$(${REALPATH} -m -P "${1}")
    local FILE="${SOURCE##*/}"
    if [ -f "${SOURCE}" ] ; then
        local TYPE=$(${MIME} -dbM "${SOURCE}" | awk '{print $1}')
    else
        log err "File ${1} is NOT valid."
        return 1
    fi
    log info "${1} ‚Äì> ${TYPE,,}"
    echo "${TYPE,,}"
    return 0
}

# ### <span id="isbundle">isbundle()</span> ([top](#FUNCTIONS))
# Function for test type file. For DjVu bundle (0), single (1), or another (1)
# $1 - file path
isbundle() {
    if [ $(mimefile "${1}") == "djvu" ] ; then
        ${DJVM} -l "${1}" &>/dev/null
        [ $? -eq 1 ] && log info "${1} ‚Äì> DjVu single file" && return 2
    else
        log err "${1} ‚Äì> NOT DjVu file"
        return 1
    fi
    log info "${1} ‚Äì> DjVu bundle file"
    return 0
}

# ### <span id="istarget">istarget()</span> ([top](#FUNCTIONS))
# Funkce nastavuje TARGETDIR a TARGETSAMPLE
istarget() {
    log goto "istarget() ‚Äì> $1"
    case "${1:$((${#1}-1)):1}" in
        /) TARGETSAMPLE="ORIGINAL"
            TARGETDIR=$(${REALPATH} -m -P "${1}")
            log info "targets() Export pages with a original names into ‚Äì> ${TARGETDIR}"
            [ ! -d "${TARGETDIR}" ] && mkdir -p "${TARGETDIR}"
        ;;
        *) if [[ "${1}" =~ "/" ]] ; then
                #/ obsahuje cestu
                local TEMPORARY=$(${REALPATH} -m -P "${1}")
                TARGETDIR="${TEMPORARY%/*}"
                TARGETSAMPLE="${TEMPORARY##*/}"
                log info "targets() Export pages a named by sample ${TARGETSAMPLE} ‚Äì> ${TARGETDIR}"
                [ ! -d "${TARGETDIR}" ] && mkdir -p "${TARGETDIR}"
            else
                #/ jde o vzorek
                TARGETDIR="$(pwd)/"
                TARGETSAMPLE="${1}"
                log info "targets() Export pages a named by sample ${TARGETSAMPLE} into actual directory"
            fi
        ;;
    esac
    return 0
}

# ### <span id="isrange">isrange()</span> ([top](#FUNCTIONS))
# Testuje, jestli p≈ôedan√Ω ≈ôetƒõzec __$1__ nezaƒç√≠n√° rozsahem (RANGE).
isrange() {
    local PARAMS=($1)
    case "${PARAMS[0]}" in
        +([0-9\-,]))
            log info "OK range ‚Äì> ${PARAMS[0]}"
            echo "${PARAMS[0]}"
            ;;
        *) log info "NOT range ‚Äì> ${PARAMS[0]}"
            return 1
            ;;
    esac
    return 0
}

# ### <span id="isscale">isscale()</span> ([top](#FUNCTIONS))
# Zji≈°≈•uje, zda-li p≈ôedan√Ω ≈ôetƒõzec zaƒç√≠n√° k√≥dem podporovan√©ho form√°tu
isformat() {
    log goto "isformat() string ‚Äì> $1"
    local PARAMS=($1)
    case "${PARAMS[0]}" in
        all)  #/ Volba pro DjVu
            #/ Vyexportuje v≈°echno
            ;;
        ant) #/ Volba pro DjVu
            #/ Pozn√°mky
            ;;
        note)  #/ Volba pro DjVu
            #/ export skryt√Ωch pozn√°mek
            ;;
        xmp)  #/ Volba pro DjVu
            #/ export XMP k√≥du
            ;;
        meta) #/ Volba pro DjVu
            ;;
        line|word|para) #/ Volby pro djvutxt
            ;;
        outline) #/ Volba pro DjVu
            #/ Obsah
            ;;
        bookmark) #/ Volba pro DjVu
            #/ Z√°lo≈æky
            ;;
        dsed-*) #/ Volba pro DjVu
            #/ Export textov√© vrstvy v dsed form√°tu
            #/ dsed-ant
            #/ dsed-all
            #/ dsed-txt
            ;;
        djvu) #/ Bitmapov√Ω soubor bude konvertov√°n do djvu
            #/ U DjVu souboru budou vyexportovan√© str√°nky slo≈æen√© opƒõt
            #/ do DjVu souboru
            ;;
        txt|text) #/ V p≈ô√≠padƒõ DjVu ƒçi PDF soubor≈Ø bude exportov√°n text
            #/ V ostatn√≠ch p≈ô√≠padech se str√°nka pro≈æene p≈ôes OCR
            ;;
        image*) #/ akceptov√°no u PDF a DjVu
            #/ V√Ωsledkem exporu bude obr√°zek str√°nky (u DjVu) nebo extrahovan√©
            #/ obr√°zky z PDF
            ;;
        orig*) #/ p≈Øvodn√≠ form√°t
            ;;
        jpg|jpeg|jp2)
            ;;
        pnm|pam)
            ;;
        mask|black|background|foreground|color) #/ Typ exportovan√© obrazov√© vrstvy
            ;;
        xcf|gimp)
            ;;
        xml-*) #/ Volba pro DjVu
            #/ export XML vrstvy
            #/ xml-ant
            #/ xml-all
            #/ xml-txt
            ;;
        *) return 1
            ;;
    esac
    log value "isformat() OK ‚Äì> ${PARAMS[0]}"
    echo "${PARAMS[0]}"
    return 0
}

# ### <span id="parsecut">parsecut()</span> ([top](#FUNCTIONS))
# Parsuje p≈ôedan√Ω ≈ôetƒõzec, kter√Ω m≈Ø≈ôe b√Ωt buƒè ve formƒõ:
# * LEFT,TOP,SIRKA,VYSKA
# * SIRKAxVYSKA+LEFT+TOP
#
# a vrac√≠ hodnoty v dan√©m po≈ôad√≠: W H X Y
#
# * W - (weight) ≈°√≠≈ôka boxu
# * H - (height) v√Ω≈°ka boxu
# * X - horizont√°ln√≠ vzd√°lenost od lev√©ho okraje
# * Y - vertik√°ln√≠ vzd√°lenost od horn√≠ho okraje
parsecut() {
    log goto "parsecut() $1"
    case ${1} in
                +([0-9])x+([0-9])|+([0-9])x+([0-9])[+]+([0-9])[+]+([0-9]))
                    local W="${1%%x*}"
                    local TEMPORAR="${1#*x}"
                    local H="${TEMPORAR%%+*}"
                    local TEMPORAR="${1#*+}"
                    local X="${TEMPORAR%+*}"
                    local Y="${1##*+}"
                ;;
                +([0-9]),+([0-9]),+([0-9]),+([0-9]))
                    local TEMPORAR=( ${1//,/ } )
                    local X="${TEMPORAR[0]}"
                    local Y="${TEMPORAR[1]}"
                    local W="${TEMPORAR[2]}"
                    local H="${TEMPORAR[3]}"
                ;;
                *) echo "Neplatn√© nastaven√≠ pro cut ‚Äì> ${1}" >> /dev/stderr
                    return 1
                ;;
    esac
    echo "$W $H $X $Y"
}

# ### <span id="imgcut">imgcut()</span> ([top](#FUNCTIONS))
# Funkce zpracov√°v√° ≈ôetƒõzec, kter√Ωm je identifikov√°na oblast vy≈æaduj√≠c√≠
# speci√°ln√≠ o≈°et≈ôen√≠. Ta m≈Ø≈æe b√Ωt nastavena dvƒõma mo≈æn√Ωmi zp≈Øsoby:
# LEFT,TOP,SIRKA,VYSKA nebo SIRKAxVYSKA+LEFT+TOP
# Za t√≠mto ≈ôetƒõzcem m≈Ø≈æe n√°sledovat dvojteƒçka, kter√° specifikuje typ r√°mce
# T - vymezen√° textov√° oblast se nakop√≠ruje na pr√°zdnou plochu `.text`
# I - vymezen√° oblast bude na masce `.fore` zaƒçernƒõn√°
# M - vymezen√° oblast bude na masce `.fore` zab√≠len√°
# G - grafika (ƒç√°ry a linky)
# bez specifikace typu r√°mce se p≈ôedpokl√°d√° ≈æe se m√° "zamaskovat" obr√°zek
#
# Pro zji≈°tƒõn√≠ sou≈ôadnic lze pou≈æ√≠t kup≈ô. geeqie Zobrazit ‚Äì> Zobrazit informace o pixelech
#
# Pro nastaven√≠ oblast√≠ lze pou≈æ√≠t i n√°stroj djvusmooth, ale sou≈ôadnice se mus√≠ p≈ôepoƒç√≠tat
# rect 225 0 804 61
#     LEFT,BOTTOM, LEFT+WIDTH,HEIGHT
imgcut() {
    log goto "imgcut() $1 ‚Äì> $2"
    local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .pam)
    local SIZE=(${1/:/ })
    local W=($(parsecut ${SIZE[0]}))
    [ $? -eq 1 ] && return 1
    if [ "${W[0]}" -eq "0" ] || [ "${W[1]}" -eq "0" ] || [ "${W[0]:0:1}" == "-" ] || [ "${W[1]:0:1}" == "-" ] ; then
        echo "${W[2]},${W[3]},[1m${W[0]}[0m,[1m${W[1]}[0m ‚Äì> ≈†√≠≈ôka a v√Ω≈°ka plochy mus√≠ m√≠t nenulovou velikost" >> /dev/stderr
        return 1
    fi
    local Y="${W[3]}"
    local X="${W[2]}"
    local H="${W[1]}"
    local W="${W[0]}"
    log info "imgcut W $W H $H X $X Y $Y"
    local FILENAME="${2%.*}"
    case ${#SIZE[@]} in
        1) #/ Vyjme vybranou oblast za ƒçernou plochu
            ${PBMMAKE} -black ${W} ${H} > ${TEMPFILE}
            log info "imgcut() ${FILENAME}.fore ‚Äì> ${FILENAME}.temp"
            ${PAMTOPNM} "${FILENAME}.fore" | ${PNMPASTE} ${TEMPFILE} "${X}" "${Y}" > "${FILENAME}.temp"
            mv -f "${FILENAME}.temp" "${FILENAME}.fore"
            rm -f ${TEMPFILE}
            log info "imgcut() Plocha $1 byla zamaskov√°na"
        ;;
        2) case ${SIZE[1]} in
            M) #/ Nahrad√≠ oblast za b√≠lou plochu (ve v√Ωsledku dojde k rozmaz√°n√≠
                ${PBMMAKE} -white ${W} ${H} > ${TEMPFILE}
                ${PAMTOPNM} "${FILENAME}.fore" | ${PNMPASTE} ${TEMPFILE} "${X}" "${Y}" > "${FILENAME}.temp"
                mv -f "${FILENAME}.temp" "${FILENAME}.fore"
                log info "imgcut() Plocha $1 byla odmaskov√°na"
            ;;
            T) #/ Text - vybran√° plocha z fore je nakl√≠ƒçovan√° na b√≠lou plochu
                #/ maska bude m√≠t p≈ô√≠ponu text
                ${PAMTOPNM} "${FILENAME}.fore" | ${PAMCUT} -left ${X} -top ${Y} -width ${W} -height ${H} > ${TEMPFILE}
                [ ! -f "${FILENAME}.text" ] && \
                    ${PBMMAKE} -white $(head -2 "${FILENAME}.fore" |tail -1) > "${FILENAME}.text"
                ${PAMTOPNM} "${FILENAME}.text" | ${PNMPASTE} ${TEMPFILE} "${X}" "${Y}" > "${FILENAME}.temp"
                mv -f "${FILENAME}.temp" "${FILENAME}.text"
                log info "imgcut() Plocha textu $1 byla vyseparovan√°"
            ;;
            I) #/ Obr√°zek - vybran√° plocha je na masce zaƒçernƒõn√°
                ${PBMMAKE} -black ${W} ${H} > ${TEMPFILE}
                ${PAMTOPNM} "${FILENAME}.fore" | ${PNMPASTE} ${TEMPFILE} "${X}" "${Y}" > "${FILENAME}.temp"
                mv -f "${FILENAME}.temp" "${FILENAME}.fore"
                log info "imgcut() Plocha $1 byla zamaskov√°na"
            ;;
            G) #/ Grafika - v r√°mci vybran√© plochy zredukuje barvy a pak ji nakl√≠ƒçuje do barevn√©ho pozad√≠
            ;;
            *) echo "Neimplemnetov√°no {SIZE[1]}" >> /dev/stderr
                return 1
            ;;
            esac
        ;;
        *) echo "Neplatn√© nastaven√≠ pro cut ‚Äì> $1" >> /dev/stderr
        ;;
    esac
}

# ### <span id="iscut">iscut()</span> ([top](#FUNCTIONS))
# Ovƒõ≈ôuje, zda-li n√°sleduje ≈ôetƒõzec pro specifikaci oblast√≠ pro zvl√°≈°tn√≠
# zach√°zen√≠. Tƒõchto oblast√≠ m≈Ø≈æe b√Ωt specifikov√°no v√≠ce, v takov√©m p≈ô√≠padƒõ
# v≈°ak mus√≠ b√Ωt oddƒõleny st≈ôedn√≠kem a uzav≈ôeny v uvozovk√°ch
iscut() {
    log goto "iscut() string ‚Äì> $1"
    local PARAMS=($1)
    log info "vysledek ${PARAMS[0]}"
    case "${PARAMS[0]}" in
        -cut) echo "${PARAMS[1]}"
        ;;
    esac
}

# ### <span id="isscale">isscale()</span> ([top](#FUNCTIONS))
# Nastavuje promƒõnnou SCALE a vrac√≠ o≈ôezan√Ω ≈ôetƒõzec
isscale() {
    log goto "isscale() string ‚Äì> $1"
    local PARAMS=($1)
    log info "vysledek ${PARAMS[0]}"
    case "${PARAMS[0]}" in
        [1-9]+([0-9])x[1-9]+([0-9]))
            case "${PARAMS[1]}" in
                -xyfit|-xyfill|-xysize)
                    SCALE="${PARAMS[1]} ${PARAMS[0]/x/ }"
                    local TEMPORAR=${1#*${PARAMS[1]}}
                ;;
                *) echo """P≈ôi ≈°k√°lov√°n√≠ na fixn√≠ rozmƒõt mus√≠ b√Ωt nastaven jeden z n√°sleduj√≠c√≠ch parametr≈Ø: 
  -xyfit
  -xyfill
  -xysize
                """
                    echo false
                ;;
            esac
        ;;
        0.|0.0|0.00) echo "Chybnƒõ nastavena hodnota ≈°k√°lov√°n√≠: ${PARAMS[0]}" >> /dev/stderr
            echo false
        ;;
        [1-9]+([0-9])x|x[1-9]+([0-9])) echo "Chybnƒõ nastaven√Ω ≈°k√°lovac√≠ box: ${PARAMS[0]}" >> /dev/stderr
            echo false
        ;;
        [0-9].[0-9]?([0-9])|+([0-9]))
            SCALE="${PARAMS[0]}"
            local TEMPORAR=${1#*${PARAMS[0]}}
        ;;
        *) return 1
            ;;
    esac
    if [[ "${TEMPORAR}" =~ "-filter=" ]] ; then
        local PARAMS=(${TEMPORAR#*-filter=})
        if [[ "${FILTERS[@]}" =~ "${PARAMS[0]}" ]] ; then
            echo "${SCALE} -filter=${PARAMS[0]}"
        else
            echo "Neplatn√Ω ≈°k√°lovac√≠ filtr: ${PARAMS[0]}" >> /dev/stderr
            echo false
        fi
    else
        echo "${SCALE}"
    fi
}

# ### <span id="fromdjvu">fromdjvu()</span> ([top](#FUNCTIONS))
# Na rozd√≠l od funkce exportimg, se zde zpracov√°vaj√≠ p≈ôedan√© parametry
# __$1__ je cesta ke kontejneru ze kter√©ho se exportuje str√°nka
# __$2__ obsahuje parametry
#
# * ant - Exportuje hyperlinky a meta atributy ve form√°tu .ant
# * meta - Exportuje meta informace str√°nky, jej√≠ rozmƒõry a stav rotace
# * djvu - Exportuje DjVu str√°nky
# * mask|background|foreground|color|black - oxportuje obr√°zek pozad√≠
# * dsed-*
# * xml-*
fromdjvu() {
    log goto "fromdjvu() ${FILETYPE} $1 ‚Äì> $2"
    local INTO=$(isformat "${2}")
    if [ -n "${INTO}" ] ; then
        local TEMPORAR="${2#*${INTO}}"
    else
        echo "C√≠lov√Ω form√°t mus√≠ b√Ωt v≈ædy uveden!" >> /dev/stderr
        return 1
    fi

    local RANGE=$(isrange "${TEMPORAR}")
    if [ -n "${RANGE}" ] ; then
        local TEMPORAR="${TEMPORAR#*${RANGE}}"
    fi

    case "${TEMPORAR:$((${#TEMPORAR}-1)):1}" in
        /) TARGETDIR=$(${REALPATH} -m -P "${TEMPORAR## }")
            log info "fromdjvu() Export pages with a original names into ‚Äì> ${TARGETDIR}"
            [ ! -d "${TARGETDIR}" ] && mkdir -p "${TARGETDIR}"
        ;;
        *) if [[ "${TEMPORAR}" =~ "/" ]] ; then
                #/ obsahuje cestu
                local TEMPORARY=$(${REALPATH} -m -P "${TEMPORAR## }")
                TARGETDIR="${TEMPORARY%/*}"
                TARGETSAMPLE="${TEMPORARY##*/}"
                log info "fromdjvu() Export pages a named by sample ${TARGETSAMPLE} ‚Äì> ${TARGETDIR}"
                [ ! -d "${TARGETDIR}" ] && mkdir -p "${TARGETDIR}"
            else
                #/ jde o vzorek
                TARGETDIR="$(pwd)"
                TARGETSAMPLE="${TEMPORAR## }"
                log info "targets() Export pages a named by sample ${TARGETSAMPLE} into actual directory"
            fi
        ;;
    esac
    echo """
    RANGE ${RANGE}
    INTO ${INTO}
    TARGETDIR ${TARGETDIR}
    TARGETSAMPLE ${TARGETSAMPLE}
    TEMPORAR ${TEMPORAR}
    M≈Ø≈æeme p≈ôikroƒçit k akci
    """ >> /dev/null
    mapfile -t ARRAY <<< $($0 "${1}" info list)
    case "${ARRAY:0:1}" in
        0) mapfile -t LISTPAGES <<< $(printf "%s\n" "${ARRAY[@]}")
        ;;
        *) LISTPAGES="0 none"
        mapfile -O 1 -t LISTPAGES <<< $(printf "%s\n" "${ARRAY[@]}")
        ;;
    esac
#/    echo "ARRAY ${#ARRAY[@]} ${ARRAY[@]}" >> /dev/stderr
#/    echo "LISTPAGES ${#LISTPAGES[@]} ${LISTPAGES[@]}" >> /dev/stderr
    case "${INTO}" in
        djvu|ant|note|meta|mask|background|foreground|color|black|dsed-*|xmp|xml-*|\
        line|word|para)
            if [ -n "${RANGE}" ] ; then
                local PAGES=($(range "${RANGE}"))
            else
                case "${TEMPORAR//+([[:blank:]])/}" in
                    '') # jenom p≈ô√≠kaz
                        local PAGES=($(range "0-${#LISTPAGES[@]}"))
                    ;;
                    *) # seznam str√°nek oddƒõlen√Ωch ƒç√°rkou
                        local IFS_BAK=$IFS
                        local IFS=$','
                        local SEZNAM=($TEMPORAR)
                        local IFS=$IFS_BAK
                        for i in "${LISTPAGES[@]}" ; do
                            if [[ "${SEZNAM[@]}" =~ "${i##+([[:digit:]])+([[:blank:]])}" ]] ; then
                                local TEMP="$TEMP${i%% *} "
                            fi
                            x=$((x + 1))
                        done
                        local PAGES=($TEMP)
                    ;;
                esac
            fi
#/            echo "PAGES ${#PAGES[@]} ${PAGES[@]}" >> /dev/stderr
            for i in ${PAGES[@]} ; do
                local PAGENAME="${LISTPAGES[$i]##+([[:digit:]])+([[:blank:]])}"
                local PAGEORDER="${LISTPAGES[$i]%% *}"
                case "${PAGEORDER}" in
                    0) case "${PAGENAME}" in
                            none)
                            ;;
                            *) case ${INTO} in
                                line|word|para)
                                ;;
                                ant)printf "# 'shared_anno.iff'\n"
                                    ${DJVUSED} "${1}" -e "select 'shared_anno.iff'; print-ant" | dsed2ant
                                ;;
                                meta) printf "# 'shared_anno.iff'\n"
                                    local META=$(${DJVUSED} "${1}" -e "select 'shared_anno.iff'; print-meta" | decode)
                                echo -e "${META}"
                                ;;
                                note) ${DJVUSED} "${1}" -e "select 'shared_anno.iff'; print-ant" | dsed2ant | grep ^note | xargs -n1 | grep -v ^note
                                ;;
                                xmp) ${DJVUSED} "${1}" -e "select 'shared_anno.iff'; print-ant" | dsed2ant | while read line
                                do
                                    case "${line}" in
                                        xmp) local PRINT="yes" ;;
                                        \<*) echo "${line}" ;;
                                        *) [ -n "${PRINT}" ] && break ;;
                                    esac
                                done
                                ;;
                                djvu) log info "Po≈ôadov√© ƒç√≠slo 0 m√° v≈ædy soubor sd√≠len√Ωch pozn√°mek, kter√Ω nelze vyexportovat jako DjVu str√°nku"
                                ;;
                                dsed-*) local EXPORT="output-ant"
                                    local TARGET=$(${REALPATH} -m -P "${TARGETDIR}/${PAGENAME}.dsed")
                                    if [ -f "${TARGET}" ] ; then
                                        anone "Soubor ${TARGET##*/} ji≈æ existuje a m≈Ø≈æe obsahovat zmƒõny. M√°m ho p≈ôepsat?"
                                        [ $? -eq 1 ]&& return 1
                                    fi
                                    printf "select '${PAGENAME}' ; remove-ant\n" > "${TARGET}"
                                    ${DJVUSED} "${1}" -e "select 'shared_anno.iff'; ${EXPORT}" >> "${TARGET}"
                                    [ $? -eq 1 ] && return 1
                                    echo "Soubor ${TARGET} byl zaps√°n" >> /dev/stderr
                                ;;
                            esac
                            ;;
                        esac
                    ;;
                    '') echo ""
                    ;;
                    *) local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .ant)
                        case ${INTO} in
                            line|word|para)  printf "# '${PAGENAME}' # page ${PAGEORDER}\n"
                                ${DJVUTXT} -page="${PAGEORDER}" -detail="${INTO}" "${FILE}" 
                                ;;
                            ant) printf "# '${PAGENAME}' # page ${PAGEORDER}\n"
                                ${DJVUSED} "${1}" -e "select ${PAGEORDER}; print-ant" | dsed2ant
                            ;;
                            meta) printf "# '${PAGENAME}' # page ${PAGEORDER} "
                                ${DJVUSED} "${1}" -e "select ${PAGEORDER}; size"
                                local META=$(${DJVUSED} "${1}" -e "select ${PAGEORDER}; print-meta" | decode)
                                [ -n "${META}" ] && echo -e "${META}"
                            ;;
                            note) ${DJVUSED} "${1}" -e "select ${PAGEORDER}; print-ant" | dsed2ant | grep ^note | xargs -n1 | grep -v ^note
                            ;;
                            xmp) ${DJVUSED} "${1}" -e "select ${PAGEORDER}; print-ant" | dsed2ant | while read line
                                do
                                    case "${line}" in
                                        xmp) local PRINT="yes" ;;
                                        \<*) echo "${line}" ;;
                                        *) [ -n "${PRINT}" ] && break ;;
                                    esac
                                done
                            ;;
                            djvu)
                                if [ -n "${TARGETSAMPLE}" ] ; then
                                    local TARGET=$(${REALPATH} -m -P "${TARGETDIR}/${TARGETSAMPLE}")
                                else
                                    local TARGET=$(${REALPATH} -m -P "${TARGETDIR}/${PAGENAME}")
                                fi
                                if [ -f "${TARGET}" ] ; then
                                    anone "Soubor ${TARGET} ji≈æ existuje. M√°m ho p≈ôepsat?"
                                    [ $? -eq 1 ]&& continue
                                fi
                                ${DJVUSED} "${1}" -e "select ${PAGEORDER}; save-page-with '${TARGET}'"
                                echo "Exportuji str√°nku ${PAGEORDER} do souboru ${TARGET}" >> /dev/stderr
                            ;;
                            mask|background|foreground|color|black)
                                local TARGET=$(${REALPATH} -m -P "${TARGETDIR}/${PAGENAME/.djvu/.png}")
                                ${DDJVU} -format=pnm -mode=${INTO} -page="${PAGEORDER}" "${1}" | ${PNMTOPNG} > "${TARGET}"
                                [ $? -eq 1 ] && return 1
                                echo "Soubor ${TARGET} byl zaps√°n" >> /dev/stderr
                            ;;
                            dsed-*)
                                case ${INTO} in
                                    dsed-all) local EXPORT="output-all"
                                        local IMPORT="remove-ant; remove-txt"
                                        local TARGET=$(${REALPATH} -m -P "${TARGETDIR}/${PAGENAME/.djvu/.dsed}")
                                    ;;
                                    dsed-txt) local EXPORT="output-txt"
                                        local IMPORT="remove-txt"
                                        local TARGET=$(${REALPATH} -m -P "${TARGETDIR}/${PAGENAME/.djvu/.txt.dsed}")
                                    ;;
                                    dsed-ant) local EXPORT="output-ant"
                                        local IMPORT="remove-ant"
                                        local TARGET=$(${REALPATH} -m -P "${TARGETDIR}/${PAGENAME/.djvu/.ant.dsed}")
                                    ;;
                                    *) return 1
                                    ;;
                                esac
                                if [ -f "${TARGET}" ] ; then
                                    anone "Soubor ${TARGET##*/} ji≈æ existuje a m≈Ø≈æe obsahovat zmƒõny. M√°m ho p≈ôepsat?"
                                    [ $? -eq 1 ]&& return 1
                                fi
                                printf "select '${PAGENAME}' ; ${IMPORT}\n" > "${TARGET}"
                                ${DJVUSED} "${1}" -e "select ${PAGEORDER}; ${EXPORT}" >> "${TARGET}"
                                [ $? -eq 1 ] && return 1
                                echo "Soubor ${TARGET} byl zaps√°n" >> /dev/stderr
                            ;;
                            xml-*) local TARGET=$(${REALPATH} -m -P "${TARGETDIR}/${PAGENAME/.djvu/.xml}")
                                case ${INTO} in
                                    xml-all) local EXPORT="--with-text --with-anno"
                                    ;;
                                    xml-txt) local EXPORT="--with-text --without-anno"
                                    ;;
                                    xml-ant) local EXPORT="--without-text --with-anno"
                                    ;;
                                    *) return 1
                                    ;;
                                esac
                                if [ -f "${TARGET}" ] ; then
                                    anone "Soubor ${PAGENAME/.djvu/.xml} ji≈æ existuje a m≈Ø≈æe obsahovat zmƒõny. M√°m ho p≈ôepsat?"
                                    [ $? -eq 1 ]&& return 1
                                fi
                                ${DJVUTOXML} --page "${PAGEORDER}" ${EXPORT} "${1}" "${TARGET}"
                                [ $? -eq 1 ] && return 1
                                echo "Soubor ${TARGET} byl zaps√°n" >> /dev/stderr
                            ;;
                        esac
                    ;;
                esac
            done
            ;;
        outline) # Export obsahu ve form√°tu .outline
            printoutline "${1}"
            ;;
        bookmark) # Export obsahu ve form√°tu .bookmarks
            local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .outline)
            printoutline "${1}" > ${TEMPFILE}
            outlinetodsed ${TEMPFILE} | encode
            printf "\n"
            ;;
        *) echo "Nedƒõl√°m nic ${INTO}" >> /dev/stderr
            ;;
    esac
}

# ### P≈Øvodn√≠ zpracov√°n√≠ - oƒçek√°v√° parametry ze startu message
# Zpracov√°v√° stream. pokud se vyskytne, vr√°t√≠ parametr a zbytek ≈ôetƒõzce
#
# Funkce je z√°visl√° na obsahu lok√°ln√≠ promƒõnn√© ELEMENT z funkce setdjvu
object() {
    # Je tady - vr√°t√≠ parametr, ≈ôetƒõzec a 0
    # Nen√≠ tady nic - vr√°t√≠ ≈ôetƒõzec a 1
    log goto "object() ${ELEMENT} ‚Äì> $@"
    while [ $# -gt 0 ]
    do
        case ${1} in
            border_avis|none|xor) case ${ELEMENT} in
                rect|oval|text) echo -e "\t$1" && shift
                ;;
                *) return 1
                ;;
            esac
            ;;
            pushpin) case ${ELEMENT} in
                text) echo -e "\t$1" && shift
                ;;
                *) return 1
                ;;
            esac
            ;;
            hilite) case ${ELEMENT} in
                rect) local PROPERTY="${1}" && shift
                    case "${1}" in
                        [0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F]) echo -e "\t${PROPERTY} #$1" && shift
                        ;;
                        *) help set-${PROPERTY}
                            return 1
                        ;;
                    esac
                ;;
                line|oval|text|arrow) shift
                    case "${1}" in
                        [0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F]) shift
                            echo "Nastaven√≠ parametru border (barva okraje) u objektu ${ELEMENT} ned√°v√° smysl, proto ho ignoruji" >> /dev/stderr
                            echo "Barvu linky lze zmƒõnit parametrem lineclr" >> /dev/stderr
                            return 1
                        ;;
                        *) help set-line
                            return 1
                        ;;
                    esac
                ;;
                *) return 1
                ;;
            esac
            ;;
            textclr|backclr|lineclr) case ${ELEMENT} in
                rect|oval|text|arrow) local PROPERTY="${1}" && shift
                    case "${1}" in
                        [0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F]) echo -e "\t${PROPERTY} #$1" && shift
                        ;;
                        *) help set-${PROPERTY}
                            return 1
                        ;;
                    esac
                ;;
                line) shift
                    case "${1}" in
                        [0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F]) shift
                            echo "Nastaven√≠ parametru border (barva okraje) u objektu ${ELEMENT} ned√°v√° smysl, proto ho ignoruji" >> /dev/stderr
                            echo "Barvu linky lze zmƒõnit parametrem lineclr" >> /dev/stderr
                            return 1
                        ;;
                        *) help set-line
                            return 1
                        ;;
                    esac
                ;;
                *) return 1
                ;;
            esac
            ;;
            _blank) echo -e "$1" && shift
                # Kv≈Øli url
            ;;
            border) case "${ELEMENT}" in
                rect|oval) local PROPERTY="${1}" && shift
                    case "${1}" in
                        [0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F]) echo -e "\t${PROPERTY} #$1" && shift
                        ;;
                        *) echo "xxxxx ${1}" >> /dev/stderr
                            help set-${PROPERTY}
                            return 1
                        ;;
                    esac
                ;;
                line) shift
                    case "${1}" in
                        [0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F]) shift
                            echo "Nastaven√≠ parametru border (barva okraje) u objektu ${TYPE} ned√°v√° smysl, proto ho ignoruji" >> /dev/stderr
                            echo "Barvu linky lze zmƒõnit parametrem lineclr" >> /dev/stderr
                            return 1
                        ;;
                        *) help set-line
                            return 1
                        ;;
                    esac
                ;;
                *) return 1
                ;;
            esac
            ;;
            shadow_+(in|out|ein|eout)) case ${ELEMENT} in
                rect) local PROPERTY="${1}" && shift
                    case "${1}" in
                        [1-9]|[1-9][0-9]) echo -e "\t${PROPERTY} $1" && shift
                        ;;
                        *) help set-${PROPERTY}
                            return 1
                        ;;
                    esac
                ;;
                text) echo "Nastaven√≠ st√≠novan√©ho okraje by zobrazov√°n√≠ objektu ${TYPE} znemo≈ænilo, proto ho ignoruji" >> /dev/stderr
                    case "${1}" in
                        [1-9]|[1-9][0-9]) shift
                            echo "Nastaven√≠ st√≠novan√©ho okraje by zobrazov√°n√≠ objektu ${TYPE} znemo≈ænilo, proto ho ignoruji" >> /dev/stderr
                        ;;
                        *) help set-${PROPERTY}
                            return 1
                        ;;
                    esac
                ;;
                *) return 1
                ;;
            esac
            ;;
            opacity) case ${ELEMENT} in
                rect|oval) local PROPERTY="${1}" && shift
                    case "${1}" in
                        [1-9]|[1-9][0-9]) echo -e "\t${PROPERTY} $1" && shift
                        ;;
                        *) help set-${PROPERTY}
                            return 1
                        ;;
                    esac
                ;;
                *) return 1
                ;;
            esac
            ;;
            width) case ${ELEMENT} in
                line|arrow) local PROPERTY="${1}" && shift
                    case "${1}" in
                        [1-9]|[1-9][0-9]) echo -e "\t${PROPERTY} $1" && shift ;;
                        *) help set-${PROPERTY} ; return 1 ;;
                    esac
                ;;
                rect|text|oval|poly)
                    case "${1}" in
                        [1-9]|[1-9][0-9]) shift ;;
                        *) help set-${PROPERTY} ; return 1 ;;
                    esac
                ;;
                *) return 1
                ;;
            esac
            ;;
            *) # echo "$@"
                break
            ;;
        esac
    done
    return 0
}

# ### <span id="djvumove">djvumove()</span> ([top](#FUNCTIONS))
# __$1__ je cesta k DjVu souboru ve kter√©m se p≈ôejmenov√°v√° str√°nka
# __$2__ obsahuje parametry
# [[:digit:]] - p≈ôesouv√° str√°nku
# by default se str√°nka p≈ôesouv√° dozadu
# fore - obr√°t√≠ smƒõr p≈ôesunu
djvumove() {
    # ovƒõ≈ôit nejprve jde-li o jednu str√°nku
    mapfile -t ARRAY <<< $($0 "${1}" info list)
    case "${ARRAY:0:1}" in
        0) mapfile -t LISTPAGES <<< $(printf "%s\n" "${ARRAY[@]}")
        ;;
        *) LISTPAGES="0 none"
            mapfile -O 1 -t LISTPAGES <<< $(printf "%s\n" "${ARRAY[@]}")
        ;;
    esac
    for i in "${LISTPAGES[@]}" ; do
        if [[ "${2}" =~ "${i##+([[:digit:]])+([[:blank:]])}" ]] ; then
            log info "Jedna str√°nka ${i}"
            local TEMP="$TEMP${i%% *} "
        fi
        x=$((x + 1))
    done
    local TEMP=(${TEMP})
    case "${#TEMP[@]}" in
        2) # obƒõ jm√©nem
            local TEST="${2//${LISTPAGES[${TEMP[0]}]##+([[:digit:]])+([[:blank:]])}/}"
            case "${TEST: -1:1}" in
                +([[:blank:]])) # Kdy≈æ z≈Østane na konci mezera, bylo to na pozici 2
                    log info "Str√°nku ${LISTPAGES[${TEMP[0]}]} p≈ôesouv√°m v≈Øƒçi ${LISTPAGES[${TEMP[1]}]} ‚Äì> ${ACTION}"
                    local POS1="${LISTPAGES[${TEMP[0]}]%%+([[:blank:]])*}"
                    local POS2="${LISTPAGES[${TEMP[1]}]%%+([[:blank:]])*}"
                ;;
                u) # Kdy≈æ z≈Østane na konci u, bylo to na pozici 1
                    log info "Str√°nku ${LISTPAGES[${TEMP[1]}]}  p≈ôesouv√°m v≈Øƒçi ${LISTPAGES[${TEMP[0]}]} ‚Äì> ${ACTION}"
                    local POS1="${LISTPAGES[${TEMP[1]}]%%+([[:blank:]])*}"
                    local POS2="${LISTPAGES[${TEMP[0]}]%%+([[:blank:]])*}"
                ;;
                *) echo "Nƒõjak√© divn√©" >> /dev/stderr
                ;;
            esac
        ;;
        1) # jedna jm√©nem, nebo jenom jedna
            local TEST="${2//${LISTPAGES[${TEMP[0]}]##+([[:digit:]])+([[:blank:]])}/}"
            case "${TEST:0:1}" in
                +([[:digit:]])) # Kdy≈æ z≈Østane na zaƒç√°tku ƒç√≠slo, bylo to na pozici 2
                    log info "Str√°nku ${TEST} p≈ôesouv√°m v≈Øƒçi ${LISTPAGES[${TEMP[0]}]} ‚Äì> ${ACTION}"
                    local POS1="${TEST// /}"
                    local POS2="${LISTPAGES[${TEMP[0]}]%%+([[:blank:]])*}"
                ;;
                +([[:blank:]])) # Kdy≈æ z≈Østane na zaƒç√°tku mezera, bylo to na pozici 1
                    log info "Str√°nku ${LISTPAGES[${TEMP[0]}]}  p≈ôesouv√°m v≈Øƒçi ${TEST} ‚Äì> ${ACTION}"
                    local POS1="${LISTPAGES[${TEMP[0]}]%%+([[:blank:]])*}"
                    local POS2="${TEST// /}"
                ;;
                *) log info "Jenom jedna str√°nka ${LISTPAGES[${TEMP[0]}]} ‚Äì> ${ACTION}"
                    local POS1="${LISTPAGES[${TEMP[0]}]%%+([[:blank:]])*}"
                ;;
            esac
        ;;
        *) local TEST=(${2})
            case "${#TEST[@]}" in
                2) #/ echo "Dvƒõ ƒç√≠slem"
                    for i in ${TEST[@]}
                    do case $i in
                        +([[:digit:]])) ;;
                        *) echo "Neplatn√Ω identifik√°tor $i" >> /dev/stderr && return 1 ;;
                        esac
                    done
                    local POS1=${TEST[0]}
                    local POS2=${TEST[1]}
                ;;
                1) #/ echo "Jedna ƒç√≠slem"
                    case "${TEST[0]}" in
                        +([[:digit:]])) ;;
                        *) echo "Neplatn√Ω identifik√°tor ${TEST[0]}" >> /dev/stderr && return 1 ;;
                    esac
                    local POS1=${TEST[0]}
                ;;
                *) echo "Nƒõco je ≈°patnƒõ" >> /dev/stderr
                    return 1
                ;;
            esac
        ;;
    esac
    local TEMP="${LISTPAGES[@]: -1}"
    local LAST="${TEMP%%+([[:blank:]])*}"
    echo """
Str√°nku z pozice
${POS1}
${ACTION}
${POS2}
${LAST}
""" >> /dev/null
    [[ "${POS1}" -lt "1" ]] && return 1
    [[ "${POS1}" -gt "${LAST}" ]] && echo "Soubor m√° pouze ${LAST} str√°nek" >> /dev/stderr && return 1
    if [ -n "${POS2}" ] ; then
        [[ "${POS2}" -lt "1" ]] && return 1
        [[ "${POS2}" -gt "${LAST}" ]] && echo "Soubor m√° pouze ${LAST} str√°nek" >> /dev/stderr && return 1
        if [ ${POS1} -lt ${POS2} ] ; then
            case "${ACTION}" in
                fore) if [ ${POS1} == $((${POS2} - 1)) ] ; then
                        echo "Nedƒõl√°m nic. Pozice str√°nky ${LISTPAGES[$POS1]##+([[:digit:]])+([[:blank:]])} by z≈Østala stejn√°" >> /dev/stderr
                    else
                        echo "P≈ôesun dozadu z pozice ${POS1} na $((${POS2}-1))"  >> /dev/stderr
                        local PAGE="${LISTPAGES[$POS1]##+([[:digit:]])+([[:blank:]])}"
                        $0 "${1}" export djvu "${POS1}" "${TEMPDIR}/${PAGE}"
                        [ $? -eq 1 ] && echo "P≈ôi pokusu o export str√°nky ${POS1} se vyskytla chyba" && return 1
                        $0 "${1}" delete "${POS1}"
                        [ $? -eq 1 ] && echo "P≈ôi pokusu o odstranƒõn√≠ str√°nky ${POS1} se vyskytla chyba" && return 1
                        $0  -f "${1}" import page "$((${POS2}-1))" "${TEMPDIR}/${PAGE}"
                    fi
                ;;
                *) if [ ${POS1} == $((${POS2} - 1)) ] ; then
                        echo "Nedƒõl√°m nic, pozice str√°nky ${LISTPAGES[$POS1]##+([[:digit:]])+([[:blank:]])} by z≈Østala stejn√°"  >> /dev/stderr
                    else
                        log info "P≈ôesun dozadu z pozice ${POS1} na ${POS2}"
                        local PAGE="${LISTPAGES[$POS1]##+([[:digit:]])+([[:blank:]])}"
                        $0 "${1}" export djvu "${POS1}" "${TEMPDIR}/${PAGE}"
                        [ $? -eq 1 ] && echo "P≈ôi pokusu o export str√°nky ${POS1} se vyskytla chyba" && return 1
                        $0 "${1}" delete "${POS1}"
                        [ $? -eq 1 ] && echo "P≈ôi pokusu o odstranƒõn√≠ str√°nky ${POS1} se vyskytla chyba" && return 1
                        $0  -f "${1}" import page "${POS2}" "${TEMPDIR}/${PAGE}"
                    fi
                ;;
            esac
        elif [ ${POS1} -gt ${POS2} ] ; then
            #/ po odstranƒõn√≠ ${POS1} se po≈ôad√≠ nezmƒõn√≠
            case "${ACTION}" in
                fore)
                    log info "P≈ôesun str√°nky z pozice ${POS1} na pozici ${POS2}"
                    local PAGE="${LISTPAGES[$POS1]##+([[:digit:]])+([[:blank:]])}"
                    $0 "${1}" export djvu "${POS1}" "${TEMPDIR}/${PAGE}"
                    [ $? -eq 1 ] && echo "P≈ôi pokusu o export str√°nky ${POS1} se vyskytla chyba" && return 1
                    $0 "${1}" delete "${POS1}"
                    [ $? -eq 1 ] && echo "P≈ôi pokusu o odstranƒõn√≠ str√°nky ${POS1} se vyskytla chyba" && return 1
                    $0  -f "${1}" import page "${POS2}" "${TEMPDIR}/${PAGE}"
                ;;
                *) if [ ${POS1} == $((${POS2} + 1)) ] ; then
                        echo "Nedƒõl√°m nic. Pozice str√°nky ${LISTPAGES[$POS1]##+([[:digit:]])+([[:blank:]])} by z≈Østala stejn√°"  >> /dev/stderr
                    else
                        log info "P≈ôesun z pozice ${POS1} na pozici $((${POS2}+1))"
                        local PAGE="${LISTPAGES[$POS1]##+([[:digit:]])+([[:blank:]])}"
                        $0 "${1}" export djvu "${POS1}" "${TEMPDIR}/${PAGE}"
                        [ $? -eq 1 ] && echo "P≈ôi pokusu o export str√°nky ${POS1} se vyskytla chyba" && return 1
                        $0 "${1}" delete "${POS1}"
                        [ $? -eq 1 ] && echo "P≈ôi pokusu o odstranƒõn√≠ str√°nky ${POS1} se vyskytla chyba" && return 1
                        $0  -f "${1}" import page "$((${POS2}+1))" "${TEMPDIR}/${PAGE}"
                    fi
                ;;
            esac
        else
            echo "Str√°nka ${LISTPAGES[$POS1]##+([[:digit:]])+([[:blank:]])} je na urƒçen√© pozici" >> /dev/stderr
        fi
    else
        # / p≈ôesouv√°m dokud nedojdu na konec, ƒçi na zaƒç√°tek
        case "${ACTION}" in
            fore) if [ ${POS1} == 1 ] ; then
                    echo "Str√°nka ${LISTPAGES[1]##+([[:digit:]])+([[:blank:]])} je na zaƒç√°tku souboru" >> /dev/stderr
                else
                    log info "P≈ôesun z pozice ${POS1} na pozici $((${POS1}-1))"
                    local PAGE="${LISTPAGES[$POS1]##+([[:digit:]])+([[:blank:]])}"
                    $0 "${1}" export djvu "${POS1}" "${TEMPDIR}/${PAGE}"
                    [ $? -eq 1 ] && echo "P≈ôi pokusu o export str√°nky ${POS1} se vyskytla chyba" && return 1
                    $0 "${1}" delete "${POS1}"
                    [ $? -eq 1 ] && echo "P≈ôi pokusu o odstranƒõn√≠ str√°nky ${POS1} se vyskytla chyba" && return 1
                    $0  -f "${1}" import page "$((${POS1}-1))" "${TEMPDIR}/${PAGE}"
                fi
            ;;
            *) if [ ${POS1} == ${LAST} ] ; then
                    echo "Str√°nka ${LISTPAGES[$POS1]##+([[:digit:]])+([[:blank:]])} je na konci souboru" >> /dev/stderr
                else
                    log info "P≈ôesun z pozice ${POS1} na pozici $((${POS1}+1)) ‚Äì ƒç√≠slov√°n√≠ str√°nek se po odstranƒõn√≠ str√°nky zmen≈°√≠"
                    local PAGE="${LISTPAGES[$POS1]##+([[:digit:]])+([[:blank:]])}"
                    $0 "${1}" export djvu "${POS1}" "${TEMPDIR}/${PAGE}"
                    [ $? -eq 1 ] && echo "P≈ôi pokusu o export str√°nky ${POS1} se vyskytla chyba" && return 1
                    $0 "${1}" delete "${POS1}"
                    [ $? -eq 1 ] && echo "P≈ôi pokusu o odstranƒõn√≠ str√°nky ${POS1} se vyskytla chyba" && return 1
                    $0  -f "${1}" import page "$((${POS1}+1))" "${TEMPDIR}/${PAGE}"
                fi
            ;;
        esac
    fi
}

# ### <span id="djvurename">djvurename()</span> ([top](#FUNCTIONS))
# __$1__ je cesta k DjVu souboru ve kter√©m se p≈ôejmenov√°v√° str√°nka
# __$2__ obsahuje parametry
djvurename() {
    local RANGE=$(isrange "${2}")
    if [ ! -n "${RANGE}" ] ; then
        # / m≈Ø≈æe b√Ωt seznam str√°nek ZA KTER√ùM nen√≠ nic
        # oddƒõlit PATTERN od seznamu
        case "${2//+([[:blank:]])/}" in
            '') # jenom p≈ô√≠kaz
                echo "Nebylo nic p≈ôed√°no ${2}" >> /dev/stderr
                return 1
                #local PAGES=($(range "0-${#LISTPAGES[@]}"))
            ;;
            *) # seznam str√°nek oddƒõlen√Ωch ƒç√°rkou

                mapfile -t ARRAY <<< $($0 "${1}" info list)
                case "${ARRAY:0:1}" in
                    0) mapfile -t LISTPAGES <<< $(printf "%s\n" "${ARRAY[@]}")
                    ;;
                    *) LISTPAGES="0 none"
                        mapfile -O 1 -t LISTPAGES <<< $(printf "%s\n" "${ARRAY[@]}")
                    ;;
                esac

                local IFS_BAK=$IFS
                local IFS=$','
                local SEZNAM=($2)
                local IFS=$IFS_BAK
                for i in "${LISTPAGES[@]}" ; do
                    if [[ "${SEZNAM[@]}" =~ "${i##+([[:digit:]])+([[:blank:]])}" ]] ; then
                        echo "Str√°nka ${i}" >> /dev/stderr
                        local TEMP="$TEMP${i%% *} "
                    fi
                    x=$((x + 1))
                done
                local PAGES=($TEMP)
                local STRING="${2##*.djvu+([[:blank:]])}"
            ;;
        esac
    else
        local STRING="${2#*${RANGE}+([[:blank:]])}"
        [ ! -n "${STRING}" ] && return 1
        local PAGES=($(range "${RANGE}"))
    fi
    case "${STRING:0:1}" in
        [a-Z])
        ;;
        *) echo "Neplatn√Ω PATTERN ‚Äì> ${STRING}" >> /dev/stderr
            return 1
        ;;
    esac
    if [ "${PAGES[0]}" == "0" ] ; then
        log warn "Sobor se sd√≠len√Ωmi informacemi nelze p≈ôejmenovat"
    else
        case "${#PAGES[@]}" in
            1) # jedna polo≈æka
                local PATTERN="${STRING}.djvu"
            ;;
            *) local DIGIT="${PAGES[@]: -1}"
                local PATTERN="${STRING}%${#DIGIT}d.djvu"
            ;;
        esac
        local z i
        for i in ${PAGES[@]} ; do
            [ "$i" == "0" ] && log warn "Sobor se sd√≠len√Ωmi informacemi nelze p≈ôejmenovat" && continue
            ((++z))
            local TARGET=$(printf "${PATTERN}" $z)
            ## export str√°nky do doƒçasn√©ho pod n√°zvem + pattern
            $0 "${1}" export djvu $i "${TEMPDIR}/${TARGET}"
            [ $? -eq 1 ] && echo "P≈ôi pokusu o export str√°nky $i se vyskytla chyba" && return 1
            log info "Save page $i ‚Äì> ${TARGET}"
            anone "Opravdu chcete nahradit str√°nku $i za jej√≠ p≈ôejmenovanou verzi?"
            [ $? -eq 1 ] && return 1
            $0 "${1}" delete $i
            [ $? -eq 1 ] && echo "P≈ôi pokusu o odstranƒõn√≠ str√°nky $i se vyskytla chyba" && return 1
            log info "Remove page $i"
            ## a jej√≠ import pod nov√Ωm n√°zvem
            $0  -f "${1}" import page $i "${TEMPDIR}/${TARGET}"
            [ $? -eq 1 ] && echo "P≈ôi pokusu o odstranƒõn√≠ str√°nky $i se vyskytla chyba" && return 1
            log info "Page ${TARGET} ‚Äì> $i"
        done
    fi
    return $?
}

# ### <span id="replacekey">replacekey()</span> ([top](#FUNCTIONS))
# Nahrazuje v doƒçasn√©m souboru metadatov√© kl√≠ƒçe
replacekey() {
    mapfile -d\: -t -c1 LINE <<< $(grep -n "${KEY} \"" "${TEMPFILE}")
    log info "${KEY} ‚Äì> ${LINE[0]}"
    case "${ACTION}" in
        unset) case "${LINE[0]}" in
            +([[:digit:]])) #/ Tady je t≈ôeba ovƒõ≈ôit jestli metadatov√Ω blok m√° v√≠ce ne≈æ jeden ≈ô√°dek
                # nejl√©pe ovƒõ≈ôit ≈ô√°dek p≈ôed a po‚Ä¶
                # Jestli je o ≈ô√°dek d≈ô√≠v tag metadata‚Ä¶
                local BEGIN=$((${LINE[0]} - 1))
                local START="$(sed -n ${BEGIN}p ${TEMPFILE})" 
                local END="$(sed -n $((${LINE[0]} + 1))p ${TEMPFILE})"
                case "${START}" in
                    metadata) # Odstra≈àuji dva ≈ô√°dky
                        case "${END%%([[:blank:]])*}" in
                            ''|metadata|xmp|note|align|background|zoom|mode)
                                ed "${TEMPFILE}" 2>/dev/null <<-EOF
${BEGIN},${LINE[0]}d
w
q
EOF
                            ;;
                            *)  # Odstra≈àuji jeden ≈ô√°dek
                                setmeta "${TEMPFILE}" "${KEY} \"" 
                            ;;
                        esac
                    ;;
                    *) # Odstra≈àuji jeden ≈ô√°dek
                        setmeta "${TEMPFILE}" "${KEY} \"" 
                    ;;
                esac
            ;;
        esac
        ;;
        set) case "${LINE[0]}" in
                +([[:digit:]])) log info "Replace content key ‚Äì> ${KEY}"
                    setmeta "${TEMPFILE}" "${KEY} \"" "${KEY} \"${VALUE}\""
                ;;
                *) mapfile -t METADATA <<< $(sed  '/metadata/!d ; = '  ${TEMPFILE} | grep -v metadata)
                    local BEGIN="${METADATA[@]: -1}"
                    case "${BEGIN}" in
                        +([[:digit:]])) log info "New metadata key ‚Äì> ${KEY}"
                            local KEYDATA="${KEY} \"${VALUE}\""
                            ed "${TEMPFILE}" 2>/dev/null <<-EOF
${BEGIN}a
${KEYDATA}
.
w
q
EOF
                        ;;
                        *) log info "Set new metadata block for key ‚Äì> ${KEY}"
                            echo "metadata" >> "${TEMPFILE}"
                            echo -e "\t${KEY} \"${VALUE}\"\n" >> "${TEMPFILE}"
                        ;;
                    esac
                ;;
            esac
        ;;
    esac

}

# ### <span id="replacenote">replacenote()</span> ([top](#FUNCTIONS))
# Nahrazuje a odstra≈àuje v doƒçasn√©m souboru skryt√© pozn√°mky
replacenote() {
    mapfile -d\: -t -c1 LINE <<< $(grep -n "${KEY} \"${VALUE}\"" "${TEMPFILE}")
    log info "${KEY} \"${VALUE}\" ‚Äì> ${LINE[0]}"
    case "${ACTION}" in
        unset) case "${LINE[0]}" in
                +([[:digit:]])) log info "Remove note from ${LINE[0]}"
                    setmeta "${TEMPFILE}" "${KEY} \"${VALUE}\""
                ;;
                *) log warn "Note is not set"
                    return 1
                ;;
        esac
        ;;
        set) case "${LINE[0]}" in
                +([[:digit:]])) log info "This note exists"
                ;;
                *) log info "Set new note"
                    echo -e "${KEY} \"${VALUE}\"\n" >> "${TEMPFILE}"
                ;;
        esac
        ;;
    esac
}

# ### <span id="replacexmp">replacexmp()</span> ([top](#FUNCTIONS))
# Nahrazuje v doƒçasn√©m souboru XMP k√≥d
replacexmp() {
    mapfile -t ITEM <<< $(sed  '/xmp/,/^[abmnpz#]/!d ; = ; /^[abmnpz#]/q' "${TEMPFILE}" | grep ^[0-9])
    local XMP=$(echo ${STRING#xmp+([[:blank:]])} | encode)
    case "${ITEM[0]}" in
        +([0-9])) case "$(sed -n ${ITEM[@]: -1}p ${TEMPFILE})" in
            +(maparea|metadata|note|mode|zoom|background|align)*)
                local BEGIN="${ITEM[0]}"
                local END="${ITEM[@]: -2:1}"
            ;;
            *) local BEGIN="${ITEM[0]}"
                local END="${ITEM[@]: -1}"
            ;;
        esac
        ;;
        *) log info "XMP unexist"
        ;;
    esac
    case "${ACTION}" in
        unset) # jestli xmp existuje - zru≈°it (staƒç√≠ grep)
            if [ -n "${BEGIN}" ] ; then
                log info "Delete XMP code ‚Äì> ${BEGIN},${END}d"
                ed "${TEMPFILE}" 2>/dev/null <<-EOF
${BEGIN},${END}d
w
q
EOF
            fi
        ;;
        set) # Jestli xmp existuje - p≈ôepsat
            if [ -n "${BEGIN}" ] ; then
                log info "Change XMP code ‚Äì> ${BEGIN},${END}c"
                ed "${TEMPFILE}" 2>/dev/null <<-EOF
${BEGIN},${END}c
xmp
${XMP//></>\\\n<}
.
w
q
EOF
            else
                # jestli neexistuje - vlo≈æit
                log info "Add XMP code to end file"
                echo "xmp" >> "${TEMPFILE}"
                echo -e "${XMP//></>\\\n<}" >> "${TEMPFILE}"
            fi
        ;;
    esac
    return $?
}

# ### <span id="setdjvu">setdjvu()</span> ([top](#FUNCTIONS))
# Na rozd√≠l od funkce exportimg, se zde zpracov√°vaj√≠ p≈ôedan√© parametry
# __$1__ je cesta ke kontejneru ze kter√©ho se exportuje str√°nka
# __$2__ obsahuje parametry
#
# * ant - Exportuje hyperlinky a meta atributy ve form√°tu .ant
# * meta - Exportuje meta informace str√°nky, jej√≠ rozmƒõry a stav rotace
# * djvu - Exportuje DjVu str√°nky
# * mask|background|foreground|color|black - oxportuje obr√°zek pozad√≠
# * dsed-*
# * xml-*#
#
# Akce set je urƒçena pro prim√°rn√≠ nastaven√≠ odkaz≈Ø v obsahu, ƒçi pozn√°mek v textu
# Sou≈ôadnice se p≈ôi n√≠ p≈ôepoƒç√≠t√°vaj√≠ podle velikosto str√°nky
# a z√°rove≈à se kontroluje syntaxe.
# Dodateƒçn√© √∫pravy lze pak prov√°dƒõt buƒè p≈ôes djvusmooth, nebo editac√≠ vrstvy .ant
# set outline : "#c√≠l" "popis"
# set meta RANGE : key "Popis"
# set note RANGE : key "Obsah skryt√© pozn√°mky"
# set poly RANGE : "" "" {none|xor|border} [border_avis] x1 y1 x2 y2 ‚Ä¶
# set rect : "" {none|xor|border c} [hilite c] [border_avis] x1 y1 x2 y2
# set oval : "" {none|xor|border} [border_avis] x1 y1 x2 y2
# set line : 
# Jak upravit line - nejprve nƒõkam nastavit a pak p≈ôes djvusmooth upravit odkud kam
# set text : x1 y1 x2 x3
# URL
# maparea
setdjvu() {
    log goto "$1 ‚Äì> $2"
    local RANGE=$(isrange "${2}")
    if [ ! -n "${RANGE}" ] ; then
        local RANGE="${2%%+([[:blank:]])*}"
    fi

    local TEMPORAR="${2#*${RANGE}+([[:blank:]])}"
    [ ! -n "${TEMPORAR##+([[:blank:]])}" ] && return 1

    case "${RANGE}" in
        global|all|\
        mode|align|background|zoom|note|key) echo """
Pokud chcete nastavit element, ƒçi parametr, tak aby ho obsahovala ka≈æd√°
str√°nka, tak m√°te dvƒõ mo≈ænosti:
  1, Buƒè nastav√≠te RANGE na hodnotu 0 (nula). V takov√©m p≈ô√≠padƒõ se prvek
     vlo≈æ√≠ mezi sd√≠len√° metadata.
  2, Nebo nastav√≠te RANGE na rozsah od prvn√≠ do posledn√≠ str√°nky (nap≈ô. 1-99)
     Prvek se pak nastav√≠ pro ka≈ædou z nich samostatnƒõ.
""" >> /dev/stderr
        ;;
        outline)
            [ "${ACTION}" == "unset" ] && echo "Nastaven√© z√°lo≈æky lze odstra≈àovat jedinƒõ p≈ôi akci edit" && return 1
            local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .outline)
            $0 "${FILE}" export outline > "${TEMPFILE}"
            local TEMP="${TEMPORAR#+([[:blank:]])}"
            case "${TEMP}" in
                +([[:digit:]])+([[:blank:]])*) echo "\"${TEMP#+([[:digit:]])+([[:blank:]])}\" \"#${TEMP%%+([[:blank:]])*}\"" >> "${TEMPFILE}"
                ;;
                http*)  echo "\"${TEMP#http*+([[:blank:]])}\" \"${TEMP%%+([[:blank:]])*}\"" >> "${TEMPFILE}"
                ;;
                *) local TARGET="${TEMP%%+([[:blank:]])*}"
                    if [[ "${TARGET}" =~ ".djvu" ]] ; then
                        echo "\"${TEMP#${TARGET}+([[:blank:]])}\" \"${TARGET}\"" >> "${TEMPFILE}"
                    else
                        echo "Neplatn√° z√°lo≈æka ‚Äì> z${TEMPORAR}z x${TEMP}x" >> /dev/stderr
                        return 1
                    fi
                ;;
            esac
            anone "Ulo≈æit zmƒõny?"
            [ $? -eq 1 ] && return 1
            outlinetodjvu "${FILE}" "${TEMPFILE}"
            if [ $? -eq 1 ] ; then
                echo "P≈ôi importu z√°lo≈æek se vyskytla chyba" >> /dev/stderr
                return 1
            else
                echo "Pozici a zano≈ôen√≠ z√°lo≈æky v obsahu m≈Ø≈æete upravit p≈ôes akci edit" >> /dev/stderr
            fi
            return $?
        ;;
        *) local TEST=($($0 "${1}" info list))
            local STRING="${TEMPORAR#+([[:blank:]])}"
            local ELEMENT="${STRING%%+([[:blank:]])*}"
            case "${ELEMENT}" in
                xmp) if [ "${RANGE}" == "0" ] ; then
                        if [ "${TEST[0]}" -eq "0" ] ; then
                            local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .ant)
                            log info "From shared_ant ‚Äì> $i"
                            $0 "${1}" export ant 0 > "${TEMPFILE}"
                            replacexmp
                            #/ Na konci mus√≠ b√Ωt alespo≈à jedna pr√°zdn√° linka 
                            echo ""  >> "${TEMPFILE}"
                            anone "Ulo≈æit zmƒõny?"
                            [ $? -eq 1 ] && return 1
                            cat "${TEMPFILE}" | $0 "${1}" import ant
                        else
                            case "${ACTION}" in
                                set) ${DJVUSED} "${1}" -e 'create-shared-ant ; set-ant' -s
                                    ( $0 "${1}" export ant 0
                                        echo "xmp"
                                        echo -e "\t\"${VALUE}\"\n"
                                    ) | $0 "${1}" import ant
                                ;;
                            esac
                        fi
                    else
                        local PAGES=($(range ${RANGE}))
                        for i in ${PAGES[@]} ; do
                            local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .ant)
                            log info "From page ‚Äì> $i"
                            $0 "${1}" export ant $i > "${TEMPFILE}"
                            replacexmp
                            #/ Na konci mus√≠ b√Ωt alespo≈à jedna pr√°zdn√° linka 
                            echo "" >> "${TEMPFILE}"
                            anone "Ulo≈æit zmƒõny?"
                            [ $? -eq 1 ] && return 1
                            cat "${TEMPFILE}" | $0 "${1}" import ant
                        done
                    fi
                    return $?
                ;;
                note|\
                key)
                    local TEMP=(${STRING//+([[:blank:]])/ })
                    case "${TEMP[0]}" in
                        note) local KEY="${TEMP[0]}"
                            local VALUE="${STRING#${TEMP[0]}+([[:blank:]])}"
                            #/ v≈ædy na jednom ≈ô√°dku
                            if [ "${RANGE}" == "0" ] ; then
                                if [ "${TEST[0]}" -eq "0" ] ; then
                                    local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .ant)
                                    log info "From shared_ant ‚Äì> $i"
                                    $0 "${1}" export ant 0 > "${TEMPFILE}"
                                    replacenote
                                    #/ Na konci mus√≠ b√Ωt alespo≈à jedna pr√°zdn√° linka 
                                    echo ""  >> "${TEMPFILE}"
                                    anone "Ulo≈æit zmƒõny?"
                                    [ $? -eq 1 ] && return 1
                                    cat "${TEMPFILE}" | $0 "${1}" import ant
                                else
                                    case "${ACTION}" in
                                        set) ${DJVUSED} "${1}" -e 'create-shared-ant ; set-ant' -s
                                            ( $0 "${1}" export ant 0
                                                echo -e "${KEY} \"${VALUE}\"\n"
                                            ) | $0 "${1}" import ant
                                        ;;
                                    esac
                                fi
                            else
                                local PAGES=($(range ${RANGE}))
                                for i in ${PAGES[@]} ; do
                                    local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .ant)
                                    log info "From page ‚Äì> $i"
                                    $0 "${1}" export ant $i > "${TEMPFILE}"
                                    echo "" >> "${TEMPFILE}"
                                    replacenote
                                    #/ Na konci mus√≠ b√Ωt alespo≈à jedna pr√°zdn√° linka 
                                    echo "" >> "${TEMPFILE}"
                                    anone "Ulo≈æit zmƒõny?"
                                    [ $? -eq 1 ] && return 1
                                    cat "${TEMPFILE}" | $0 "${1}" import ant
                                done
                            fi
                        ;;
                        key) local KEY="${TEMP[1]}"
                            [ "${KEY}" == "xmp" ] && echo "XMP k√≥d se nenastavuje p≈ôes key, ale xmp" >> /dev/stderr && return 1
                            [ "${KEY}" == "note" ] && echo "Pro skryt√© pozn√°mky se nepou≈æ√≠v√° key, ale note" >> /dev/stderr && return 1
                            local VALUE="${STRING#${TEMP[0]}+([[:blank:]])${TEMP[1]}+([[:blank:]])}"
                            if [ "${RANGE}" == "0" ] ; then
                                if [ "${TEST[0]}" -eq "0" ] ; then
                                    local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .ant)
                                    log info "From shared_ant ‚Äì> $i"
                                    $0 "${1}" export ant 0 > "${TEMPFILE}"
                                    replacekey
                                    #/ Na konci mus√≠ b√Ωt alespo≈à jedna pr√°zdn√° linka 
                                    echo ""  >> "${TEMPFILE}"
                                    anone "Ulo≈æit zmƒõny?"
                                    [ $? -eq 1 ] && return 1
                                    cat "${TEMPFILE}" | $0 "${1}" import ant
                                else
                                    case "${ACTION}" in
                                        set) ${DJVUSED} "${1}" -e 'create-shared-ant ; set-ant' -s
                                            ( $0 "${1}" export ant 0
                                                case "${KEY}" in
                                                    note) echo -e "${KEY} \"${VALUE}\"\n"
                                                    ;;
                                                    *) echo "metadata" >> "${TEMPFILE}"
                                                        echo -e "\t${KEY} \"${VALUE}\"\n"
                                                    ;;
                                                esac
                                            ) | $0 "${1}" import ant
                                        ;;
                                    esac
                                fi
                            else
                                local PAGES=($(range ${RANGE}))
                                for i in ${PAGES[@]} ; do
                                    local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .ant)
                                    log info "From page ‚Äì> $i"
                                    $0 "${1}" export ant $i > "${TEMPFILE}"
                                    replacekey
                                    #/ Na konci mus√≠ b√Ωt alespo≈à jedna pr√°zdn√° linka 
                                    echo "" >> "${TEMPFILE}"
                                    anone "Ulo≈æit zmƒõny?"
                                    [ $? -eq 1 ] && return 1
                                    cat "${TEMPFILE}" | $0 "${1}" import ant
                                done
                            fi
                        ;;
                        *) #/ je≈°tƒõ nev√≠m
                            return 1
                        ;;
                    esac
                    return $?
                ;;
                align|\
                background|\
                mode|\
                pfoot|\
                phead|\
                zoom) #/ Metadata co se mohou vyskytovat v≈ædy pouze jednou
                    local KEY="${ELEMENT}"
                    case "${ACTION}" in
                        unset)
                        ;;
                        set)
                            local VALUE="${STRING#${KEY}+([[:blank:]])}"
                            case "${KEY}" in
                                align) case "${VALUE}" in
                                    +(left|center|right)+([[:blank:]])+(top|center|bottom))
                                        ;;
                                        *) log err "align invalid value ‚Äì> #${VALUE}#"
                                            help set-align
                                            return 1
                                        ;;
                                    esac
                                    ;;
                                background) case "${VALUE}" in
                                        [0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F]) # Mohu nastavit
                                        local VALUE="#${VALUE}"
                                        ;;
                                        *) log err "background invalid value ‚Äì> ${VALUE}#"
                                            help set-background
                                            return 1
                                        ;;
                                    esac
                                    ;;
                                mode) case "${VALUE}" in
                                        color|bw|fore|black) # Mohu nastavit
                                        ;;
                                        *) log err "mode invalid value ‚Äì> #${VALUE}#"
                                            help set-mode
                                            return 1
                                        ;;
                                    esac
                                    ;;
                                pfoot|phead) case "${VALUE}" in
                                        '') log err "${KEY} invalid value ‚Äì> #${VALUE}#"
                                            help set-${KEY}
                                            return 1
                                        ;;
                                        *) echo "Z√°hlav√≠ a z√°pat√≠ nen√≠ ve vƒõt≈°inƒõ prohl√≠≈æeƒç≈Ø, proto ani ned√°v√° smysl ho nastavovat, ale kdy≈æ chcete‚Ä¶"
                                            local VALUE="\"${VALUE}\""
                                        ;;
                                    esac
                                    ;;
                                zoom) case "${VALUE}" in
                                    stretch|one2one|width|page|d+([[:digit:]]))
                                        ;;
                                        *) log err "zoom invalid value ‚Äì> #${VALUE}#"
                                            help set-zoom
                                            return 1
                                        ;;
                                    esac
                                    ;;
                                *) #/ je≈°tƒõ nev√≠m
                                    return 1
                                    ;;
                            esac
                        ;;
                    esac
                    if [ "${RANGE}" == "0" ] ; then
                        if [ "${TEST[0]}" -eq "0" ] ; then
                            local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .ant)
                            log info "From shared_ant ‚Äì> $i"
                            $0 "${1}" export ant 0 > "${TEMPFILE}"
                            [ -n "${VALUE}" ] && setmeta "${TEMPFILE}" "${KEY}" "${KEY} ${VALUE}" || setmeta "${TEMPFILE}" "${KEY}"
                            anone "Ulo≈æit zmƒõny?"
                            [ $? -eq 1 ] && return 1
                            cat "${TEMPFILE}" | $0 "${1}" import ant
                        else
                            if [ -n "${VALUE}" ] ; then
                                ${DJVUSED} "${1}" -e 'create-shared-ant ; set-ant' -s
                                ( $0 "${1}" export ant 0
                                    echo "${KEY} ${VALUE}"
                                ) | $0 "${1}" import ant
                            fi
                        fi
                    else
                        local PAGES=($(range ${RANGE}))
                        for i in ${PAGES[@]} ; do
                            local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .ant)
                            log info "From page ‚Äì> $i"
                            $0 "${1}" export ant $i > "${TEMPFILE}"
                            [ -n "${VALUE}" ] && setmeta "${TEMPFILE}" "${KEY}" "${KEY} ${VALUE}" || setmeta "${TEMPFILE}" "${KEY}"
                            anone "Ulo≈æit zmƒõny?"
                            [ $? -eq 1 ] && return 1
                            cat "${TEMPFILE}" | $0 "${1}" import ant
                        done
                    fi
                    return $?
                ;;
                *) # Prvky vy≈æaduj√≠c√≠ koordin√°ty
                   # link, oval, rect, text, ram, line, arrow a poly
                    local TEMP="${STRING#${ELEMENT}+([[:blank:]])}"
                    # odfiltrov√°n√° koordin√°t≈Ø
                    local MESSAGE="${TEMP//+([[:digit:]])+([[:blank:]])+([[:digit:]])+([[:blank:]])/}"
                    local COORDS="${TEMP%${MESSAGE}}"
                    # dal≈°√≠ parametry n√°sleduj√≠ za dvojteƒçkou
                    if [[ "${MESSAGE}" =~ ":" ]] ; then
                        mapfile PARAMS < <( object ${MESSAGE##*:+([[:blank:]])} )
                        #object "${MESSAGE##*:+([[:blank:]])}"
                        local MESSAGE="${MESSAGE%+([[:blank:]]):*}"
                    fi
                    if [[ ${MESSAGE:0:1} =~ [0-9] ]] ; then
                        echo "Chyba v poƒçtu koordin√°t≈Ø ‚Äì> ${MESSAGE}" >> /dev/stderr
                        return 1
                    else
                        # Vƒõt≈°ina typ≈Ø ploch m≈Ø≈æe m√≠t pouze 4 sou≈ôadnice
                        local TEST=(${COORDS})
                        case "${ELEMENT}" in
                            link|oval|rect|text|ram|line|arrow) [ ${#TEST[@]} -ge 5 ] && help set-${ELEMENT} && return 1
                        esac
                        echo "MESSAGE ${MESSAGE%+([[:blank:]]):*}" >> /dev/stderr
                        echo "COORDS ${COORDS}" >> /dev/stderr
                        printf "%s" "${PARAMS[@]}" >> /dev/stderr
                        #return 0
                        local PAGES=($(range ${RANGE}))
                        for i in ${PAGES[@]} ; do
                            (
                            # co mohu mmƒõnit - buƒè sou≈ôadnice, nebo c√≠lovou message
                            local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .ant)
                            local INCFILE=$(tempfile -d ${TEMPDIR} -s .inc)
                            $0 "${1}" export ant $i > "${TEMPFILE}"
                            case "${ACTION}" in
                                set) (
                                    echo "maparea"
                                    case "${MESSAGE}" in
                                        +([a-Z0-9])\.djvu+([[:blank:]])*)
                                            case "${ELEMENT}" in
                                                arrow) echo "U prvku typu arrow a line odkazy nelze pou≈æ√≠t, proto link na #${MESSAGE%%+([[:blank:]])*} ignoruji" >> /dev/stderr
                                                    echo -e "\t\"\" \"${MESSAGE#*+([[:blank:]])}\""
                                                    if [ "${ELEMENT}" == "arrow" ] ; then
                                                        echo -e "\tline ${COORDS}"
                                                        echo -e "\tarrow"
                                                        printf "%s" "${PARAMS[@]/_blank}"
                                                    elif [ "${ELEMENT}" == "line" ] ; then
                                                        echo -e "\tline ${COORDS}"
                                                        printf "%s" "${PARAMS[@]/_blank}"
                                                    else
                                                        echo -e "\t${ELEMENT} ${COORDS}"
                                                        printf "%s" "${PARAMS[@]}"
                                                        printf "%s" "${PARAMS[@]/_blank}"
                                                    fi
                                                ;;
                                                *) echo -e "\t\"#${MESSAGE%%+([[:blank:]])*}\" \"${MESSAGE#*+([[:blank:]])}\""
                                                    echo -e "\t${ELEMENT} ${COORDS}"
                                                    #printf "%s" "${PARAMS[@]/_blank}"
                                                    printf "%s" "${PARAMS[@]}"
                                                ;;
                                            esac
                                        ;;
                                        http\:\/\/*) # link na www str√°nku
                                            case "${ELEMENT}" in
                                                arrow|line) echo "U prvku typu arrow a line odkazy nelze pou≈æ√≠t, proto link na URL ${MESSAGE%%+([[:blank:]])*} ignoruji" >> /dev/stderr
                                                    echo -e "\t\"\" \"${MESSAGE}\""
                                                    if [ "${ELEMENT}" == "arrow" ] ; then
                                                        echo -e "\tline ${COORDS}"
                                                        echo -e "\tarrow"
                                                        printf "%s" "${PARAMS[@]/_blank}"
                                                    elif [ "${ELEMENT}" == "line" ] ; then
                                                        echo -e "\tline ${COORDS}"
                                                        printf "%s" "${PARAMS[@]/_blank}"
                                                    else
                                                        echo -e "\t${ELEMENT} ${COORDS}"
                                                        printf "%s" "${PARAMS[@]}"
                                                        printf "%s" "${PARAMS[@]/_blank}"
                                                    fi
                                                ;;
                                                *) if [[ "${PARAMS}" =~ "_blank" ]] ; then
                                                        echo -e "\turl \"${MESSAGE%%+([[:blank:]])*}\" \"_blank\" \"${MESSAGE#*+([[:blank:]])}\""
                                                        echo -e "\t${ELEMENT} ${COORDS}"
                                                        printf "%s" "${PARAMS[@]/_blank}"
                                                    else
                                                        echo -e "\t\"${MESSAGE%%+([[:blank:]])*}\" \"${MESSAGE#*+([[:blank:]])}\""
                                                        echo -e "\t${ELEMENT} ${COORDS}"
                                                        printf "%s" "${PARAMS[@]}"
                                                    fi
                                                ;;
                                            esac
                                        ;;
                                        *)  # bez linku
                                            echo -e "\t\"\" \"${MESSAGE}\""
                                            if [ "${ELEMENT}" == "arrow" ] ; then
                                                echo -e "\tline ${COORDS}"
                                                echo -e "\tarrow"
                                                printf "%s" "${PARAMS[@]}"
                                            elif [ "${ELEMENT}" == "line" ] ; then
                                                echo -e "\tline ${COORDS}"
                                                printf "%s" "${PARAMS[@]}"
                                            else
                                                echo -e "\t${ELEMENT} ${COORDS}"
                                                printf "%s" "${PARAMS[@]}"
                                            fi
                                        ;;
                                    esac
                                    echo -e "\n"
                                    ) > "${INCFILE}"
                                    local INC=$(cat "${INCFILE}")
                                    local ADRESA=$(infile "${TEMPFILE}")
                                    case "${ADRESA}" in
                                    +([[:digit:]])\ +([[:digit:]]))
                                            # echo "${ADRESA/ /,}c" >> /dev/stderr
                                            ed "${TEMPFILE}" 2>/dev/null <<-EOF
${ADRESA/ /,}c
${INC}

.
w
q
EOF
                                            echo "" >> "${TEMPFILE}"
                                        ;;
                                        *) echo "${INC}" >> "${TEMPFILE}"
                                            echo "" >> "${TEMPFILE}"
                                        ;;
                                    esac
                                ;;
                                unset) local ADRESA=$(infile "${TEMPFILE}")
                                    case "${ADRESA}" in
                                        +([[:digit:]])\ +([[:digit:]]))
                                            # echo "${ADRESA/ /,}d" >> /dev/stderr
                                            ed "${TEMPFILE}" 2>/dev/null <<-EOF
${ADRESA/ /,}d
w
q
EOF
                                            echo "" >> "${TEMPFILE}"
                                        ;;
                                        *) echo "Pokou≈°√≠te se odstranit neexistuj√≠c√≠ polo≈æku" >> /dev/stderr
                                        ;;
                                    esac
                                ;;
                            esac
                            #echo "---------"  >> /dev/stderr
                            case ${DEBUG} in
                                -d1|-d3|-d4|-d6|-d7|-d9) cat "${TEMPFILE}" >> /dev/stderr
                            esac
                            anone "Ulo≈æit zmƒõny?"
                            [ $? -eq 1 ] && return 1
                            cat "${TEMPFILE}" ) | $0 "${1}" import ant
                        done
                    fi
                ;;
        esac
        case ${ACTION} in
            set) echo "Nastavuji informaci pro sd√≠lenou str√°nku - pozici v obsahu upravte p≈ôes akci edit" >> /dev/stderr
        esac
        ;;
    esac
}

# ### <span id="fromcontainer">fromcontainer()</span> ([top](#FUNCTIONS))
# Na rozd√≠l od funkce exportimg, se zde zpracov√°vaj√≠ p≈ôedan√© parametry
# __$1__ je cesta ke kontejneru ze kter√©ho se exportuje str√°nka
# __$2__ obsahuje parametry
#
# Rozd√≠l oproti podobn√© funkci fromfile je ve zpracov√°n√≠ v√Ωstupu
# C√≠lem t√©hle funkce je nahradit funkce fromfile() a extractionpage() a filters()
fromcontainer() {
    log goto "fromcontainer() $1 ‚Äì> $2"

    local INTO=$(isformat "${2}")
    if [ -n "${INTO}" ] ; then
        local TEMPORAR="${2#*${INTO}}"
    else
        echo "C√≠lov√Ω form√°t mus√≠ b√Ωt v≈ædy uveden!" >> /dev/stderr
        return 1
    fi

    local RANGE=$(isrange "${TEMPORAR}")
    if [ -n "${RANGE}" ] ; then
        local TEMPORAR="${TEMPORAR#*${RANGE}}"
    fi

    local CUT=$(iscut "${TEMPORAR}")
    if [ -n "${CUT}" ] ; then
        local TEMPORAR="${TEMPORAR#*${CUT}}"
    fi

    local SCALE=$(isscale "${TEMPORAR}")
    if [ -n "${SCALE}" ] ; then
        [ "${SCALE}" == "false" ] && return 1
        local PARAM=(${SCALE})
        case "${PARAM[$((${#PARAM[@]}-1))]}" in
            -filter=*)
                log info "fromcontainer()" \
                "Scale use any resize filter ‚Äì> ${PARAM[$((${#PARAM[@]}-1))]}"
                local TEMPORAR="${TEMPORAR#*${PARAM[$((${#PARAM[@]}-1))]}}"
            ;;
            [0-9]*)
                case ${#PARAM[@]} in
                1) log info "fromcontainer()" \
                    "Only resize scale ‚Äì> ${PARAM[$((${#PARAM[@]}-1))]}"
                    local TEMPORAR="${TEMPORAR#*${PARAM[$((${#PARAM[@]}-1))]}}"
                ;;
                2) echo \
                    "Nƒõkde je chyba v nastaven√≠ ≈°k√°lov√°n√≠ ‚Äì> ${SCALE}" >> /dev/stderr
                    return 1
                ;;
                *) #/ 3 a v√≠ce polo≈æek
                    case "${PARAM[0]}" in
                        -xy*) local TEMPORAR="${TEMPORAR#*${PARAM[0]}}"
                        ;;
                        *) echo \
                            "Nƒõkde je chyba v nastaven√≠ ≈°k√°lov√°n√≠ ‚Äì> ${SCALE}" >> /dev/stderr
                            return 1
                        ;;
                    esac
                ;;
            esac
            ;;
            *) echo "${PARAM[$((${#PARAM[@]}-1))]}"
            ;;
        esac
    fi
    case "${TEMPORAR:$((${#TEMPORAR}-1)):1}" in
        /) TARGETDIR=$(${REALPATH} -m -P "${TEMPORAR## }")
            log info "targets() Export pages with a original names into ‚Äì> ${TARGETDIR}"
            [ ! -d "${TARGETDIR}" ] && mkdir -p "${TARGETDIR}"
        ;;
        *) if [[ "${TEMPORAR}" =~ "/" ]] ; then
                #/ obsahuje cestu
                local TEMPORARY=$(${REALPATH} -m -P "${TEMPORAR## }")
                TARGETDIR="${TEMPORARY%/*}"
                TARGETSAMPLE="${TEMPORARY##*/}"
                log info "targets() Export pages a named by sample ${TARGETSAMPLE} ‚Äì> ${TARGETDIR}"
                [ ! -d "${TARGETDIR}" ] && mkdir -p "${TARGETDIR}"
            else
                #/ jde o vzorek
                TARGETDIR="$(pwd)"
                TARGETSAMPLE="${TEMPORAR## }"
                log info "targets() Export pages a named by sample ${TARGETSAMPLE} into actual directory"
            fi
        ;;
    esac
    echo "RANGE ${RANGE}"
    echo "INTO ${INTO}"
    echo "CUT ${CUT}"
    echo "SCALE ${SCALE}"
    echo "TARGETDIR ${TARGETDIR}"
    echo "TARGETSAMPLE ${TARGETSAMPLE}"
    echo "TEMPORAR ${TEMPORAR}"
    echo "M≈Ø≈æeme p≈ôikroƒçit k akci ${FILETYPE}"
    echo "DPI ${DPI}"
    echo "ALG ${ALG[@]}"
    # exit 33
    case ${FILETYPE} in
        pbm|pgm|ppm) log info "fromcontainer() Export from ${FILETYPE^^}"
            if [ -n "${RANGE}" ] && [ ! ${RANGE} -eq 1 ] ; then
                echo "Form√°t ${FILETYPE} podporuje pouze jednu str√°nku" >> /dev/stderr
                return 1
            fi
            local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .pam)
            #/ Nejd≈ô√≠v je t≈ôeba obr√°zek nakop√≠rovat do pracovn√≠ho prostoru
            cp "${FILE}" "${TEMPFILE}"
            #/ Pak je t≈ôeba vyseparovat v√Ωchoz√≠ masku
            if [ ${#ALG[@]} -gt 1 ] ; then
                cp "${TEMPFILE}" "${TEMPFILE}.in"
                COUNT=1
                for i in ${ALG[@]} ; do
                    separatemask "${TEMPFILE}.in" "${TEMPFILE}.${COUNT}" "$i"
                    while [ ! -f "${TEMPFILE}.${COUNT}" ] ; do
                        sleep 0.1
                    done
                    ${PAMARITH} -divide "${TEMPFILE}" "${TEMPFILE}.${COUNT}" > "${TEMPFILE}.in"
                    COUNT=$((COUNT + 1))
                done
                echo "Je t≈ôeba slo≈æit ${COUNT} masek"
                case ${COUNT} in
                    1) #/ Pouze jedna maska 
                        echo "Do≈°lo k nƒõjak√© chybƒõ p≈ôi zpracov√°n√≠ cyklu!" >> /dev/stderr
                        return 1 
                    ;;
                    *) #/ V√≠ce masek
                        #cp "${TEMPFILE}.1" "${TEMPFILE}.in"
                        while [ ! ${COUNT} -eq 2 ] ; do
                            log info "Sluƒçuji ${TEMPFILE}.$((COUNT - 1)) ${TEMPFILE}.$((COUNT - 2))"
                            ${PAMARITH} -and "${TEMPFILE}.$((COUNT - 1))" "${TEMPFILE}.$((COUNT - 2))" > "${TEMPFILE/.pam/.fore}"
                            COUNT=$((COUNT - 1))
                        done
                    ;;
                esac
                log ok "Masky slouƒçeny"
            else
                separatemask "${TEMPFILE}" "${TEMPFILE/.pam/.fore}" "${ALG}"
            fi
            if [ -n "${CUT}" ] ; then
                #/ Na masku se aplikuj√≠ vybran√© r√°meƒçky
                local BOX=( "${CUT//;/ }" )
                echo "${CUT}" >> /dev/stderr
                for i in ${BOX[@]} ; do
                    imgcut "${i}" "${TEMPFILE}"
                done
            fi
            #exit 33
            if [ -n "${TARGETSAMPLE}" ] ; then
                # jedu podle vzorku
                local TARGET="${TARGETDIR}/${TARGETSAMPLE}.${INTO}"
            else
                local TARGET="${TARGETDIR}/${FILE##*/}.${INTO}"
            fi
            case "${INTO}" in
                djvu) #/ V tomto bodƒõ se v p≈ô√≠padƒõ DjVu provede konverze
                    encodefile ${TEMPFILE} "${TARGET}"
                    # na anglicke texty d√°v√° lep≈°√≠ v√Ωsledky cuneiform
                ;;
                mask|pbm) #/ V√Ωsledkem je soubor s c√≠lov√Ωm n√°zvem, ale p≈ô√≠ponou pbm
                    if [ -f "${TEMPFILE/.pam/.text}" ] ; then
                        cp "${TEMPFILE/.pam/.text}" "${TARGET/.mask/.pbm}"
                    else
                        cp "${TEMPFILE/.pam/.fore}" "${TARGET/.mask/.pbm}"
                    fi
                ;;
                back) #/ V√Ωsledkem je PNG soubor pozad√≠ s c√≠lov√Ωm n√°zvem, a p≈ô√≠ponou back.png
                    if [ -f "${TEMPFILE/.pam/.text}" ] ; then
                        ${PAMTOPNG} -alpha="${TEMPFILE/.pam/.text}" "${TEMPFILE}" > "${TARGET}.png"
                    else
                        ${PAMTOPNG} -alpha="${TEMPFILE/.pam/.fore}" "${TEMPFILE}" > "${TARGET}.png"
                    fi
                ;;
                png) #/ konvertuji pozad√≠
                    if [ -n "${SCALE}" ] ; then
                        ${PAMTOPNM} ${TEMPFILE} | ${PAMSCALE} ${SCALE} | ${PAMTOPNG} > "${TARGET}"
                    else
                        ${PAMTOPNG} ${TEMPFILE} > "${TARGET}"
                    fi
                ;;
                jpg|jpeg)
                    if [ -n "${SCALE}" ] ; then
                        ${PAMTOPNM} ${TEMPFILE} | ${PAMSCALE} ${SCALE} | ${PNMTOJPEG} > "${TARGET}"
                    else
                        ${PNMTOJPEG} ${TEMPFILE} > "${TARGET}"
                    fi
                ;;
                jp2)
                    if [ -n "${SCALE}" ] ; then
                        ${PAMTOPNM} ${TEMPFILE} | ${PAMSCALE} ${SCALE} | ${PAMTOJPEG2K} > "${TARGET}"
                    else
                        ${PAMTOJPEG2K} ${TEMPFILE} > "${TARGET}"
                    fi
                ;;
                *) log info "Konverze do v√Ωchoz√≠ho form√°tu ${FILETYPE} nen√≠ nutn√°"
                    cp "${TEMPFILE}" "${TARGET%.}.pam"
                ;;
            esac
        ;;
        jpeg) log info "fromcontainer() Export from JPEG into ${INTO}"
            #exit 33
            local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .pam)
            if [ -n "${TARGETSAMPLE}" ] ; then
                # jedu podle vzorku
                local TARGET="${TARGETDIR}/${TARGETSAMPLE}.${INTO}"
            else
                local TARGET="${TARGETDIR}/${FILE##*/}.${INTO}"
            fi
            case "${INTO}" in
                djvu) #/ V tomto bodƒõ se v p≈ô√≠padƒõ DjVu provede konverze
                    encodefile ${TEMPFILE} "${TARGET}"
                    # na anglicke texty d√°v√° lep≈°√≠ v√Ωsledky cuneiform
                ;;
                mask|pbm) #/ V√Ωsledkem je soubor s c√≠lov√Ωm n√°zvem, ale p≈ô√≠ponou pbm
                    $0 ${FILE} export 1 mask ${TEMPFILE}
                    #if [ -f "${TEMPFILE/.pam/.text}" ] ; then
                    #    cp "${TEMPFILE/.pam/.text}" "${TARGET/.mask/.pbm}"
                    #else
                    #    cp "${TEMPFILE/.pam/.fore}" "${TARGET/.mask/.pbm}"
                    #fi
                ;;
                back) #/ V√Ωsledkem je PNG soubor pozad√≠ s c√≠lov√Ωm n√°zvem, a p≈ô√≠ponou back.png
                    $0 ${FILE} export 1 back ${TEMPFILE}
                ;;
                pnm) echo "POZOR! P≈ôi konverzi do PNM form√°tu dojde ke ztr√°tƒõ meta informac√≠ a t√≠m i k anonymizaci obr√°zku" >> /dev/stderr
                    ${JPEGTOPNM} -dct float -dumpexif -exif="${TEMPFILE/.pam/.exif}" -repair "${FILE}" > ${TEMPFILE}
                    if [ -n "${SCALE}" ] ; then
                        ${PAMTOPNM} ${TEMPFILE} | ${PAMSCALE} ${SCALE} > "${TARGET}"
                    else
                        cp ${TEMPFILE} "${TARGET}"
                    fi
                ;;
                png) log info "export do PNG"
                    if [ -n "${SCALE}" ] ; then
                        $0 ${FILE} export 1 png ${TEMPFILE}
                    else
                        $0 ${FILE} export 1 png ${TEMPFILE}
                    fi
                ;;
                jpg|jpeg) 
                    if [ -n "${SCALE}" ] ; then
                        $0 ${FILE} export 1 pnm ${TEMPFILE}
                        ${PAMTOPNM} ${TEMPFILE} | ${PAMSCALE} ${SCALE} | ${PNMTOJPEG} > "${TARGET}"
                    else
                        log info "export do v√Ωchoz√≠ho form√°tu ${FILETYPE} m√° smysl pouze p≈ôi p≈ôe≈°k√°lov√°n√≠"
                    fi
                ;;
                jp2)
                    if [ -n "${SCALE}" ] ; then
                        ${PAMTOPNM} ${TEMPFILE} | ${PAMSCALE} ${SCALE} | ${PAMTOJPEG2K} > "${TARGET}"
                    else
                        ${PAMTOJPEG2K} ${TEMPFILE} > "${TARGET}"
                    fi
                ;;
                *) log info "Konverze do v√Ωchoz√≠ho form√°tu ${FILETYPE} m√° smysl pouze p≈ôi ≈°k√°lov√°n√≠"
                    return 1
                ;;
            esac
        ;;
        png)   log info "fromcontainer() Export from PNG"
            case "${INTO}" in
                images) echo "Parametr pou≈æiteln√Ω pouze u PDF - exportuj√≠ se obr√°zky m√≠sto str√°nek" >> /dev/stderr
                    return 1
                ;;
                ocr) echo "TODO Aplikace OCR na konverovan√Ω origin√°ln√≠ soubor" >> /dev/stderr
                ;;
                txt|text) echo "Parametr pou≈æiteln√Ω pouze u PDF - exportuj√≠ se text m√≠sto str√°nky" >> /dev/stderr
                    return 1
                ;;
                *)
                    log info "fromcontainer() Original file is exported from container without conversion"
                    local PAGES=($(range "${RANGE}"))
                    local LISTPAGES=($(listpng "${FILE}"))
                    #/ echo "${LISTPAGES[-1]}"
                    #/ echo "${PAGES[@]}"
                    for i in ${PAGES[@]} ; do
                        local PAGE="${LISTPAGES[$((i-1))]}"
                        case "${INTO}" in
                            png|orig*)
                                if [ -n "${TARGETSAMPLE}" ] ; then
                                    # jedu podle vzorku
                                    local TEMPORAR=$(printf "${TARGETSAMPLE}" $i)
                                    local TARGET="${TARGETDIR}/${TEMPORAR// /0}.png"
                                else
                                    local TARGET="${TARGETDIR}/${PAGE}.png"
                                fi
                                local TEMPFILE=$(tempfile)
                                if [ -n "${SCALE}" ] ; then
                                    local FORSCALE=$(tempfile)
                                    $(itempng "${FILE}" "${PAGE}" > "${FORSCALE}")
                                    pamscale ${SCALE} ${FORSCALE} > ${TEMPFILE}
                                    rm ${FORSCALE}
                                else
                                    $(itempng "${FILE}" "${PAGE}" > "${TEMPFILE}")
                                fi
                                convertovergimp png "${TEMPFILE}"
                                mv -i "${TEMPFILE}.png" "${TARGET}"
                                [ -f "${TEMPFILE}" ] && rm "${TEMPFILE}"
                            ;;
                                pnm|pam)
                                    if [ -n "${TARGETSAMPLE}" ] ; then
                                        # jedu podle vzorku
                                        local TEMPORAR=$(printf "${TARGETSAMPLE}" $i)
                                        local TARGET="${TARGETDIR}/${TEMPORAR// /0}.${INTO}"
                                    else
                                        local TARGET="${TARGETDIR}/${PAGE}.${INTO}"
                                    fi
                                    local TEMPFILE=$(tempfile)
                                    if [ -n "${SCALE}" ] ; then
                                        local FORSCALE=$(tempfile)
                                        $(itempng "${FILE}" "${PAGE}" > "${FORSCALE}")
                                        pamscale ${SCALE} ${FORSCALE} > ${TEMPFILE}
                                        rm ${FORSCALE}
                                    else
                                        $(itempng "${FILE}" "${PAGE}" > "${TEMPFILE}")
                                    fi
                                    case "${INTO}" in
                                        pnm|pam)
                                            mv -i "${TEMPFILE}" "${TARGET}"
                                        ;;
                                        *) echo "Unsupported format ‚Äì> ${INTO}" >> /dev/stderr
                                            return 1
                                        ;;
                                    esac
                                    [ -f "${TEMPFILE}" ] && rm "${TEMPFILE}"
                                ;;
                                *) echo "U XCF soubor≈Ø je t≈ôeba uv√©st typ c√≠lov√©ho souboru" >> /dev/stderr
                                    return 1
                                ;;
                            esac
                        done
                ;;
            esac
        ;;
        pdf)  log info "fromcontainer() Export from PDF"
            case "${INTO}" in
                images) log info "exportuji pouze obr√°zky z ≈ôedan√©ho rozsahu"
                ;;
                ocr) log info "exportuji str√°nku jako obr√°zek a aplikuji OCR"
                ;;
                txt|text) log info "exportuji str√°nku jako text"
                ;;
                pdf) 
                    if [ -n "${TARGETSAMPLE}" ] ; then
                        # jedu podle vzorku
                        local TEMPORAR=$(printf "${TARGETSAMPLE}" $i)
                        local TARGET="${TARGETDIR}/${TARGETSAMPLE}_${RANGE}.pdf"
                    else
                        local TARGET="${TARGETDIR}/${FILE##*/}"
                        pdftopdf "${FILE}" "${TARGET/.pdf/${RANGE}}.pdf"
                    fi
                ;;
                *) if [ "${INTO}" == "" ] ; then
                        echo "Neuveden√Ω form√°t. " >> /dev/stderr
                        if [ -n "${TARGETSAMPLE}" ] ; then
                            # jedu podle vzorku
                            local TEMPORAR=$(printf "${TARGETSAMPLE}" $i)
                            local TARGET="${TARGETDIR}/${TEMPORAR// /0}.${INTO}"
                        else
                            local TARGET="${TARGETDIR}/${FILE##*/}"
                            pdftopdf "${FILE}" "${TARGET/.pdf/_${RANGE}}.pdf"
                        fi
                    else
                        echo "Unsupported format ‚Äì> ${INTO}" >> /dev/stderr
                        return 1
                    fi
                ;;
            esac
        ;;
        gimp|xcf) log info "fromcontainer() Export from XCF"
            case "${INTO}" in
                images) echo "Parametr pou≈æiteln√Ω pouze u PDF - exportuj√≠ se obr√°zky m√≠sto str√°nek" >> /dev/stderr
                    return 1
                ;;
                ocr) echo "TODO Aplikace OCR na konverovan√Ω origin√°ln√≠ soubor" >> /dev/stderr
                ;;
                txt|text) echo "Parametr pou≈æiteln√Ω pouze u PDF - exportuj√≠ se text m√≠sto str√°nky" >> /dev/stderr
                    return 1
                ;;
                *)
                    log info "fromcontainer() Original file is exported from container without conversion"
                    local PAGES=($(range "${RANGE}"))
                    local LISTPAGES=($(listxcf "${FILE}"))
                    #/ echo "${LISTPAGES[-1]}"
                    #/ echo "${PAGES[@]}"
                    for i in ${PAGES[@]} ; do
                        local PAGE="${LISTPAGES[$((i-1))]}"
                        case "${INTO}" in
                            xcf|orig*)
                                if [ -n "${TARGETSAMPLE}" ] ; then
                                    # jedu podle vzorku
                                    local TEMPORAR=$(printf "${TARGETSAMPLE}" $i)
                                    local TARGET="${TARGETDIR}/${TEMPORAR// /0}.xcf"
                                else
                                    local TARGET="${TARGETDIR}/${PAGE}.xcf"
                                fi
                                local TEMPFILE=$(tempfile)
                                if [ -n "${SCALE}" ] ; then
                                    local FORSCALE=$(tempfile)
                                    $(itemxcf "${FILE}" "${PAGE}" > "${FORSCALE}")
                                    pamscale ${SCALE} ${FORSCALE} > ${TEMPFILE}
                                    rm ${FORSCALE}
                                else
                                    $(itemxcf "${FILE}" "${PAGE}" > "${TEMPFILE}")
                                fi
                                convertovergimp xcf "${TEMPFILE}"
                                mv -i "${TEMPFILE}.xcf" "${TARGET}"
                                [ -f "${TEMPFILE}" ] && rm "${TEMPFILE}"
                            ;;
                                pnm|pam)
                                    if [ -n "${TARGETSAMPLE}" ] ; then
                                        # jedu podle vzorku
                                        local TEMPORAR=$(printf "${TARGETSAMPLE}" $i)
                                        local TARGET="${TARGETDIR}/${TEMPORAR// /0}.${INTO}"
                                    else
                                        local TARGET="${TARGETDIR}/${PAGE}.${INTO}"
                                    fi
                                    local TEMPFILE=$(tempfile)
                                    if [ -n "${SCALE}" ] ; then
                                        local FORSCALE=$(tempfile)
                                        $(itemxcf "${FILE}" "${PAGE}" > "${FORSCALE}")
                                        pamscale ${SCALE} ${FORSCALE} > ${TEMPFILE}
                                        rm ${FORSCALE}
                                    else
                                        $(itemxcf "${FILE}" "${PAGE}" > "${TEMPFILE}")
                                    fi
                                    case "${INTO}" in
                                        pnm|pam)
                                            mv -i "${TEMPFILE}" "${TARGET}"
                                        ;;
                                        *) echo "Unsupported format ‚Äì> ${INTO}" >> /dev/stderr
                                            return 1
                                        ;;
                                    esac
                                    [ -f "${TEMPFILE}" ] && rm "${TEMPFILE}"
                                ;;
                                *) echo "U XCF soubor≈Ø je t≈ôeba uv√©st typ c√≠lov√©ho souboru" >> /dev/stderr
                                    return 1
                                ;;
                            esac
                        done
                ;;
            esac
        ;;
        zip|tar) log info "fromcontainer() Export from archive"
            case "${INTO}" in
                images) echo "Parametr pou≈æiteln√Ω pouze u PDF - exportuj√≠ se obr√°zky m√≠sto str√°nek" >> /dev/stderr
                    return 1
                ;;
                ocr) echo "TODO Aplikace OCR na konverovan√Ω origin√°ln√≠ soubor" >> /dev/stderr
                ;;
                txt|text) echo "Parametr pou≈æiteln√Ω pouze u PDF - exportuj√≠ se text m√≠sto str√°nky" >> /dev/stderr
                    return 1
                ;;
                *) local PAGES=($(range "${RANGE}"))
                    local LISTPAGES=($(listzip "${FILE}"))
                    #echo "${LISTPAGES[-1]}"
                    #echo "${PAGES[@]}"
                    for i in ${PAGES[@]} ; do
                        local PAGE="${LISTPAGES[$((i-1))]}"
                        case "${INTO}" in
                            pnm|pam|png|jpg|tiff|jp2) local SUFFIX="${PAGE##*.}"
                                case ${SUFFIX} in
                                    jp2) $(itemzip "${FILE}" "${PAGE}" |\
                                        ${JPEG2KTOPAM} > "${TEMPFILE}")
                                    ;;
                                    jpg) $(itemzip "${FILE}" "${PAGE}" |\
                                        ${JPEGTOPNM} > "${TEMPFILE}")
                                    ;;
                                    png) $(itemzip "${FILE}" "${PAGE}" |\
                                        ${PNGTOPNM} > "${TEMPFILE}")
                                    ;;
                                    tiff) $(itemzip "${FILE}" "${PAGE}" |\
                                        ${TIFFTOPNM} > "${TEMPFILE}")
                                    ;;
                                    *) echo "Nepodporovan√Ω form√°t ${SUFFIX}"
                                        return 1
                                    ;;
                                esac
                                if [ -n "${TARGETSAMPLE}" ] ; then
                                    # jedu podle vzorku
                                    local TEMPORAR=$(printf "${TARGETSAMPLE}" $i)
                                    local TARGET="${TARGETDIR}/${TEMPORAR// /0}.${INTO}"
                                else
                                    local TEMPORAR="${PAGE#*/}"
                                    local TARGET="${TARGETDIR}/${TEMPORAR%.*}.${INTO}"
                                fi
                                case ${INTO} in
                                    jp2) if [ -n "${SCALE}" ] ; then
                                            $(${PAMTOPNM} ${TEMPFILE} |\
                                                ${PAMSCALE} ${SCALE} |\
                                                ${PAMTOJPEG2K} > "${TARGET}")
                                        else
                                            $(${PAMTOPNM} ${TEMPFILE} |\
                                                ${PAMTOJPEG2K} > "${TARGET}")
                                        fi
                                    ;;
                                    jpg)if [ -n "${SCALE}" ] ; then
                                            $(${PAMTOPNM} ${TEMPFILE} |\
                                                ${PAMSCALE} ${SCALE} |\
                                                ${PNMTOJPEG} > "${TARGET}")
                                        else
                                            $(${PAMTOPNM} ${TEMPFILE} |\
                                                ${PNMTOJPEG} > "${TARGET}")
                                        fi
                                    ;;
                                    tiff) if [ -n "${SCALE}" ] ; then
                                            $(${PAMTOPNM} ${TEMPFILE} |\
                                                ${PAMSCALE} ${SCALE} |\
                                                ${PAMTOTIFF} > "${TARGET}")
                                        else
                                            $(${PAMTOPNM} ${TEMPFILE} |\
                                                ${PAMTOTIFF} > "${TARGET}")
                                        fi
                                    ;;
                                    png) if [ -n "${SCALE}" ] ; then
                                            $(${PAMTOPNM} ${TEMPFILE} |\
                                                ${PAMSCALE} ${SCALE} |\
                                                ${PAMTOPNG} > "${TARGET}")
                                        else
                                            $(${PAMTOPNM} ${TEMPFILE} |\
                                                ${PAMTOPNG} > "${TARGET}")
                                        fi
                                    ;;
                                    pnm|pam) if [ -n "${SCALE}" ] ; then
                                            $(${PAMTOPNM} ${TEMPFILE} |\
                                                ${PAMSCALE} ${SCALE} > "${TARGET}")
                                        else
                                            $(${PAMTOPNM} ${TEMPFILE} > "${TARGET}")
                                        fi
                                    ;;
                                esac
                                echo "Page $i saved as ${TARGET}" >> /dev/stderr
                                ;;
                            *) local SUFFIX="${PAGE##*.}"
                                if [ -n "${TARGETSAMPLE}" ] ; then
                                    # jedu podle vzorku
                                    local TEMPORAR=$(printf "${TARGETSAMPLE}" $i)
                                    local TARGET="${TARGETDIR}/${TEMPORAR// /0}.${SUFFIX}"
                                else
                                    local TARGET="${TARGETDIR}/${PAGE#*/}"
                                fi
                                if [ -n "${SCALE}" ] ; then
                                    anone "P≈ôi p≈ôe≈°k√°lov√°n√≠ do p≈Øvodn√≠ho form√°tu dojde k degradaci kvality obrazu m√°m pokraƒçovat?"
                                    [ $? -eq 1 ] && return 1
                                    case ${SUFFIX} in
                                        jp2) $(itemzip "${FILE}" "${PAGE}" |\
                                                ${JPEG2KTOPAM} |\
                                                ${PAMSCALE} ${SCALE} |\
                                            ${PAMTOJPEG2K} > "${TARGET}")
                                        ;;
                                        jpg) $(itemzip "${FILE}" "${PAGE}" |\
                                            ${JPEGTOPNM} |\
                                            ${PAMSCALE} ${SCALE} |\
                                            ${PNMTOJPEG} > "${TARGET}")
                                        ;;
                                        png) $(itemzip "${FILE}" "${PAGE}" |\
                                            ${PNGTOPNM} |\
                                            ${PAMSCALE} ${SCALE} |\
                                            ${PAMTOPNG} > "${TARGET}")
                                        ;;
                                        tiff) $(itemzip "${FILE}" "${PAGE}" |\
                                            ${TIFFTOPNM} |\
                                            ${PAMSCALE} ${SCALE} |\
                                            ${PAMTOTIFF} > "${TARGET}")
                                        ;;
                                    esac
                            else
                                log info "fromcontainer() Original file ${PAGE} is exported from container without conversion"
                                $(itemzip "${FILE}" "${PAGE}" > "${TARGET}")
                            fi
                            echo "Page $i saved as ${TARGET}" >> /dev/stderr
                            ;;
                        esac
                    done
                ;;
            esac
        ;;
    esac
    return 0
}

# ### <span id="exportimg">exportimg()</span> ([top](#FUNCTIONS))
# Funkce exportuje ze souboru str√°nky jako obr√°zky.
# Vstupn√≠mi parametry jsou glob√°ln√≠ promƒõnn√©:
# * FILE - Soubor ze kter√©ho se str√°nka exportuje.
# * CHARSTRING - Promƒõnn√°, kter√° obsahuje dal≈°√≠ parametry:
# ** Rozsah exportovan√Ωch str√°nek. Nen√≠-li uveden, budou exportov√°ny
#    v≈°echny str√°nky ze souboru.
# ** Form√°t c√≠lov√©ho souboru
# ** Velikost c√≠lov√©ho souboru, nastaven√° buƒè formou XxY, nebo procetu√°lnƒõ Z%
#
# M√≠sto parametr≈Ø m≈Ø≈æe b√Ωt tak√© p≈ôed√°na tak√© cesta k souboru, ve kter√©m
# mohou b√Ωt parametry nastaveny specificky pro ka≈ædou str√°nku (rozsah)
# zvl√°≈°≈•. Tento soubor __mus√≠__ m√≠t p≈ô√≠ponu `.list`
#
# Za parametry, nebo cestou k souboru s p≈ô√≠ponou `.list` m≈Ø≈æe n√°sledovat
# c√≠lov√Ω adres√°≈ô, resp. vzor pro pojmenov√°n√≠ str√°nek
#
#     example/example
#
# P≈ôi exportu jpeg soubor≈Ø z arch√≠vu ulo≈æ√≠ do podadres√°≈ôe example
# exportovan√© str√°nky pod n√°zvy: example_00001.jpg, example_00002.jpg, ‚Ä¶
#
# #### export
# Operace export slou≈æ√≠ k extrakci str√°nek (vrstev)
# z form√°t≈Ø, kter√© mohou obsahovat v√≠ce str√°nek, p≈ô√≠padnƒõ
# k jejich transormaci na jin√Ω rozmƒõr ƒçi konverzi do
# jin√©ho form√°t. Viz p≈ô√≠klad:
#
#      djvutool soubor.jpg export 1 jpg 30%
#
# Vygeneruje JPEG obr√°zek s n√°zvem soubor_30%.jpg jeho≈æ
# obsahem bude p≈Øvodn√≠ obr√°zek, zmen≈°en√Ω na 30% velikost
#
# U kontejner≈Ø, kter√© maj√≠ ulo≈æeny v sobƒõ obr√°zky,
# lze prov√©st export pouze s uveden√≠m rozsahu. C√≠lov√©
# soubory se pak budou jmenovat stejnƒõ, jako v arch√≠vu:
#
# djvutool soubor.zip export 2-7
# 
# U form√°t≈Ø s podporou v√≠ce str√°nek, kter√© maj√≠
# ulo≈æen n√°zev vrstvy ƒçi str√°nky, je vhodn√© uv√©st
# c√≠lov√Ω form√°t souboru. Jm√©no c√≠lov√©ho souboru pak
# bude stejn√© jako n√°zev p≈ô√≠slu≈°n√© vrstvy ƒçi str√°nky:
# 
# djvutool soubor.xcf export 2-7
#
# V p≈ô√≠padƒõ PDF soubor≈Ø, kter√© mohou obsahovat mix textu
# a obr√°zk≈Ø volbou p≈ô√≠pony sdƒõl√≠te, ≈æe chcete vyexportovat
# pouze obr√°zky:
#
# djvutool soubor.pdf export 1 jpg
#
# V tomto p≈ô√≠padƒõ se budou jmenovat soubory b≈Øhv√≠ jak.
# Je tedy v tomto p≈ô√≠padƒõ ≈æ√°douc√≠ uv√©st p≈ô√≠padnƒõ jm√©no
# a p≈ô√≠padnƒõ i v√Ωchoz√≠ cestu:
#
# djvutool soubor.pdf export 1 jpg 30% example/
#
# V tomto p≈ô√≠padƒõ se obr√°zky nasypou do adres√°≈ôe example.
# Pokud neexistuje, tak se zalo≈æ√≠.
#
#  djvutool soubor.pdf export 1 jpg 30% example
#
# Pokud nekonƒç√≠ ≈ô√°dek lom√≠tkem, pou≈æije se cel√Ω zbytek
# ≈ôetƒõzce jako v√Ωchoz√≠ vzor pro pojmenov√°n√≠ str√°nky
# (obr√°zku) c√≠lov√Ω soubor se tedy bude v tomto p≈ô√≠padƒõ
# jmenovat example_30%_001.jpg
exportimg() {
    log goto "exportimg() ${FILE} ‚Äì> ${CHARSTRING}"
    if [[ "${CHARSTRING}" =~ "?" ]] ||\
        [[ "${CHARSTRING}" =~ "-h" ]] ||\
        [[ "${CHARSTRING}" =~ "help" ]] ; then
        help bitmap-export
    elif [[ "${CHARSTRING}" =~ ".list" ]] ; then
        local SOURCE=$(${REALPATH} -m -P "${CHARSTRING%.list*}.list" 2>/dev/null)
        if [ -f "${SOURCE}" ] ; then
            log info "exportimg() Read params from ‚Äì> ${SOURCE}"
            local TARGET="${CHARSTRING#*.list}"
            while read line ; do
                CHARSTRING="$line ${TARGET}"
                fromcontainer "${FILE}" "${CHARSTRING}"
            done < "${SOURCE}"
        else
            return 1
        fi
    else
        fromcontainer "${FILE}" "${CHARSTRING}"
    fi
    return $?
}

# ### <span id="viewdjvu">viewdjvu()</span> ([top](#FUNCTIONS))
# Funkce se vol√° p≈ôi akci view, kdy≈æ si chci prohl√©dnout DjVu soubor
viewdjvu() {
     log info "View ‚Äì> ${FILE}"
    (${DJVIEW} "${FILE}" &)
}

# ### <span id="viewimg">viewimg()</span> ([top](#FUNCTIONS))
# Funkce se vol√° p≈ôi akci view, kdy≈æ si chce≈° prohl√©dnout bitmapov√Ω 
# obr√°zek
viewimg() {
    log info "viewimg() open ‚Äì> ${FILE}"
    case ${FILETYPE} in
        pnm|ppm|pgm|pbm|pam|\
        png|jpg|jpeg|bmp|gif|tiff) if [ -n "${FEH}" ] ; then
                local TEMPORARY=($(parsecut $(xrandr | grep '[ ]connected' | head -1 | cut -d' ' -f3)))
                echo "${TEMPORARY[@]}" >> /dev/stderr
                local W=$(( ${TEMPORARY[0]} / 2 ))
                local H=$(( ${TEMPORARY[1]} / 2 ))
                local X=50
                local Y=50
                echo "${W}x${H}+${X}+${Y}" >> /dev/stderr
                ${FEH} --scale-down --auto-zoom --geometry "${W}x${H}+${X}+${Y}" "${FILE}"
            else
                ${GEEQIE} "${FILE}"
            fi
        ;;
        plain|jpeg-2000) local TEMPFILE="${TEMPDIR}/${FILE##*/}"
            ${JPEG2KTOPAM} ${FILE} > ${TEMPFILE}
            #opj_decompress -i ${FILE} -o ${TEMPFILE} -l 1
            ls -alh ${TEMPFILE}
            exiftool ${TEMPFILE}
            $0 ${TEMPFILE} view
        ;;
#        gimp|pdf|xcf|eps|psd|tga|ps)
#            ${GIMP} "${FILE}"
#        ;;
        gimp) isrange ${CHARSTRING}
            if [ $? -eq 0 ] ; then
                local PAGES=($(range "${CHARSTRING}"))
                local LISTPAGES=($(listxcf "${FILE}"))
                #echo "${LISTPAGES[-1]}"
                #echo "${PAGES[@]}"
                for i in ${PAGES[0]} ; do
                    local PAGE="${LISTPAGES[$((i-1))]}"
                    $(itemxcf "${FILE}" "${PAGE}" > "${TEMPDIR}/${PAGE##*/}.pam")
#                    exit 33
                    $0 view "${TEMPDIR}/${PAGE##*/}.pam"
                done
            else
                echo "V p≈ô√≠padƒõ xcf souboru mus√≠ b√Ωt uvedeno ƒç√≠slo str√°nky" >> /dev/stderr
                return 1
            fi
        ;;
        zip) isrange ${CHARSTRING}
            if [ $? -eq 0 ] ; then
                local PAGES=($(range "${CHARSTRING}"))
                local LISTPAGES=($(listzip "${FILE}"))
                #echo "${LISTPAGES[-1]}"
                #echo "${PAGES[@]}"
                for i in ${PAGES[0]} ; do
                    local PAGE="${LISTPAGES[$((i-1))]}"
                    $(itemzip "${FILE}" "${PAGE}" > "${TEMPDIR}/${PAGE##*/}")
                    $0 view "${TEMPDIR}/${PAGE##*/}"
                done
            else
                echo "V p≈ô√≠padƒõ kontejneru mus√≠ b√Ωt uvedeno ƒç√≠slo str√°nky" >> /dev/stderr
                return 1
            fi
        ;;
        *) echo "Nepodporovan√Ω form√°t ${FILETYPE}" >> /dev/stderr
            return 1
        ;;
    esac
}

# ### <span id="infoimg">infoimg()</span> ([top](#FUNCTIONS))
# Funkce vypisuje info o bitmapov√Ωch souborech a p≈ô√≠padnƒõ vicestr√°nkov√Ωch
# form√°t≈Ø i jejich str√°nk√°ch.
# Vstupn√≠mi parametry jsou glob√°ln√≠ promƒõnn√©:
# * FILE - Soubor ze kter√©ho se str√°nka exportuje.
# * CHARSTRING - Promƒõnn√°, kter√° obsahuje dal≈°√≠ parametry:
# ** typ zobrazovan√© informace
# ** a p≈ô√≠padnƒõ ƒç√≠slo konkr√©tn√≠ str√°nky (vrstvy)
infoimg() {
    log goto "infoimg() ${FILE} ‚Äì> ${CHARSTRING}"
    if [[ "${CHARSTRING}" =~ "?" ]] ||\
        [[ "${CHARSTRING}" =~ "-h" ]] ||\
        [[ "${CHARSTRING}" =~ "help" ]] ; then
        help bitmap-info
    else
        case ${FILETYPE} in
            gif) # GIF je grafick√Ω form√°t, s bezztr√°tovou kompres√≠, kter√Ω
                # m√° podporu pro animace.
                # Je omezen√Ω p≈ôedev≈°√≠m v tom, ≈æe m√° k dispozici pouze 256
                # barev. Za urƒçit√Ωch okolnost√≠ m≈Ø≈æe fungovat i jako
                # kontejner pro v√≠ce str√°nkov√© dokumenty (co vrstva, to str√°nka).
                #
                # V√Ωhodou GIF form√°tu oproti MNG ƒçi (AP)NG je p≈ôedev≈°√≠m
                # to, ≈æe m√° ≈°irokou podporu u webov√Ωch prohl√≠≈æeƒç≈Ø. Proto
                # se vy≈æ√≠v√° p≈ôedev≈°√≠m pro n√°hledy v√≠cestr√°nkov√Ωch dokument≈Ø.
                # Kdy se n√°hledy vybran√Ωch str√°nek, ulo≈æen√© jako jednotliv√©
                # sn√≠mky p≈ôehr√°vaj√≠ v nekoneƒçn√© smyƒçce.
                # Poƒçet sn√≠mk≈Ø (str√°nek) ud√°v√° exif tag 'Animation frames'
                #
                # .gif
                case ${CHARSTRING} in
                    meta*) ${EXIFTOOL} "${FILE}"
                    ;;
                    pages) echo "Zjistit poƒçet vrstev"
                    ;;
                    *) local INFO=($(cat "${FILE}"|infoitem))
                        echo "${INFO[@]}"
                    ;;
                esac
            ;;
            jpg|jpeg) # JPEG je grafick√Ω form√°t se ztr√°tovou kompres√≠, kter√Ω
                # podporuje pouze jednu vrstvu
                #
                # .jpg, .jpeg, .jpe, .jif, .jfif, .jfi
                case ${CHARSTRING} in
                    meta*) ${EXIFTOOL} "${FILE}"
                    ;;
                    pages) echo "1"
                    ;;
                    *) local INFO=($(cat "${FILE}"|infoitem))
                        echo "${INFO[@]}"
                    ;;
                esac
            ;;
            jpeg-2000) # JPEG 2000 je grafick√Ω form√°t, kter√Ω pracuje se
                # ztr√°tovou, ale i bezeztr√°tovou wavelet kompres√≠. To je
                # kl√≠ƒçov√Ωm rozd√≠lem oproti DjVu, proto≈æe u DjVu z principu
                # v≈ædy dojde k ƒç√°steƒçn√© ztr√°tƒõ grafick√© informace.
                # Oproti bezeztr√°tov√©mu PNG m√° lep≈°√≠ kompresn√≠ pomƒõr. A
                # p≈ôi ztr√°tov√© kompresi je v√Ωsledek po dekompresi v≈ædy
                # lep≈°√≠ ne≈æ u JPEG form√°tu.
                # Nev√Ωhodou je zdlouhav√° dekomprese a t√≠m i pomalej≈°√≠
                # zobrazov√°n√≠ v prohl√≠≈æeƒçi. Proto se vyu≈æ√≠v√° p≈ôedev≈°√≠m
                # pro archivaci p≈Øvodn√≠ho skenu.
                #
                # Nepodporuje v√≠ce vrstev! Proto se naskenovan√© soubory
                # obvykle zabal√≠ do `.zip` kontejneru
                #
                # .jp2, .j2k, .jpf, .jpx, .jpm, .mj2
                case ${CHARSTRING} in
                    meta*) ${EXIFTOOL} "${FILE}"
                    ;;
                    pages) echo "1"
                    ;;
                    *) local INFO=($(cat "${FILE}"|infoitem))
                        echo "${INFO[@]}"
                    ;;
                esac
            ;;
            pnm|pgm|pbm|ppm) # Form√°t se kter√Ωm p≈ôi≈°el projekt Netpbm.
                # Nepodporuje v√≠ce vrstev!!!
                # PNM form√°t (portable anymap) zastupuje n√°sleduj√≠c√≠ form√°ty:
                # * PBM - portable bitmap (ƒçernob√≠l√© obr√°zky)
                #   V hlaviƒçce m√° P1 (P4 - bin√°rn√≠ form√°t)
                # * PGM - portable graymap (obr√°zky ve stupn√≠ch ≈°edi)
                #   V hlaviƒçce m√° P2 (P5 - bin√°rn√≠ form√°t)
                # * PPM - portable pixmap (RGB obr√°zky)
                #   V hlaviƒçce m√° P3 (P6 - bin√°rn√≠ form√°t)
                # * PAM - portable anymap, zastupuje podobnƒõ jako PNM
                #   v≈°echny form√°ty a v m√° hlaviƒçce P7. Je schopen zachytit
                #   barvy stejnƒõ jako CMYK
                #
                # Rozd√≠ly jsou p≈ôedev≈°√≠m v podpo≈ôe bitov√© hloubky barev:
                # 48-bit≈Ø podporuje pouze PPM (rgb48be)
                # 32-bit≈Ø podporuje plain PNM a plain PAM - bin√°rn√≠ verze nikoliv!!!
                # 24-bitov√° podopora je u v≈°ech form√°t≈Ø
                # 16-bit≈Ø PGM a PAM bez pr≈Øhlednosti (grap16be)
                #
                # https://en.wikipedia.org/wiki/Netpbm_format
                case ${CHARSTRING} in
                    meta*) ${EXIFTOOL} "${FILE}"
                    ;;
                    pages) echo "1"
                    ;;
                    *) local INFO=($(cat "${FILE}"|infoitem))
                        echo "${INFO[@]}"
                    ;;
                esac
            ;;
            mng) # MNG je form√°t pro animace, zalo≈æen√Ω na PNG, podobnƒõ
                # jako (A)PNG. Nen√≠ moc roz≈°√≠≈ôen√Ω.
                # Poƒçet vrstev ud√°v√° v exifu 'Animation frames'
                #
                # .mng
                case ${CHARSTRING} in
                    meta*) ${EXIFTOOL} "${FILE}"
                    ;;
                    pages) local SUMPAGES=$(${IDENTIFY} "${FILE}" | wc -l)
                        echo "${SUMPAGES}"
                    ;;
                    *) local INFO=($(cat "${FILE}"|infoitem))
                        local SUMPAGES=$(${IDENTIFY} "${FILE}" | wc -l)
                        echo "${INFO[@]} ${SUMPAGES}"
                    ;;
                esac
            ;;
            png) # PNG je form√°t, u kter√©ho se p≈Øvodnƒõ v≈Øbec nepoƒç√≠talo,
                # ≈æe by mohl m√≠t v√≠ce ne≈æ jednu vrstvu. Proto≈æe ale form√°t
                # GIF, kter√Ω animace podporuje, m√° sv√° omezen√≠ (nepodporuje
                # pr≈Øhlednost a m√° k dispozici pouze 256 barev), vzniklo
                # jako alternativa APNG ‚Äì co≈æ je sv√Ωm zp≈Øsobem video
                # kontejner, kter√Ω obsahuje ≈ôadu po sobƒõ jdouc√≠ch PNG obr√°zk≈Ø.
                #
                # Oproti podobn√©mu MNG form√°tu v≈°ak umo≈æ≈àuje zpƒõtnou
                # kompatibilitu, kdy se v prohl√≠≈æeƒç√≠ch co animace nepodporuj√≠,
                # zobrazuje pouze prvn√≠ sn√≠mek. Soubory maj√≠ stejnou p≈ô√≠ponu
                # .png, jako klasick√© PNG
                #
                # Poƒçet vrstev ud√°v√° exif tag 'Animation frames'
                #
                # .png
                case ${CHARSTRING} in
                    meta*) ${EXIFTOOL} "${FILE}"
                    ;;
                    pages) echo "Zjistit poƒçet vrstev"
                    ;;
                    *) local INFO=($(cat "${FILE}"|infoitem))
                        echo "${INFO[@]}"
                    ;;
                esac
            ;;
            gimp|xcf) # Nativn√≠ form√°t Gimpu m≈Ø≈æe m√≠t v√≠ce vrstev
                case ${CHARSTRING} in
                    meta*)  ${EXIFTOOL} "${FILE}"
                    ;;
                    pages\ +([0-9])|pages\ all|pages)
                        local TEMPORAR=(${CHARSTRING})
                        case ${TEMPORAR[1]} in
                            all) ${XCFINFO} -u "${FILE}"
                            ;;
                            +([0-9])) ${XCFINFO} -u "${FILE}" | \
                                grep -m ${TEMPORAR[1]} '^+.*RGB.*Normal' | \
                                tail -1
                            ;;
                            *) local SUMPAGES=$(${XCFINFO} "${FILE}" | wc -l)
                                echo "${SUMPAGES}"
                            ;;
                        esac
                    ;;
                    *) local INFO=($(cat "${FILE}"|infoitem))
                        local SUMPAGES=$(${XCFINFO} "${FILE}" | wc -l)
                        echo "${INFO[@]} ${SUMPAGES}"
                    ;;
                esac
            ;;
            tiff) # Form√°t TIFF m≈Ø≈æe m√≠t v√≠ce str√°nek
                case ${CHARSTRING} in
                    meta*) ${EXIFTOOL} "${FILE}"
                    ;;
                    pages) local SUMPAGES=$(${TIFFINFO} "${FILE}" | grep "TIFF Directory" | wc -l)
                        echo "${SUMPAGES}"
                    ;;
                    *) local INFO=($(cat "${FILE}"|infoitem))
                        local SUMPAGES=$(${TIFFINFO} "${FILE}" | grep "TIFF Directory" | wc -l)
                        echo "${INFO[@]} ${SUMPAGES}"
                    ;;
                esac
            ;;
            stl|pcd) # PCD je rastrov√Ω form√°t fy. Kodak
                # Star≈°√≠ form√°t, pro jeho≈æ konverzi lze pou≈æ√≠t ImageMagick,
                # ale lep≈°√≠ v√Ωsledky d√°v√° ji≈æ del≈°√≠ dobu neudr≈æovan√° konverzn√≠
                # utilita pcdtojpeg.
                # http://pcdtojpeg.sourceforge.net/Download.html
                #
                # Form√°t je podobn√Ω form√°tu Tiled Multi-Resolution TIFF
                # ‚Ä¶
                # Obr√°zek je v kontejneru ulo≈æen v 6
                # velikostech:
                # Suffix [1] produces an image 192 by 128 ("Base/16")
                # Suffix [2] produces an image 384 by 256 ("Base/4")
                # Suffix [3] produces an image 768 by 512 ("Base")
                # Suffix [4] produces an image 1536 by 1024 ("4 Base")
                # Suffix [5] produces an image 3072 by 2048 ("16 Base")
                # Suffix [6] produces an image 6144 by 4096 ("64 Base")
                #
                # Pozn√°mka: Kdy≈æ pou≈æijete ƒç√≠slo 7 a vy≈°≈°√≠ tak to m√° stejn√Ω
                # efekt jako kdy≈æ se pou≈æije 6
                #
                # P≈ôi konverzi vych√°z√≠ obr√°zek moc tmav√Ω to lze po≈ôe≈°it buƒè
                # nastaven√≠m barevn√©ho profilu, nebo gammy
                # Resolutin
                # Contrast
                # Saturation
                # Red
                # Green
                # Nepodporuje v√≠ce str√°nek
                #
                # https://en.wikipedia.org/wiki/Photo_CD
                case ${CHARSTRING} in
                    meta*) ${EXIFTOOL} "${FILE}"
                    ;;
                    pages) echo "1"
                    ;;
                    *) local INFO=($(cat "${FILE}"|infoitem))
                        echo "${INFO[@]}"
                    ;;
                esac
            ;;
            psd|psb) # Propriet√°rn√≠ form√°t Photoshopu
                # PSB je PSD roz≈°√≠≈ôen√© na podporu obr√°zk≈Ø o velikosti
                # 300 tis. pixel≈Ø. Standardn√≠ PSD podporuje max. 30 tis.
                # pixel≈Ø. Pracuje s vrstvami
                # .psd .psb
            ;;
            pdf) # PDF - portable document format, je do uƒçit√© m√≠ry
                # alternativou k DjVu. Nebyl ale navr≈æen pro rychl√©
                # prohl√≠≈æen√≠ (jako DjVu) ale pro lep≈°√≠ p≈ôenositelnost mezi
                # operaƒçn√≠mi syst√©my. Z toho plynou i jeho nev√Ωhody.
                # P≈ôedev≈°√≠m zdlouhav√° dekomprese.
                #
                # Z principu m√° podporu pro v√≠ce str√°nek
                case ${CHARSTRING} in
                    meta*) pdfinfo -box "${FILE}"
                    ;;
                    *) local INFO=($(cat "${FILE}"|infoitem))
                        local SUMPAGES=$(${EXIFTOOL} -s3 -PageCount "${FILE}")
                        echo "${INFO[@]} ${SUMPAGES}"
                    ;;
                esac
            ;;
            sgi) #
                # https://en.wikipedia.org/wiki/Silicon_Graphics_Image
            ;;
            tga) # 
                # https://en.wikipedia.org/wiki/Truevision_TGA
            ;;
            webp) #
                # https://en.wikipedia.org/wiki/WebP
            ;;
            xbm) #
                # https://en.wikipedia.org/wiki/X_BitMap
            ;;
            xpm) #
                # https://en.wikipedia.org/wiki/X_PixMap
            ;;
            xwd) # Form√°t do kter√©ho ukl√°d√° screenshoty obrazovky X Windows systems
                # https://en.wikipedia.org/wiki/Xwd
            ;;
            tar|zip) # Nejde o grafick√© form√°ty, ale kontejnery, co m≈Ø≈æou
                # obsahovat r≈Øzn√© typy soubor≈Ø. Na serveru archive.org se
                # vyu≈æ√≠vaj√≠ pro zabalen√≠ soubor≈Ø sken≈Ø ve form√°tu jp2, jpeg aj.
                case ${CHARSTRING} in
                    list) listzip "${FILE}"
                    ;;
                    meta*) #/ m≈Ø≈æe b√Ωt archiv s obr√°zky
                        local LISTPAGES=($(listzip "${FILE}"))
                        local PAGE="${CHARSTRING#meta }"
                        case ${PAGE} in
                            meta) log info "main() Exif info for first file ${LISTPAGES[0]} from archive ${FILE}"
                                echo $(itemzip "${FILE}" "${LISTPAGES[0]}" | infoitem)
                            ;;
                            *) if [ "${PAGE}" -ge "0" ] && [ "${PAGE}" -lt "${#LISTPAGES[@]}" ] ; then
                                    log info "main() Exif info for ${PAGE} file: ${LISTPAGES[${PAGE}]} from archive ${FILE}"
                                    itemzip "${FILE}" "${LISTPAGES[${PAGE}]}" | ${EXIFTOOL} -
                                else
                                    echo "Ivalid value ${PAGE}" >> /dev/stderr
                                    return 1
                                fi
                            ;;
                        esac
                    ;;
                    pages\ +([0-9])|pages\ all|pages) local TEMPORAR=(${CHARSTRING})
                        case ${TEMPORAR[1]} in
                            all) local LISTPAGES=($(listzip "${FILE}"))
                                printf "%s\n" ${LISTPAGES[@]}
                            ;;
                            +([0-9])) local LISTPAGES=($(listzip "${FILE}"))
                                printf "%s\n" ${LISTPAGES[@]} | \
                                grep -m ${TEMPORAR[1]} -v /$ | tail -1
                            ;;
                            *) local SUMPAGES=$(listzip "${FILE}" | wc -l)
                                echo "${SUMPAGES}"
                            ;;
                        esac
                    ;;
                    *) # zjistit jak√©ho typu jsou obr√°zky v archivu
                        local SUMPAGES=$(listzip "${FILE}" | wc -l)
                        echo "${FILETYPE^^} ${SUMPAGES}"
                    ;;
                esac
            ;;
        esac
    fi
    return $?
}

# ### <span id="jp2to">jp2to()</span> ([top](#FUNCTIONS))
# Konvertuje obr√°zky z form√°tu JPEG-2000 do bitmapov√Ωch form√°t≈Ø:
# `.bmp`, `.pgm`, `.pgx`, `.png`, `.pnm`, `.ppm`, `.raw`, `.tga`, `.tif`.
# Vyu≈æ√≠v√° se p≈ôi tom n√°stroj libopenjp2-tools
# P≈ôi konverzi do PNG je vy≈æadov√°na knihovna libpng a p≈ôi konverzi do
# form√°tu TIFF zase knihovna libtiff.
#
# Srovn√°n√≠: Cca 4,1M jp2 ve stupn√≠ch ≈°edi, mizern√© kvality m√° po konverzi
# do DjVu p≈ôi pou≈æit√≠ v√Ωchoz√≠ho algoritmu (`djvu`) 1,1M. O nƒõco lep≈°√≠ v√Ωsledek
# jak z hlediska vizu√°ln√≠ho, tak velikosti souboru nab√≠dnul algoritmus
# `otsu` ‚Äì 0.7MB
# Stejn√Ω soubor nekomprimovan√Ω zabral 33M a v PNG 21M
jp2to() {
    log goto "jp2to() $1 ‚Äì> $2"
    ${PAMTO} -i "${1}" -o "${2}"
    return $?
}

# ### <span id="jp2in">jp2in()</span> ([top](#FUNCTIONS))
# Konvertuje obr√°zky do form√°tu JPEG-2000
# `.bmp`, `.pgm`, `.pgx`, `.png`, `.pnm`, `.ppm`, `.raw`, `.tga`, `.tif`.
# Vyu≈æ√≠v√° se p≈ôi tom n√°stroj libopenjp2-tools.
# P≈ôi konverzi z PNG je vy≈æadov√°na knihovna libpng a p≈ôi konverzi z
# form√°tu TIFF zase knihovna libtiff.
#
# Konverze ji≈æ zpracovan√©ho obr√°zku u≈æ nen√≠ tak dobr√° jako z origin√°lu 8-/
jp2in() {
    log goto "jp2in() $1 ‚Äì> $2"
    
    ${JP2IN} -i "${1}" -o "${2}"
    return $?
}


# ### <span id="listpdf">listpdf()</span> ([top](#FUNCTIONS))
# Funkce vrac√≠ seznam str√°nek v PDF souboru.
#
# pdftk soubor.pdf dump_data | grep PageMedia
#
# PageMediaNumber: 5
# PageMediaRotation: 0
# PageMediaRect: 0 0 533 838
# PageMediaDimensions: 533 838
#
# D≈Øle≈æit√© jsou rozmƒõry, rotace a ƒç√≠slo
#     + 2451x3363+0+0 RGB-alpha Normal 46
#
# 1, polo≈æka viditelnost vrstvy (+|-)
# 2, polo≈æka rozmƒõry vrstvy
# 3, 
# 4, typ vrstvy - by mƒõly b√Ωt typu Normal 
# 5, jm√©no vrstvy
#
# Pokud se u nƒõkter√© z viditeln√Ωch vrstev vyskytuje jin√Ω typ, ne≈æ Normal,
# pak se vrac√≠ upozornƒõn√≠, ≈æe jde o rozpracovan√Ω soubor a v√Ωsledek nemus√≠
# odpov√≠dat po≈æadovku
#
# Po≈ôadov√© ƒç√≠slo souboru tak odpov√≠d√° ƒç√≠slu str√°nky
listpdf() {
    log goto "listpdf() From "
    ${PDFTK} "${1}" dump_data | awk '/^PageMediaNumber/ {print $2}'
}

# ### <span id="pdftopdf">pdftopds()</span> ([top](#FUNCTIONS))
# Export rozsahu ${RANGE} str√°nek z pdf souboru $1 do nov√©ho pdf souboru $2
pdftopdf() {
    log goto "pdftopdf() From pdf $1 range ${RANGE}"
    local TEMPORAR=(${RANGE//,/ })
    local RANGE=$(printf "A%s " ${TEMPORAR[@]})
    ${PDFTK} A="${1}" cat ${RANGE} output "${2}"
}

# ### <span id="itemxcf">itemxcf()</span> ([top](#FUNCTIONS))
# Funkce vyblije na standardn√≠ v√Ωstup str√°nku __$2__ z PDF souboru __$1__
itempdf() {
    ${PDFTOPPM} -f ${2} -l ${2} < "${1}"
}

# ### <span id="listxcf">listxcf()</span> ([top](#FUNCTIONS))
# Funkce vrac√≠ seznam vrstev v XCF souboru.
#
# Ov≈°em tento vstupn√≠ XCF soubor mus√≠ b√Ωt p≈ôipraven ke konverzi a to tak,
# ≈æe vrstvy, kter√© maj√≠ b√Ωt pova≈æov√°ny za str√°nky, mus√≠ b√Ωt typu Normal a
# viditeln√©. 
#
#     + 2451x3363+0+0 RGB-alpha Normal 46
#
# 1, polo≈æka viditelnost vrstvy (+|-)
# 2, polo≈æka rozmƒõry vrstvy
# 3, 
# 4, typ vrstvy - by mƒõly b√Ωt typu Normal 
# 5, jm√©no vrstvy
#
# Pokud se u nƒõkter√© z viditeln√Ωch vrstev vyskytuje jin√Ω typ, ne≈æ Normal,
# pak se vrac√≠ upozornƒõn√≠, ≈æe jde o rozpracovan√Ω soubor a v√Ωsledek nemus√≠
# odpov√≠dat po≈æadovku
#
# Po≈ôadov√© ƒç√≠slo souboru tak odpov√≠d√° ƒç√≠slu str√°nky
listxcf() {
    local TEST=$( ${XCFINFO} "${1}" | grep ^+ | awk '{print $4}' | grep -v Normal )
    ${XCFINFO} -u "${1}" | while read line ; do
        case "${line:0:1}" in
            +) echo "${line#*RGB* Normal }"
            ;;
        esac
    done
    [ -n "${TEST}" ] && return 1 || return 0
}

# ### <span id="itemxcf">itemxcf()</span> ([top](#FUNCTIONS))
# Funkce vyblije na standardn√≠ v√Ωstup z XCF __$1__ vrstvu __$2__
itemxcf() {
    log goto "itemxcf() From $1 flush ‚Äì> $2"
    ${XCF2PNM} "${1}" "${2}"
}

# ### <span id="itempng">itempng()</span> ([top](#FUNCTIONS))
# Funkce vyblije na standardn√≠ v√Ωstup z XCF __$1__ vrstvu __$2__
itempng() {
    log goto "itempng() From $1 flush ‚Äì> $2"
    # ${XCF2PNM} "${1}" "${2}"
}

# ### <span id="listpng">listpng()</span> ([top](#FUNCTIONS))
# Vrac√≠ po≈ôadov√© ƒç√≠slo vrstvy, kter√© odpov√≠d√° ƒç√≠slu str√°nky
listpng() {
    local TEMPORARY="${1##*/}"
    mkdir ${TEMPORARY}
    # ${ZIP} l -so "${1}" | awk '{print $6}' | grep '/' | sort -t _
}

# ### <span id="listdjvu">listdjvu()</span> ([top](#FUNCTIONS))
# Vrac√≠ seznam str√°nek v DjVu souboru
listdjvu() {
    #${ZIP} l -so "${1}" | awk '{print $6}' | grep '/' | sort -t _
    echo nil
}

# ### <span id="listzip">listzip()</span> ([top](#FUNCTIONS))
# Vrac√≠ set≈ô√≠dƒõn√Ω seznam soubor≈Ø v ZIP archivu - je zalo≈æen na syntaxi
# pou≈æ√≠van√© u soubor≈Ø archive.org, kdy ƒç√≠slov√°n√≠ str√°nek je p≈ôed p≈ô√≠ponou
# souboru, oddƒõlen√© od jm√©na adres√°≈ôe podtr≈æ√≠tkem
#
#         pg35600_jp2/pg35600_0158.jp2
#
# Po≈ôadov√© ƒç√≠slo souboru tak odpov√≠d√° ƒç√≠slu str√°nky
listzip() {
    ${ZIP} l -so "${1}" | awk '{print $6}' | grep '/' | sort -t _
}

# ### <span id="itemzip">itemzip()</span> ([top](#FUNCTIONS))
# Funkce vyblije na standardn√≠ v√Ωstup ze zazipovan√©ho arch√≠vu __$1__
# soubor __$2__
itemzip() {
    log goto "itemzip() From $1 flush ‚Äì> $2"
    ${ZIP} e -so "${1}" "${2}"
}

# ### <span id="infile">infile()</span> ([top](#FUNCTIONS))
# Vrac√≠ adresy poƒç√°teƒçn√≠ho a posledn√≠ ≈ô√°dku bloku, kter√Ω vyhovuje odpov√≠daj√≠c√≠mu vzorku
# $1 - jm√©no souboru
# $COORDS
# $MESSAGE
infile() {
    log goto "infile() $1 ‚Äì> ${COORDS}"

    mapfile -d\: -t -c1 CORDANT <<< $(grep -n "${COORDS%+([[:blank:]])}" "${1}")
    mapfile -d\: -t -c1 MESANT <<< $(grep -n "${MESSAGE}" "${1}")
    #echo "${MESSAGE}" >> /dev/stderr
    #echo "${MESANT}" >> /dev/stderr
    mapfile -t TEMP <<< $(grep -n '^[a-Z#]' "${1}")
    local POLEOBJEKTU=(${TEMP[@]%:*})
    local RADKYCELKEM=$(wc -l < ${1})

    _f() {
        local z i
        for i in ${POLEOBJEKTU[@]} ; do [ $i -gt $1 ] && break || ((++z)) ; done
        if [ $i -lt $1 ] ; then
            log info "_f() Za ≈ô√°dkem $1 u≈æ nebyl ≈æ√°dn√Ω objekt"
            echo "$i" "${RADKYCELKEM}"
        else
            log info "_f() Za ≈ô√°dkem $1 zaƒç√≠nal dal≈°√≠ objekt na $i"
            echo "${POLEOBJEKTU[$((z - 1))]}" "$((i - 1))"
        fi
    }
    
    case "${MESANT}" in
        +([[:digit:]])) #/ jenom MESANT
            _f "${MESANT}"
        ;;
        *) case "${CORDANT}" in
            +([[:digit:]]))
                _f  "${CORDANT}"
            ;;
            *) return 1
            ;;
        esac
        ;;
    esac
    return 0
}

# ### <span id="infoitem">infoitem()</span> ([top](#FUNCTIONS))
# Na vstupu je stream a v√Ωstupem je sada hodnot
infoitem() {
    ${EXIFTOOL} -s3 -FileType -ImageSize -Compression -AnimationFrames -FrameCount -
}

# ### <span id="convertovergimp">convertovergimp()</span> ([top](#FUNCTIONS))
# Bitmapov√Ω editor gimp lze rovnƒõ≈æ vyu≈æ√≠vat ke konverzi bitmapov√Ωch soubor≈Ø
#
# $1 - v√Ωstupn√≠ form√°t
convertovergimp() {
    # Start gimp with python-fu batch-interpreter
    gimp -i --batch-interpreter=python-fu-eval -b - << EOF
import gimpfu

def convert(filename):
    img = pdb.gimp_file_load(filename, filename)
    new_name = filename.rsplit(".",1)[0] + ".$1"
    layer = pdb.gimp_image_merge_visible_layers(img, 1)

    pdb.gimp_file_save(img, layer, new_name, new_name)
    pdb.gimp_image_delete(img)

convert('${2}')

pdb.gimp_quit(1)
EOF
}

# ### <span id="identifypage">identifypage()</span> ([top](#FUNCTIONS))
# Function return DjVu page actual ORDER in DjVu bundle
# $1 type (order|name)
# $2 DjVu file
# $3 Page identificator (order or name)
identifypage() {
    log goto "identifypage() ${1} page ${3} from ${2}"
    case "${3}" in
        +([[:digit:]])) #/ Identifikace podle ƒç√≠sla str√°nky
            local PAGE=$(${DJVUSED} "${2}" -e dump | grep "\[P${3}\]")
        ;;
        *) #/ Identifikace podle n√°zvu str√°nky
            local PAGE=$(${DJVUSED} "${2}" -e dump | grep "\{${3}\}")
        ;;
    esac
    [ ! -n "${PAGE}" ] && \
        log err "identifypage() Invalid identificator ${1} for ${2}" && \
        return 1
    case "${1}" in
        name) local TEMPORAR="${PAGE##*\{}"
            echo "${TEMPORAR%%\}*}"
        ;;
        order) local TEMPORAR="${PAGE##*\[P}"
            echo "${TEMPORAR%%\]*}"
        ;;
        *) log err "identifypage() Invalid type ‚Äì> ${1}"
            return 1
        ;;
    esac
    return 0
}

# ### <span id="lastpage">lastpage()</span> ([top](#FUNCTIONS))
# Function return count of all pages in DjVu bundle
# $1 DjVu file
lastpage() {
    log goto "lastpage() ‚Äì> ${1}"
    local SOURCE=$(${REALPATH} -m -P "${1}")
    local FILE="${SOURCE##*/}"
    [ "$(mimefile ${SOURCE})" == "djvu" ] || return 1
    local OUTPUT=$(${DJVUSED} "${SOURCE}" -e n)
    log info "lastpage() Count of all pages in ${FILE} ‚Äì> ${OUTPUT}"
    echo -n "${OUTPUT}"
    return 0
}

# ### <span id="deletepage">deletepage()</span> ([top](#FUNCTIONS))
# Odstra≈àuje z DjVu svazku str√°nky, pokud jejich celkov√Ω poƒçet je > 1
#
# $1 - jm√©no DjVu svazku se kter√Ωm se pracuje
# $2 - ƒç√≠slo, nebo n√°zev strany co se m√° odstranit
#
# Pokud je str√°nka √∫spƒõ≈°nƒõ odstranƒõna, vrac√≠ __0__
# Pokud se str√°nka ve svazku nevyskytuje, vrac√≠ __1__
# Pokud nen√≠ DjVu soubor typu bundle, vrac√≠ __2__
deletepage() {
    log goto "deletepage() From ${1} ‚Äì> ${2}"
    [ -z ${2} ] && return 1
    local SUMPAGE=$(${DJVUSED} "${1}" -e 'n')
    [ $? -eq 1 ] && return 1
    case $SUMPAGE in
        1) echo "Single page DjVu file ‚Äì> ${FILE}" >> /dev/stderr
            return 0
            ;;
        *) local PAGE=$(identifypage order "${1}" "${2}")
            if [ ! -z "${PAGE}" ] ; then
                ${DJVM} -d "${1}" "${PAGE}"
                echo "Page ${2} from ${1} was removed" >> /dev/stderr
            else
                return 1
            fi
            ;;
    esac
    return $?
}

# ### <span id="djvurotate">djvurotate()</span> ([top](#FUNCTIONS))
# $1 - soubor se kter√Ωm se pracuje
# $2 - ƒç√≠slo, nebo n√°zev strany kter√° se m√° rotovat
# $3 - hodnota rotace
#	echo "$*" >> /dev/stderr
function djvurotate {
    log goto "$1 ‚Äì> $2"
    local INFO="""
Uvedenou hodnotu rotace nelze akceptovat. Rotaci lze nastavit buƒè 
absolutnƒõ, a nebo relativnƒõ (pootoƒçit o 90¬∞). AKceptovan√© hodnoty:

      0 - v√Ωchoz√≠ pozice
      1 - natoƒçen√≠ vpravo
      2 - otoƒçen√≠  vzh≈Øru nohama
      3 - natoƒçen√≠ vlevo
   left - rotace smƒõrem doleva
  right - rotace smƒõrem doprava).
    180 - p≈ôetoƒçen√≠ o 180¬∞

Ka≈æd√° jin√° hodnota parametru je ignorov√°na."""

    local ROTATE="${2%%+([[:blank:]])*}"
    case "${ROTATE}" in
        0|1|2|3|180|left|right)
            local TEMPORAR="${2#${ROTATE}+([[:blank:]])}"
            mapfile -t ARRAY <<< $($0 "${1}" info list)
            case "${ARRAY:0:1}" in
                0) mapfile -t LISTPAGES <<< $(printf "%s\n" "${ARRAY[@]}")
                ;;
                *) LISTPAGES="0 none"
                    mapfile -O 1 -t LISTPAGES <<< $(printf "%s\n" "${ARRAY[@]}")
                ;;
            esac
            RANGE=$(isrange "${TEMPORAR}")
            if [ -n "${RANGE}" ] ; then
                local PAGES=($(range "${RANGE}"))
            else
                case "${TEMPORAR//+([[:blank:]])/}" in
                    '') echo "${INFO}" >> /dev/stderr
                        return 1
                    ;;
                    *) # seznam str√°nek oddƒõlen√Ωch ƒç√°rkou
                        local IFS_BAK=$IFS
                        local IFS=$','
                        local SEZNAM=($TEMPORAR)
                        local IFS=$IFS_BAK
                        for i in "${LISTPAGES[@]}" ; do
                            if [[ "${SEZNAM[@]}" =~ "${i##+([[:digit:]])+([[:blank:]])}" ]] ; then
                                local TEMP="$TEMP${i%% *} "
                            fi
                            x=$((x + 1))
                        done
                        local PAGES=($TEMP)
                    ;;
                esac
            fi
            echo "ROTATE ${ROTATE} PAGES ${#PAGES[@]} ${PAGES[@]}" >> /dev/stderr
            for i in ${PAGES[@]} ; do
                local PAGENAME="${LISTPAGES[$i]##+([[:digit:]])+([[:blank:]])}"
                local PAGEORDER="${LISTPAGES[$i]%% *}"
                case "${PAGEORDER}" in
                    0) case "${PAGENAME}" in
                            none)
                            ;;
                            *) # glob√°ln√≠ rotace
                                case "${ROTATE}" in
                                    0|1|2|3)  ${DJVUSED} -e "set-rotation ${ROTATE}; save" "${1}"
                                    ;;
                                    left) ${DJVUSED} -e "set-rotation +1; save" "${1}"
                                    ;;
                                    right) ${DJVUSED} -e "set-rotation -1; save" "${1}"
                                    ;;
                                    180) ${DJVUSED} -e "set-rotation +2; save" "${1}"
                                    ;;
                                    *) echo "${INFO}" >> /dev/stderr
                                    ;;
                                esac
                            ;;
                        esac
                    ;;
                    '') #/ nic
                    ;;
                    *) #/ str√°nky dle rozsahu ƒçi seznamu
                        case "${ROTATE}" in
                            0|1|2|3)  ${DJVUSED} -e "select '${PAGEORDER}'; set-rotation ${ROTATE}; save" "${1}"
                            ;;
                            left) ${DJVUSED} -e "select '${PAGEORDER}'; set-rotation +1; save" "${1}"
                            ;;
                            right) ${DJVUSED} -e "select '${PAGEORDER}'; set-rotation -1; save" "${1}"
                            ;;
                            180) ${DJVUSED} -e "select '${PAGEORDER}'; set-rotation +2; save" "${1}"
                            ;;
                            *) echo "${INFO}" >> /dev/stderr
                            ;;
                        esac
                    ;;
                esac
            done
        ;;
        *) printf "%s - is not valid rotate VALUE" "${ROTATE}" >> /dev/stderr
            return 1
        ;;
    esac
}

# ### <span id="range">range()</span> ([top](#FUNCTIONS))
# Funkce, kter√° zpracuje p≈ôedan√Ω ≈ôetƒõzec do sekvence ƒç√≠sel
# 1,2,3-9,10-20
# Pokud zpracov√°n√≠ ≈ôetƒõzce probƒõhne v po≈ô√°dku je n√°vratov√Ω k√≥d __0__,
# v opaƒçn√©m p≈ô√≠padƒõ __1__.
range() {
    log goto "range() ‚Äì> ${@}"
    case "${1:0:1}" in
        [[:digit:]]) local INPUTARRAY=( ${1//,/ } )
            for i in ${INPUTARRAY[@]} ; do
                if [[ "$i" =~ "-" ]] ; then
                    seq ${i//-/ }
                else
                    seq ${i} ${i}
                fi
            done | sort -nu
            return 0
        ;;
        *) printf "range: FAIL - range of pages must be set only from order numbers, commas and hyphens.\n" >> /dev/stderr
            return 1
        ;;
    esac
}

# ###  <span id="signature">signature()</span> ([top](#FUNCTIONS))
# Funkce nastav√≠ do str√°nky tyto meta atributy
# Producer
# ModDate
# HostComputer
signature() {
    local RANGE=$(isrange "${2}")
    if [ ! -n "${RANGE}" ] ; then
        # / m≈Ø≈æe b√Ωt seznam str√°nek ZA KTER√ùM nen√≠ nic
        # oddƒõlit PATTERN od seznamu
        case "${2//+([[:blank:]])/}" in
            '') # jenom p≈ô√≠kaz
                echo "Nebylo nic p≈ôed√°no ${2}" >> /dev/stderr
                return 1
                #local PAGES=($(range "0-${#LISTPAGES[@]}"))
            ;;
            *) # seznam str√°nek oddƒõlen√Ωch ƒç√°rkou

                mapfile -t ARRAY <<< $($0 "${1}" info list)
                case "${ARRAY:0:1}" in
                    0) mapfile -t LISTPAGES <<< $(printf "%s\n" "${ARRAY[@]}")
                    ;;
                    *) LISTPAGES="0 none"
                        mapfile -O 1 -t LISTPAGES <<< $(printf "%s\n" "${ARRAY[@]}")
                    ;;
                esac

                local IFS_BAK=$IFS
                local IFS=$','
                local SEZNAM=($2)
                local IFS=$IFS_BAK
                for i in "${LISTPAGES[@]}" ; do
                    if [[ "${SEZNAM[@]}" =~ "${i##+([[:digit:]])+([[:blank:]])}" ]] ; then
                        echo "Str√°nka ${i}" >> /dev/stderr
                        local TEMP="$TEMP${i%% *} "
                    fi
                    x=$((x + 1))
                done
                local PAGES=($TEMP)
                local STRING="${2##*.djvu+([[:blank:]])}"
            ;;
        esac
    else
        local STRING="${2#*${RANGE}+([[:blank:]])}"
        [ ! -n "${STRING}" ] && return 1
        local PAGES=($(range "${RANGE}"))
    fi
    case "${STRING:0:1}" in
        [a-Z])
        ;;
        *) echo "Neplatn√Ω PATTERN ‚Äì> ${STRING}" >> /dev/stderr
            return 1
        ;;
    esac
    for i in ${PAGES[@]} ; do
        $0 "${1}" set "${i}" key Producer "${STRING}, djvutool 0.1 alpha [http://www.thewoodcraft.org/djvutool]"
        $0 "${1}" set "${1}" key ModDate "$(date -u +%FT%T%:z)"
        $0 "${1}" set "${1}" key HostComputer "$(hostname)"
    done
    return $?
}

# ### <span id="setmeta">setmeta()</span> ([top](#FUNCTIONS))
# V souboru $1 naj√≠t $2, pokud se vyskytuje, tak ho nahradit za $3,
# pokud nevyskytuje, p≈ôidat $3 na konec
setmeta() {
    mapfile -d\: -t -c1 ITEM <<< $(grep -n "${2}" "${1}")
    case "${ITEM[0]}" in
        +([[:digit:]])) #/ vyskytuje se
            case "${3}" in
                '') log info "Delete ‚Äì> $2"
                    ed "${1}" 2>/dev/null <<-EOF
${ITEM[0]}
d
w
q
EOF
                ;;
                *) #/ nahrazuji
                    log info "Replace $2 ‚Äì> $3"
                    log info "${ITEM[0]}c"
                    ed "${1}" 2>/dev/null <<-EOF
${ITEM[0]}c
${3}
.
w
q
EOF
                ;;
            esac
        ;;
        *) #/ nevyskytuje se
            case "${3}" in
                '')
                ;;
                *) #/ p≈ôid√°m na konec
                    echo "${3}" >> "${1}"
                    log info "Add $3 to end"
                ;;
            esac
        ;;
    esac
    return $?
}

# ### <span id="djvuinfo">djvuinfo()</span> ([top](#FUNCTIONS))
# Prvn√≠m parametrem __$1__ je cesta k DjVu souboru a druh√Ωm $2 po≈æadovan√°
# informace:
#
# * list
# * exif
# * meta
# * pages
# * grep
#
# Pokud nen√≠ p≈ôedan√° platn√° hodnota , vrac√≠ funkce pouze informaci o typu
# souboru, ev. doplnƒõnou o poƒçet stran ƒçi vrstev
djvuinfo() {
    log goto "$1 ‚Äì> $2"
    case ${2} in
        '') local INFO=($(cat "${1}"|infoitem))
            isbundle "${1}"
            case $? in
                0) local SUMPAGES=$(${DJVM} -l "${1}" | grep PAGE\ # | wc -l)
                 local TEMP=$(${DJVM} -l "${1}" | grep SHARED_ANNO)
                ;;
                2) local SUMPAGES=1
                ;;
                *) local SUMPAGES=error
                ;;
            esac
            if [ -n "${TEMP}" ] ; then
                echo "${INFO[@]} ${SUMPAGES} shared_anno"
            else
                echo "${INFO[@]} ${SUMPAGES}"
            fi
        ;;
        pages) isbundle "${1}"
            case $? in
                0) ${DJVM} -l "${1}" | grep PAGE\ # | wc -l
                ;;
                2) echo 1
                ;;
                *) echo error
                ;;
            esac
        ;;
        list) isbundle "${1}"
            case $? in
                0) ${DJVM} -l "${1}" |\
                    sed -E 's/SHARED_ANNO/#0/ ; s/[[:alnum:][:blank:]]+#// ; /^Size/d ; /^\-/d' | sort -n
                ;;
                2) ${DJVUSED} "${1}" -e 'dump' | grep '{' | grep -v INCL |\
                    awk -F'}' '{print $2,$1}' | \
                    sed -E 's/][[:blank:]]+[[:alnum:]:]+[[:blank:]]+\[[[:digit:]]+\][[:blank:]]+\{/ / ; s/ \[// ; s/^P// ; s/^S/0/' | sort -n
                ;;
                *) echo error
                ;;
            esac
        ;;
        exif) ${EXIFTOOL} "${1}"
        ;;
        dsed*) log dsed "djvuinfo() ‚Äì> ${2#dsed+([[:blank:]])}"
            ${DJVUSED} "${1}" -e "${2#dsed+([[:blank:]])}"
        ;;
        grep*) log grep "grep ‚Äì> ${2#grep+([[:blank:]])}"
            $0 "${1}" info list | \
            while read line ; do
                case "${line%% *}" in
                    O)
                    ;;
                    '') return 1
                    ;;
                    *) local PAGE="${line#* }"
                        local ORDER="${line%% *}"
                        local TEMPORAR=$(${DJVUTXT} "${1}" -page=${ORDER} | ${2} 2>1)
                        if [ -n "${TEMPORAR}" ] ; then
                            echo "# ${PAGE} #[P${ORDER}]"
                            printf "%s\n" "${TEMPORAR}"
                        fi
                    ;;
                esac
            done
        ;;
        *) return 1
        ;;
    esac
    return $?
}

# ### <span id="help">help()</span> ([top](#FUNCTIONS))
#
help() {
    log info "$1"
	case "$1" in
        actions) echo """Implementovan√© akce: """
        ;;
		algorithm) echo """

Binarizaƒçn√≠ algoritmy ovli≈àuj√≠ vygenerov√°n√≠ optim√°ln√≠ ƒçernob√≠l√© masky
Utilita DiDjVu podporuje tyto algoritmy:

abutaleb
bernsen
  - region-size=N (1 .. 50, default: 11)
  - contrast-limit=N (0 .. 255, default: 80)
  - doubt-to-black
brink
djvu (default) (vhodn√Ω pro ƒçernob√≠l√© obr√°zky)
  - smoothness=X (0.0 .. 1.0, default: 0.2)
  - max-block-size=N (default: 512)
  - min-block-size=N (default: 64)
  - block-factor=N (1 .. 8, default: 2)
global
  - threshold=N
niblack
  - region-size=N (default: 15)
  - sensitivity=X (default: -0.2)
  - lower-bound=N (0 .. 255, default: 20)
  - upper-bound=N (0 .. 255, default: 150)
otsu (vhodn√Ω pro ƒçernob√≠l√© obr√°zky, lep≈°√≠ komprese ne≈æ u v√Ωchoz√≠ho djvu)
sauvola
  - region-size=N (default: 15)
  - sensitivity=X (default: 0.5)
  - dynamic-range=N (1 .. 255, default: 128)
  - lower-bound=N (0 .. 255, default: 20)
  - upper-bound=N (0 .. 255, default: 150)
shading-subtraction
  - k=N (default: 7)
  - threshold=N
tsai
white-rohrer
  - x-lookahead=N (default: 8)
  - y-lookahead=N (default: 1)
  - bias-mode=N (default: 0)
  - bias-factor=N (default: 100)
  - f-factor=N (default: 100)
  - g-factor=N (default: 100)

V√Ωchoz√≠ nastaven√≠ algoritm≈Ø lze upravit 
		"""
		;;
        bitmap) echo """
        """
        ;;
		bitmap-export) echo """
U bitmapov√Ωch soubor≈Ø, kter√© maj√≠ podporu pro v√≠ce str√°nek (ƒçi vrstev)
lze vyu≈æ√≠t export k jejich extrakci a p≈ô√≠padnƒõ i transformaci na jin√Ω
rozmƒõr ƒçi konverzi do jin√©ho form√°tu ‚Äì vƒçetnƒõ DjVu. Viz p≈ô√≠klad:

    ${APP} soubor.jpg export jpg 1 30%

Vygeneruje JPEG obr√°zek s n√°zvem soubor_30%.jpg jeho≈æ obsahem bude p≈Øvodn√≠
obr√°zek ze souboru soubor.jpg, zmen≈°en√Ω na 30% p≈Øvodn√≠ velikosti.

U kontejner≈Ø typu zip ƒçi tar, kter√© mohou obsahovat obr√°zky v r≈Øzn√Ωch form√°tech,
lze prov√©st export pouze s uveden√≠m rozsahu. C√≠lov√© soubory se pak budou
jmenovat stejnƒõ, jako ty v arch√≠vu:

    ${APP} soubor.zip export orig 2-7

U bitmapov√Ωch form√°t≈Ø s podporou v√≠ce str√°nek, kter√© maj√≠ v sobƒõ ulo≈æen
tak√© n√°zev vrstvy ƒçi str√°nky, bude m√≠t vyexportovan√Ω soubor stejn√© jm√©no
jako byl n√°zev p≈ô√≠slu≈°n√© vrstvy ƒçi str√°nky.

    ${APP} soubor.xcf export 2-7

V tomto p≈ô√≠padƒõ tedy bude v√Ωsledkem s√©rie ≈°esti soubor≈Ø ve form√°tu .xcf,
vytvo≈ôen√Ωch z druh√© a≈æ sedm√© vrstvy souboru soubor.xcf pojmenovan√Ωch podle
jejich n√°zv≈Ø.

Pokud se maj√≠ soubory jmenovat podle jin√©ho vzoru, mus√≠ b√Ωt uveden v√Ωchoz√≠
vzorek. Viz p≈ô√≠klad:

    ${APP} soubor.xcf export 2-7 soubor

V takov√©m p≈ô√≠padƒõ se budou vyexportovan√© soubory jmenovat soubor_00002.xcf
a≈æ soubor_00007.xcf

Akci export lze vyu≈æ√≠t i ke konverzi do jin√©ho form√°tu:

    ${APP} soubor.pdf export 1 jpg

V p≈ô√≠padƒõ PDF soubor≈Ø, kter√© mohou obsahovat mix textu a obr√°zk≈Ø bude v tomto
p≈ô√≠padƒõ v√Ωstupem jako bitmapov√Ω obr√°zek cel√° str√°nka. Pokud v≈°ak chcete,
aby v√Ωstupem byly pouze vlo≈æen√© obr√°zky (nebo text), je t≈ôeba jako v√Ωstupn√≠
form√°t uv√©st co chcete:

    ${APP} soubor.pdf export 1 images

Nen√≠-li ≈ôeƒçeno jinak, jsou v√Ωsledn√© soubory v p≈Øvodn√≠m rozli≈°en√≠. Ov≈°em
p≈ôi konverzi lze velikost c√≠lov√©ho obr√°zku rovnou p≈ôe≈°k√°lovat:

    ${APP} soubor.pdf export 1 jpg 0.5 example

T√≠mto zp≈Øsobem zvol√≠te, ≈æe c√≠lov√° velikost bude obr√°zku bude 50% p≈Øvodn√≠
velikosti.

Velikost v√Ωsledn√©ho souboru tak√© m≈Ø≈æete uv√©st uveden√≠m rozmƒõru c√≠lov√©ho
obr√°zku. V takov√©m p≈ô√≠padƒõ ale mus√≠te pou≈æ√≠t i jeden z n√°sleduj√≠c√≠ch
parametr≈Ø, kter√Ωm urƒç√≠te jak se m√° p≈ôi ≈°k√°lov√°n√≠ postupovat:

-xysize p≈ôe≈°k√°luje obr√°zek t√≠m zp≈Øsebem, ≈æe pou≈æije krat≈°√≠ rozmƒõr a ten
        co bude p≈ôesahovat o≈ô√≠zne tak aby v√Ωsledek odpov√≠dal velikosti
        vymezen√©ho prostoru a z√°rove≈à z≈Østal zachov√°n pomƒõr stran v√Ωchoz√≠ho
        obr√°zku
-xyfit  rozt√°hne obr√°zek tak aby vyplnil cel√Ω uveden√Ω rozmƒõr, pomƒõr stran
        tedy nebude zachov√°n
-xyfill p≈ôe≈°k√°luje obr√°zek podle vƒõt≈°√≠ho rozmƒõru, tak aby se ve≈°el do
        vymezen√©ho prostoru cel√Ω a pomƒõr stran p≈ôi tom z≈Østal zachov√°n.

Viz p≈ô√≠klad:

    ${APP} soubor.pdf export 1 jpg 250x300 -xysize example

P≈ôi ≈°k√°lov√°n√≠ se automaticky pou≈æije volba -nomix, m≈Ø≈æete ji ale zamƒõnit
za konkr√©tn√≠ ≈°k√°lovac√≠ filtr. Viz p≈ô√≠klad:

    ${APP} soubor.pdf export 1 jpg 250x300 -filter=box example
"""
        echo "Seznam pou≈æiteln√Ωch ≈°k√°lovac√≠ch filtr≈Ø:"
        printf "\t%s\n" ${FILTERS[@]}
echo """
Ve v≈°ech uveden√Ωch p≈ô√≠kladech jsou v√Ωsledn√© soubory ulo≈æeny do adres√°≈ôe,
ve kter√©m se ${APP} spou≈°t√≠. Pokud se maj√≠ ulo≈æit jinam, je t≈ôeba uv√©st
i c√≠lovou  cestu:

    djvutool soubor.pdf export 1 jpg 0.33 example/

V tomto p≈ô√≠padƒõ se vyexportovan√© str√°nky nasypou do podadres√°≈ôe example.
Pokud neexistuje, tak se vytvo≈ô√≠. Pokud se maj√≠ soubory p≈ôi exportu tak√©
p≈ôejmenovat, je t≈ôeba za lom√≠tkem uv√©st tak√© p≈ô√≠slu≈°n√Ω vzor:

    djvutool soubor.pdf export 1 jpg 0.33 example/example

V tomto p≈ô√≠padƒõ by se tedy v√Ωsledn√Ω soubor jmenoval example_30%_00001.jpg

Pokud m√° b√Ωt ƒç√≠slov√°n√≠ jin√© ne≈æ v√Ωchoz√≠ pƒõtim√≠stn√©, vypad√° vzorek takto:

    djvutool soubor.pdf export 1 jpg 30% example/example_XX
"""
		;;
        bitmap-info) echo """
  ACTION [1minfo[0m

  If isn't subkey, return basic informations about file: Format, dimensions
  of page and for file in multipage format summary count of pages.

  [1m${0##*/}[0m info <file> [ pages | list | meta <num> ]

         num  - order of page (or layer) in file

  SUBKEYS:
         [3mlist[23m - (only multipage file) return list names, or numbers of
                pages from multipage file, or from container 
         [3mmeta[23m - return exif info about page from container or file
        [3mpages[23m - return only sumary count of pages as number

[3mNotice:[23m
  * For [3m'meta'[23m [2minfo[22m different from [2mexport[22m in that output is purified from syntax chars, whose is required for [2mimport[22m.
  * When is passed subkey [3m'exif'[23m with an identificator of page, be export a page into temporary dir and view info only about this page.
  * Subkey [3m'pages'[23m with an identificator of page return only item for this.
        """
        ;;
		bundle) echo """N√°povƒõda pro volbu typu svazku.. ToDo
		"""
		;;
		dpi) echo """
[1mOption:[0m --dpi  <[2mƒç√≠slo[22m> Hodnota DPI, kter√° se m√° pou≈æ√≠t p≈ôi zpracov√°n√≠ obr√°zku.
                               p≈ôi konverzi. Optim√°ln√≠ je zjistit hodnotu p≈ô√≠mo ze vstupn√≠ho
                               obr√°zku. P≈ôed nastaven√≠m t√©to hodnoty pro fin√°ln√≠ konverzi. lze vyzkou≈°et
                               optim√°ln√≠ nastaven√≠ na nƒõkter√©m ze soubor≈Ø s vyu≈æit√≠m parametru
                               --test

  Rozsah ƒç√≠seln√© hodnoty je od 72 do 6000 dpi. V√Ωchoz√≠ hodnota 300 se pou≈æije 
  v p≈ô√≠padƒõ, ≈æe parametr --dpi nen√≠ v≈Øbec uveden.
  Vliv dpi na zpracov√°n√≠ obrazu..
"""
		;;
		dsed) echo """Option [1m-d[0m ([1m--dsed[0m)

  Extrakce skryt√© textov√© vrstvy DjVu str√°nky ve form√°tu pro djvused.
  Parametrem lze zvolit, co se m√° p≈ôi akci [2mexport[22m ulo≈æit.

  [1m${0##*/}[0m ... {-d|--dsed} [yes|no|all|txt|ant] ...
  
         yes - stejn√Ω efekt jako volba all
         no  - textov√° vrstva se neexportuje (default)
         all - exportuje se cel√Ω obsah skryt√© textov√© vrstvy
         txt - exportuje se pouze obsah str√°nky
         ant - exportuj√≠ se meta atributy str√°nky, hyperlinky, atp.

[4mPozn√°mka:[24m
  * Pokud za volbou nen√≠ uveden ≈æ√°dn√Ω dal≈°√≠ parametr, tak se automaticky
    p≈ôedpokl√°d√° - yes.
  * V√Ωchoz√≠ parametr - no - lze implicitnƒõ zmƒõnit nastaven√≠m promƒõnn√©
    DSED do souboru v adres√°≈ôi ${HOME}/.config/${NAME}/
  * Exportovan√° data se ukl√°daj√≠ do soubor≈Ø s p≈ô√≠ponou [3m.dsed[23m.
"""
		;;
    exif) echo """Nastaven√≠ exif tagu Creator:

    [1m${0##*/}[0m soubor.djvu set 1,3,7-12 key Creator Thomas Jefferson

P≈ôehled nejpou≈æ√≠vanƒõj≈°√≠ch EXIF tag≈Ø:
        [3mTitle[23m - N√°zev dokumentu
      [3mCreator[23m - Osoba, kter√° zpracovala sken do DjVu str√°nky
 [3mCreationDate[23m - Datum po≈ô√≠zen√≠ skenu
     [3mKeywords[23m - Kl√≠ƒçov√° slova pro indexaci DjVu souboru
       [3mannote[23m - Pozn√°mka o p≈Øvodu dokumentu & etc.
  [3mDescription[23m - Popis obsahu dokumentu
       [3mAuthor[23m - Autor dokumentu
     [3mNickname[23m - P≈ôezd√≠vka
  [3mContactInfo[23m - Kontaktn√≠ informace na zpracovatele dokumentu
     [3mProducer[23m - Software kter√Ωm byl sken zpracov√°n do DjVu
  [3mCreatorTool[23m - Za≈ô√≠zen√≠ na kter√©m byl sken ƒçi sn√≠mek po≈ô√≠zen
      [3mModDate[23m - ƒåas zpracov√°n√≠ do DjVu
   [3mModifyDate[23m - ƒåas zpracov√°n√≠ do DjVu
 [3mMetadataDate[23m - ƒåas, kdy byla naposled aktualizov√°na metadata
                              na str√°nce
    DocumentName
ImageDescription
        Software
        DateTime
          Artist
       Copyright
    ImageHistory
       MakerNote
     UserComment
"""
    ;;
		existed) echo """
  Soubor $2 existuje. Pokud se m√° p≈ôepsat, mus√≠ b√Ωt
  uveden parametr -f (--force)
"""
		;;
		exporttometa) echo """volba [1m-m[0m ([1m--meta[0m)

  Extrakce DjVu str√°nky ze svazku

  [1m${0##*/}[0m ... {-x|--xml} [yes|no] ...
  
  Prost≈ôednictv√≠m t√©to volby lze zvolit zda se m√°, nebo nem√° p≈ôi akci
  [3mexport[23m z DjVu svazku exportovat i cel√° DjVu str√°nka. Pokud za volbou
  nen√°sleduje parametr, pak se automaticky p≈ôedpokl√°d√° ≈æe ano (yes).
  V√Ωchoz√≠ nastaven√≠ (no), lze implicitnƒõ zmƒõnit prost≈ôednictv√≠m
  u≈æivatelsk√©ho konfiguraƒçn√≠ho souboru um√≠stƒõn√©ho v v adres√°≈ôi:

    ${HOME}/.config/${NAME}/
"""
		;;
		exporttothumb) echo """volba [1m-t[0m ([1m--thumb[0m)

  Extrakce DjVu str√°nky ze svazku

  [1m${0##*/}[0m ... {-t|--thumb} [yes|no] ...
  
  Prost≈ôednictv√≠m t√©to volby lze zvolit zda se m√°, nebo nem√° p≈ôi akci
  [3mexport[23m z DjVu svazku exportovat i cel√° DjVu str√°nka. Pokud za volbou
  nen√°sleduje parametr, pak se automaticky p≈ôedpokl√°d√° ≈æe ano (yes).
  V√Ωchoz√≠ nastaven√≠ (no), lze implicitnƒõ zmƒõnit prost≈ôednictv√≠m
  u≈æivatelsk√©ho konfiguraƒçn√≠ho souboru um√≠stƒõn√©ho v v adres√°≈ôi:

    ${HOME}/.config/${NAME}/
"""
		;;
		force) echo """volba [1m-f[0m ([1m--force[0m)

  Nastaven√≠m t√©to volby si lze vynutit v√Ωchoz√≠ chov√°n√≠ k soubor≈Øm p≈ôi
  akci [2mexport[22m. Nen√≠-li uvedena, tak se skript p≈ôed ka≈æd√Ωm
  p≈ôeps√°n√≠m ji≈æ existuj√≠c√≠ho souboru zept√°, zda-li m√°, nebo nem√°
  pokraƒçovat.

  [1m${0##*/}[0m ... {-f|--force} [yes|no|skip] ...
  
         yes  - v≈°echny soubory se budou bez kec≈Ø p≈ôepisovat.
         no   - skript se p≈ôed p≈ôeps√°n√≠m souboru bude dotazovat, zda-li
                m√° soubor p≈ôepsat.
         skip - pokud bude c√≠lov√Ω soubor existovat, tak se akce p≈ôeskoƒç√≠.

[4mPozn√°mka:[24m
  * Pokud za volbou nen√≠ uveden ≈æ√°dn√Ω dal≈°√≠ parametr, tak se automaticky
    p≈ôedpokl√°d√° - skip.
  * V√Ωchoz√≠ parametr hodnotu parametru  (skip) - lze implicitnƒõ zmƒõnit
    nastaven√≠m promƒõnn√© FORCE v u≈æivatelsk√©m konfiguraƒçn√≠m souboru.
"""
		;;
		image) echo """volba [1m-i[0m ([1m--img[0m)

  [4mExtrakce obrazov√© vrstvy[24m DjVu str√°nky do bitmapov√©ho souboru

  [1m${0##*/}[0m ... {-i|--img} [yes|no|<layer>] ...

  Je-li parametrem volby [3myes[23m, tak se bude p≈ôi akci [2mexport[22m generovat z DjVu
  str√°nky plnobarevn√Ω bitmapov√Ω obr√°zek ve form√°tu PNG.
  V ostatn√≠ch p≈ô√≠padech bude ve form√°tu PNM.

      [1m${0##*/}[0m --img background svazek.djvu export stranka.djvu
 
Pou≈æiteln√© parametry:
                 color - plnobarevn√° str√°nka
                 black - ƒçernob√≠l√° kresba
            foreground - vrstva pop≈ôed√≠
            background - vrstva pozad√≠
                  mask - maska
  Je-li m√≠sto [3m'yes'[23m uvedeno [3m'background'[23m, bude p≈ôi exportu str√°nky
  strana.djvu ulo≈æen obr√°zek pozad√≠ pod jm√©nem strana.background.pnm
  V√Ωchoz√≠ nastaven√≠ lze implicitnƒõ zmƒõnit nastaven√≠m promƒõnn√© IMGPAGE
"""
		;;
		indirect) echo"""
[1mVolba[0m
         --indirect Volba, kterou lze zmƒõnit v√Ωchoz√≠ typ v√≠cestr√°nkov√©ho 
                    DjVu svazku (bundeled)

  Volbu je t≈ôeba aplikovat pokud chcete rozbalit stv√°vaj√≠c√≠ DjVu svazek 
  do podoby voln√©ho svazku, nebo pokud chcete p≈ôi konverzi bitmapov√Ωch
  soubor≈Ø rovnou sestavit DjVu svazek jako voln√Ω

  V√Ωhodou voln√©ho svazku je, ≈æe lze dodateƒçnƒõ upravovat jednotliv√© str√°nky
  jako samostatn√© DjVu soubory, ani≈æ by je bylo nutn√© exportovat.

  Pro finalizaci DjVu svazku je pak lep≈°√≠ svazek p≈ôekonvertovat na typ
  bundled, kdy je v≈°e zabaleno v jednom souboru
"""
		;;
        '') help keywords && help options
        ;;
        keywords) echo """
 DJVUTOOL - n√°stroj pro pr√°ci s obr√°zky a DjVu soubory

       [1m${0##*/}[0m [volby] {AKCE} [SOUBOR] ‚Ä¶
  resp.
       [1m${0##*/}[0m [volby] [SOUBOR] {AKCE} ‚Ä¶

Pro podrobnƒõj≈°√≠ informace o volbƒõ, akci ƒçi atributu, m≈Ø≈æete v≈ædy pou≈æ√≠t volbu [2m-h[22m
Viz p≈ô√≠klad, demonstruj√≠c√≠ v√Ωpis n√°povƒõdy k volbƒõ -v (verbose):

   [1m${0##*/}[0m -v -h

AKCE
    export - export a konverze bitmapov√Ωch soubor≈Ø, jejich vrstev ƒçi str√°nek
             do jin√Ωch form√°t≈Ø, vƒçetnƒõ DjVu. V p≈ô√≠padƒõ DjVu soubor≈Ø lze
             vyexportovat buƒè obrazovou vrstvu, ve formƒõ bitmapov√©ho obr√°zku,
             nebo obsah textov√©, ƒçi metadatov√© vrstvy.
      info - zji≈°tuje informace o souboru ƒçi str√°nce
      view - zobrazuje obrazov√Ω soubor ƒçi nƒõkterou z jeho str√°nek.

AKCE specifick√© pro pr√°ci s DjVu soubory:
      edit - editace textov√© vrstvy DjVu souboru
    delete - odstranƒõn√≠ str√°nky z DjVu svazku
fore, back - p≈ôesuny a import str√°nek v r√°mci DjVu svazku
    rotate - zmƒõna rotace str√°nky v DjVu souboru
    import - import do textov√© vrstvy DjVu svazku (obsah, metadata, text)
?      ocr - aplikace OCR
? indirect,bundle - mƒõn√≠ typ DjVu svazku
    rename - p≈ôejmenov√°n√≠ str√°nek v DjVu svazku dle vzorku
       set - jednor√°zov√© nastaven√≠ meta atributu
     unset - zru≈°en√≠ meta atributu
?     sign - vlo≈æen√≠ informace o posledn√≠ zmƒõnƒõ str√°nky

AKCE kter√© nevy≈æaduj√≠ ≈æ√°dn√Ω soubor:
    coords - p≈ôepoƒç√≠t√°v√° koordin√°ty .dsed soubor≈Ø
      help - vypisuje n√°povƒõdu
"""
		;;
    keywords-delete) echo """
  ACTION: [1mdelete[0m

  [1m${0##*/}[0m [volby] <svazek> delete RANGE

  Odstra≈àuje str√°nky z DjVu svazku. Pozor, akce je [4mnevratn√°[24m!
"""
        help range
        echo """[4mPozn√°mky:[24m
  * P≈ôi odstra≈àov√°n√≠ str√°nek je uveden√Ω rozsah set≈ô√≠dƒõn tak, aby se str√°nky
    odstra≈àovaly postupnƒõ odzadu, tak aby se bƒõhem odstra≈àov√°n√≠ nemƒõnilo
    jejich po≈ôadov√© ƒç√≠slo.
  * K odstranƒõn√≠ str√°nky dojde pouze v p≈ô√≠padƒõ ≈æe DjVu soubor tvo≈ô√≠ v√≠c ne≈æ
    jedna str√°nka.
  * P≈ôi odstra≈àov√°n√≠ str√°nek je bezpeƒçnƒõj≈°√≠ pou≈æ√≠vat k identifikaci jm√©na
    str√°nek, nebo≈• pozice str√°nky se m≈Ø≈æe v pr≈Øbƒõhu zpracov√°n√≠ DjVu svazku
    mƒõnit, kde≈æto jm√©no z≈Øst√°v√° v≈ædy v r√°mci svazku jedineƒçn√©.
"""
    ;;
    delete-*) help keywords-delete
        ;;
    keywords-fore) echo """
  ACTION [1mfore[0m

  P≈ôesun str√°nky v r√°mci DjVu svazku o pozici vp≈ôed. V p≈ô√≠padƒõ, u≈æ je
  p≈ôesouvan√° str√°nka na prvn√≠ pozici, se nestane nic.
  P≈ôi p≈ôesunu vp≈ôed, lze rovnƒõ≈æ p≈ôesunout str√°nku skokem na pozici p≈ôed
  str√°nkou urƒçenou jej√≠ pozic√≠ v souboru, nebo jm√©nem.

  [1m${0##*/}[0m [volby] <svazek> fore {ORDER|PAGE} [ORDER|PAGE]

ORDER
    Po≈ôadov√© ƒç√≠slo str√°nky v DjVu svazku

PAGE
   Jm√©no str√°nky v DjVu svazku

  Je doporuƒçeno pou≈æ√≠t jako identifik√°tor jm√©na str√°nek, m√≠sto jejich 
  aktu√°ln√≠ pozice, prtot≈æe ta se v pr≈Øbƒõhu zpracov√°n√≠ DjVu svazku mƒõn√≠,
  kde≈æto jej√≠ jm√©no str√°nky je v≈ædy v r√°mci DjVu svazku jedineƒçn√©.
"""
    ;;
    keywords-back) echo """
  ACTION [1mback[0m

  P≈ôesun str√°nky v r√°mci DjVu svazku o pozici zpƒõt. V p≈ô√≠padƒõ, u≈æ je
  p≈ôesouvan√° str√°nka na posledn√≠ pozici, se nestane nic.
  P≈ôi p≈ôesunu zpƒõt, lze rovnƒõ≈æ p≈ôesunout str√°nku skokem na pozici za
  str√°nkou urƒçenou jej√≠ pozic√≠ v souboru, nebo jm√©nem.

  [1m${0##*/}[0m [volby] <svazek> back {ORDER|PAGE} [ORDER|PAGE]

ORDER
    Po≈ôadov√© ƒç√≠slo str√°nky v DjVu svazku

PAGE
   Jm√©no str√°nky v DjVu svazku

  Je doporuƒçeno pou≈æ√≠t jako identifik√°tor jm√©na str√°nek, m√≠sto jejich 
  aktu√°ln√≠ pozice, prtot≈æe ta se v pr≈Øbƒõhu zpracov√°n√≠ DjVu svazku mƒõn√≠,
  kde≈æto jej√≠ jm√©no str√°nky je v≈ædy v r√°mci DjVu svazku jedineƒçn√©.
"""
    ;;
		keywords-edit) echo """
  ACTION [1medit[0m

  Editace textov√Ω informac√≠ DjVu svazku - meta informace, bookmarks,outline

  [1m${0##*/}[0m <DjVu> edit outline

  [1m${0##*/}[0m <DjVu> edit ant [<num>|<name>|<RANGE>]

         outline - v√Ωpis aktu√°ln√≠ho obsahu DjVu svazku ve form√°tu .outline
         meta  - vygenerov√°n√≠ ≈°ablony pro .outline form√°t s adresov√°n√≠m
                 str√°nek podle jejich n√°zv≈Ø

         num  - po≈ôadov√© ƒç√≠slo str√°nky v DjVu svazku
         name - jm√©no str√°nky v DjVu svazku

[3mPozn√°mka:[23m
  Vygenerovanou ≈°ablonu .outline form√°tu lze upravit editac√≠ v libovoln√©m
  textov√©m editoru. ≈ò√°dky s nevyu≈æit√Ωmi polo≈ækami je t≈ôeba smazat.
  Do dal≈°√≠ch √∫rovn√≠ lze polo≈æky obsahu zano≈ôit pomoc√≠ odsazen√≠ ≈ô√°dku
                   1 √∫rove≈à = 1 tabul√°tor = 8 mezer
  Aktu√°ln√≠ obsah lze vyexportovat v .outline form√°tu parametrem print
  Upraven√Ω obsah lze do DjVu svazku naimportovat ze souboru p≈ôes akci [2mimport[22m,
[1mPozor:[0m Soubor ve form√°tu .outline mus√≠ m√≠t (a≈æ na p≈ô√≠ponu) stejn√© jm√©no,
  jako m√° DjVu svazek do kter√©ho se m√° vlo≈æit, jinak se nenaimportuje!
"""
    help range
    ;;
    keywords-export) echo """
  ACTION: [1mexport[0m

  [1m${0##*/}[0m [volby] <DjVu svazek> export {FORMAT} [RANGE] [TARGET]

FORMAT
      ant - pozn√°mky
     note - export skryt√Ωch pozn√°mek
      xmp - export xmp
      xml - na v√Ωstup bude vyps√°n XML obsah vybran√©ho rozsahu str√°nek
     dsed - na v√Ωstup bude vyps√°n obsah vybran√©ho rozsahu str√°nek v dsed form√°tu
  outline - na v√Ωstup bude vyps√°n obsah DjVu svazku ve form√°tu pro import
     meta - meta atributy str√°nek, jejich rozmƒõry a info o rotaci

     color - plnobarevn√° str√°nka
     black - ƒçernob√≠l√° kresba
foreground - vrstva pop≈ôed√≠
background - vrstva pozad√≠
      mask - maska

RANGE
      num - po≈ôadov√© ƒç√≠slo str√°nky v DjVu svazku
     name - jm√©no str√°nky v DjVu svazku
TARGET
      dir - adres√°≈ô do kter√©ho m√° b√Ωt v√Ωstup ulo≈æen
      all - p≈ôedmƒõtem exportu bude obsah cel√©ho DjVu svazku

  O tom co bude p≈ôedmƒõtem exportu rozhoduje typ vstupn√≠ho souboru, a dal≈°√≠ 
  volby.

  Je-li je vstupn√≠m souborem jin√Ω form√°t souboru ne≈æ DjVu, umo≈æ≈àuje export:
  * u v√≠cestr√°nkov√Ωch dokument≈Ø extrakci jednotliv√Ωch str√°nek
  * jejich konverzi do jin√Ωch bitmapov√Ωch form√°t≈Ø, vƒçetnƒõ p≈ôe≈°k√°lov√°n√≠
  * i konverzi do DjVu
  
  Je-li vstupn√≠m souborem DjVu dokument, jsou v√Ωsledkem exportu soubory,
  kter√© lze po √∫pravƒõ importovat zpƒõt a tak prov√°dƒõt kup≈ô. textovou korekturu
  jeho p≈Øvodn√≠ho obsahu, ƒçi dopl≈àovat obsah a dal≈°√≠ metadata.
  
  Export textov√© vrstvy zajist√≠ volby [3m-x[23m a [3m-d[23m, n√°hled obrazov√© vrstvy
  se generuje p≈ôi volbƒõ [3m-i[23m, a cel√° str√°nka v DjVu form√°tu se exportuje
  p≈ôi volbƒõ [3m-p[23m.

[4mPozn√°mky:[24m
  * Pro zpracov√°n√≠ single-page DjVu str√°nek je parametr [3mall[23m doporuƒçen√Ω
  * Nen√≠-li uveden c√≠lov√Ω adres√°≈ô, budou soubory exporovan√© do adres√°≈ôe,
    kde byl [1m${0##*/}[0m spu≈°tƒõn.
  * P≈ôeps√°n√≠ ji≈æ existuj√≠c√≠ch soubor≈Ø si lze vynutit volbou [3m--force yes[23m
    V√Ωchoz√≠ chov√°n√≠ je - [3mskip[23m (existuj√≠c√≠ soubory se znovu neexportuj√≠)
"""
    ;;
    export-ant) echo """
N√°povƒõda pro export metainformac√©
"""
    ;;
    export-meta) echo """
ACTION [1mexport[0m ‚Äì> meta

  [1m${0##*/}[0m [volby] <DjVu soubor> export meta [RANGE]

  Vypisuje meta informace z DjVu souboru, vƒçetnƒõ jmen a po≈ôad√≠ str√°nek,
  jejich rozmƒõr≈Ø a p≈ô√≠padnƒõ aktu√°ln√≠ stav rotace. Viz uk√°zka v√Ωstupu:

   # 'shared_anno.iff' #[S]
   Creator    \"Zpracovatel DjVu svazku\"
   # 'w01.djvu' #[P1] #width=4019 height=4910
   # 'dal≈°√≠ str√°nka.djvu' #[P2] #width=3972 height=4904 rotation=2
   CreatorPage2    \"Zpracovatel str√°nky ƒç. 2\"

SEE ALSO
    [1mexport[0m ‚Äì> ant, [1minfo[0m ‚Äì> exif, [1minfo[0m ‚Äì> meta
"""
    help range
    ;;
    export-outline) echo """
N√°povƒõda pro export obsahu
"""
    ;;
    export-dsed-*) echo """
N√°povƒõda pro export metainformac√©
"""
    ;;
    export-xml-*) echo """
N√°povƒõda pro export metainformac√©
"""
    ;;
    export-color|\
    export-black|\
    export-background|\
    export-foreground|\
    export-mask) echo """
N√°povƒõda pro export grafick√© vrstvy
    """
    ;;
    export-line|\
    export-word|\
    export-para) echo """
N√°povƒõda pro export textov√© vrstvy
    """
    ;;
    export-grep|export-pages|export-exif) help keywords-export
    ;;
		keywords-import) echo """
   ACTION: [1mimport[0m
  [4mImport obsahu textov√© vrstvy[24m do DjVu souboru

  [1m${0##*/}[0m [volby] <svazek> import [<file>|<dir>]

         file - soubor s obsahem skryt√© textov√© vrstvy
         dir  - adres√°≈ô se soubory s obsahem skryt√© textov√© vrstvy

[3mPozn√°mky:[23m
  * Parametrem akce [2mimport[22m m≈Ø≈æe b√Ωt buƒè adres√°≈ô se soubory, nebo soubor s
    daty k importu
  * N√°zev souboru mus√≠ odpov√≠dat n√°zvu svazku (pro gob√°ln√≠ metadata), nebo
    n√°zvu str√°nky, kterou obsahuje, s t√≠m rozd√≠lem, ≈æe jeho p≈ô√≠pona odpov√≠d√°
    typu dat kter√© obsahuje:
          [3m.meta[23m - meta atributy
           [3m.xml[23m - skryt√Ω text obsahu
          [3m.dsed[23m - pozn√°mky, meta atributy a skryt√Ω text obsahu
       [3m.outline[23m - obsah svazku; Pozor! Obsah je souƒç√°st cel√©ho svazku, nem√°
                  tedy smysl ho vkl√°dat do single-page DjVu dokumentu.
    K form√°tu tƒõchto soubor≈Ø v√≠ce viz manu√°l
  * Nen√≠-li uveden ≈æ√°dn√Ω adres√°≈ô, ani soubor, tak se p≈ôedpokl√°d√° ≈æe se budou
    zpracov√°vat soubory z aktu√°ln√≠ho adres√°≈ôe
"""
		;;
    keywords-info) echo """
  ACTION [1minfo[0m

  [1m${0##*/}[0m [volby] <DjVu soubor> info [SUBKEY] [-h]

  Vypisuje informace o DjVu souboru. Nen√≠-li uveden ≈æ√°dn√Ω SUBKEY, vypad√°
  v√Ωstup jako u n√°sleduj√≠c√≠ch uk√°zek:

  A, DjVu Bundle o 3 str√°nk√°ch, ov≈°em bez sd√≠len√Ωch metainformac√≠.

        DJVU (multi-page) 3983x4874 3

  B, DjVu Bundle o jedn√© stranƒõ, se sd√≠len√Ωmi metainformacemi.

        DJVU (multi-page) 4007x4867 1 shared_anno

  C, DjVu Single.

        DJVU 4019x4910 1

SUBKEY
    pages - vrac√≠ celkov√Ω poƒçet stran v DjVu svazku
     list - vrac√≠ set≈ô√≠dƒõn√Ω seznam str√°nek DjVu svazku
     exif - vypisuje exif informace k DjVu souboru, vƒçetnƒõ meta informac√≠
            ze str√°nek
     meta - vypisuje rozmƒõry str√°nek DjVu souboru a info o p≈ô√≠padn√© rotaci
     dsed - aplikuje nad soubor p≈ô√≠kaz p≈ôedan√Ω utilitƒõ [1mdjvused[0m
     grep - aplikuje na plain textov√Ω v√Ωstup z DjVu souboru p≈ô√≠kaz [1mgrep[0m
            s p≈ôedan√Ωmi parametry

[3mPozn√°mka:[23m
  * V√Ωstupy lze d√°le zpracov√°vat p≈ôes rouru, nebo pou≈æ√≠vat ve skriptech
"""
    ;;
    info-dsed) echo """
  ACTION [1minfo[0m ‚Äì> dsed

  [1m${0##*/}[0m [volby] <DjVu soubor> info dsed ‚Ä¶

  ≈òetƒõzec se p≈ôed√° k dal≈°√≠mu zpracov√°n√≠ utilitƒõ djvused
"""
    ;;
    info-exif) echo """
  ACTION [1minfo[0m ‚Äì> exif

  [1m${0##*/}[0m [volby] <DjVu soubor> info exif

  Vrac√≠ exif informace o DjVu souboru ‚Äì vƒçetnƒõ metainformac√≠, pokud je
  obsahuje.
"""
    ;;
    info-grep) echo """
  ACTION [1minfo[0m ‚Äì> grep

  [1m${0##*/}[0m [volby] <DjVu soubor> info grep ‚Ä¶

  Aplikuje p≈ô√≠kazy utility grep na v√Ωstup textov√©ho obsahu DjVu souboru,
  pokud nƒõjak√Ω obsahuje. V p≈ô√≠padƒõ ≈æe nalezen√Ω vzorek podm√≠nce p≈ô√≠kazu
  vyhov√≠, tak se ‚Äì kromƒõ nalezen√©ho vzorku ‚Äì vyp√≠≈°e tak√© jm√©no a po≈ôadov√©
  ƒç√≠slo p≈ô√≠slu≈°n√© str√°nky v DjVu svazku.
"""
    ;;
    info-list) echo """
  ACTION [1minfo[0m ‚Äì> list

  [1m${0##*/}[0m [volby] <DjVu soubor> info list

  Vrac√≠ seznam v≈°ech str√°nek v DjVu souboru, vƒçetnƒõ speci√°ln√≠ str√°nky
  shared_anno.iff, kter√° (pokud se ve svazku vyskytuje) je v≈ædy oznaƒçena
  jako str√°nka 0. V√Ωpis pak vypad√° takto:

0     shared_anno.iff
1     w03.djvu
2     P≈ô√≠li≈° ≈ælu≈•ouƒçk√Ω k≈Ø≈à.djvu
3     w02.djvu
"""
    ;;
    info-pages) echo """
  ACTION [1minfo[0m ‚Äì> pages

  [1m${0##*/}[0m [volby] <DjVu soubor> info pages

  Vrac√≠ celkov√Ω poƒçet stran v DjVu souboru. V p≈ô√≠padƒõ DjVu single vrac√≠ 1,
  stejnƒõ jako v p≈ô√≠padƒõ DjVu svazku s jednou str√°nkou.
"""
    ;;
    keywords-rename) echo """
  AKCE [1mrename[0m

  P≈ôejmenov√°n√≠ str√°nek v DjVu souboru.

  [1m${0##*/}[0m [option] <DjVu> rename [RANGE] PATTERN

P≈ô√≠klad:

  [1m${0##*/}[0m [option] <DjVu> rename 1,3-8 Str√°nka o nƒõƒçem nov√©m

  V√Ωsledkem akce bude, ≈æe str√°nky vymezen√© rozsahem budou p≈ôejmenov√°ny, a
  v p≈ô√≠padƒõ ≈æe jich bude v√≠ce tak√© p≈ôeƒç√≠slov√°ny dle uveden√©ho vzoru PATTERN
"""
    help range
    ;;
    keywords-rotate) echo """
  AKCE [1mrotate[0m

  Mƒõn√≠ v√Ωchoz√≠ orientaci str√°nek v DjVu souboru.

  [1m${0##*/}[0m [option] <DjVu> rotate {VALUE} {RANGE}

Pro nastaven√≠ orientace v≈°ech str√°nek na v√Ωchoz√≠ hodnotu, pou≈æijte: 0

  [1m${0##*/}[0m [option] <DjVu> rotate 0 0

  VALUE:
             0 - v√Ωchoz√≠ orientace (0¬∞)
             1 - otoƒçit str√°nku o 90¬∞ doprava
             2 - otoƒçit str√°nku o 180¬∞ (vzh≈Øru nohama)
             3 - otoƒçit str√°nku o 90¬∞ doleva (na 270¬∞)
          left - rotovat str√°nku o 90¬∞ smƒõrem doleva
         right - rotovat str√°nku o 90¬∞ smƒõrem doprava
           180 - otoƒçit str√°nku opaƒçnƒõ ne≈æ aktu√°lnƒõ je

Pozor! Je-li uvedeno pouze jedno ƒç√≠slo, je aplikov√°no z√°rove≈à jako nastaven√≠
       rotace i rozsah RANGE.

"""
    help range
    ;;
    keywords-set) echo """
  AKCE [1mset[0m

  Akce je urƒçena pro nastaven√≠ metadat a dal≈°√≠ch element≈Ø v DjVu souboru
  z p≈ô√≠kazov√© ≈ô√°dky. P≈ôes [2mset[22m lze tak√© dodateƒçnƒõ vlastnosti ELEMENTU
  a jeho ATRIBUTY zmƒõnit, ale odstranit se d√° pouze p≈ôi akci [2medit[22m!

  [1m${0##*/}[0m [volby] <DjVu svazek> set [RANGE] {METADATA} ‚Ä¶

  [1m${0##*/}[0m [volby] <DjVu svazek> set [RANGE] {ELEMENT} ‚Ä¶ [: ATRIBUTY ]

METADATA:       
       key - metadatov√Ω kl√≠ƒç (vypisuje se p≈ôes exiftools)
      note - skryt√° pozn√°mka v metadatov√© vrstvƒõ DjVu dokumentu
   outline - polo≈æka aktivn√≠ho obsahu DjVu dokumentu (z√°lo≈æka)
      mode - v√Ωchoz√≠ zobrazovac√≠ m√≥d obrazov√© vrstvy
background - barva pozad√≠ okna prohl√≠≈æeƒçe DjVu souboru (djview)
       xmp - nastaven√© XMP atribut≈Ø
      zoom - v√Ωchoz√≠ velikost zobrazen√≠ str√°nky

ELEMENTY:
  Jsou prvky, jimi≈æ lze u≈æivatelsky doplnit informaƒçn√≠ hodnotu p≈Øvodn√≠ho
  obsahu str√°nky. Jde kup≈ô. o hyperlinky v textu, zv√Ωraznƒõn√© oblasti,
  pozn√°mky, upozornƒõn√≠ atp.

     arrow - ≈°ipka
      line - ƒç√°ra
      oval - ov√°ln√© ohraniƒçen√≠ oblasti
      poly - ohraniƒçen√≠ oblasti polygonem
      rect - ograniƒçen√≠ oblasti r√°mcem
      text - textov√° pozn√°mka
            
Ka≈æd√Ω z element≈Ø m√° sv√© v√Ωchoz√≠ vlastnosti, kter√© lze v p≈ô√≠padƒõ modifikovat
nastaven√≠m dal≈°√≠ch  atribut≈Ø. Tyto atributy jsou p≈ôi nastaven√≠ elementu od
z√°kladn√≠ch parametr≈Ø  oddƒõleny dvojteƒçkou. Viz p≈ô√≠klad:

   ‚Ä¶ set oval 123 123 123 123 Popis oblasti : border FF0000

ATRIBUTY element≈Ø:
    align               lineclr               textclr
    backclr             none                  width
    border              pushpin               xor
    border_avis         shadow_*

[3mPozn√°mka:[23m
  V√≠ce informac√≠ o ka≈æd√©m z atribut≈Ø a pou≈æit√≠ elemnt≈Ø ƒçi metadat lze
  vypsat tak, ≈æe se bezprost≈ôednƒõ za nƒõ nap√≠≈°e volba -h.
"""
    ;;
    set-arrow) echo """
  ELEMENT [1m${1#set-}[0m

  ≈†ipka, je ve skuteƒçnosti element line, s nastaven√Ωm atributem arrow,
  kter√° se pak na str√°nce zobrazuje jako ≈°ipka.

   ‚Ä¶ set arrow X1 Y1 X2 Y2 DESC : [lineclr COLOR] [width SIZE]

X1 Y1
  Souƒçasnice bodu, ze kter√©ho bude ≈°ipka vych√°zet
X2 Y2
  Sou≈ôadnice bodu do kter√©ho bude ≈°ipka ukazovat

DESC
  Popis k ≈°ipce

Pou≈æiteln√© atributy:
  linecrl - barva ≈°ipky v RGB
    width - tlou≈°≈•ka ƒç√°ry ≈°ipky
"""
    ;;
    set-backclr) echo """
ATRIBUT [1m${1#set-}[0m
(voliteln√Ω prvek)
Barva pozad√≠ prvku. D√°v√° smysl pouze u typu:
    rect - barva or√°movan√© plochy a
    text - barva pozad√≠ textu

V p≈ô√≠padƒõ prvk≈Ø typu oval, poly, line nebo arrow, se vybarv√≠ pravo√∫hl√° plocha
"""
    ;;
    set-background) echo """
  METADATA [1m${1#set-}[0m

  Meta atribut background nastavuje barvu pozad√≠ okna prohl√≠≈æeƒçe, ve kter√©m
  se zobrazuje p≈ô√≠slu≈°n√° str√°nka. Smysl d√°v√° p≈ôedev≈°√≠m tehdy. je-li vhodn√©
  barvu pozad√≠ zmƒõnit v≈Øƒçi str√°nce tak, aby d√°vala lep≈°√≠ barevn√Ω kontrast.
  Vƒõt≈°inou se nastavuje glob√°lnƒõ, ale je mo≈æn√© ho nastavit tak√© pro konkr√©tn√≠
  str√°nky.

  [1m${0##*/}[0m [volby] <DjVu svazek> set {RANGE} background {COLOR}

     COLOR - Barva v RGB

P≈ô√≠klad:
 ‚Ä¶ set set 0 background F8F8F8
 ‚Ä¶ set set 1,5,10-25 background FF0000

[3mPozn√°mka:[23m
  Pro glob√°ln√≠ nastaven√≠ barnu pozad√≠ pou≈æijte hodnota RANGE nula ‚Äì 0.
"""
    ;;
    set-+(border|xor|none)) echo """
ELEMENT [1m${1#set-}[0m
Nastaven√≠ okraje r√°meƒçku

  border <BARVA> - nastav√≠ jinou barvu r√°meƒçku (v√Ωchoz√≠ je ƒçern√°)
             xor - r√°meƒçek je tvo≈ôen p≈ôeru≈°ovanou linkou
            none - vypne zobrazov√°n√≠ r√°meƒçku √∫plnƒõ

Okraj je zobrazen tenkou linkou, jej√≠≈æ tlou≈°≈•ku nelze zmƒõnit!!!
"""
    ;;
    set-border_avis) echo """
ELEMENT [1m${1#set-}[0m
(voliteln√Ω prvek)
border_avis - nastaven√≠ viditelnosti prvku

Nen√≠-li ≈ôeƒçeno jinak, z≈Øst√°vaj√≠ elementy typu rect na DjVu str√°nce skryt√© ‚Äì zobrazuj√≠ se teprve v okam≈æiku, kdy nad nƒõ najedete my≈°√≠.
Ov≈°em v p≈ô√≠padƒõ prvku, co m√° b√Ωt ihned viditeln√Ω se takov√© chov√°n√≠ nehod√≠. Proto existuje tento parametr, kter√Ωm se nastav√≠ aby byl
prvek viditeln√Ω st√°le
"""
    ;;
    set-key) echo """
  METADATA [1m${1#set-}[0m

  P≈ôes metadatov√Ω element key se nastavuj√≠ metadatov√© kl√≠ƒçe, kter√© mohou
  b√Ωt interpretov√°ny jako EXIF tagy. Do DjVu souboru lze vlo≈æit rovnƒõ≈æ
  XMP k√≥d, ov≈°em pouze p≈ôes akci edit.

Nastaven√≠, resp. p≈ôenastaven√≠ kl√≠ƒçe:

  [1m${0##*/}[0m <DjVu> set RANGE key KEY VALUE

Zru≈°en√≠ kl√≠ƒçe:

  [1m${0##*/}[0m <DjVu> uset RANGE key KEY [VALUE]

KEY
  ≈òetƒõzec znak≈Ø bez mezer a diakritiky, kter√Ω nesm√≠ zaƒç√≠nat ƒç√≠slem

VALUE
  Hodnota kl√≠ƒçe. Vyvarujte se pou≈æit√≠ kulat√Ωch z√°vorek!

[3mPozn√°mka:[23m
  * I kdy≈æ je to technicky mo≈æn√©, jeden kl√≠ƒç nelze na str√°nce pou≈æ√≠t v√≠c
    ne≈æ jednou. P≈ôi pokusu o nastaven√≠ kl√≠ƒçe s jinou hodnotou VALUE, dojde
    k nahrazen√≠ obsahu kl√≠ƒçe st√°vaj√≠c√≠ho  nov√Ωm obsahem.

Pro p≈ôehled nejƒçastƒõji pou≈æ√≠van√Ωch EXIF (ƒçi XMP) tag≈Ø spus≈•te:

  [1m${0##*/}[0m exif
"""
		;;
    set-line) echo """
  ELEMENT [1m${1#set-}[0m

  Linka kter√° se zobrazuje na str√°nce. Od prvku arrow (≈°ipka) se li≈°√≠ t√≠m,
  nem√° nastaveno aby se na jej√≠m konci zobrazovala ≈°ipka.

   ‚Ä¶ set line X1 Y1 X2 Y2 DESC : [lineclr COLOR] [width SIZE]

X1 Y1
  Souƒçasnice bodu, ze kter√©ho bude linka vych√°zet
X2 Y2
  Sou≈ôadnice bodu ve kter√©m bude linka konƒçit

DESC
  Popis k lince

Pou≈æiteln√© atributy:
  linecrl - barva ƒç√°ry v RGB
    width - tlou≈°≈•ka ƒç√°ry
"""
    ;;
    set-lineclr) echo """
ATRIBUT [1m${1#set-}[0m
(voliteln√Ω prvek)
Nastaven√≠ barvy vykreslen√© ƒç√°ry. D√°v√° smysl pouze u typu
     line - linka
    arrow - ≈°ipka

U prvk≈Ø rect, oval, poly a text se nastavuje barva linky, co ohraniƒçuje plochu voliteln√Ωm parametrem border
"""
    ;;
    set-metadata) echo """
METADATA [1m${1#set-}[0m
Nastaven√≠ metadatov√©ho kl√≠ƒçe
"""
    ;;
    set-mode) echo """
  METADATA [1m${1#set-}[0m

 Meta atribut mode umo≈æ≈àuje zmƒõnit v√Ωchoz√≠ zobrazen√≠ str√°nky. D√° se nastavit
 jak glob√°lnƒõ pro v≈°echny str√°nky najednou, tak pro konkr√©tn√≠ str√°nky.
 Hod√≠ se obzvl√°stƒõ v situaci, kdy jsou v r√°mci jednoho DjVu svazku
 zkombinov√°ny str√°nky zpracovan√© r≈Øzn√Ωm zp≈Øsobe - ƒçernob√≠l√© i barevn√©.
 U≈æivatel si pak nemus√≠ p≈ôi prohl√≠≈æen√≠ p≈ôep√≠nat m√≥d zobrazen√≠ manu√°lnƒõ.

 Pou≈æ√≠t lze buƒè akci set:

  [1m${0##*/}[0m <DjVu svazek> set [RANGE] mode MODE

MODE
   color - norm√°ln√≠ barevn√© zobrazen√≠
      bw - ƒçernob√≠l√© zobrazen√≠ masky
    fore - zobrazen√≠ pop≈ôed√≠
   black - ƒçernob√≠l√© zobrazen√≠

Pokud se m√≠sto rozsahu, ƒçi seznamu str√°nek RANGE uvede kl√≠ƒçov√© slovo
'global', bude nastaven tento meta atribut do sd√≠len√© metadatov√© vrstvy.
T√≠m se zapne nastaven√° volba jako v√Ωchoz√≠ pro v≈°echny str√°nky, u kter√Ωch
nebude nastaven√° jinak. Atribut lze nastavit tak√© p≈ôi p≈ô√≠m√© editaci metadat:

  [1m${0##*/}[0m <DjVu svazek> edit ant

Do bloku p≈ô√≠slu≈°n√© str√°nky p≈ôidejte n√°sleduj√≠c√≠ ≈ô√°dek
    ‚Ä¶
    mode bw
    ‚Ä¶
"""
    ;;
    set-note) echo """
  METADATA [1m${1#set-}[0m

  Nastavuje skrytou pozn√°mku, kterou nezobrazuje a nezpracov√°v√° ≈æ√°dn√Ω prohl√≠≈æeƒç
  DjVu soubor≈Ø. Lze ji vyu≈æ√≠t pro ulo≈æen√≠ informac√≠ o pr≈Øbƒõhu zpracov√°n√≠
  dokumentu, digit√°ln√≠ch podpis≈Ø obrazov√Ωch vrstev & etc.

   ‚Ä¶ set 0 note NOTE

NOTE
  M≈Ø≈æe b√Ωt libovoln√Ω textov√Ω ≈ôetƒõzec, kter√Ω neobsahuje kulat√© z√°vorky.
  Do pozn√°mky lze vlo≈æit tak√© soubor. Podm√≠nkou je, ≈æe mus√≠ b√Ωt zakryptovan√Ω
  do textov√©ho ≈ôetƒõzce. Viz n√°sleduj√≠c√≠ p≈ô√≠klad vlo≈æen√≠ bin√°rn√≠ho archivu,
  zak√≥dovan√©ho do ≈ôetƒõzce pomoc√≠ base64:

  djvutool a.djvu set 0 note \$(base64 archiv.zip | tr '\n' '-')

  A jeho vyta≈æen√≠:

  djvutool a.djvu export note 0 | tr '-' '\n' | base64 -d > kopie.zip

[3mPozn√°mka:[23m
  Na rozd√≠l od exif tag≈Ø, vkl√°dan√Ωch p≈ôes metadatov√Ω kl√≠ƒç [1mkey[0m, m≈Ø≈æe b√Ωt
  skryt√Ωch pozn√°mek vlo≈æen√Ωch do metadatov√© vrstvy neomezenƒõ. Pro zru≈°en√≠
  skryt√© pozn√°mky p≈ôi akci [2munset[22m ov≈°em mus√≠ b√Ωt uveden i ≈ôetƒõzec, kter√Ω
  obsahuje. Ten v≈°ak lze z√≠skat p≈ôi akci [2mexport[22m.

  Alternativn√≠ mo≈ænost√≠ je odstranƒõn√≠ skryt√© pozn√°mky p≈ôi akci [2medit[22m.
"""
    ;;
    set-none) echo """
ATRIBUT [1m${1#set-}[0m
(voliteln√Ω prvek)
none - vypne zobrazov√°n√≠ okraje plochy

Anuluje nastaven√≠ hodnoty border i boorder_avis
"""
    ;;
    set-outline) echo """
  METADATA [1m${1#set-}[0m

 Z√°lo≈æky (outline), pat≈ô√≠ mezi metadata. V prohl√≠≈æeƒçi DjVu soubor≈Ø se zobrazuj√≠
 jako rozbalovac√≠ v√≠ce√∫rov≈àov√© menu odkaz≈Ø na intern√≠ str√°nky resp. extern√≠ linky.
 Jednotlivou z√°lo≈æku lze nastavit prost≈ôednictv√≠m akce set:

  [1m${0##*/}[0m [volby] <DjVu svazek> set outline {TARGET} {DESC}

    TARGET - C√≠l z√°lo≈æky. Extern√≠ link (≈ôetƒõzec zaƒç√≠naj√≠c√≠ http://‚Ä¶), po≈ôad√≠ (ƒç√≠slo),
             ƒçi jm√©no str√°nky v DjVu souboru (nap≈ô. p0003.djvu)
      DESC - Popis z√°lo≈æky

P≈ô√≠klady:
 ‚Ä¶ set outline 1 Z√°lo≈æka odkazuj√≠c√≠ na str√°nku ƒç. 1
 ‚Ä¶ set outline jmeno_stranky.djvu Z√°lo≈æka odkazuj√≠c√≠ na intern√≠ str√°nku jm√©nem
 ‚Ä¶ set outline http://example.org Z√°lo≈æka odkazuj√≠c√≠ na extern√≠ web

[3mPozn√°mka:[23m
 * Z√°lo≈æky, jejich po≈ôad√≠ ƒçi √∫rove≈à zano≈ôen√≠ lze upravit p≈ôi akci [2medit[22m.
 * Z√°lo≈æky lze p≈ôes akci [2mexport[22m vyexportovat v [3m.outline[23m ƒçi [3m.dsed[23m form√°tu
 * Soubor v [3m.outline[23m form√°tu lze upravit editac√≠ v libovoln√©m textov√©m editoru.
   Pr√°zdn√© ≈ô√°dky je t≈ôeba smazat. Na rozd√≠l od nastaven√≠ z√°lo≈æky p≈ôes akci set,
   je v .outline form√°tu na ≈ô√°dce v≈ædy nejprve uveden popis (DESC) a teprve pak
   n√°sleduje c√≠l (TARGET), kter√©mu p≈ôedch√°z√≠ znak #
   Ka≈æd√° z nich je uzav≈ôena v z√°vork√°ch. Do ni≈æs√≠ √∫rovnƒõ v≈Øƒçi p≈ôedchoz√≠ z√°lo≈æce
   lze z√°lo≈æku zano≈ôit odsazen√≠ cel√©ho obsahu ≈ô√°dku tabul√°torem:
                   1 √∫rove≈à = 1 tabul√°tor = 8 mezer
 * Z√°lo≈æky lze naimportovat buƒè ze souboru ve form√°tu [3m.outline[23m p≈ôes akci [2mimport[22m,
  nebo p≈ôes [1mdjvused[0m (form√°t  [3m.dsed[23m)
"""
    ;;
    set-oval) echo """
ELEMENT [1m${1#set-}[0m
Nastaven√≠ ov√°ln√© (kruhov√©) plochy
Default:

barva a typ okraje - ƒçern√°, p≈ôeru≈°ovan√° linka (xor) 
barvu a pr≈Øhlednost plochy - pr≈Øhledn√° (nelze zmƒõnit) 
URL - aktivn√≠

    oval 0 0 50 50

Nakresl√≠ kru≈ænici o polomƒõru 50 pixel≈Ø, kter√° bude um√≠stƒõna v lev√©m doln√≠m
rohu.
Prvn√≠ sou≈ôadnice ud√°vaj√≠ x,y sou≈ôadnice v√Ωchoz√≠ho bodu, od kter√©ho se pak
odmƒõ≈ô√≠ X,Y souƒçadnice st≈ôedu kru≈ænice.

    oval 350 125 100 100

Vykresl√≠ kru≈ænici o polomƒõru 100px, co bude m√≠t st≈ôed na absolutn√≠ch
sou≈ôadnic√≠ch 450 225

"""
    ;;
    set-+(pfoot|phead)) echo """
METADATA [1m${1#set-}[0m
Z√°hlav√≠ a z√°pat√≠

Vƒõt≈°ina prohl√≠≈æeƒç≈Ø je neum√≠ zobrazit. Je tedy zbyteƒçn√© je nastavovat.
"""
    ;;
    set-poly) echo """
ELEMENT [1m${1#set-}[0m
Polynomick√Ω obrys plochy
Default:
barva a pr≈Øhlednost plochy - pr≈Øhledn√°. Obarvit lze pouze pravo√∫hlou plochu ve kter√© je polynom vepsan√Ω

Pou≈æiteln√© parametry:
  [border_avis]
  [none|border c] 
"""
    ;;
    set-rect) echo """
ELEMENT [1m${1#set-}[0m
Nastaven√≠ pravo√∫hl√© plochy
    rect 0 0 50 50

Nakresl√≠ ƒçtverec o stranƒõ 50x50 pixel≈Ø, jeho≈æ lev√Ω doln√≠ roh bude na sou≈ôadnic√≠ch
x,y a prav√Ω horn√≠ se odmƒõ≈ô√≠ jako vzd√°lenost X,Y

    rect 350 125 100 100

Vykresl√≠ ƒçtverec o stranƒõ 100x100 pixel≈Ø, co bude m√≠t st≈ôed na absolutn√≠ch
sou≈ôadnic√≠ch 450 225

Vykreslen√≠ pomoc√≠ djvutxt:
want@schroeder:~$ djvutxt -detail=line -page=1 b.djvu | grep SEIFERT
  (line 281 498 776 535 \"MILO≈† SEIFERT \")

 ¬≠‚Ä¶ set 1 area rect 281 498 $((535-281)) $((776-498)) Milo≈° Seifert, zakladatel LLM

Nejd≈ô√≠v p≈ôes info grep zjistit sou≈ôadnice textu

"""
    ;;
    set-shadow_+(in|out|ein|eout)) echo """
ATRIBUT [1m${1#set-}[0m

Nastaven√≠ velikosti st√≠nu u pravo√∫hl√©ho r√°meƒçku

  shadow_in - vnit≈ôn√≠ plocha r√°meƒçku vypad√° jako zahlouben√° dovnit≈ô
 shadow_out - vnit≈ôn√≠ plocha r√°meƒçku vypad√° jako vystoupl√° ven
 shadow_ein - vnƒõj≈°√≠ okraj r√°meƒçku vypad√° jako zahlouben√Ω dovnit≈ô
shadow_eout - vnƒõj≈°√≠ okraj r√°meƒçku vypad√° jako vystoupl√Ω ven

Nastaven√≠ libovoln√©ho parametru okraje (none, xor, nebo border) aplikaci st√≠nu vylouƒç√≠!!!
"""
    ;;
    set-text)  echo """
ELEMENT [1m${1#set-}[0m
Nastaven√≠ pravo√∫hl√© plochy
    text 0 0 50 50
         X Y W H
Do obd√©ln√≠ku o rozmƒõrech WxH, s lev√Ωm doln√≠m rohem na sou≈ôadnic√≠ch XxY
vep√≠≈°e text. Velikost p√≠sma uprav√≠ dle mno≈æstv√≠ textu v r√°mci
"""
    ;;
    set-textclr) echo """
ATRIBUT [1m${1#set-}[0m
(voliteln√Ω prvek)
Barva textu - D√°v√° smysl pouze u typu text

V p≈ô√≠padƒõ prvk≈Ø rect, oval, poly, line a arrow je tento parametr zbyteƒçn√Ω, proto≈æe se u nich ≈æ√°dn√Ω text nezobrazuje
"""
    ;;
    set-width) echo """
ATRIBUT [1m${1#set-}[0m
    (voliteln√Ω prvek)
width - Nastaven√≠ ≈°√≠≈ôky ƒç√°ry (≈°ipky). Cel√© ƒç√≠slo od 1 do 999
"""
    ;;
    set-xmp) echo """
  METADATA [1m${1#set-}[0m

  P≈ôes metadatov√Ω element xmp lze nait metadatov√Ω kl√≠ƒç s XMP k√≥dem, kter√Ω
  je pak interpretov√°n podobnƒõ jako EXIF tagy.

  ‚Ä¶ set 0 key xmp '<rdf:RDF xmlns:rdf=‚Ä¶     ‚Ä¶scription></rdf:RDF>'

[3mPozn√°mka:[23m
  * I kdy≈æ je to technicky mo≈æn√©, na jedn√© str√°nce je akceptov√°n v≈ædy pouze
    jeden XMP element. P≈ôi nastaven√≠ jin√©ho k√≥du dojde k nahrazen√≠ toho 
    st√°vaj√≠c√≠ho nov√Ωm obsahem.  Pro d√≠lƒç√≠ √∫pravy je tedy vhodnƒõj≈°√≠ pou≈æ√≠t
    akci edit.

Pro v√≠ce informac√≠ o XMP spus≈•te:

  [1m${0##*/}[0m xmp

"""
    ;;
    set-zoom) echo """
  METADATA [1m${1#set-}[0m

  Meta atribut zoom umo≈æ≈àuje zmƒõnit v√Ωchoz√≠ velikost zobrazovan√Ωch str√°nek.
  Vƒõt≈°inou se nastavuje glob√°lnƒõ, ale je mo≈æn√© ho nastavit tak√© pro konkr√©tn√≠
  str√°nky. To se m≈Ø≈æe hodit, pokud jsou v r√°mci jednoho DjVu svazku um√≠stƒõn√©
  r≈Øznƒõ velk√© str√°nky.

  Meta atribut background nastavuje barvu pozad√≠ okna prohl√≠≈æeƒçe, ve kter√©m
  se zobrazuje p≈ô√≠slu≈°n√° str√°nka. Smysl d√°v√° p≈ôedev≈°√≠m tehdy. je-li vhodn√©
  barvu pozad√≠ zmƒõnit v≈Øƒçi str√°nce tak, aby d√°vala lep≈°√≠ barevn√Ω kontrast.
  Vƒõt≈°inou se nastavuje glob√°lnƒõ, ale je mo≈æn√© ho nastavit tak√© pro konkr√©tn√≠
  str√°nky.

  [1m${0##*/}[0m [volby] <DjVu svazek> set {RANGE} zoom {SIZE}

SIZE
  stretch - rozt√°hne str√°nku podle okna
  one2one - zobrazen√≠ 1:1
    width - na maxim√°ln√≠ ≈°√≠≈ôku str√°nky
     page - cel√° str√°nka
 d1-99999 - velikost str√°nky v procentech
     

P≈ô√≠klad:
 ‚Ä¶ set set 0 zoom stretch
 ‚Ä¶ set set 1,5,10-25 zoom 150d

[3mPozn√°mka:[23m
  * Pro glob√°ln√≠ nastaven√≠ velikosti str√°nky pou≈æijte hodnotu RANGE nula ‚Äì 0.
  * Bohu≈æel vƒõt≈°ina prohl√≠≈æeƒç≈Ø s t√≠mto parametrem (ani djview), ale plugin
    zalo≈æen√Ω na djvulibre ano.
"""
    ;;
    keywords-view) echo """
  AKCE: [1mview[0m

  [1m${0##*/}[0m [volby] <SOUBOR> view

  Otev≈ôe na pozad√≠ soubor v prohl√≠≈æeƒçi. V p≈ô√≠padƒõ bitmapov√Ωch obr√°zk≈Ø se
  pou≈æije [1mfeh[0m a v p≈ô√≠padƒõ DjVu soubor≈Ø [1mdjview4[0m.
"""
    ;;
		level) echo """
[1mParametr[0m
         -l|--level  <[2mƒç√≠slo[22m> Hodnota akceptovateln√Ωch ztr√°t u ƒçernob√≠l√© kresby
                               p≈ôi konverzi. P≈ôed nastaven√≠m t√©to hodnoty vyzkou≈°ejte
                               optim√°ln√≠ nastaven√≠ na nƒõkter√©m ze soubor≈Ø a s parametrem
                               --test

  Kromƒõ ƒç√≠seln√© hodnoty, kter√° mus√≠ b√Ωt men≈°√≠ ne≈æ 200 lze √∫rove≈à ztr√°t
  nastavit i pomoc√≠ nƒõkter√©ho z n√°sleduj√≠c√≠ch parametr≈Ø - v p≈ô√≠padƒõ ≈æe 
  jich bude uvedeno v√≠c, m√° prioritu posledn√≠ z nich.

        --lossless     0 - ≈æ√°dn√© ztr√°ty (default)
        --clean        1 - ignoruj√≠ se body o velikosti 1 pixelu
        --lossy        100 - ignoruj√≠ se plochy
"""
		;;
		ocr) echo "N√°povƒõda k OCR - ToDo"
		;;
		options) echo """Options:
    -a|--algorithm Algorithm for separating mask of image (fore or back)
xx  -b|--bundle    Setting type of DjVu bundle
    -d|--dsed      Export hiddent text layer in native code for DjVused
       --dpi       DPI input image for import (actions fore or back)
    -f|--force     Force action
       --clean     Params for convert image to DjVu with separate layers
       --lossy
       --lossless
       --level
    -h|--help      Main options for help about option, or action
    -i|--image     Export .png image of page for use with DjVuWebEd
??  -m|--meta      Export meta attributes from DjVu file
    -o|--ocr       Application OCR
    -p|--page      Export single DjVu page from bundle
    -r|--rename    Pattern for action rename 
xx  -t|--thumb     Creating thumbnails in DjVu bundle
    -v|--verbose   
    -x|--xml       Export hiddent text layer (XML) for use with DjVuWebEd"""
		;;
		page) echo """volba [1m-p[0m ([1m--page[0m)

  Extrakce DjVu str√°nky ze svazku p≈ôi akci [2mexport[22m

  [1m${0##*/}[0m ... {-p|--page} [yes|no] ...
  
[4mPozn√°mka:[24m
  * Pokud za volbou nen√≠ uveden ≈æ√°dn√Ω dal≈°√≠ parametr, tak se automaticky
    p≈ôedpokl√°d√° - yes.
  * V√Ωchoz√≠ parametr - no - lze implicitnƒõ zmƒõnit nastaven√≠m promƒõnn√©
    PAGE do souboru v adres√°≈ôi ${HOME}/.config/${NAME}/
  * Exportovan√© str√°nky se ukl√°daj√≠ pod sv√Ωm p≈Øvodn√≠m n√°zvem.
"""
		;;
    range) echo """RANGE
    Str√°nky lze identifikovat buƒè jm√©nem nebo aktu√°ln√≠ pozic√≠ v r√°mci DjVu
    souboru. Pokud chceme identifikovat v√≠ce str√°nek najednou, lze pou≈æ√≠t
    buƒè seznam jmen str√°nek, oddƒõlen√Ωch ƒç√°rkou:

                        ‚Ä¶ 'name_1.djvu,name_23.djvu,name_4.djvu'

    Nebo seznam jejich po≈ôadov√Ωch ƒç√≠sel v souboru. P≈ôiƒçem≈æ pomlƒçka
    identifikuje rozsah od-do:
                        ‚Ä¶ 1,10,4-5
[4mPozn√°mka:[24m
  * P≈ôed realizac√≠ akce se na z√°kladƒõ jmen v seznamu vytvo≈ô√≠ rozsah po≈ôad√≠
    str√°nek v souboru, kter√Ω se n√°slednƒõ set≈ô√≠d√≠. Nez√°le≈æ√≠ tedy na tom, v
    jak√©m po≈ôad√≠ byly str√°nky, ƒçi jejich po≈ôadov√° ƒç√≠sla p≈ôed√°ny.
  * Jm√©na str√°nek co v DjVu svazku neexistuj√≠ se p≈ôi zpracov√°n√≠ ignoruj√≠
"""
        ;;
		rename) echo """ volba [1m-r[0m, [1m--rename[0m
 Nastaven√≠ vzorku, podle jak√©ho se maj√≠ pojmenovat, nebo p≈ôejmenovat DjVu soubory v DjVu svazku.

Lze vyu≈æ√≠t parametr %01d pro nastaven√≠ poƒçtu znak≈Ø v ƒç√≠slov√°n√≠ str√°nky, p≈ôi konverzi v√≠cestr√°nkov√Ωch bitmapov√Ωch soubor≈Ø (tiff, png, xcf)

[4mPopis:[24m
  Pomoc√≠ [2mvzoru[22m lze upravit n√°zvy zkonvertovan√Ωch DjVu soubor≈Ø
  p≈ôed jejich sestaven√≠m do DjVu svazku. [2mVzor[22m m≈Ø≈æe b√Ωt tvo≈ôen:
    1, Pouze jednou, nebo v√≠ce nulami - 000
    2, Nebo ≈ôetƒõzcem, n√°sledovan√Ωm nulami - soubor_00

[3mPozn√°mka:[23m
  Je-li uvedena pouze jedna nula, budou str√°nky oƒç√≠slov√°ny [4mnumericky[24m,
  t.j. od ƒç√≠sla 1 d√°le. Je-li nul v√≠ce, pak bude ƒç√≠slo interpretov√°no
  jako [4m≈ôetƒõzec[24m. tedy 001 a d√°le. Pokud by ƒç√≠slov√°n√≠ str√°nek p≈ôes√°hlo
  nastaven√Ω poƒçet ƒç√≠sel, bude upraven dle maxim√°ln√≠ho ƒç√≠sla.

[3mUk√°zkov√© vzory : a v√Ωsledn√Ω efekt..[23m
   soubor-0000 : soubor-0001.djvu .. soubor-0123.djvu
   soubor_0    : soubor_1.djvu    .. soubor_123.djvu
   soubor000   : soubor0001.djvu  .. soubor1234.djvu
"""
			;;
		suffix) echo """
[1mParametr[0m
         -e|--ext  <[2msuffix[22m>  P≈ô√≠pona soubor≈Ø, ze kter√Ωch se m√° sestavit 
                                DjVu soubor.
[4mPopis:[24m
  [2mSuffix[22m je nutn√© uv√©st pouze v p≈ô√≠padƒõ, ≈æe soubory s n√°zvem odpov√≠daj√≠c√≠m
  vzorku dosud nebyly do DjVu zkonvertov√°ny. Jinak se v≈ædy p≈ôedpokl√°d√°, ≈æe
  se bude pracovat s ji≈æ konvertovan√Ωmi DjVu soubory.

  Je-li [2msuffix[22m uveden, budou konvertov√°ny soubory vyhovuj√≠c√≠ vzorku.
  Pokud nƒõkter√© z nich ji≈æ konvertov√°ny byly, tak se se f√°ze konverze
  p≈ôeskoƒç√≠. Pracuje se pak s ji≈æ existuj√≠c√≠m DjVu souborem.

  Konvertov√°ny jsou pouze soubory, kter√© chyb√≠. Kvalitu konverze lze
  ovlivnit  dal≈°√≠mi parametry. Maj√≠-li b√Ωt soubory p≈ôekonvertov√°ny znovu,
  lze si to vynutit parametrem -f (--force) a st√°vaj√≠c√≠ soubory  p≈ôepsat.

  Akceptovan√© sufixy: 
     djvu (default), jpg, gif, png, bmp, pnm, pbm, pgm.
  V√≠cevrstv√© soubory:
     xcf, tiff, pdf 
"""
			;;
		value) echo """  VALUE - is normal text string in quotes"""
		;;
		verbose) echo """volbu [1m-v[0m ([1m--verbose[0m)
  Prost≈ôednictv√≠m t√©to volby si lze p≈ôesmƒõrovat v√Ωstup dopl≈àuj√≠c√≠ch
  informaƒçn√≠ch v√Ωpis≈Ø na konzoli. D√≠ky nim pak lze podrobnƒõ sledovat
  postup skriptu p≈ôi zpracov√°n√≠ souboru

  [1m${0##*/}[0m ... {-v|--verbose} ...
"""
		;;
		xml) echo """volba [1m-x[0m ([1m--xml[0m)

  Extrakce skryt√© textov√© vrstvy DjVu str√°nky ve form√°tu XML.
  Parametrem lze zvolit, co se m√° p≈ôi akci [2mexport[22m ulo≈æit.

  [1m${0##*/}[0m ... {-d|--dsed} [yes|no|all|txt|ant] ...
  
         yes - stejn√Ω efekt jako volba all
         no  - textov√° vrstva se neexportuje (default)
         all - exportuje se cel√Ω obsah skryt√© textov√© vrstvy
         txt - exportuje se pouze obsah str√°nky
         ant - exportuj√≠ se meta atributy str√°nky

[4mPozn√°mka:[24m
  * Pokud za volbou nen√≠ uveden ≈æ√°dn√Ω dal≈°√≠ parametr, tak se automaticky
    p≈ôedpokl√°d√° - yes.
  * V√Ωchoz√≠ parametr - no - lze implicitnƒõ zmƒõnit nastaven√≠m promƒõnn√©
    XML do souboru v adres√°≈ôi ${HOME}/.config/${NAME}/
  * Exportovan√° data se ukl√°daj√≠ do soubor≈Ø s p≈ô√≠ponou [3m.xml[23m.

[1mPozor:[0m  P≈ôi exportu do XML nelze podchytit v≈°echny meta atributy!!!
"""
    ;;
    xmp) echo """Nastaven√≠ XMP

  Na rozd√≠l od EXIF tag≈Ø, kter√© lze nastavovat postupnƒõ jako metadatov√© kl√≠ƒçe,
  jsou XMP atributy ulo≈æeny ve speci√°ln√≠m metadatov√©m kl√≠ƒçi XMP, kter√Ω mus√≠
  b√Ωt v r√°mci str√°nky v≈ædy jedineƒçn√Ω.

  N√°sleduj√≠c√≠ uk√°zkov√Ω p≈ô√≠klad demonstruje, jak vypad√° obdobn√° informace
  nastaven√° jako EXIF tag, i jako XMP atribut.

  user@stroj:~$ djvutool soubor.djvu export ant 0
  # 'shared_anno.iff'
  metadata
      Title \"N√°zev dokumentu\"
  xmp
      <rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\">
      <rdf:Description rdf:about=\"\">
      <dc:title xmlns:dc=\"http://purl.org/dc/elements/1.1/\">N√°zev dokumentu
      </dc:title>
      </rdf:Description>
      </rdf:RDF>

"""
    ;;
    *) echo "N√°povƒõda pro $1 nebyla dosud implementov√°na" >> /dev/stderr
        return 1
    ;;
    esac
}

# ### <span id="djvuview">djvuview()</span> ([top](#FUNCTIONS))
# Funkce na z√°kladƒõ p≈ôedan√©ho jm√©na (parametr __$1__) a zvolen√Ωch
# enkodovac√≠ch algoritm≈Ø otev≈ôe prohl√≠≈æeƒç DjVu soubor≈Ø, aby bylo mo≈æn√©
# prov√©st vizu√°ln√≠ srovn√°n√≠ kvality zkonvertovan√Ωch soubor≈Ø
djvuview() {
    log goto "djvuview() Open ‚Äì> $@"
    while [ $# -gt 0 ] ; do
        local TYPE=$(mimefile "${1}")
        case "${TYPE}" in
            djvu) (${DJVIEW} "${1}" &) ;;
            *) echo "File ${1} is not DjVu file" >> /dev/stderr ;;
        esac
        shift
    done
}

# Zpracov√°n√≠ parametr≈Ø p≈ôedan√Ωch p≈ôi startu skriptu
main() {
case $# in
    0) help  && return 0
esac
while [ $# -gt 0 ]
do
    case ${1} in
        coords) case "$@" in
                coords+([[:blank:]])+([[:digit:]])+([[:blank:]])+([[:digit:]])+([[:blank:]])+([[:digit:]])+([[:blank:]])+([[:digit:]]))
                echo "${2} ${3} $((${4} - ${2})) $((${5} - ${3}))"
                ;;
                coords+([[:blank:]])+([[:digit:]]),+([[:digit:]]),+([[:digit:]]),+([[:digit:]]))
                # LEFT,TOP,SIRKA,VYSKA
                local TEMP=(${@//,/ })
                echo "${TEMP[3]},${TEMP[4]},${TEMP[1]#*+([[:blank:]])},${TEMP[2]}"
                ;;
                coords+([[:blank:]])+([[:digit:]])x+([[:digit:]])\++([[:digit:]])\++([[:digit:]]))
                #SIRKAxVYSKA+LEFT+TOP
                local TEMP=(${@//[x+]/ })
                echo "${TEMP[3]},${TEMP[4]},${TEMP[1]#*+([[:blank:]])},${TEMP[2]}"
                ;;
            esac
            return 0
        ;;
        exif|xmp) help ${1}
            return 0
        ;;
        help) echo "Otev≈ô√≠t ke ƒçten√≠ extern√≠ manu√°l"
            return 0
        ;;
        -a|--algorithm) #/ Volba pro akci insert
            #/ Nen√≠-li uveden ≈æ√°dn√Ω kompresn√≠ algoritmus, je aplikov√°no
            #/ v√Ωchoz√≠ nastaven√≠ promƒõnn√© $ALG z konfigurace"
            case ${2} in
                -h|--help) help algorithm
                    exit 0
                    ;;
                *) for i in ${2//;/ } ; do
                    if [[ ${ALGORITHM[@]} =~ (^|[^[:alpha:]])${i%:*}([^[:alpha:]]|$) ]] ; then
                        log info "main() Verify algorithm $i ‚Äì> OK"
                    else
                        printf "Algorithm %s isn't supported\n" "$i" 1>&2
                        exit 0
                    fi
                    done
                    ALG=(${2//;/ })
                    log set "main() Compression algorithm ‚Äì> ${ALG[@]}"
                    shift && shift
                    ;;
            esac
            ;;
        -d|--dsed) # Volba pro akci export
            case ${2} in
                -h*|--help*) help dsed && exit 0
                    ;;
                yes|no|txt|ant|all) DSED=${2}
                    log info "main() Aplikuji pro DSED parametr - ${DSED}"
                    shift && shift
                    ;;
                *) log warn "main() Nebyl uveden ≈æ√°dn√Ω parametr, aplikuji pro DSED parametr - yes"
                    DSED="yes"
                    shift
                    ;;
            esac
            ;;
        --dpi) # Volba pro akci insert
            case ${2} in
                -h*|--help*) help dpi && exit 0
                    ;;
                [[:digit:]])
                    if [ "${2}" -ge "72" ] && [ "${2}" -le "6000" ] ; then
                        DPI="${2}"
                        log info "main() Aplikuji pro DPI parametr - ${DPI}"
                        shift && shift
                    else
                        echo "Hodnota u volby --dpi se mus√≠ pohybovat v rozmez√≠ od 72 do 6000" >> /dev/stderr
                        exit 1
                    fi
                    ;;
                *) echo "Nebyla uvedena hodnota dpi. Pokud chcete volbou --dpi zmƒõnit v√Ωchoz√≠ hodnotu (300), mus√≠te ji uv√©st jako ƒç√≠seln√Ω parametr" >> /dev/stderr
                    exit 1
                    ;;
            esac
            ;;
        -f|--force)
            case ${2} in
                -h*|--help*) help force && exit 0
                    ;;
                yes|no|skip) FORCE=${2}
                    log info "main() Aplikuji pro FORCE parametr - ${FORCE}"
                    shift && shift
                    ;;
                *) log warn "main() Nebyl uveden ≈æ√°dn√Ω parametr, aplikuji pro FORCE parametr - skip"
                    FORCE="yes"
                    shift
                    ;;
            esac
            log set "main() FORCE ‚Äì> ${FORCE}"
            ;;
        --clean) LEVEL="--loss-level=1" && shift
            ;;
        --lossy) LEVEL="--loss-level=100" && shift
            ;;
        --lossless) LEVEL="--loss-level=0" && shift
            ;;
        --level) # Volba pro akci insert
            case ${2} in
                -h*|--help*) help force && exit 0
                    ;;
                [[:digit:]])
                    if [ "${2}" -ge "0" ] && [ "${2}" -lt "200" ] ; then
                        LEVEL="--loss-level=${2}"
                        log info "main() Aplikuji pro LEVEL hodnotu - ${LEVEL}"
                        shift && shift
                    else
                        help level && exit 0
                    fi
                    ;;
                *) echo "main() Volba --loss-level mus√≠ m√≠t v≈ædy uvedenou ƒç√≠selnou hodnotu v rozmez√≠ 0-199" >> /dev/stderr
                    exit 1
                    ;;
            esac
            log info "main() √örove≈à ztr√°tovosti p≈ôi kompresi ${LEVEL}"
            ;;
        -i|--image) # Volba pro akci export
            case "${2}" in
                -h*|--help*) help image && exit 0
                    ;;
                yes|no|color|black|foreground|background|mask)
                    IMG="${2}"
                    log info "main)) Aplikuji pro IMG parametr - ${IMG}"
                    shift && shift
                    ;;
                *) log warn "main() Nebyl uveden ≈æ√°dn√Ω parametr, aplikuji pro IMG parametr - yes"
                    IMG="yes"
                    shift
                    ;;
            esac
            ;;
        -m|--meta) # Volba pro akci export
            case "${2}" in
                -h*|--help*) help meta && exit 0
                    ;;
                yes|no) META="${2}"
                    log info "main() Aplikuji pro META parametr - ${META}"
                    shift && shift
                    ;;
                *) META="yes"
                    log warn "main() Nebyl uveden ≈æ√°dn√Ω parametr, aplikuji pro META parametr - yes"
                    shift
                    ;;
            esac
            ;;
        -o|--ocr) # Volba pro akci insert
            case "${2}" in
                -h*|--help*) help ocr
                    ${TESSERACT} --list-langs 2>&1 | sed -n '1!p'
                    exit 0
                    ;;
                *)
#			echo $(${TESSERACT} --list-langs 2>&1 | sed '1d;x') >> /dev/stderr
                for i in ${2//+/ } ; do
                    local TEST="no"
                    local OCR=(${i//:/\ })
                    if [ "${#OCR[@]}" -eq 2 ] ; then
                        # ${OCR[0]} engine
                        # ${OCR[1]} jazyk
                        case "${OCR[0]:0:1}" in
                            c) CUNEIFORM=$(command -v cuneiform)
                                [ ! -x "${CUNEIFORM}" ] && exit 31
                                if [ "${OCR[1]}" == "?" ] ; then
                                    ${CUNEIFORM} -l
                                    exit 0
                                else
                                    local LANGUAGES=($(${CUNEIFORM} -l | grep languages | sed 's/^[a-Z ]*://'))
                                    if [[ ${LANGUAGES[@]} =~ (^|[^[:alpha:]])$y([^[:alpha:]]|$) ]] ; then
                                        OCRLANG=$y && local TEST="yes"
                                        log info "main() OCR lang ‚Äì> $y"
                                    fi
                                fi
                                ;;
                            t) TESSERACT=$(command -v tesseract)
                                [ ! -x "${TESSERACT}" ] && exit 31
                                if [ "${OCR[1]}" == "?" ] ; then
                                    ${TESSERACT} --list-langs
                                    exit 0
                                else
                                    local LANGUAGES=($(${TESSERACT} --list-langs 2>&1 | sed -n '1!p'))
                                    if [[ ${LANGUAGES[@]} =~ (^|[^[:alpha:]])$y([^[:alpha:]]|$) ]] ; then
                                        OCRLANG=$y && local TEST="yes"
                                        log info "main() OCR lang ‚Äì> $y"
                                    fi
                                fi
                                ;;
                            *) help keywords-convert-ocr
                                exit 0
                                ;;
                        esac
                    elif [ "${#OCR[@]}" -eq 1 ] ; then
                        # ${OCR[0]} jazyk
                        # v√Ωchoz√≠ engine je tesseract
                        TESSERACT=$(command -v tesseract)
                        [ ! -x "${TESSERACT}" ] && exit 31
                        if [ "${OCR[0]}" == "?" ] ; then
                            ${TESSERACT} --list-langs
                            exit 0
                        else
                            local LANGUAGES=($(${TESSERACT} --list-langs 2>&1 | sed -n '1!p'))
                            if [[ ${LANGUAGES[@]} =~ (^|[^[:alpha:]])$y([^[:alpha:]]|$) ]] ; then
                                OCRLANG=$y && local TEST="yes"
                                log info "main() OCR lang ‚Äì> $y"
                            fi
                        fi
                    else
                        help keywords-convert-ocr
                        exit 0
                    fi
                    echo "OCR ${#OCR[@]}" >> /dev/stderr
                    echo "OCRLANG ${OCRLANG}" >> /dev/stderr
                    echo "TESSERACT ${TESSERACT}" >> /dev/stderr
                    echo "CUNEIFORM ${CUNEIFORM}" >> /dev/stderr
                    if [ "${TEST}" == "no" ] ; then
                        echo "Pro OCR engine $i nen√≠ nainstalovan√°jazykov√° podpora" >> /dev/stderr
#					exit 1
                    fi
                done

                if [ "${TEST}" == "yes" ] ; then
                    OCR="${2%%+([[:blank:]])}"
                    log info "main() Aplikuji pro OCR parametr - ${OCR}"
                    shift && shift
                else
                    OCR="${OCR=ces}"
                    echo "Nebyl uveden ≈æ√°dn√Ω parametr, pro OCR pou≈æiji v√Ωchoz√≠ jazyk - ${OCR}" >> /dev/stderr
#				exit 1
                    shift
                fi
                ;;
            esac
            ;;
        -p|--page) # Volba pro akci export
            case "${2}" in
                -h*|--help*) help page && exit 0
                    ;;
                yes|no) PAGE="${2}"
                    log info "main() Aplikuji pro PAGE parametr - ${PAGE}"
                    shift && shift
                    ;;
                *) log warn "main() Nebyl uveden ≈æ√°dn√Ω parametr, aplikuji pro PAGE parametr - yes"
                    PAGE="yes"
                    shift
                    ;;
            esac
            ;;
        -r|--rename) # Nastaven√≠ vzoru pro pojmenov√°n√≠ str√°nek p≈ôi akc√≠ch rename, fore a back
            case "${2}" in
                -h*|--help*) help rename && exit 0
                ;;
                *) if [ "${2##+([[:alnum:]%_-])}" == "" ] ; then
                    RENAME="${2}"
                    log info "main() Aplikuji pro RENAME parametr - ${RENAME}"
                    shift && shift
                else
                    echo "main() FAIL - pattern '${VALUE}' for rename is is not acceptable." >> /dev/stderr
                    exit 1
                fi
            ;;
            esac
        ;;
        -t|--thumb) # Volba pro akci insert
            case "${2}" in
                -h*|--help*) help thumb && exit 0
                    ;;
                *) if [ "${2//+([[:digit:]])}" == "" ] ; then
                        if [ "${2}" -ge "32" ] && [ "${2}" -le "256" ] ; then
                            THUMB="${2%%+([[:blank:]])}"
                            log info "main() Aplikuji pro THUMB parametr - ${DPI}"
                            shift && shift
                        else
                            echo "Hodnota u volby --thumb se mus√≠ pohybovat v rozmez√≠ od 32 do 256" >> /dev/stderr
                            exit 1
                        fi
                    else
                        echo "Nebyla uvedena hodnota velikosti n√°hledu. Pokud chcete volbou --thumb nastavit v√Ωchoz√≠ hodnotu, mus√≠te ji uv√©st jako ƒç√≠seln√Ω parametr" >> /dev/stderr
                        exit 1
                    fi
                    ;;
            esac
            ;;
        -v*|--verbose*) #/ Zmƒõna v√Ωchoz√≠ hodnoty promƒõnn√© $DEBUG
            case ${1} in
                -v|--verbose)
                    case ${2} in
                        -h|--help|help|\?)
                            help verbose && exit 0
                            ;;
                        [0-9])
                            DEBUG="-d${2}"
                            shift && shift
                            ;;
                        *) DEBUG="-d1"
                            shift
                            ;;
                    esac
                    ;;
                -v[0-9])
                    DEBUG="-d${1:2}"
                    shift
                    ;;
                *=*)
                    case "${1#*=}" in
                        0) shift
                            ;;
                        [1-9]) DEBUG="-d${1#*=}"
                            shift
                            ;;
                        *) help_debug "${1#*=}" && exit 1
                            ;;
                    esac
                    ;;
            esac
            log set "DEBUG ‚Äì> ${DEBUG}"
            ;;
        -x|--xml) # Volba pro akci export
            case "${2}" in
                -h*|--help*) help xml && exit 0
                    ;;
                yes|no|txt|ant|all) XML="${2%%+([[:blank:]])}"
                    log info "main() Aplikuji pro XML parametr - ${XML}"
                    shift && shift
                    ;;
                *) log warn "main() Nebyl uveden ≈æ√°dn√Ω parametr, aplikuji pro XML parametr - yes"
                    XML="yes"
                    shift
                    ;;
            esac
            ;;
            *.[dD][jJ][vV][uU]|\
            *.[gG][iI][fF]|\
            *.[jJ][pP][gG]|\
            *.[jJ][pP]2|\
            *.[zZ][iI][pP]|\
            *.[pP][nN][gG]|\
            *.[pP][nNpPgGaAbB][mM]|\
            *.fore|\
            *.[pP][cC][dD]|\
            *.[mM][nN][gG]|\
            *.[pP][dD][fF]|\
            *.[tT][aA][rR]|\
            *.[tT][iI][fF][fF]|\
            *.[tT][iI][fF]|\
            *.[xX][cC][fF])
                local FILE=$(realpath -P "${1}")
                [ ! -n "${FILE}" ] && echo "Invalid filepath ${1}" && exit 1
                shift
                if [[ ${ACTIONS[@]} =~ (^|[^[:alpha:]])${1}([^[:alpha:]]|$) ]] && [ "?" != "${1}" ]; then
                    ACTION=${1}
                    shift
                    local CHARSTRING="$@"
                    log info "ACTION ‚Äì> ${ACTION}"
                    log info "CHARSTRING ‚Äì> ${CHARSTRING}"
                    break
                else
                    case ${1} in
                        -h|--help|help|?) help actions
                            printf "\t"
                            printf "%s " ${ACTIONS[@]}
                            help keywords
                            return 0
                        ;;
                        *) echo "Neimplementovan√° ekce, nebo parametr ‚Äì> ${1}" >> /dev/stderr
                            return 1
                        ;;
                    esac
                fi
                ;;
        *) if [[ ${ACTIONS[@]} =~ (^|[^[:alpha:]])${1}([^[:alpha:]]|$) ]] && [ "?" != "${1}" ]; then
                ACTION=${1}
                shift
                case ${1} in
                    *.[dD][jJ][vV][uU]|\
                    *.[gG][iI][fF]|\
                    *.[jJ][pP][gG]|\
                    *.[jJ][pP]2|\
                    *.[zZ][iI][pP]|\
                    *.[pP][nN][gG]|\
                    *.[pP][nNpPgGaAbB][mM]|\
                    *.fore|\
                    *.[pP][cC][dD]|\
                    *.[mM][nN][gG]|\
                    *.[pP][dD][fF]|\
                    *.[tT][aA][rR]|\
                    *.[tT][iI][fF][fF]|\
                    *.[tT][iI][fF]|\
                    *.[xX][cC][fF])
                        local FILE=$(realpath -P "${1}")
                        [ ! -n "${FILE}" ] && echo "Invalid filepath ${1}" && exit 1
                        shift
                        local CHARSTRING="$@"
                        log info "main() ACTION ‚Äì> ${ACTION}"
                        log info "main() CHARSTRING ‚Äì> ${CHARSTRING}"
                        break
                    ;;
                    *) echo "${1} ‚Äì Nepodporovan√Ω typ souboru" >> /dev/stderr
                        return 1
                    ;;
                esac
            else
# Smyƒçka se p≈ôeru≈°√≠, pokud nen√≠ p≈ôedan√° ≈æ√°dn√° zn√°m√° akce, ani parametr,
# kter√Ω by byl o≈°et≈ôen pomoc√≠ voleb. Dal≈°√≠ paramtery jsou pak ji≈æ ƒç√≠slov√°ny
# 1, 2, 3 atd..
                case ${1} in
                    -h|--help|help|?) help actions
                        printf "\t"
                        printf "%s " ${ACTIONS[@]}
                        help keywords
                        return 0
                    ;;
                    *) log warn "Neimplementovan√Ω parametr ${1}"
                        help options
                        return 1
                    ;;
                esac
            fi
            ;;
    esac
done


# echo "${ACTION}" >> /dev/stderr
# echo "$@" >> /dev/stderr

FILETYPE=$(mimefile "${FILE}")
if [[ "${CHARSTRING}" =~ "-h" ]] ; then
        if [ -n "${ACTION}" ] ; then
            case ${FILETYPE} in
                djvu) case "${CHARSTRING%%+([[:blank:]])*}" in
                        ant|dsed|meta) help "${ACTION}-${CHARSTRING%%+([[:blank:]])*}"
                        ;;
                        exif|grep|list|pages) help "info-${CHARSTRING%%+([[:blank:]])*}"
                        ;;
                        *) local TEMP=(${CHARSTRING%%+(-)h*})
                            local PROPERTY="${TEMP[@]: -1}"
                            case "${PROPERTY}" in
                                align|\
                                arrow|\
                                backclr|\
                                background|\
                                border|\
                                border_avis|\
                                key|\
                                line|\
                                lineclr|\
                                mode|\
                                none|\
                                note|\
                                outline|\
                                oval|\
                                poly|\
                                pushpin|\
                                rect|\
                                shadow_*|\
                                text|\
                                textclr|\
                                width|\
                                xmp|\
                                xor|\
                                zoom) help set-${PROPERTY}
                                ;;
                                *) help "keywords-${ACTION}"
                                ;;
                            esac
                        ;;
                    esac
                ;;
                *) help "bitmap-${ACTION}"
                ;;
            esac
        else
            help
        fi
        exit 0
fi

case ${FILETYPE} in
    '') echo "${FILE} ‚Äì> invalid path!" >> /dev/stderr
        return 1
    ;;
    djvu) #/ Pracuji se souborem v DjVu form√°tu
        log goto "Actions for DjVu file"
        case "${ACTION}" in
            delete) local TEST=$(isrange "${CHARSTRING}")
                if [ -n "${TEST}" ] ; then
                    #/ Rozsah str√°nek identifikovan√Ωch po≈ôad√≠m
                    RANGE=$(range ${TEST})
                else
                    #/ Seznam str√°nek oddƒõlen√Ωch ƒç√°rkami
                    x=0
                    for i in ${CHARSTRING//,/ } ; do
                       RANGE[$x]=$(identifypage order "${FILE}" "${i}")
                    done
                fi
                #/ Set≈ô√≠dƒõn√≠ RANGE pozp√°tku, 
                for i in $(printf "%d\n" ${RANGE[@]} | sort -nr) ; do
                    deletepage "${FILE}" "${i}"
                    [ $? -eq 1 ] && echo "Page isn't in ${FILE} ‚Äì> $i" >> /dev/stderr && return 1
                done
            ;;
            fore|back) #/ P≈ôesouv√°m
                djvumove "${FILE}" "${CHARSTRING}"
            ;;
            export) #/ Exportuji str√°nku
                log info "main() export from page ${CHARSTRING}"
                fromdjvu "${FILE}" "${CHARSTRING}"
            ;;
            import|edit) #/ Import p≈ôedhozen√©ho souboru a p≈ô√≠padn√° editace jeho obsahu
                # P≈ôed editac√≠ meta informac√≠, je doporuƒçeno zkontrolovat a p≈ô√≠padnƒõ 
                # vyexportovat aktu√°ln√≠ stav, p≈ô√≠kazem
                #
                # djvutool <DJVU soubor> export ant [> aktualni_stav.ant]
                #
                # Pokud chcete m√≠t obarven√Ω v√Ωstup a z√°rove≈à ho ulo≈æit obvarven√Ω do souboru, pou≈æijte n√°sleduj√≠c√≠ kombinaci:
                #
                # ( grc djvutool soubor.djvu export ant | tee >(sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})*)?m//g" > soubor.ant) )
                case "${CHARSTRING}" in
                    ant*) #/ Importuji obsah .ant souboru
                        local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .ant)
                        local ANTFILE="${CHARSTRING#ant+([[:blank:]])}"
                        #/ o≈ôezat mezery p≈ôed a za
                        if [ -f "${ANTFILE}" ] ; then
                            cat "${ANTFILE}" > "${TEMPFILE}"
                        else
                            writefile "${TEMPFILE}"
                            if [ $? -eq 1 ] ; then
                                printf '; Pravidla pro obsah souboru .ant :\n' >> "${TEMPFILE}"
                                printf '; * Glob√°ln√≠ meta informace se p√≠≈°√≠ jako souƒç√°st str√°nky "shared_anno.iff" \n' >> "${TEMPFILE}"
                                printf '; * Str√°nka m≈Ø≈æe b√Ωt identifikov√°na buƒè po≈ôadov√Ωm ƒç√≠slem, nebo jm√©nem\n' >> "${TEMPFILE}"
                                printf '; * Blok meta informac√≠ v≈ædy zaƒç√≠n√° ≈ô√°dkem uvozen√Ωm znakem # za kter√Ωm n√°sleduje identifik√°tor str√°nky (ƒç√≠slo, nebo jm√©no)\n' >> "${TEMPFILE}"
                                printf '; * Text z√°lo≈æky i jej√≠ c√≠l mus√≠ b√Ωt v uvozovk√°ch\n' >> "${TEMPFILE}"
                                printf '; * Ve≈°ker√Ω text na ≈ô√°dc√≠ch zaƒç√≠naj√≠c√≠ch st≈ôedn√≠kem je pova≈æov√°n za koment√°≈ô\n' >> "${TEMPFILE}"
                                printf '; * P≈ôi importu souboru bude zakomentovan√Ω obsah odfiltrov√°n\n' >> "${TEMPFILE}"
                                printf '; * Soubor nesm√≠ konƒçit pr√°zdn√Ωm ≈ô√°dkem!\n' >> "${TEMPFILE}"
                                printf '; * Pokud se do soubory zmƒõny neulo≈æ√≠, tak se vlo≈æ√≠ zpƒõt p≈Øvodn√≠ obsah.\n' >> "${TEMPFILE}"
                                printf ';\n' >> "${TEMPFILE}"
                                printf ';Author "Ale≈° Nov√°k"\n' >> "${TEMPFILE}"
                                printf ';\n' >> "${TEMPFILE}"
                                printf ';; Aktivn√≠ link bez bubliny"\n' >> "${TEMPFILE}"
                                printf ';maparea "https://www.thewoodcraft.org/" ""\n' >> "${TEMPFILE}"
                                printf ';rect 225 0 804 61\n' >> "${TEMPFILE}"
                                printf ';xor\n' >> "${TEMPFILE}"
                                printf ';\n' >> "${TEMPFILE}"
                                printf ';; Aktivn√≠ link s bublinou"\n' >> "${TEMPFILE}"
                                printf ';URL ("https://www.thewoodcraft.org/" "_blank" ) "Odkaz na str√°nky Thewoodcraft.org"\n' >> "${TEMPFILE}"
                                printf ';        (rect 225 0 804 61 )\n' >> "${TEMPFILE}"
                                printf ';        (xor )\n' >> "${TEMPFILE}"
                                printf ';; Aktivn√≠ link s bublinou u textu p≈ôes dva ≈ô√°dky"\n' >> "${TEMPFILE}"
                                printf ';URL ("https://www.thewoodcraft.org/" "_blank" ) "Odkaz na str√°nky Thewoodcraft.org"\n' >> "${TEMPFILE}"
                                printf ';        ("https://www.thewoodcraft.org/" "_blank" ) "Odkaz na str√°nky Thewoodcraft.org"\n' >> "${TEMPFILE}"
                                $0 "${FILE}" export ${CHARSTRING} >> "${TEMPFILE}"
                            fi
                        fi
                        case ${ACTION} in
                            edit)
                                editor "${TEMPFILE}"
                                anone "Ulo≈æit zmƒõny?"
                                [ $? -eq 1 ] && return 1
                            ;;
                        esac
                        local DSEDFILE=$(tempfile -d ${TEMPDIR} -s .dsed)
                        ant2dsed "${TEMPFILE}" > "${DSEDFILE}"
                        if [ $? -eq 1 ] ; then
                            echo "V importovan√©m souboru ${TEMPFILE} je syntaktick√° chyba" >> /dev/stderr
                            exit 33
                        fi
                        ${DJVUSED} "${FILE}" -f "${DSEDFILE}" -s
                        return $?
                    ;;
                    meta*) echo "import from meta file to ${FILE}"
                        echo nil
                        ;;
                    outline*) echo "Importuji z√°lo≈æky"
                        echo "P≈ôijato k importu ${CHARSTRING}"
                        #/ M≈Ø≈æe b√Ωt p≈ôedan√Ω i soubor
                        #/ Nen√≠-li p≈ôedan√Ω soubor, zkus naƒç√≠st stdin
                        local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .outline)
                        local OUTLINEFILE="${CHARSTRING#outline+([[:blank:]])}"
                        #/ o≈ôezat mezery p≈ôed a za
                        if [ -f "${OUTLINEFILE}" ] ; then
                            log info "main() Importuji .outline soubor ${OUTLINEFILE}"
                            cat "${OUTLINEFILE}" > "${TEMPFILE}"
                        else
                            writefile "${TEMPFILE}"
                            if [ $? -eq 1 ] ; then
                                log info "main() Na stdin nebylo nic, p≈ôid√°m z√°hlav√≠ a vyt√°hnu st√°vaj√≠c√≠ z√°lo≈æky"
                                printf '; Pravidla pro obsah souboru .outline :\n' >> "${TEMPFILE}"
                                printf '; * Text z√°lo≈æky i jej√≠ c√≠l mus√≠ b√Ωt v uvozovk√°ch\n' >> "${TEMPFILE}"
                                printf ';  * C√≠l m≈Ø≈æe b√Ωt identifikov√°n buƒè po≈ôadov√Ωm ƒç√≠slem str√°nky, nebo jej√≠m jm√©nem\n' >> "${TEMPFILE}"
                                printf ';  * Identifik√°tor v≈ædy zaƒç√≠n√° znakem #\n' >> "${TEMPFILE}"
                                printf ';  * √örove≈à zano≈ôen√≠ z√°lo≈æky je dan√° odsazen√≠m pomoc√≠ tabel√°toru\n' >> "${TEMPFILE}"
                                printf ';  * Ve≈°ker√Ω text na ≈ô√°dc√≠ch zaƒç√≠naj√≠c√≠ch st≈ôedn√≠kem je pova≈æov√°n za koment√°≈ô\n' >> "${TEMPFILE}"
                                printf ';  * P≈ôi importu souboru bude zakomentovan√Ω obsah odfiltrov√°n\n' >> "${TEMPFILE}"
                                printf ';  * Soubor nesm√≠ konƒçit pr√°zn√Ωm ≈ô√°dkem!\n' >> "${TEMPFILE}"
                                printf ';  * Pokud se do soubory zmƒõny neulo≈æ√≠, tak se vlo≈æ√≠ zpƒõt p≈Øvodn√≠ obsah.\n' >> "${TEMPFILE}"
                                printf ';\n' >> "${TEMPFILE}"
                                printf ';"Link prvn√≠ √∫rovnƒõ" "#1"\n' >> "${TEMPFILE}"
                                printf ';      "Link druh√© √∫rovnƒõ" "#strana-001.djvu"\n' >> "${TEMPFILE}"
                                $0 "${FILE}" info list | sed 's/^/; /' >> "${TEMPFILE}"
                                $0 "${FILE}" export outline >> "${TEMPFILE}"
                            fi
                        fi
#                        echo "Obsah z√°lo≈æek byl zaps√°n do souboru ${TEMPFILE}" >> /dev/stderr
                        case ${ACTION} in
                            edit) editor "${TEMPFILE}"
                            ;;
                        esac
#                        lig info "main() Importuji soubor .outline ${TEMPFILE} do ${FILE}"
#                        local DSEDFILE=$(tempfile -d ${TEMPDIR} -s .dsed)
                        outlinetodjvu "${FILE}" "${TEMPFILE}"
                        if [ $? -eq 1 ] ; then
                            echo "V importovan√©m souboru ${TEMPFILE} je syntaktick√° chyba" >> /dev/stderr
                            exit 33
                        else
                            echo "Z√°lo≈æky byly aktualizov√°ny" >> /dev/stderr
                        fi
                        return 0
                    ;;
                    page*)
                        #/ Importovat lze jednu str√°nku i soubor
                        #/ Importuje se na urƒçitou pozici
                        local TEMP="${CHARSTRING#page+([[:blank:]])}"
                        local RANGE=$(isrange "${TEMP}")
                        case "${RANGE}" in
                            +([[:digit:]]))
                                local DJVUFILE=$(${REALPATH} -m -P "${TEMP#${RANGE}+([[:blank:]])}")
                            ;;
                            *) if [ -n "${RANGE}" ] ; then
                                    echo "P≈ôi importu nelze pou≈æ√≠t rozsah." >> /dev/stderr
                                    return 1
                                else
                                    local DJVUFILE=$(${REALPATH} -m -P "${TEMP}")
                                fi
                            ;;
                        esac
                        if [ -f "${DJVUFILE}" ] ; then
                            if [ -n "${RANGE}" ] ; then
                                anone "Opravdu vlo≈æit soubor ${DJVUFILE} na pozici ${RANGE}?"
                                [ $? -eq 1 ] && return 1
                                ${DJVM} -i "${FILE}" "${DJVUFILE}" "${RANGE}"
                            else
                                anone "Opravdu p≈ôipojit soubor ${DJVUFILE}?"
                                [ $? -eq 1 ] && return 1
                                ${DJVM} -i "${FILE}" "${DJVUFILE}"
                            fi
                        else
                            echo "Neplatn√° cesta k souboru ‚Äì> ${DJVUFILE}" >> /dev/stderr
                            return 1
                        fi
                        return $?
                    ;;
                    *) help keyword-${CHARSTRING%% *}
                    ;;
                esac
            ;;
            info) djvuinfo "${FILE}" "${CHARSTRING}"
            ;;
            rename) #/ P≈ôejmenov√°v√°m str√°nky
                djvurename "${FILE}" "${CHARSTRING}"
            ;;
            rotate) #/ Ot√°ƒç√≠m str√°nku
                djvurotate "${FILE}" "${CHARSTRING}"
            ;;
            set|unset) setdjvu  "${FILE}" "${CHARSTRING}"
            ;;
            sign) signature "${CHARSTRING}"
            ;;
            view) viewdjvu
            ;;
        esac
        return $?
    ;;
    *) log info "Input bitmap file (or archive) ${FILE} in format ‚Äì> ${FILETYPE}"
        case ${ACTION} in
            export) exportimg
            ;;
            info) infoimg
            ;;
            view) viewimg
            ;;
            set) log info "main() set exif tag in img ${FILE} ‚Äì> ToDo"
            ;;
            unset) log info "main() unset exif tag in ${FILE} ‚Äì> ToDo"
            ;;
            rotate) log info "main() rotate ${FILE}"
            ;;
            rename) log info "main() rename ${FILE}"
            ;;
            import) echo '''Pokud n√°sleduje djvu soubor'''
                echo '''Pokud n√°sleduje adres√°≈ô'''
                echo '''to je existuj√≠c√≠ soubor typu bundle a:
- nen√°sleduje ≈æ√°dn√Ω dal≈°√≠ existuj√≠c√≠ soubor typu djvu, nebo adres√°≈ô
    a z√°rove≈à existuje $DIRECTORY, pak to znamen√° ≈æe se m√° rozbalit
    - pokud n√°sleduje dal≈°√≠ soubor, pak to znamen√° ≈æe se m√° nƒõjak√Ωm zp≈Øsobem s t√≠mto dal≈°√≠m souborem nalo≈æit. Je-li to:
    - djvu soubor, m√° se p≈ôipojit
    - xml soubor, m√° se vlo≈æit
    - soubor typu dsed m√° se zpracovat
    - jin√Ω soubor - obr√°zek, kter√Ω se m√° p≈ôev√©st a vlo≈æit
    '''
                log info "main() import ${FILE} into DjVu"
                case ${FILETYPE} in
                    djvu) echo "Konvertovat vstupn√≠ soubor a vlo≈æit do p≈ôedchozen√©ho DjVu souboru - TODO" >> /dev/stderr
                        #/ Sestavit z nich soubor typu bundle
                        ;;
                    gif) #/ m≈Ø≈æe b√Ωt m√≠t v√≠ce vrstev 'Animation frames
                        ;;
                    mng) #/ m≈Ø≈æe b√Ωt m√≠t v√≠ce vrstev 'Animation frames'
                        ;;
                    png) #/ m≈Ø≈æe b√Ωt m√≠t v√≠ce vrstev 'Animation frames'
                        ;;
                    gimp|xcf) #/m≈Ø≈æe m√≠t v√≠ce vrstev
                        ;;
                    tiff) #/ m≈Ø≈æe m√≠t v√≠ce str√°nek
                        ;;
                    pdf) #/ m≈Ø≈æe m√≠t v√≠ce str√°nek
                        ;;
                    xml|XML) #/ imporuji soubor s textovou vrstvou
                        ;;
                    unknown) echo "Pokud je soubor ${1} typu DjVU, m≈Ø≈æe j√≠t o tzv. SecureDjVu form√°t, kter√Ω m√° kryptovan√© vrstvy. S takov√Ωm souborem nelze s opensource n√°stroji pracovat." >> /dev/stderr
                        exit 1
                        ;;
                    *) echo "Z√°le≈æ√≠ na typu " >> /dev/stderr
                    ;;
                esac
            ;;
        esac
    ;;
esac
}

main "$@"

exit 0
