#!/bin/bash
# -*- mode: sh -*-

# https://elpa.gnu.org/packages/djvu.html
# djvutool - tool for conversion and work with DjVu files
#
# Author: Aleš Kapica <kapica@fel.cvut.cz>, 2015-2016
#
# Použití...
# convertor [test] image
#	provede testovací konverzi pro všechny dostupné separační algoritmy didjvu
shopt -s extglob

# Changelog
# - ošetřena situace, kdy není nainstalován ocrodjvu
# - ošetřit situaci, kdy soubor neobsahuje žádný textový obsah a soubor dsed, ani xml neexistuje
# - mezi klíčové operace přidáno delete a insert
# - OCR zpracované do samostatné funkce
# - výchozí algoritmus djvu; testovací konverze pro všechny algoritmy se
#   provede pouze je-li uveden parametr --test-conversion
# - implementována rotace stránky
# - implementovány přesuny stránek (akce fore a back)
# - implementováno generování náhledů do exportu
# - upraveny funkce pro export náhledů a souborů textové vrstvy
# - akce 'delete' odstraňuje stránky
# - akce 'fore' a 'back' přesouvají stránky podle udaných parametrů
# - akce 'unset outline' umožňuje odstraňovat záložky na základě čísla řádky
# - akce 'set outline' dovoluje vložit záložku z příkazové řádky
# - do akce 'export' byla přidána možnost interaktivní volby
# - akce 'print outline', 'edit outline', 'export outline', 'convert outline', 'convert bookmarks'

# Otestovat
# - export ze single-page dokumentu
#

# ToDo
# Doplnit nové funkce do wiki souboru
# Opravit akci edit meta - dočasný soubor je někde v pytli - binec dělá asi realpath nebo co..
# implementovat kontrolu do funkce todjvu, aby nedocházelo k nekontrolovatelnému vkládání již existujících stránek
# - přidat kontrolu do akce insert na duplicitní soubory při vkládání
#   vícestránkových DjVu souborů. to ovšem bude vyžadovat samostatnou
#   funkci...
# - dopsat manuál pro akci set, argumenty, xmp, atp.
# - implementovat import
# doplnit nápovědu k rotaci stránky (akce rotate)
# opravit volby --algoritmus a --view
NAME="djvutool"
[ -d "${HOME}/.config/${NAME}" ] &&	. ${HOME}/.config/${NAME}/* &>>/dev/null

DEBUG="-d0"
LOG="${LOG=/dev/null}"
XML="${XML=no}"
DPI="${DPI=300}"
DSED="${DSED=no}"
PAGE="${PAGE=no}"
META="${META=no}"
IMG="${IMG=no}"
INDIRECT="${INDIRECT=no}"
FORCE="${FORCE=skip}"
RENAME="no"
EXTENSION=".djvu"
THUMBNAIL="${THUMBNAIL=no}"
INSERTTEXT="${INSERTTEXT=no}"
ALG="${ALG=djvu}"
EXTRACTPAGE="${EXTRACTPAGE=no}"
IMGPAGE="${IMGPAGE=no}"
ALGORITHM=( abutaleb bernsen brink djvu niblack otsu sauvola shading-subtraction )
TABS="8"

trap '''CHYBA=$? ;
case $CHYBA in
 10) echo "Žádná sdílená metadata"
 ;;
 20) echo "Není nainstalován balík djvu-tools"
 ;;
 21) echo "ERROR: mimetype - tool for detection type of image"
 ;;
 22) echo "ERROR: readlink - tool for detection absolute path of directory"
 ;;
 23) echo "ERROR: netpbm-sf - pack of utilities for image conversions not installed "
 ;;
 24) echo "ERROR: imagemagick - tool for image convert is not installed"
 ;;
 25) echo "ERROR: xmlstarlet - tool for work with xml not installed"
 ;;
 26) echo "ERROR: xcftools - tool for work with xcf file (GIMP) not installed"
 ;;
 31) echo "Není nainstalován balík ocrodjvu, na djvu soubory nelze aplikovat OCR. Buďto jej doinstalujte, nebo odstraňte z příkazové řádky parametr -o (--ocr)" >> /dev/stderr
 ;;
 32) echo "Pokud má při operaci zpracovat do DjVu bitmapový soubor, je třeba uvést na příkazové řádce parametrem -a jaký se má použít algoritmus. Jaké parametry lze použít se dozvíte pokud místo jména algoritmu napíšete znak ?" >> /dev/stderr
 ;;
 33) NORMDIR=yes
 ;;
 38) echo "ERROR - identifikátor stránky není platný!" >> /dev/stderr
 ;;
esac
[ $NORMDIR ] || rm -rf -- "$TEMPDIR"
exit $CHYBA
''' EXIT

TEMPDIR=$(mktemp -d -p /tmp ${NAME}-XXX) || exit 1

#=== testy závislostí ===
# Dependencies:
#   * feh      ( http://feh.finalrewind.org/ )
#   * exiftool ( http://www.sno.phy.queensu.ca/~phil/exiftool ) in Debian package: libimage-exiftool-perl 
#   * yad      ( http://sourceforge.net/projects/yad-dialog )
REALPATH=$(which realpath)
[ ! ${REALPATH} ] && exit 1
REALPATH="$REALPATH -e "

DIDJVU=$(which didjvu)
[ ! ${DIDJVU} ] && echo 'Není nainstalován balík didjvu, nebude možné aplikovat pokročilé algoritmy pro separaci popředí při konverzi do DjVu' >> /dev/stderr && DIDJVU=false
OCRODJVU=$(which ocrodjvu)
[ ! ${OCRODJVU} ] && OCRODJVU=31
DJVIEW=$(which djview)
[ ! ${DJVIEW} ] && echo 'Není nainstalován balík djview, nebude fungovat testovací zobrazení djvu.souborů' >> /dev/stderr && DJVIEW=false
DDJVU=$(which ddjvu)
[ ! ${DDJVU} ] && exit 20
DJVUTXT=$(which djvutxt)
[ ! ${DJVUTXT} ] && exit 20
DJVUSED=$(which djvused)
[ ! ${DJVUSED} ] && exit 20
DJVUTOXML=$(which djvutoxml)
[ ! ${DJVUTOXML} ] && exit 20
DJVUXMLPARSER=$(which djvuxmlparser)
[ ! ${DJVUXMLPARSER} ] && exit 20
DJVMCVT=$(which djvmcvt)
[ ! ${DJVMCVT} ] && exit 20
DJVM=$(which djvm)
[ ! ${DJVM} ] && exit 20
CJB2=$(which cjb2)
[ ! ${CJB2} ] && exit 20
DJVUMAKE=$(which djvumake)
[ ! ${DJVUMAKE} ] && exit 20
#YAD=$(which yad)
#[ ! ${YAD} ] && echo 'Není nainstalován balík yad' && exit 1
MIME=$(which mimetype)
[ ! -x "${MIME}" ] && exit 21
STAT=$(which readlink)
[ ! -x "${STAT}" ] && exit 22
EXIFTOOL=$(which exiftool)
[ ! -x "${EXIFTOOL}" ] && exit 23
# Přesunuto do funkce main k volbě -o|--ocr
#TESSERACT=$(which tesseract)
#[ ! -x "${TESSERACT}" ] && exit 31
IDENTIFY=$(which identify)
[ ! -x "${IDENTIFY}" ] && echo exit 24
CONVERT=$(which convert)
[ ! -x "${CONVERT}" ] && echo exit 24
XCFINFO=$(which xcfinfo)
[ ! -x "${XCFINFO}" ] && echo exit 26
XCF2PNM=$(which xcf2pnm)
[ ! -x "${XCF2PNM}" ] && echo exit 26



NETPBM=0
PNMSCALE=$(which pnmscale)
[ ! -x "${PNMSCALE}" ] && NETPBM=1
if (( $NETPBM == 0 )); then
    VERSION=($(${PNMSCALE} -version 2>&1 | head -1))
    case ${VERSION[$((${#VERSION[@]} - 1))]} in
	9*) echo "WARNING: Version Netpbm pnmscale don't support filters. I must use imagemagick convert" >> /dev/stderr
	    NETPBM=1
	    ;;
	*)  NETPBM=0
	    BMPTOPNM=$(which bmptopnm)
	    [ ! -x "${BMPTOPNM}" ] && exit 23
	    JPEGTOPNM=$(which jpegtopnm)
	    [ ! -x "${JPEGTOPNM}" ] && exit 23
	    GIFTOPNM=$(which giftopnm)
	    [ ! -x "${GIFTOPNM}" ] && exit 23
	    PNGTOPNM=$(which pngtopnm)
	    [ ! -x "${PNGTOPNM}" ] && exit 23
	    PNMTOJPEG=$(which pnmtojpeg)
	    [ ! -x "${PNMTOJPEG}" ] && exit 23
	    TIFFTOPNM=$(which tifftopnm)
	    [ ! -x "${TIFFTOPNM}" ] && exit 23
	    PNMTOPNG=$(which pnmtopng)
	    [ ! -x "${PNMTOPNG}" ] && exit 23
	    PNMTOPLAINPNM=$(which pnmtoplainpnm)
	    [ ! -x "${PNMTOPLAINPNM}" ] && exit 23
	    PPMTOPGM=$(which ppmtopgm)
	    [ ! -x "${PPMTOPGM}" ] && exit 23
	    PGMTOPBM=$(which pgmtopbm)
	    [ ! -x "${PGMTOPBM}" ] && exit 23
	    ;;
    esac
fi
if (( $NETPBM == 1 )) ; then
    CONVERT=$(which convert)
    [ ! -x "${CONVERT}" ] && echo exit 24
fi

#=== konec testu závislostí ===

## Pomocné funkce...
function xtabs {
	# $1 - count of tabs
	# return string of tabs
	local TAB=$1
	while [ ! $TAB -eq 0 ] ; do
		printf '\t'
		TAB=$(( $TAB - 1 ))
	done 
}

function tabs {
	# $1 - file with tabs
	local TAB=$(printf '%.0s\ ' {0..${TABS}})
	sed "s/\t/${TAB}/g" "${1}"
}

# ### <span id="log">log()</span> ([top](#FUNCTIONS))
# Je-li použita volba `-d` nebo `--debug`, nastaví funkce [main](#main)
# do globální proměnné [$DEBUG](#$DEBUG) řetězcovou hodnotu, která určuje
# kam se budou zprávy předané této funkci posílat. Ta je tvořená řetězcem
# `-d` a číslem. Jakž bude mít toto číslo efekt viz
# [Parametry pro debug](#debug-levels).
#
# První položka, předaná této funkci jako parametr __$1__, určuje
# závažnost zprávy. Ostatní předané položky pak jsou již součástí
# vypisované zprávy.
#
#     log info "Zpráva s informativní hodnotou"
# Informační zprávy obsahují kontrolní výpisy, které informují o průběhu
# zpracování akce skriptem
#
#     log warn "Zpráva, co upozorňuje že by něco nemuselo klapnout"
# Upozorňující zprávy se používají při operacích, které mohou představovat
# problém. Kupř. když skript realizuje nevratný krok. Modelovým příkladem
# takové situace je zpracování příkazu [___delete___](#delete-command-config)
# při akci [__config__](#config), při kterém se odstraňují všechny
# konfigurační soubory pro VM, ze všech hostitelů.
#
#     log err "Zpráva, která oznamuje chybu"
# Chybové zprávy popisují stavy, které mají návratový kód __1__
#
# #### <span id="debug-levels">Parametry pro debug</span>
# Výchozí hodnota pro [$DEBUG](#$DEBUG) je __0__ při které se nevypisuje
# nic. Doporučená úroveň pro ladění skriptu je __7__. A pro normální
# použití, v případě že je skript spravován kupř. přes `cron` __5__.
#
# 1. Vypisuje pouze chybové (ERR) zprávy pouze na standardní chybový výstup
# 2. Zapisuje pouze do logu a pouze chybové (ERR) zprávy
# 3. Vypisuje chybové (ERR) zprávy na standardní výstup a zároveň je
#    zapisuje do logu
# 4. Vypisuje chybové (ERR) a varovné (WARN) zprávy pouze na standardní
#    chybový výstup
# 5. Zapisuje chybové (ERR) a varovné (WARN) zprávy pouze do logu
# 6. Zapisuje chybové (ERR) a varovné (WARN) zprávy na standardní výstup
#    a zároveň je zapisuje do logu
# 7. Vypisuje všechny zprávy pouze na standardní chybový výstup
# 8. Zapisuje všechny zprávy pouze do logu
# 9. Vypisuje všechny zprávy na standardní výstup a zároveň je zapisuje do logu
#
# #### Kde se rozhodně nesmí použít parametr $DEBUG
# Parametr $DEBUG rozhodně nepoužívejte tam, kde se musí zavolat akce na
# vzdáleném stroji přes $SSH a navrácený výstup se má dále zpracovávat.
# Problém spočívá v tom, že SSH s parametrem -t, které se používá pro
# interaktivní práci, přetočí chybový výstup na standardní výstup a tím
# pádem se může vrátit neplatný výsledek.
#
# Typickým příkladem budiž volání akce master. Je-li zavoláno s parametrem
# DEBUG, je výsledek pro další zpracování nepoužitelný!
#
#      local MASTER=$($0 ${DEBUG} master ${PROCESS})
#
# Správně:
#
#      local MASTER=$($0 master ${PROCESS})
#
log() {
    local TIMESTAMP="$(date +%T.%N) $(hostname)"
    local LOG="${LOGDIR}/messages"
    if [ -n "${DEBUG}" ] ; then
        case ${DEBUG} in
            -d0) ;;
            -d1) [ "${1^^}" == "ERR" ] && \
                echo -e "${TIMESTAMP} ${ACTION} ${1^^} ${@:2}" >> /dev/stderr
                ;;
            -d2) [ "${1^^}" == "ERR" ] && \
                echo -e "${TIMESTAMP} ${ACTION} ${1^^} ${@:2}" >> ${LOG}
                ;;
            -d3) [ "${1^^}" == "ERR" ] && \
                echo -e "${TIMESTAMP} ${ACTION} ${1^^} ${@:2}" | \
                tee ${LOG} >> /dev/stderr
                ;;
            -d4) [ "${1^^}" == "ERR" ] || [ "${1^^}" == "WARN" ] && \
                echo -e "${TIMESTAMP} ${ACTION} ${1^^} ${@:2}" >> /dev/stderr
                ;;
            -d5) [ "${1^^}" == "ERR" ] || [ "${1^^}" == "WARN" ] && \
                echo -e "${TIMESTAMP} ${ACTION} ${1^^} ${@:2}" >> ${LOG}
                ;;
            -d6) [ "${1^^}" == "ERR" ] || [ "${1^^}" == "WARN" ] && \
                echo -e "${TIMESTAMP} ${ACTION} ${1^^} ${@:2}" | \
                tee ${LOG} >> /dev/stderr
                ;;
            -d7) echo -e "${TIMESTAMP} ${ACTION} ${1^^} ${@:2}" >> /dev/stderr
                ;;
            -d8) echo -e "${TIMESTAMP} ${ACTION} ${1^^} ${@:2}" >> ${LOG}
                ;;
            -d9) echo -e "${TIMESTAMP} ${ACTION} ${1^^} ${@:2}" | \
                tee ${LOG} >> /dev/stderr
                ;;
            *) help_debug && exit 1
                ;;
        esac
    fi
}
# <span id="help_debug" /> ([top](#FUNCTIONS))
help_debug() {
    echo """Chybné nastavení pro debug –> $1

Pro debug lze použít pouze čísla od 1 do 9. Nastavení lze provést těmito způsoby:

    … -d2 …
    … -d 2 …
    … -d=2 …
    … --debug 2 …
    … --debug=2 …

  0 Je výchozí stav, při kterém se logovací zprávy nevypisují nikam.
  1 Vypisuje pouze chybové (ERR) zprávy pouze na standardní chybový
    výstup.
  2 Zapisuje pouze do logu a pouze chybové (ERR) zprávy.
  3 Vypisuje chybové (ERR) zprávy na standardní výstup a zároveň je
    zapisuje do logu.
  4 Vypisuje chybové (ERR) a varovné (WARN) zprávy pouze na standardní
    chybový výstup.
  5 Zapisuje chybové (ERR) a varovné (WARN) zprávy pouze do logu.
  6 Zapisuje chybové (ERR) a varovné (WARN) zprávy na standardní výstup
    a zároveň je zapisuje do logu.
  7 Vypisuje všechny zprávy pouze na standardní chybový výstup.
  8 Zapisuje všechny zprávy pouze do logu.
  9 Vypisuje všechny zprávy na standardní výstup a zároveň je zapisuje
    do logu.
"""
}

function pushd {
    command pushd "$@" > /dev/null
}

function popd {
    command popd "$@" > /dev/null
}

function potvrdit {
    read -r -p "${1:-Opravdu chcete akci provést? [y/N]} " response
    case $response in
        [yY][eE][sS]|[yY]) 
            true
            ;;
        [aA][nN][oO]|[aA]) 
            true
            ;;
        *)
            false
            ;;
    esac
}

function printtext {
	echo "${#1}" >> /dev/stderr
	echo -e "${@}"
}

function escape_path {
# Zatím nepoužitá
	echo "escape_path $*" >> /dev/stderr
	echo "$*" | sed \
  -e 's/\ /\\\ /g'
}

function extractmaparea {
	if [ $1 == "(maparea" ] ; then
		if [ $2 == "(url" ] ; then
			echo "URL ($3 $4"
			shift && shift && shift && shift
		else
			echo "NOTE $2"
			shift && shift
		fi
		echo -e $@ | sed 's/ (/\n(/g' | sed 's/^/\t/' | sed 's/))/)/'
	fi
}

function createant {
	# $1 - na vstupu je obsah souboru formátu .ant
	# na výstupu je obsah v .dsed formátu
	local IFS_BAK=$IFS
	local IFS=$'\n'
	local TEMP
	local META
	while read line ; do
		if [[ "${line:0:1}" == $'\t' ]] ; then
			TEMP="$TEMP ${line:1}"
			#TEMP="$TEMP${line}"
		elif [[ "${line:0:1}" == $';' ]] ; then
			echo "Komentář - Ignoruji" >> ${LOG}
		elif [[ "${line:0:1}" == $'#' ]] ; then
			local PAGE="${line#* }"
			if [[ "${PAGE%.*}" == "shared_anno" ]] ; then
				printf "select \"%s.iff\"\nset-ant\n" "${PAGE%.*}" >> ${LOG}
			else
				printf "select \"%s.djvu\"\nset-ant\n" "${PAGE%.*}" >> ${LOG}
			fi
		else
			if [[ "${line:0:4}" == $'NOTE' ]] ; then
				[ "${#TEMP}" != "0" ] && echo "$TEMP )"
				TEMP="(maparea ${line//NOTE /}"
			elif [[ "${line:0:4}" == $'URL ' ]] ; then
				[ "${#TEMP}" != "0" ] &&  echo "$TEMP )"
				TEMP="(maparea ${line//URL (/(url }"
			else
				META="$META ( $line )"
			fi
		fi
	done < $1
	[ "${#TEMP}" != "0" ] && echo "$TEMP )"
	echo "(metadata $META )"
	local IFS=$IFS_BAK
	return 0
}

function anttodsed {
	# Funkce převádí obsah .ant souboru na formát .dsed
	# Výstup zapisuje do souborů s příponou .dsed umístěných v cílovém adresáři
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	if [ ! -z "${SOURCE}" ] ; then
		local OBSAH=($(wc -l ${SOURCE}))
		local ITEMS=($(grep -n '^#' ${SOURCE} | awk -F\: '{print $1}'))
		local index=0
		for i in ${ITEMS[@]} ; do
			index=$(( $index + 1 ))
			# soubor...
			local SOUBOR=($(sed -n "${i}p" ${SOURCE}))
			local TEMPFILE="${TEMPDIR}/${SOUBOR['1']%.*}.bak"
			if [ "${SOUBOR['1']%.*}" == "shared_anno" ] ; then
				printf "create-shared-ant; select '%s'\nset-ant\n" "${SOUBOR['1']%.*}.iff" >> ${TEMPFILE//.bak/.dsed}
			else
				printf "select '%s'\nset-ant\n" "${SOUBOR['1']%.*}.djvu" >>  ${TEMPFILE//.bak/.dsed}
			fi
			if [ -z ${ITEMS["$index"]} ] ; then
				sed -n "${i},${OBSAH['0']}p" ${SOURCE} >> ${TEMPFILE}
				createant ${TEMPFILE} | encode >> ${TEMPFILE//.bak/.dsed}
			else
				sed -n "${i},$((${ITEMS["$index"]} - 1))p" ${SOURCE} >> ${TEMPFILE}
				createant ${TEMPFILE} | encode >> ${TEMPFILE//.bak/.dsed}
			fi
			printf "\n\n.\n" >> ${TEMPFILE//.bak/.dsed}
		done
		echo "Soubory jsou uloženy v adresáři ${TEMPDIR}"
	fi
}

function important {
	# $1 - DjVu
	# $2 - .ant file
	# $3 - select parameters
	echo ${1} >> /dev/stderr
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	if [ ! -z "${SOURCE}" ] ; then
		local ANT=$(${REALPATH} -m -P "${2}")
		if [ "$(head -1 -c1 ${ANT})" == "#" ] ; then
			# jdu importovat položky...
			local OBSAH=($(wc -l ${ANT}))
			local ITEMS=($(grep -n '^#' ${ANT} | awk -F\: '{print $1}'))
			local index=0
			for i in ${ITEMS[@]} ; do
				index=$(( $index + 1 ))
				# soubor...
				local SOUBOR=($(sed -n "${i}p" ${ANT}))
				local TEMPFILE="${TEMPDIR}/${SOUBOR['1']%.*}.bak"
				if [ "${SOUBOR['1']%.*}" == "shared_anno" ] ; then
					printf "create-shared-ant; select '%s'\nset-ant\n" "${SOUBOR['1']%.*}.iff" >> ${TEMPFILE//.bak/.dsed}
				else
					printf "select '%s'\nset-ant\n" "${SOUBOR['1']%.*}.djvu" >>  ${TEMPFILE//.bak/.dsed}
				fi
				if [ -z ${ITEMS["$index"]} ] ; then
					sed -n "${i},${OBSAH['0']}p" ${ANT} >> ${TEMPFILE}
					#createant ${TEMPFILE} | encode >> ${TEMPFILE//.bak/.dsed}
				else
					sed -n "${i},$((${ITEMS["$index"]} - 1))p" ${ANT} >> ${TEMPFILE}
					#createant ${TEMPFILE} | encode >> ${TEMPFILE//.bak/.dsed}
				fi
				printf "\n\n.\n" >> ${TEMPFILE//.bak/.dsed}
				if [ "${FORCE}" == "skip" ] ; then
					printf "Při importu budou stávající hyperlinky i meta atributy stránky ${SOUBOR['1']} v souboru '%s' přepsány. Mám pokračovat?\n" "${SOURCE}" >> /dev/stderr
					potvrdit
					echo "${FORCE}" >> /dev/stderr
				else
					echo "${FORCE}" >> /dev/stderr
				fi
			done
		else
			printf "File ${ANT} isn't not in .ant format!" >> /dev/stderr
			exit 1
		fi
	fi
}

function formatdsed {
	# .dsed to .ant
	sed 's/\t/\n/g ; s/(/\n(/g ; s/("/\n\t"/g ; ' | grep -v ^$ | \
	sed '/^(m[ea][tp]a[dr][ae][ta]/! s/^(/\t(/ ; /^\t($/d ; s/) ) )/) )/ ; s/\\/\\\\0/g' | \
	while read line ; do
		case ${line} in
			\(metadata) local TAB=""
				;;
			\(maparea) echo -e "\n"
				local TAB="\t"
			 ;;
			\"*) echo -e "NOTE ${line}"
			;;
			*) if [ "${TAB}" == "\t" ] ; then
					case "${line:0:2}" in
						"(u") echo -e "URL (${line#(url }"
						;;
						*) echo -e "${TAB}${line}"
						;;
					esac
				else
					echo -e "${line//[)(]/}"
				fi
			;;
		esac
	done  | sed 's/) )/)/ ; /^$/d '
}

function printant {
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	TEMPFILE=$(tempfile -d ${TEMPDIR} -s .txt)
	local CHARSET="${2}"
	local RANGE="${CHARSET%%\ *}"
	if identifybundle ${SOURCE} ; then
		if [ "${RANGE}" == "all" ] ; then
			if ${DJVM} -l ${SOURCE} 2>/dev/null | grep SHARED_ANNO &>/dev/null ; then
				printf "# 'shared_anno.iff'\n"
				${DJVUSED} ${SOURCE} -e "select 'shared_anno.iff'; print-ant" | formatdsed
			fi
			for i in $(${DJVM} -l ${SOURCE} | grep PAGE\ # | awk '{print $4}') ; do
				printf "# '%s'\n" "$i"
				${DJVUSED} ${SOURCE} -e "select '$i'; print-ant" | formatdsed
			done
		elif [ "${RANGE//+([[:alpha:]])/}" == "" ] ; then
			if ${DJVM} -l ${SOURCE} 2>/dev/null | grep SHARED_ANNO &>/dev/null ; then
				printf "# 'shared_anno.iff'\n"
				${DJVUSED} ${SOURCE} -e "select 'shared_anno.iff'; print-ant" | formatdsed
			fi
		elif [ "${RANGE}" != "${RANGE/[a-Z]/}" ] ; then
			# zkontrolovat jestli range není seznam stránek
			# tj. obsahuje písmena
			for i in ${RANGE//,/ } ; do
				local PAGE=$(identifyname ${SOURCE} ${i})
				if  [ ! -z "${PAGE}" ] ; then
					printf "# '%s'\n" "${PAGE#*:}"
					${DJVUSED} ${SOURCE} -e "select '${PAGE#*:}'; print-ant" 2>/dev/null | formatdsed
				fi
			done
		else
			local IDPAGES=($(range "${RANGE}" | sort -n))
			local PAGES=($(${DJVM} -l ${SOURCE} | grep PAGE\ # | awk '{print $4}'))
			local ITEM="${CHARSET#* }"
			local KEY=(${ITEM})
			for i in ${IDPAGES[@]} ; do
				local PAGE="${PAGES[$((${i} -1))]}"
				if [ ! -z "${PAGE}" ] ; then
					printf "# '%s'\n" "${PAGE}"
					${DJVUSED} ${SOURCE} -e "select '${PAGE}'; print-ant" | formatdsed
				fi
			done
		fi
	else
		# Single page
		local PAGE=$(identifyname 1)
		printf "# '%s'\n" "${PAGE}"
		${DJVUSED} ${SOURCE} -e "select 1; print-ant" | formatdsed
	fi
}

function printmeta {
	# $1 - svazek
	# $2 - identifikátor, klíčové slovo 'all' nebo atribut
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	case "${2}" in
		all) printf "printmeta: All meta attributes for %s\n" "${FILE}" >> ${LOG}
			local META=$(${DJVUSED} "${SOURCE}" -e "select; print-meta" | sed 's/\\/\\0/g')
			if [ ! -z "${META}" ] ; then
				echo "#"
				echo -e "${META}" | tr '\000' '\\'
				echo -e "\n."
			fi
			for i in $(seq $(lastpage ${SOURCE})) ; do
				local PAGENAME=$(identifyname "${SOURCE}" "${i}")
				local META=$(${DJVUSED} "${SOURCE}" -e "select '${PAGENAME}'; print-meta" | sed 's/\\/\\0/g')
				if [ ! -z "${META}" ] ; then
					echo "#$i '${PAGENAME}'"
					echo -e "${META}" | tr '\000' '\\'
					echo -e "\n."
				fi
			done
		;;
		global) printf "printmeta: Global meta attributes from %s\n" "${FILE}" >> ${LOG}
			local META=$(${DJVUSED} "${SOURCE}" -e "select; print-meta" | sed 's/\\/\\0/g')
			if [ ! -z "${META}" ] ; then
				echo "#"
				echo -e "${META}" | tr '\000' '\\'
				echo -e "\n."
			fi
		;;
		+([[:digit:]])|*.djvu) printf "printmeta: Meta attributes for page %s from %s\n" "${2}" "${FILE}" >> ${LOG}
			local PAGENAME=$(identifyname "${SOURCE}" "${2}")
			if [ ! -z "${PAGENAME}" ] ; then
				local IDPAGE=$(identifypage "${SOURCE}" "${PAGENAME}")
				local META=$(${DJVUSED} "${SOURCE}" -e "select '${PAGENAME}'; print-meta" | sed 's/\\/\\0/g')
				if [ ! -z "${META}" ] ; then
					echo "#${IDPAGE} '${PAGENAME}'"
					echo -e "${META}" | tr '\000' '\\'
					echo -e "\n."
				fi
			fi
		;;
		*) printmeta "${SOURCE}" all
		;;
	esac
}

function printoutline {
	# $1 - DjVu file
	# $2 - cíl
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	if [ -z "${2}" ] ; then
		bookmarktooutline "${SOURCE}" | awk '{print i++ "\t|" $0}'
	elif [ -f "${2}" ] ; then
		bookmarktooutline "${SOURCE}" >> "${2}"
	elif [ -d "${2}" ] ; then
		if [ -f "${2}/${FILE//.djvu/.outline}" ] ; then
			echo "Overwrite file ${2}/${FILE//.djvu/.outline}?" >> /dev/stderr
			potvrdit
			bookmarktooutline "${SOURCE}" > "${2}/${FILE//.djvu/.outline}"
		else
			bookmarktooutline "${SOURCE}" > "${2}/${FILE//.djvu/.outline}"
		fi
	else
		bookmarktooutline "${SOURCE}"
	fi
	return 0
}

function djvuimport {
	# Import nevkládá nové stránky, ale importuje soubory textové vrstvy
	# $1 - DjVu file
	# $2 - soubor identifikátor + cílový adresář
	#echo "1- ${1}" >> /dev/stderr
	#echo "2- ${2}" >> /dev/stderr
	#echo "3- ${3}" >> /dev/stderr
	local SOURCE=$(${REALPATH} -m -P "${1}")
	echo "djvuimport: SOURCE ${SOURCE}" >> /dev/stderr
	local FILE="${SOURCE##*/}"
	if [ -z "${2}" ] ; then
		local FROM=$(${REALPATH} -m -P "$(pwd)")
		echo "djvuimport: FROM ${FROM}" >> /dev/stderr
	else
		local FROM=$(${REALPATH} -m -P "${2}")
		echo "djvuimport: FROM ${FROM}" >> /dev/stderr
	fi

	if [ -d "${FROM}" ] ; then
		local LIST=$(djvuinfo "${SOURCE}" pages)
		local IFS_BAK=$IFS
		local IFS=$'\n'
		for i in  ${LIST} ; do

			local PAGENAME="${i##*:}"
			log info "djvuimport() Hledám soubory pro import dat do stránky ${PAGENAME} v souboru ${FILE}"
			if [ -f "${FROM}/${PAGENAME/.djvu/.dsed}" ] ; then
				importdsedpage "${SOURCE}" "${PAGENAME}" "${FROM}/${PAGENAME/.djvu/.dsed}"
			fi
			if [ -f "${FROM}/${PAGENAME/.djvu/.xml}" ] ; then
				importxmlpage "${SOURCE}" "${FROM}/${PAGENAME/.djvu/.xml}"
			fi
			if [ -f "${FROM}/${PAGENAME/.djvu/.meta}" ] ; then
				importmetapage "${SOURCE}" "${PAGENAME}" "${FROM}/${PAGENAME/.djvu/.meta}"
			fi

		done
		local IFS=$IFS_BAK
		log info "djvuimport() Importuji meta atributy a obsah pro celý soubor ${FILE}"
		# Import obsahu souboru..
		if [ -f "${FROM}/${FILE/.djvu/.meta}" ] ; then
			importmetaall "${SOURCE}" "${FROM}/${FILE/.djvu/.meta}"
		fi
		if [ -f "${FROM}/${FILE/.djvu/.outline}" ] ; then
			importoutline "${SOURCE}" "${FROM}/${FILE/.djvu/.outline}"
		fi
	elif [ -f "${FROM}" ] ; then
		case "$(head -c 1 ${FROM})" in
			\<) echo "import: import XML file" >> /dev/stderr
				XML="yes"
				importxmlpage "${SOURCE}" "${FROM}"
				return 0
			;;
			s) echo "import: import file in dsed format" >> /dev/stderr
				DSED="yes"
				importdsedall "${SOURCE}" "${FROM}"
				return 0
			;;
			\") echo "import: import outline file" >> /dev/stderr
				local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .outline)
				outlinetodsed "${FROM}" | encode > "${TEMPFILE}"
				importoutline "${SOURCE}" "${TEMPFILE}"
				return 0
			;;
			\() echo "import: import outline in dsed format" >> /dev/stderr
				"${SOURCE}" 
				importoutline "${SOURCE}" "${FROM}"
				return 0
			;;
			\#) echo "import: import meta atribute file" >> /dev/stderr
				META="yes"
				importmeta "${SOURCE}" "${FROM}"
				return 0
			;;
			[[:alpha:]]) echo "import: meta TODO atribute file for one page - not implemented" >> /dev/stderr
				echo "může jít i o seznam stránek k importu do souboru.." >> /dev/stderr
				local FROMFILE="${FROM##*/}"
				#echo  "${FILE%.*} ${FROMFILE%.*}" >> /dev/stderr
				log info "djvuimport() Importuji data do stránky ${FROMFILE}"
				local LIST=$(djvuinfo "${SOURCE}" pages)
				local IFS_BAK=$IFS
				local IFS=$'\n'
				for i in  ${LIST} ; do
					local PAGENAME="${i##*:}"
					if [ "${PAGENAME%.*}" == "${FROMFILE%.*}" ] ; then
						echo "Importuji data ze souboru ${FROM} do stránky ${PAGENAME} v souboru ${FILE}" >> /dev/stderr
						case "${FROMFILE}" in
							*.dsed) DSED="yes"
								importdsedpage "${SOURCE}" "${PAGENAME}" "${FROM}"
							;;
							*.meta) META="yes"
								importmeta "${SOURCE}" "${PAGENAME}" "${FROM}"
							;;
							*.xml) XML="yes"
								importxmlpage "${SOURCE}" "${FROM}"
							;;
							*) echo "import: Při importu textových dat do stránky jsou akceptovány pouze soubory s příponou .dsed, .xml a .meta" >> /dev/stderr
							;;
						esac
					fi
				done
				local IFS=$IFS_BAK
				return 0
			;;
			*) echo "import: FAIL - unknown file" >> /dev/stderr
				exit 1
			;;
		esac
	else
		echo "import: Parametrem akce import může být buď adresář se soubory, nebo soubor s daty k importu" >> /dev/stderr
		exit 1
	fi
}

function djvuexport {
	# $1 - DjVu file
	# $2 - identifikátor + cílový adresář
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"

	# Parsing $2
	local CHARSTRING="$2"
	if [ "${CHARSTRING}" == "" ] ; then
		help keywords-export
		exit 0
	fi

#	echo "${PAGE} ${DSED} ${XML} ${IMG} ${META} ${FORCE} option" >> /dev/stderr
	export EXPORTVALUE=0
	[ "${PAGE}" != "no" ] && export EXPORTVALUE=$(( $EXPORTVALUE + 1 )) && echo "actual $EXPORTVALUE" >> /dev/stderr
	[ "${IMG}" != "no" ] && export EXPORTVALUE=$(( $EXPORTVALUE + 2 )) && echo "actual $EXPORTVALUE" >> /dev/stderr
	[ "${XML}" != "no" ] && export EXPORTVALUE=$(( $EXPORTVALUE + 4 )) && echo "actual $EXPORTVALUE" >> /dev/stderr
	[ "${META}" != "no" ] && export EXPORTVALUE=$(( $EXPORTVALUE + 8 )) && echo "actual $EXPORTVALUE" >> /dev/stderr
	[ "${DSED}" != "no" ] && export EXPORTVALUE=$(( $EXPORTVALUE + 16 )) && echo "actual $EXPORTVALUE" >> /dev/stderr
#	if [ "${PAGE}" == "no" ] && [ "${DSED}" == "no" ] && [ "${XML}" == "no" ] && [ "${IMG}" == "no" ] && [ "${META}" == "no" ] ; then

	if  [ "${FORCE}" == "skip" ] ; then
		# Interaktivní mód
		printf "export: For export from DjVu bundle we must use any option\n" >> /dev/stderr
		# Co mám vyexportovat ze svazku?
		# 1) pouze stránky ve formátu DjVu
		# 2) pouze náhledy stránek ve formátu PNG
		# 3) 0+P
		# 4) pouze xml soubory textové vrstvy
		# 5) X+P
		# 6) X+O
		# 7) X+O+P
		# 8) pouze metainformace
		# 9) M+P
		# 10) M+O
		# 11) M+O+P
		# 12) M+X
		# 13) M+X+P
		# 14) M+X+O
		# 15) M+X+O+P
		# 16) pouze dsed soubory
		# 17) D+P
		# 18) D+O
		# 19) D+O+P
		# 20) D+X
		# 21) D+X+P
		# 22) D+X+O
		# 23) D+X+O+P
		# 24) D+M
		# 25) D+M+P
		# 26) D+M+O
		# 27) D+M+O+P
		# 28) D+M+X
		# 29) D+M+X+P
		# 30) D+M+X+O
		# 31) D+M+X+O+P
		printf "Export of DjVu pages from bundle?\n" >> /dev/stderr
		potvrdit && export EXPORTVALUE=$(( $EXPORTVALUE + 1 ))
		printf "Export pages as PNG too?\n" >> /dev/stderr
		potvrdit && export EXPORTVALUE=$(( $EXPORTVALUE + 2 ))
		printf "Export text layer as XML file?\n" >> /dev/stderr
		potvrdit && export EXPORTVALUE=$(( $EXPORTVALUE + 4 ))
		printf "Export meta and outline from bundle?\n" >> /dev/stderr
		potvrdit && export EXPORTVALUE=$(( $EXPORTVALUE + 8 ))
		printf "Export text from bundle in DSED format?\n" >> /dev/stderr
		potvrdit && export EXPORTVALUE=$(( $EXPORTVALUE + 16 ))
#		echo "Budu zpracovávat $EXPORTVALUE"
	fi

	if [ $EXPORTVALUE == 0 ] ; then
		printf "export: Options are necessary for specify of content for export from DjVu bundle.\n" >> /dev/stderr
		return 1
	fi

	local CHARCOUNT=$((${#CHARSTRING} + 1))
	local CHARPOS=0
	local STRPOS=0
	while [ "${CHARCOUNT}" -gt "0" ] ; do
		case "${CHARSTRING:0:$((${CHARPOS} - ${STRPOS}))}" in
			*.[dD][jJ][vV][uU]) local PAGENAME="${CHARSTRING:0:$((${CHARPOS} - ${STRPOS}))}"
				local STRPOS="${CHARPOS}"
				local CHARSTRING="${CHARSTRING#${PAGENAME}}"
				local CHARCOUNT=$((${#CHARSTRING} + 1))
			;;
		esac
		local CHARPOS=$((CHARPOS + 1))
		local CHARCOUNT=$((CHARCOUNT - 1))
	done

	if [  -z "${CHARSTRING}" ] ; then
		if [ -z "${PAGENAME}" ] ; then
			log info "djvuexport() Export all pages from ${FILE} into aktual directory - do set TARGETDIR"
			local TARGETDIR=$(targetdir $(pwd))
			exportdjvuall "${SOURCE}" "${TARGETDIR}"
			return 0
		else
			log info "djvuexport() Export page identificated by ${PAGENAME} from ${FILE} into aktual directory - do set TARGETDIR"
			local IDPAGE=$(identifypage "${SOURCE}" "${PAGENAME}")
			if [ -z "${IDPAGE}" ] ; then
				case "${PAGENAME%%\ *}" in
					meta) printmeta "${SOURCE}" "${PAGENAME#* }"
						return 0
					;;
					*) echo "export: In ${FILE} is not any page identificated by ${PAGENAME}"  >> /dev/stderr &&  exit 1
					;;
				esac
			else
				local NAMEPAGE=$(identifyname "${SOURCE}" "${PAGENAME}")
				local TARGETDIR=$(targetdir $(pwd))
			fi
		fi
	else
		if [ -z "${PAGENAME}" ] ; then
			local TEMP=${CHARSTRING##+([[:blank:]])}
			local IDPAGE=${TEMP%%+([[:blank:]])*}
			local CHARSTRING=${TEMP#${IDPAGE}}
			local TARGETDIR=${CHARSTRING##+([[:blank:]])}
			# Tady může být nějaký jiný parametr, než pořadové číslo, a také TARGETDIR může být prázdný.
			case "${IDPAGE}" in
				all) if [ -z "${TARGETDIR}" ] ; then
						log info "djvuexport() Export all pages from ${FILE} into actual directory - do set TARGETDIR"
						local TARGETDIR=$(targetdir $(pwd))
						exportdjvuall "${SOURCE}" "${TARGETDIR}"
						return 0
					else
						log info "djvuexport() Export all pages from ${FILE} into ${TARGETDIR}"
						local TARGETDIR=$(targetdir "${TARGETDIR}")
						exportdjvuall "${SOURCE}" "${TARGETDIR}"
						return 0
					fi
				;;
				meta) printmeta "${SOURCE}" "${TARGETDIR}"
					return 0
				;;
				outline) bookmarktooutline "${SOURCE}"
					return 0
				;;
				*) log info "djvuexport() Export page identificated by order -${IDPAGE}- from ${FILE} into -${TARGETDIR}-"
					local NAMEPAGE=$(identifyname "${SOURCE}" "${IDPAGE}")
					if [ -z "${NAMEPAGE}" ] ; then
						# djvutool bundle.djvu export
						if [ -e "${IDPAGE}" ] ; then
							if [ -d "${IDPAGE}" ] ; then
								djvuexport "${SOURCE}" "all ${IDPAGE}"
							else
								echo "export: In ${FILE} is not any page on position ${IDPAGE}"  >> /dev/stderr &&  exit 1
							fi
						else
							djvuexport "${SOURCE}" "all ${IDPAGE}"
						fi
					else
						local TARGETDIR=$(targetdir "${TARGETDIR}")
					fi
				;;
			esac
		else
			local NAMEPAGE=${PAGENAME##+([[:blank:]])}
			local TARGETDIR=${CHARSTRING##+([[:blank:]])}
			log info "djvuexport() Export page identificated by name -${NAMEPAGE}- from ${FILE} into -${TARGETDIR}-"
			local IDPAGE=$(identifypage "${SOURCE}" "${NAMEPAGE}")
			[ -z "${IDPAGE}" ] && echo "export: In ${FILE} is not any page with name ${NAMEPAGE}" >> /dev/stderr &&  exit 1
			local TARGETDIR=$(targetdir "${TARGETDIR}")
		fi
	fi

#	echo "export: SOURCE ${SOURCE}">> /dev/stderr
#	echo "export: FILE ${FILE}">> /dev/stderr
#	echo "export: IDPAGE ${ODPAGE}">> /dev/stderr
#	echo "export: NAMEPAGE ${NAMEPAGE}">> /dev/stderr
#	echo "export: TARGETDIR ${TARGETDIR}">> /dev/stderr
#	echo "export: FORCE ${FORCE}">> /dev/stderr

	exportdjvupage "${SOURCE}" "${NAMEPAGE}" "${TARGETDIR}"
	exportdsedpage "${SOURCE}" "${NAMEPAGE}" "${TARGETDIR}"
	#echo "export: For export text content from DjVu page in dsed format we must use option -d" >> /dev/stderr
	exportxmlpage "${SOURCE}" "${NAMEPAGE}" "${TARGETDIR}"
	#echo "export: For export hidden text layer of pages from DjVu bundle in XML format we must use option -x" >> /dev/stderr
	exportimgpage "${SOURCE}" "${NAMEPAGE}" "${TARGETDIR}"
	#echo "export: For export image of page from DjVu bundle we must use option -i" >> /dev/stderr
	exportmetapage "${SOURCE}" "${NAMEPAGE}" "${TARGETDIR}"
	# echo "export: For export meta attributes from pages DjVu bundle in we must use option -m" >> /dev/stderr
}

function exportdjvuall {
	# $1 - DjVu file - full path
	# $2 - targetdir - full path
	echo "$EXPORTVALUE" >> /dev/stderr
	local EXPORTDJVU="1|3|5|9|11|13|15|17|19|21|23|25|27|29|31"
	local EXPORTIMG="2|3|6|7|10|11|14|15|18|19|22|23|26|27|30|31"
	local EXPORTXML="4|5|6|7|12|13|14|15|20|21|22|23|28|29|30|31"
	local EXPORTMETA="8|9|10|11|12|13|14|15|24|25|26|27|28|29|30|31"
	local EXPORTDSED="16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31"
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	[ "${PAGE}" != "no" ] || echo "exportdjvuall: For export pages in DjVu format we must use option -p" >> /dev/stderr
	[ "${DSED}" != "no" ] || echo "exportdjvuall: For export hidden text layer of pages from DjVu bundle in dsed format we must use option -d" >> /dev/stderr
	[ "${XML}" != "no" ] || echo "exportdjvuall: For export hidden text layer of pages from DjVu bundle in XML format we must use option -x" >> /dev/stderr
	[ "${IMG}" != "no" ] || echo "exportdjvuall: For export image of page from DjVu bundle we must use option -i" >> /dev/stderr
	[ "${META}" != "no" ] || echo "exportdjvuall: For export meta attributes from pages DjVu bundle in we must use option -m" >> /dev/stderr
	local PAGES=$(lastpage "${SOURCE}")
	local NUMPAGE=1
	while [ ${PAGES} -gt "0" ] ; do
		local NAMEPAGE=$(identifyname "${SOURCE}" "${NUMPAGE}")
		log info "exportdjvuall() Exportuji stránku ${NAMEPAGE}"

		[[ $EXPORTDJVU =~ $EXPORTVALUE ]] && exportdjvupage "${1}" "${NAMEPAGE}" "${2}"
		[[ $EXPORTIMG =~ $EXPORTVALUE ]] && exportimgpage "${1}" "${NAMEPAGE}" "${2}"
		[[ $EXPORTXML =~ $EXPORTVALUE ]] && exportxmlpage "${1}" "${NAMEPAGE}" "${2}"
		[[ $EXPORTMETA =~ $EXPORTVALUE ]] && exportmetapage "${1}" "${NAMEPAGE}" "${2}"
		[[ $EXPORTDSED =~ $EXPORTVALUE ]] && exportdsedpage "${1}" "${NAMEPAGE}" "${2}"

		local NUMPAGE=$((NUMPAGE + 1))
		local PAGES=$((PAGES - 1))
	done
	[[ $EXPORTXML =~ $EXPORTVALUE ]] && exportxmlbundle "${1}" "${2}"
	[[ $EXPORTMETA =~ $EXPORTVALUE ]] && exportmetabundle "${1}" "${2}"
	[[ $EXPORTMETA =~ $EXPORTVALUE ]] && bookmarktooutline "${1}" > "${2}/${FILE/.djvu/.outline}"
	[[ $EXPORTDSED =~ $EXPORTVALUE ]] && exportdsedbundle "${1}" "${2}"
}

function exportdsedbundle {
	# $1 - DjVu file - full path
	# $2 - targetdir - full path
	local FILE="${1##*/}"
	pushd "${2}"
	case "${DSED}" in
		yes|all) local EXPORT="output-all"
		;;
		txt) local EXPORT="output-txt"
		;;
		ant) local EXPORT="output-ant"
		;;
		no) return 0
		;;
	esac
	if [ "${DSED}" != "no" ] ; then
		local TARGET="${FILE/.djvu/.dsed}"
		if [ -f "${TARGET}" ] ; then
			if [ "${FORCE}" == "yes" ] ; then
				${DJVUSED} "${1}" -e "${EXPORT}" > "${TARGET}"
			elif [ "${FORCE}" == "skip" ] ; then
				log warn "exportdsedbundle() Soubor ${TARGET} již v adresáři ${3} existuje."
			else
				echo "exportdsedbundle: Soubor ${TARGET} již v adresáři ${3} existuje.." >> /dev/stderr
				potvrdit && ${DJVUSED} "${1}" -e "${EXPORT}" > "${TARGET}"
			fi
		else
			${DJVUSED} "${1}" -e "${EXPORT}" > "${TARGET}"
		fi
	fi
	popd
}

function exportxmlbundle {
	# $1 - DjVu file - full path
	# $2 - targetdir - full path
	local FILE="${1##*/}"
	pushd "${2}"
	case "${XML}" in
		yes|all) local EXPORT="--with-text --with-anno"
		;;
		txt) local EXPORT="--with-text --without-anno"
		;;
		ant) local EXPORT="--without-text --with-anno"
		;;
		no) return 0
		;;
	esac
	if [ "${XML}" != "no" ] ; then
		local TARGET="${FILE/.djvu/.xml}"
		if [ -f "${TARGET}" ] ; then
			if [ "${FORCE}" == "yes" ] ; then
				${DJVUTOXML} "${1}" "${TARGET}"
			elif [ "${FORCE}" == "skip" ] ; then
				log warn "exportxmlbundle() Soubor ${TARGET} již v adresáři ${3} existuje."
			else
				echo "exportxmlbundle: Soubor ${TARGET} již v adresáři ${3} existuje.." >> /dev/stderr
				potvrdit && ${DJVUTOXML} "${1}" "${TARGET}"
			fi
		else
			${DJVUTOXML} "${1}" "${TARGET}"
		fi
	fi
	popd
}

function exportimgpage {
	# $1 - DjVu file - full path
	# $2 - identificator - page name
	# $3 - targetdir - full path
	pushd "${3}"
	case "${IMG}" in
		yes) local EXPORT="-mode=color"
		;;
		color|black|foreground|background|mask) local EXPORT="-mode=${IMG}"
		;;
		no) return 0
		;;
	esac
	echo "$EXPORT" >> /dev/stderr
	echo "$PNMTOPNG" >> /dev/stderr
	if [ "${IMG}" != "no" ] ; then
		local PAGE=$(identifypage "${1}" "${2}")
		local TARGET="${2/.djvu/.png}"
		if [ -f "${TARGET}" ] ; then
			if [ "${FORCE}" == "yes" ] ; then
				${DDJVU} -format=pnm "${EXPORT}" -page="${PAGE%%(*}" "${1}" | ${PNMTOPNG} > "${TARGET}"
			elif [ "${FORCE}" == "skip" ] ; then
				log warn "exportimgpage() Soubor ${TARGET} již v adresáři ${3} existuje."
			else
				echo "exportimgpage: Soubor ${TARGET} již v adresáři ${3} existuje.." >> /dev/stderr
				potvrdit && ${DDJVU} -format=pnm "${EXPORT}" -page="${PAGE%%(*}" "${1}" | ${PNMTOPNG} > "${TARGET}"
			fi
		else
			echo "${DDJVU} -format=pnm ${EXPORT} -page=${PAGE%%(*} ${1} | ${PNMTOPNG} > ${TARGET}"
			${DDJVU} -format=pnm "${EXPORT}" -page="${PAGE%%(*}" "${1}" | ${PNMTOPNG} > "${TARGET}"
		fi
	fi
	popd
}

function exportxmlpage {
	# $1 - DjVu file - full path
	# $2 - identificator - page name
	# $3 - targetdir - full path
	pushd "${3}"
	case "${XML}" in
		yes|all) local EXPORT="--with-text --with-anno"
		;;
		txt) local EXPORT="--with-text --without-anno"
		;;
		ant) local EXPORT="--without-text --with-anno"
		;;
		no) return 0
		;;
	esac
	if [ "${XML}" != "no" ] ; then
		local PAGE=$(identifypage "${1}" "${2}")
		local TARGET="${2/.djvu/.xml}"
		if [ -f "${TARGET}" ] ; then
			if [ "${FORCE}" == "yes" ] ; then
				${DJVUTOXML} --page "${PAGE}" ${EXPORT} "${1}" "${TARGET}"
			elif [ "${FORCE}" == "skip" ] ; then
				log warn "exportxmlpage() Soubor ${TARGET} již v adresáři ${3} existuje."
			else
				echo "Soubor ${TARGET} již v adresáři ${3} existuje.." >> /dev/stderr
				potvrdit && ${DJVUTOXML} --page "${PAGE}" ${EXPORT} "${1}" "${TARGET}"
			fi
		else
			${DJVUTOXML} --page "${PAGE}" ${EXPORT} "${1}" "${TARGET}"
		fi
	fi
	popd
}

function importmetapage {
	# $1 - soubor se stránkou
	# $2 - identifikátor stránky
	# $3 - soubor s meta atributy
	echo "importmetapage: Importuji meta atributy do jedné stránky" >> /dev/stderr
	${DJVUSED} "${1}" -e "select '${2}'; set-meta ${3}; save"
}

function importmetaall {
	# $1 - soubor se stránkou
	# $2 - soubor s meta atributy
	echo "importmetaall: Importuji meta atributy pro celý svazek" >> /dev/stderr
	${DJVUSED} "${1}" -e "select; set-meta ${2}; save"
}

function encode {
	# Funkce průběžně konvertuje unicode znaky do číselné podoby
	while read -n 1 a
	do
	CHAR=($( echo "$a" | od -A n -t c ))
	if [ "${#CHAR[@]}" -gt "2" ] ; then 
		echo -n "\\${CHAR[0]}\\${CHAR[1]}"
	elif [ "${#CHAR[@]}" == "1" ] ; then 
		echo -n " "
	else
		if [ "${#CHAR[0]}" == "0" ] ; then
			echo -n " "
		else
			echo -n "${CHAR[0]}"
		fi
	fi
	done
}

function bookmarktooutline {
	local TARGET="$1"
	local BEGIN=""
	local TAB=0
	${DJVUSED} "${1}" -e 'print-outline' | sed -n '
	s|(|\n(\n|g
	s|)|\n)\n|g
	s|\\|\\\\0|g
	p
	' |	while read y
	do
		case "$y" in
			\)) local TAB=$((TAB - 1))
			;;
			\() local TAB=$((TAB + 1))
			;;
			\"*) if [ "${BEGIN}" == "" ] ; then
					local TEXT="$y"
					local BEGIN="yes"
				else
					for i in $(seq $((TAB-2))) ; do echo -en '\t' ; done
					echo -e "${TEXT} ${y}"
					local BEGIN=""
				fi
			;;
		esac
	done
}

function outlineunset {
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .outline)
	local CHARSET="$(( $2 + 1 ))"
	bookmarktooutline "${SOURCE}" >> "${TEMPFILE}"
	if [ "${CHARSET//+([[:digit:]])}" == "" ] ; then
		ed ${TEMPFILE} 2>/dev/null <<-EOF
${CHARSET}d
w
q
EOF
		outlinetodsed "${TEMPFILE}" | encode > "${TEMPFILE/.outline/.temp}"
		${DJVUSED}  "${SOURCE}" -e "set-outline ${TEMPFILE/.outline/.temp}; save"
	fi
}

function outlineset {
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .outline)
	local CHARSET="${2}"
	bookmarktooutline "${SOURCE}" >> "${TEMPFILE}"
	local ORDER="${CHARSET%% *}"
	local BOOKMARKTARGET="${CHARSET##* }"
	local TEMP="${CHARSET#${ORDER} *}"
	local BOOKMARKITEM="${TEMP%* ${BOOKMARKTARGET}}"
	case ${ORDER:$((${#ORDER}-1))} in
		+) if [ -z ${ORDER%:+} ] ; then
				local TEMP=$(tail -1 ${TEMPFILE})
				local TABS="${TEMP%%\"*}"
				local ITEM="$(xtabs $((${#TABS} + 1)))\"${BOOKMARKITEM}\" \"#${BOOKMARKTARGET}\""
				ed ${TEMPFILE} 2>/dev/null <<-EOF
a
${ITEM}
.
w
q
EOF
			else
				local TEMP=$(head -$((${ORDER%:+*}+1)) ${TEMPFILE} | tail -1)
				local TABS="${TEMP%%\"*}"
				local ITEM="$(xtabs $((${#TABS} + 1)))\"${BOOKMARKITEM}\" \"#${BOOKMARKTARGET}\""
				ed ${TEMPFILE} 2>/dev/null <<-EOF
${ORDER%:+}a
${ITEM}
.
w
q
EOF
			fi
			;;
		-) if [ -z ${ORDER%:-*} ] ; then
				local TEMP=$(tail -1 ${TEMPFILE})
				local TABS="${TEMP%%\"*}"
				local MINUS="${ORDER#:}"
				if [ ${#TABS} -ge ${#MINUS} ] ; then
					local ITEM="$(xtabs $((${#TABS} - ${#MINUS})))\"${BOOKMARKITEM}\" \"#${BOOKMARKTARGET}\""
				else
					local ITEM="\"${BOOKMARKITEM}\" \"#${BOOKMARKTARGET}\""
				fi
				ed ${TEMPFILE} 2>/dev/null <<-EOF
a
${ITEM}
.
w
q
EOF
			else
				local TEMP=$(head -$((${ORDER%:-*}+1)) ${TEMPFILE} | tail -1)
				local TABS="${TEMP%%\"*}"
				local MINUS="${ORDER#*:}"
				if [ ${#TABS} -ge ${#MINUS} ] ; then
					local ITEM="$(xtabs $((${#TABS} - ${#MINUS})))\"${BOOKMARKITEM}\" \"#${BOOKMARKTARGET}\""
				else
					local ITEM="\"${BOOKMARKITEM}\" \"#${BOOKMARKTARGET}\""
				fi
				ed ${TEMPFILE} 2>/dev/null <<-EOF
${ORDER%:-*}a
${ITEM}
.
w
q
EOF
			fi
			;;
		:) if [ -z ${ORDER%:} ] ; then
				local TEMP=$(tail -1 ${TEMPFILE})
				local TABS="${TEMP%%\"*}"
				local ITEM="$(xtabs ${#TABS})\"${BOOKMARKITEM}\" \"#${BOOKMARKTARGET}\""
				ed ${TEMPFILE} 2>/dev/null <<-EOF
a
${ITEM}
.
w
q
EOF
			else
				local TEMP=$(head -$((${ORDER%:}+1)) ${TEMPFILE} | tail -1)
				local TABS="${TEMP%%\"*}"
				local ITEM="$(xtabs ${#TABS})\"${BOOKMARKITEM}\" \"#${BOOKMARKTARGET}\""
				ed ${TEMPFILE} 2>/dev/null <<-EOF
${ORDER%:}a
${ITEM}
.
w
q
EOF
			fi
			;;
		[[:digit:]]) local TEMP=$(head -$((${ORDER}+1)) ${TEMPFILE} | tail -1)
			local TABS="${TEMP%%\"*}"
			local ITEM="$(xtabs ${#TABS})\"${BOOKMARKITEM}\" \"#${BOOKMARKTARGET}\""
				ed ${TEMPFILE} 2>/dev/null <<-EOF
${ORDER}a
${ITEM}
.
w
q
EOF
			;;
		*) echo "outlineset: Sem bys nikdy neměl dojít" && exit 1
			;;
	esac
	outlinetodsed "${TEMPFILE}" | encode > "${TEMPFILE/.outline/.temp}"
	${DJVUSED}  "${SOURCE}" -e "set-outline ${TEMPFILE/.outline/.temp}; save"
}

function outlinetodjvu {
	# Funkce převádí obsah .outline souboru na formát .dsed
	# a výsledek zapisuje do djvu souboru
	# $1 - DjVu file
	# $2 - outline file nebo stream
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local OUTLINE=$(${REALPATH} -m -P "${2}")
	local FILE="${SOURCE##*/}"
	local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .bookmarks)
	if [ -z "${3}" ] ; then
		if [ -f "${OUTLINE}" ] ; then
			# zdrojem je outline soubor
			outlinetodsed "${OUTLINE}" | encode > "${TEMPFILE}"
			pushd ${TEMPDIR}
				${DJVUSED}  "${SOURCE}" -e "set-outline ${TEMPFILE##*/}; save"
			popd
		else
			echo "outlinetodjvu: import only from outline file" >> /dev/stderr
		fi
	else
		local BOOKMARKS=$(${REALPATH} -m -P ${3})
		if [ -f "${BOOKMARKS}" ] ; then
			echo "File for bookmarks in dsed format exist. Overwrite it?"
			potvrdit
			printf "set-outline\n" > "${BOOKMARKS}"
			outlinetodsed "${OUTLINE}" | encode >> "${BOOKMARKS}"
			printf "\n\n.\n" >> "${BOOKMARKS}"
		elif [ -d "${BOOKMARKS}" ] ; then
			outlinetodsed "${OUTLINE}" | encode >> "${BOOKMARKS}/${FILE//.djvu/.bookmarks}"
		else
			outlinetodsed "${OUTLINE}" | encode >> ${3}
		fi
	fi
	return 0
}

function outlinetodsed {
	# $1 - temporary .outline file with TAB syntax
	# Output is txt stream
	local TARGET="$1"
	# Remove comment from .outline file
	sed --in-place '/^#/d ; /^;/d' "${TARGET}"
	[ $(grep -c ^ "${TARGET}") -eq "0" ] && return 1
	local LEVEL="1"
	IFS=''
	echo -n "(bookmarks "
	CONTENT=$(sed '
		s/\ \ \ \ /\t/g
		s/^/\t/
		' "${TARGET}" | while read line ; do
		local SPACE="${line%%\"*}"
		if [ "${#SPACE}" -gt "${LEVEL}" ] ; then
			local PREV="${PREV%)} ( ${line} )"
			local LEVEL=$((${LEVEL} + 1))
		elif [ "${#SPACE}" -eq "${LEVEL}" ] ; then
			local PREV="${PREV} ( ${line} )"
		elif [ "${#SPACE}" -lt "${LEVEL}" ] ; then
			local ROZDIL=$((${LEVEL} - ${#SPACE}))
			local ZAV=$(seq  -f "%1.0f" -s '' ${ROZDIL})
			local PREV="${PREV} ${ZAV//[[:digit:]]/)} ( $line )"
			local LEVEL=$((${LEVEL} - ${ROZDIL}))
		fi
		echo "${PREV}"
		echo "-----${LEVEL}"
	done | sed 's/\t/\ /g' | tail -2)
	TEST="${CONTENT##*-----}"
	echo -n "${CONTENT%-----*}"
	local ZAV=$(seq  -f "%1.0f" -s '' ${TEST})
	echo "${ZAV//[[:digit:]]/)}"
	return 0
}


function importdsedall {
	case "${DSED}" in
		# Vytvořit dočasný soubor s následující hlavičkou...
		# -e "select '${2}'; remove-ant; remove-txt"
		# -------------------------
		# time awk '/^set-ant$/{flag=1;next} ; /^.$/{flag=0}; flag' vysledek.dsed 
		all|yes) # nejprve ant, pak text..
		${DJVUSED} "${1}" -f "${2}" -s
		;;
		no)
		;;
	esac
}

function importdsedpage {
	# $1 - DjVu file - full path
	# $2 - identificator - page name
	# $3 - source DSED file - full path
	case "${DSED}" in
		# Vytvořit dočasný soubor s následující hlavičkou...
		# -e "select '${2}'; remove-ant; remove-txt"
		# -------------------------
		# time awk '/^set-ant$/{flag=1;next} ; /^.$/{flag=0}; flag' vysledek.dsed 
		all|yes) awk '/^set-ant$/{flag=1;next} ; /^.$/{flag=0}; flag' "${3}" > ${TEMPDIR}/${2}.ant
			${DJVUSED} "${1}" -e "select '${2}'; set-ant ${TEMPDIR}/${2}.ant ; save"
			awk '/^set-txt$/{flag=1;next} ; /^.$/{flag=0}; flag' "${3}" > ${TEMPDIR}/${2}.txt
			${DJVUSED} "${1}" -e "select '${2}'; set-txt ${TEMPDIR}/${2}.txt ; save"
		;;
		ant) awk '/^set-ant$/{flag=1;next} ; /^.$/{flag=0}; flag' "${3}" > ${TEMPDIR}/${2}.ant
			${DJVUSED} "${1}" -e "select '${2}'; set-ant ${TEMPDIR}/${2}.ant ; save"
		;;
		txt) awk '/^set-txt$/{flag=1;next} ; /^.$/{flag=0}; flag' "${3}" > ${TEMPDIR}/${2}.txt
			${DJVUSED} "${1}" -e "select '${2}'; set-txt ${TEMPDIR}/${2}.txt ; save"
		;;
		no) echo "K importu textových dat ze souboru ${3} se přistoupí pouze bude-li uvedena volba -d" >> /dev/stderr
		;;
	esac
}

function importmeta {
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .meta)
	local FROM=$(${REALPATH} -m -P "${2}")
	local FROMFILE="${FROM##*/}"
	grep '^#' "${FROM}" | while read line ; do
		echo "$line" >> /dev/stderr
		local NAMEPAGE=( $line )
		case "${#NAMEPAGE[@]}" in
			2) local PAGENAME=$(identifyname "${SOURCE}" "${NAMEPAGE[1]//\'/}")
				if [ -z "${PAGENAME}" ] ; then
					echo "importmeta: FAIL - for ${FILE} is identificator ${NAMEPAGE[1]} not valid" >> /dev/stderr
				else
					awk "/.\ '${PAGENAME}'$/{flag=1;next} ; /^.$/{flag=0}; flag" "${FROM}" > ${TEMPFILE}
					${DJVUSED} "${1}" -e "select ${PAGENAME}; set-meta ${TEMPFILE}" -s
				fi
			;;
			1) if [ "${NAMEPAGE[0]}" == "#" ] ; then
					awk "/^#$/{flag=1;next} ; /^.$/{flag=0}; flag" "${FROM}" > ${TEMPFILE}
					${DJVUSED} "${1}" -e "select ; set-meta ${TEMPFILE}" -s
				else
					local PAGENAME=$(identifyname "${SOURCE}" "${NAMEPAGE[0]:1}")
					if [ -z "${PAGENAME}" ] ; then
						echo "importmeta: FAIL - for ${FILE} is identificator ${NAMEPAGE[0]:1} not valid" >> /dev/stderr
					else
						awk "/^#${NAMEPAGE[0]:1}$/{flag=1;next} ; /^.$/{flag=0}; flag" "${FROM}" > ${TEMPFILE}
						${DJVUSED} "${1}" -e "select ${PAGENAME}; set-meta ${TEMPFILE}" -s
					fi
				fi
			;;
		esac
	done
}

function importmeta1 {
	# $1 - DjVu file - full path
	# $2 - identificator - page name
	# $3 - source DSED file - full path
	if [ -f "${2}" ] ; then
		if [ "${3}" ] ; then
			local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .meta)
			# Zpracování gobálních metadat
			awk '/^# select '${i}'$/{flag=1;next} ; /^.$/{flag=0}; flag' "${2}" > ${TEMPFILE}
			${DJVUSED} "${1}" -e "select ${3}; set-meta ${TEMPFILE}" -s
		else
			for i in $(seq $(lastpage ${1})) ; do
				awk '/^# select '${i}'$/{flag=1;next} ; /^.$/{flag=0}; flag' "${2}" > ${TEMPFILE}
				if [ "${TEMPFILE}" ] ; then
					${DJVUSED} "${1}" -e "select ${i}; set-meta ${TEMPFILE}" -s
				fi
			done
		fi
	else
		importmeta "${1}" "${3}" 
	fi
}

function importoutline {
	# Import outline in dsed format
	${DJVUSED}  "${1}" -e "set-outline ${2}" -s
}

function importxmlpage {
	# $1 - DjVu file - full path
	# $2 - source XML file - full path
	# INFO: XML file has name of target page in self.
	case "${XML}" in
		no) echo "K importu textových dat ze souboru ${2} se přistoupí pouze bude-li uvedena volba -x" >> /dev/stderr
		;;
		*) ${DJVUXMLPARSER} -o "${1}" "${2}"
		;;
	esac
}

# TODO - meta - Nepoužitá funkce
function exportmetabundle {
	# $1 - DjVu file - full path
	# $2 - targetdir - full path
	local FILE="${1##*/}"
	pushd "${2}"
	if [ "${META}" != "no" ] ; then
		local TARGET="${FILE/.djvu/.meta}"
		if [ -f "${TARGET}" ] ; then
			if [ "${FORCE}" == "yes" ] ; then
				${DJVUSED} "${1}" -e "print-meta" > "${TARGET}"
			elif [ "${FORCE}" == "skip" ] ; then
				log warn "exportmetabundle() Soubor ${TARGET} již v adresáři ${2} existuje."
			else
				echo "Soubor ${TARGET} již v adresáři ${2} existuje.." >> /dev/stderr
				potvrdit && ${DJVUSED} "${1}" -e "print-meta" > "${TARGET}"
			fi
		else
			${DJVUSED} "${1}" -e "print-meta" > "${TARGET}"
		fi
	fi
	popd
}

# TODO - meta - Nepoužitá funkce
function exportmetapage {
	# $1 - DjVu file - full path
	# $2 - identificator - page name
	# $3 - targetdir - full path
	pushd "${3}"
	if [ "${META}" != "no" ] ; then
		local TARGET="${2/.djvu/.meta}"
		if [ -f "${TARGET}" ] ; then
			if [ "${FORCE}" == "yes" ] ; then
				${DJVUSED} "${1}" -e "select '${2}'; print-meta" > "${TARGET}"
			elif [ "${FORCE}" == "skip" ] ; then
				log warn "exportmetapage() Soubor ${TARGET} již v adresáři ${3} existuje."
			else
				echo "Soubor ${TARGET} již v adresáři ${3} existuje.." >> /dev/stderr
				potvrdit && ${DJVUSED} "${1}" -e "select '${2}'; print-meta" > "${TARGET}"
			fi
		else
			${DJVUSED} "${1}" -e "select '${2}'; print-meta" > "${TARGET}"
		fi
	fi
	popd
}

function exportdsedpage {
	# $1 - DjVu file - full path
	# $2 - identificator - page name
	# $3 - targetdir - full path into dir for file
	pushd "${3}"
	case "${DSED}" in
		yes|all) local EXPORT="output-all"
		;;
		txt) local EXPORT="output-txt"
		;;
		ant) local EXPORT="output-ant"
		;;
		no) return 0
		;;
	esac
	if [ "${DSED}" != "no" ] ; then
		local TARGET="${2/.djvu/.dsed}"
		if [ -f "${TARGET}" ] ; then
			if [ "${FORCE}" == "yes" ] ; then
				${DJVUSED} "${1}" -e "select '${2}'; ${EXPORT}" > "${TARGET}"
			elif [ "${FORCE}" == "skip" ] ; then
				log warn "exportdsedpage() Soubor ${TARGET} již v adresáři ${3} existuje."
			else
				echo "Soubor ${TARGET} již v adresáři ${3} existuje.." >> /dev/stderr
				potvrdit && ${DJVUSED} "${1}" -e "select '${2}'; ${EXPORT}" > "${TARGET}" 2>${LOG}
			fi
		else
#			echo "select '${2}'; ${EXPORT} > ${TARGET}" >> /dev/stderr
#			echo $(pwd) >> /dev/stderr
			${DJVUSED} "${1}" -e "select '${2}'; ${EXPORT}" > "${TARGET}" 2>${LOG}
			return $?
		fi
	fi
	popd
}

function exportdjvupage {
	# $1 - DjVu file - full path
	# $2 - identificator - page name
	# $3 - targetdir - full path
	log info "exportdjvupage() -${1}- -${2}- ${3}"
	pushd "${3}"
	if [ "${PAGE}" == "yes" ] ; then
		if [ -f "${2}" ] ; then
			if [ "${FORCE}" == "yes" ] ; then
				${DJVUSED} -e "select '${2}'; save-page-with '${2}'" "${1}"
			elif [ "${FORCE}" == "skip" ] ; then
				log warn "exportdjvupage() Soubor ${2} již v adresáři ${3} existuje."
			else
				echo "Soubor ${2} již v adresáři ${3} existuje.." >> /dev/stderr
				potvrdit && ${DJVUSED} -e "select '${2}'; save-page-with '${2}'" "${1}"
			fi
		else
			${DJVUSED} -e "select '${2}'; save-page-with '${2}'" "${1}"
		fi
	fi
	popd
}

function getocr {
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	if [ "${OCR}" ] ; then
		${OCRODJVU} --in-place -l "${OCR}" "${SOURCE}"
		[ "$?" ] && log info "getocr() OCR was applicated on ${FILE}" 
	fi
}

function testfile {
	# Function return type file by MIME
	# $1 - file
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	if [ -f "${SOURCE}" ] ; then
		local TYPE=$(${MIME} -dbM "${SOURCE}" | awk '{print $1}')
	else
		log err "testfile() File ${1} is NOT valid."
		exit 1
	fi
	echo "${TYPE,,}"
}

function targetdir {
	# Function return path into existing directory
	# $1 - path
	if [ -z "${1}" ] ; then
		log err "targetdir() NOT PATH"
		exit 1
	else
		local TARGETDIR=$(${REALPATH} -m -P "${1}")
		if [ -d "${TARGETDIR}" ] ; then
			echo -n "${TARGETDIR}"
		else
			mkdir -p "${TARGETDIR}"
			if [ $? -gt "0" ] ; then
				log err "targetdir() Could not create target directory ${TARGETDIR}"
				exit 1
			else
				echo -n "${TARGETDIR}"
			fi
		fi
	fi
}

function identifybundle {
	# Function testing DjVu file if is (0) or not (1) bundle
	# $1 - DjVu file
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	if [ -z "${SOURCE}" ] ; then
		log err "identifybundle() Path ${1} is not valid."
		exit 1
	else
		if [ $(testfile "${SOURCE}") == "djvu" ] ; then
			${DJVM} -l "${SOURCE}" &>/dev/null && [ $? ] && return 0 || return 1
		else
			log err "identifybundle() File ${FILE} is NOT DjVu file."
			exit 1
		fi
	fi
}

function comparedjvu {
	#  Function do test two DjVu files and return (0) if is not any page in conflict or (1)
	# $1 - Djvu full path
	# $2 - Djvu full path
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	local FROMPATH=$(${REALPATH} -m -P "${2}")
	local FROM="${FROMPATH##*/}"
	if identifybundle ${SOURCE} ; then
		${DJVM} -l "${SOURCE}" | grep PAGE\ # | awk '{print $4}' | while read x ; do
		if identifybundle ${FROMPATH} ; then
			${DJVM} -l "${FROMPATH}" | grep PAGE\ # | awk '{print $4}' | while read y ; do
				if [ "${x}" == "${y}" ] ; then
					echo "comparedjvu: WARNING Page with name ${x} from file ${FILE} is in ${FROM} too." >> /dev/stderr
					break
				fi
			done
		else
			${DJVUSED} "${FROMPATH}" -e dump | grep FORM:DJVU | awk -F'[{}]' '{print $2}' | while read y ; do
				if [ "${x}" == "${y}" ] ; then
					echo "comparedjvu: WARNING Page with name ${x} from file ${FILE} is in ${FROM} too." >> /dev/stderr
					break
				fi
			done
		fi
		done
	else
		${DJVUSED} "${SOURCE}" -e dump | grep FORM:DJVU | awk -F'[{}]' '{print $2}' | while read x ; do
		if identifybundle ${FROMPATH} ; then
			${DJVM} -l "${FROMPATH}" | grep PAGE\ # | awk '{print $4}' | while read y ; do
				if [ "${x}" == "${y}" ] ; then
					echo "comparedjvu: WARNING Page with name ${x} from file ${FILE} is in ${FROM} too." >> /dev/stderr
					break
				fi
			done
		else
			${DJVUSED} "${FROMPATH}" -e dump | grep FORM:DJVU | awk -F'[{}]' '{print $2}' | while read y ; do
				if [ "${x}" == "${y}" ] ; then
					echo "comparedjvu: WARNING Page with name ${x} from file ${FILE} is in ${FROM} too." >> /dev/stderr
					break
				fi
			done
		fi
		done
	fi
	potvrdit && return 0 || return 1
}

function splitxcf {
	# vrátí seznam
#	echo ${RANGE[@]} >> /dev/stderr
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	pushd ${TEMPDIR}
		i=0
		${XCFINFO} ${SOURCE} | grep -v Version | cut -d ' ' -f5- | while read line
		do i=$((i+1))
			if [ -z ${RANGE} ] ; then
				${XCF2PNM} ${SOURCE} -o "${line%.pnm}.pnm" "$line"
			else
				for x in ${RANGE[@]}
					do if [ "$x" -eq "$i" ] ; then
						${XCF2PNM} ${SOURCE} -o "${line%.pnm}.pnm" "$line"
					fi
				done
			fi
		done
	popd
}

function splittiff {
	# vrátí seznam
	echo nic
}

function convertimg {
	# Function for splitting multilayer image format
	# $1 Image in multilayer format (tiff, mng or xcf (gimp)
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	if [ "${2}" ] ; then 
		#cíl bude jinde...
		local TOPATH=$(${REALPATH} -m -P "${2}")
	else
		#cíl bude v adresáři kde jsem teď..
		local TOPATH=$(pwd "${SOURCE}")
	fi
	if [ -d "${TOPATH}/${FILE%.*}" ] ; then
		echo "convertimg: WARNING Dir ${TOPATH}/${FILE%.*} exists. Do rewrite files?" >> /dev/stderr
		potvrdit || return 1
	else
		mkdir "${TOPATH}/${FILE%.*}"
	fi
	convert "${SOURCE}" "${TOPATH}/${FILE%.*}/${FILE%.*}.png"
	pushd "${TOPATH}/${FILE%.*}"
		for i in $(ls -cr -1 *.png) ; do
			filetodjvu "${i}" "${i/.png/.djvu}"
		done
	popd
}

function identifyname {
	# Function return NAME of DjVu page in DjVu bundle
	# $1 DjVu Bundle
	# $2 Page identificator (order or name)
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	local IDENTIFICATOR="${2##+([[:blank:]])}"
	identifybundle "${SOURCE}" 
	if identifybundle "${SOURCE}" ; then
		if [ "${IDENTIFICATOR//+([[:digit:]])}" == "" ] ; then
			${DJVM} -l "${SOURCE}" | grep PAGE\ #${IDENTIFICATOR}\  | awk '{print $4}'
		else
			${DJVM} -l "${SOURCE}" | grep PAGE\ # | grep ${IDENTIFICATOR}$ | awk '{print $4}'
		fi
	else
		if [ "${IDENTIFICATOR//+([[:digit:]])}" == "" ] ; then
			local SEARCH="\[P${IDENTIFICATOR}\]"
		else
			local SEARCH="\{${IDENTIFICATOR}\}"
		fi
		local OUTPUT=$(${DJVUSED} "${SOURCE}" -e dump | grep FORM:DJVU | grep "${SEARCH}" | awk -F'[{}]' '{print $2}')
		if [ -z "${OUTPUT}" ] ; then
			return 0
		else
			echo -n "${OUTPUT}"
		fi
	fi
}

function identifypage {
	# Function return DjVu page actual ORDER in DjVu bundle
	# $1 DjVu Bundle
	# $2 Page identificator (order or name)
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	local IDENTIFICATOR="${2##+([[:blank:]])}"
	if [ "${IDENTIFICATOR//+([[:digit:]])}" == "" ] ; then
		log info "identifypage() Has DjVu file ${FILE} page on position ${IDENTIFICATOR}?"
		local SEARCH="\[P${IDENTIFICATOR}\]"
	else
		log info "identifypage() Has DjVu file ${FILE} page with name ${IDENTIFICATOR}?"
		local SEARCH="\{${IDENTIFICATOR}\}"
	fi
#	echo "${SEARCH}" >> /dev/stderr
	local OUTPUT=$(${DJVUSED} "${SOURCE}" -e dump | grep FORM:DJVU | grep "${SEARCH}" | awk -F'[{}]' '{print $3}')
#	echo "${OUTPUT}" >> /dev/stderr
#	echo "${KEY}" >> /dev/stderr
	if [ -z "${OUTPUT}" ] ; then
		printf "identifypage: FAIL - for DjVu bundle %s identificator %s is NOT VALID.\n" "${FILE}" "${IDENTIFICATOR}" >> ${LOG}
		return 0
	else
		local ORDER="${OUTPUT//+([\]P\[ ])/}"
		log info "identifypage() OK order page is %s.\n" "${ORDER}"
		echo -n "${ORDER}"
	fi
}

function lastpage {
	# Function return count of all pages in DjVu bundle
	# $1 DjVu file
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	[ "$(testfile ${SOURCE})" == "djvu" ] || exit 1
	log info "lastpage() Count of all pages in ${FILE}"
	local OUTPUT=$(${DJVUSED} "${SOURCE}" -e n)
	echo -n "${OUTPUT}"
	
}

function deletepage {
	# $1 - soubor se kterým se pracuje
	# $2 - číslo, nebo název strany co se má odstranit
	local FILE="${1##*/}"
	if $(identifybundle "${1}") ; then
		echo "Soubor ${FILE} je typu single-page"
		return 1
	else
		local PAGE=$(identifypage "${1}" "${2}")
		if [ ! -z "${PAGE}" ] ; then
			${DJVM} -d "${1}" "${PAGE}"
		else
			return 2
		fi
	fi
}

function djvurotate {
	# $1 - soubor se kterým se pracuje
	# $2 - číslo, nebo název strany která se má rotovat
	# $3 - hodnota rotace
#	echo "$*" >> /dev/stderr
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	local INFO="""
Uvedenou hodnotu rotace nelze akceptovat. Rotaci lze nastavit buď 
absolutně, a nebo relativně (pootočit o 90°). AKceptované hodnoty:

      0 - výchozí pozice
      1 - natočení vpravo
      2 - otočení  vzhůru nohama
      3 - natočení vlevo
   left - rotace směrem doleva
  right - rotace směrem doprava).
    180 - přetočení o 180°

Každá jiná hodnota parametru je ignorována."""
	local PARAMS=($2)
	if [ "${#PARAMS[@]}" -gt "1" ] ; then
		case "${PARAMS[$((${#PARAMS[@]} -1))]}" in
			0|1|2|3|180|left|right) # echo "Jak mám otáčet $1" >> /dev/stderr
				local ROTATE="${PARAMS[$((${#PARAMS[@]} -1))]}"
#				echo "rotate: před ořezáním -$2-"
				local TEMP="${2% ${ROTATE}}"
				local IDPAGE=${TEMP##+([[:blank:]])}
#				echo "rotate: po ořezání -${IDPAGE}-"
			;;
			*) printf "%s - is not valid rotate VALUE" "${2}" >> /dev/stderr
				exit 1
			;;
		esac
	else
		case "${PARAMS}" in
			0|1|2|3|180|left|right) local ROTATE="${PARAMS}"
			;;
			*) printf "%s - is not valid rotate VALUE" "${PARAMS}" >> /dev/stderr
				exit 1
			;;
		esac
	fi

	if $(identifybundle "${1}") ; then
		if [ -z "${IDPAGE}" ] ; then
			case "${ROTATE}" in
				0|1|2|3)  ${DJVUSED} -e "set-rotation ${ROTATE}; save" "${SOURCE}"
				;;
				left) ${DJVUSED} -e "set-rotation +1; save" "${SOURCE}"
				;;
				right) ${DJVUSED} -e "set-rotation -1; save" "${SOURCE}"
				;;
				180) ${DJVUSED} -e "set-rotation +2; save" "${SOURCE}"
				;;
				*) echo "${INFO}" >> /dev/stderr
				;;
			esac
		else
			printf "DjVu file is single page. Param %s is non sense, continue in rotate?" "${IDPAGE}" >> /dev/stderr
			if $(potvrdit) ; then
				case "${ROTATE}" in
					0|1|2|3)  ${DJVUSED} -e "set-rotation ${ROTATE}; save" "${SOURCE}"
					;;
					left) ${DJVUSED} -e "set-rotation +1; save" "${SOURCE}"
					;;
					right) ${DJVUSED} -e "set-rotation -1; save" "${SOURCE}"
					;;
					180) ${DJVUSED} -e "set-rotation +2; save" "${SOURCE}"
					;;
					*) echo "${INFO}" >> /dev/stderr
					;;
				esac
			else
				exit 0
			fi
		fi
	else
		if [ -z "${IDPAGE}" ] ; then
			echo "Warning: If you want c a global orientation of pages Při globálním natočení stránek dokumentu dávejte pozor, zda-li nastavujete absolutní hodnotu natočení, nebo, zda-li otáčíte stránky relativně (left/right). Při točení se upravuje natočení všech stránek. Buďte tedy při této operaci opatrní a raději si předem zkontrolujte, zda-li tím neovlivníte i některou ze stránek. Pokud ano, pak zvolte buť relativní parametr natočení, nebo ji pak otočte do správné pozice dodatečně."
			if $(potvrdit) ; then
				case "${ROTATE}" in
					0|1|2|3)  ${DJVUSED} -e "set-rotation ${ROTATE}; save" "${SOURCE}"
					;;
					left) ${DJVUSED} -e "set-rotation +1; save" "${SOURCE}"
					;;
					right) ${DJVUSED} -e "set-rotation -1; save" "${SOURCE}"
					;;
					180) ${DJVUSED} -e "set-rotation +2; save" "${SOURCE}"
					;;
					*) echo "${INFO}" >> /dev/stderr
					;;
				esac
			else
				exit 0
			fi
		else
#			echo "Je třeba provést identifikaci stránky ${IDPAGE}"
			local NAMEPAGE=$(identifyname "${1}" "${IDPAGE}")
			if [ -z "${NAMEPAGE}" ] ; then
				printf "Page %s is not valid for file %s" "${IDPAGE}" "${FILE}" >> /dev/stderr
				exit 1
			else
				printf "Change orientation page %s in %s by %s" "${NAMEPAGE}" "${FILE}" "${ROTATE}" >> ${LOG}
				case "${ROTATE}" in
					0|1|2|3)  ${DJVUSED} -e "select '${NAMEPAGE}'; set-rotation ${ROTATE}; save" "${SOURCE}"
					;;
					left) ${DJVUSED} -e "select '${NAMEPAGE}'; set-rotation +1; save" "${SOURCE}"
					;;
					right) ${DJVUSED} -e "select '${NAMEPAGE}'; set-rotation -1; save" "${SOURCE}"
					;;
					180) ${DJVUSED} -e "select '${NAMEPAGE}'; set-rotation +2; save" "${SOURCE}"
					;;
					*) echo "${INFO}" >> /dev/stderr
					;;
			esac
			fi
		fi
	fi
}

function djvumove {
	# $1 - DjVu file
	# $2 - Parametry
	#	zdroj : identifikátor pozice
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"

	local VSTUP="${2}"
	local COUNT=${#VSTUP}
	local POS=0
	local START=0
	while [ $POS -lt $COUNT ]
	do local POS=$((POS+1))
#		echo "${VSTUP:$START:$POS}" >> /dev/stderr
		case "${VSTUP:$START:$POS}" in
			*.[dD][jJ][vV][uU]|*.[gG][iI][fF]|*.[jJ][pP][gG]|*.[mM][nN][gG]|*.[pP][dD][fF]|*.[pP][nN][gG]|*.[pP][nN][mM]|*.[tT][iI][fF][fF]|*.[xX][cC][fF]) 
				local SOUBOR="${VSTUP:0:$POS}"
				log info "move() Zachycen soubor $SOUBOR - ${SOUBOR:$((${#SOUBOR} - 4)):4}"
				if [ "${SOUBOR:$((${#SOUBOR} - 4)):4}" == "djvu" ] ; then
#					echo "Před testem.. '${SOUBOR##+([[:blank:]])}'" >> /dev/stderr
					local TESTORDER=$(identifypage "${SOURCE}" "${SOUBOR##+([[:blank:]])}")
#					echo "Po testu.." >> /dev/stderr
					if [ -z "${TESTORDER}" ] ; then
						if [ -f "${SOUBOR}" ] ; then
							local FROM="${SOUBOR}"
							local VSTUP="${VSTUP#${SOUBOR} }"
							local COUNT=${#VSTUP}
							local POS=0
							echo "move: OK - jde o DjVu soubor ${SOUBOR} co se má vložit" >> /dev/stderr
							local ANAME="${SOUBOR}"
							##### Ve zbytku musí být identifikátor
							# ....
#							echo "Insert djvu file yet not implemented!!!" >> /dev/stderr
#							return 0
						else
							local TEST=( ${SOUBOR} )
							if [ "${#TEST}" -gt "0" ] ; then
								local A="${TEST[0]}"
								if [ "${A%%+([[:digit:]])}" == "" ] ; then
									local BTEST="${SOUBOR##${A}+([[:blank:]])}"
									local B=$(identifypage "${SOURCE}" "${BTEST}")
									if [ -z "${B}" ] ; then
										echo "move: FAIL - for DjVu file ${FILE} identificator target page ${BTEST} is not valid." >> /dev/stderr
										exit 1
									else
										#FINITO### tady budu realizovat přesun...?
										local ANAME=$(identifyname "${SOURCE}" "${A}")
										local BNAME=$(identifyname "${SOURCE}" "${B}")
										if [ "${ANAME}" == "${BNAME}" ] ; then
											echo "move: FAIL - If you want move page on position ${A}, which is the same page as target. If you want moved page from position ${2} before actual position, use command without identification of target position." >> /dev/stderr
											exit 1
										fi
										if [ "${MOVE}" == "fore" ] ; then
											if [ "$A" == "1" ] ; then
												echo "move: INFO - page ${ANAME} is on first position in ${FILE}." >> /dev/stderr
												return 1
											elif [ "$A" == "$((${B} - 1))" ] ; then
												echo "move: INFO - page ${ANAME} is on previous position (${A}) in ${FILE} before page ${BNAME} (position ${B})." >> /dev/stderr
												return 1
											else
												PAGE="yes"
												exportdjvupage "${SOURCE}" "${ANAME}" "${TEMPDIR}"
												deletepage "${SOURCE}" "${ANAME}"
												if [ "${A}" -gt "${B}" ] ; then
													${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "${B}"
												else
													${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "$((${B} - 1))"
												fi
												return 0
											fi
										elif [ "${MOVE}" == "back" ] ; then
											local TEST=$(lastpage "${1}")
											if [ "$A" == "${TEST}" ] ; then
												echo "move: INFO - page ${ANAME} is on last position in ${FILE}." >> /dev/stderr
												return 1
											elif [ "$A" == "$((${B} + 1))" ] ; then
												echo "move: INFO - page ${ANAME} is on next position in ${FILE} after page ${BNAME}." >> /dev/stderr
												return 0
											else
												PAGE="yes"
												exportdjvupage "${SOURCE}" "${ANAME}" "${TEMPDIR}"
												deletepage "${SOURCE}" "${ANAME}"
												if [ "${A}" -lt "${B}" ] ; then
													${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "${B}"
												else
													${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "$((${B} - 1))"
												fi
												return 0
											fi
										else
											echo "move: Nedělám nic" >> /dev/stderr
										fi
									fi
								else
									echo "move: FAIL - identificator '${SOUBOR##+([[:blank:]])}' for file ${FILE} is not valid. Pay attention to the gap - are treacherous!" >> /dev/stderr
									exit 1
								fi
							else
								echo "move: S názvem souboru není něco v pořádku" >> /dev/stderr
							fi
						fi
					else
						if [ -z "${ANAME}" ] ; then
							# Nenastavené ANAME 
							local ANAME="${SOUBOR}"
							local A="${TESTORDER}"
							local VSTUP="${VSTUP#${SOUBOR}}"
							if [ "${VSTUP##+([[:blank:]])}" == "" ] ; then
								#FINITO### tady budu realizovat přesun...?
								if [ "${MOVE}" == "fore" ] ; then
									if [ "$A" == "1" ] ; then
										echo "move: INFO - page ${ANAME} is on first position in ${FILE}." >> /dev/stderr
										return 1
									else
										PAGE="yes"
										exportdjvupage "${SOURCE}" "${ANAME}" "${TEMPDIR}"
										deletepage "${SOURCE}" "${ANAME}"
										${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "$((${A} - 1))"
										return 0
									fi
								elif [ "${MOVE}" == "back" ] ; then
									local TEST=$(lastpage "${1}")
									if [ "$A" == "${TEST}" ] ; then
										echo "move: INFO - page ${ANAME} is on last position in ${FILE}." >> /dev/stderr
										return 1
									else
										PAGE="yes"
										exportdjvupage "${SOURCE}" "${ANAME}" "${TEMPDIR}"
										deletepage "${SOURCE}" "${ANAME}"
										${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "$((${A}+1))"
										return 0
									fi
								else
									echo "move: Nedělám nic" >> /dev/stderr
								fi
							else
								local TEST="${VSTUP##+([[:blank:]])}"
								if [ "${TEST##+([[:digit:]])}" == "" ] ; then
#									# Pořadové číslo - budu přesouvat..
									local B=$(identifypage "${SOURCE}" "${TEST}")
									if [ -z "${B}" ] ; then
										echo "move: ERROR - target position is not valid for file ${FILE}" >> /dev/stderr
										exit 1
									else
										#FINITO## Budu přesouvat
										if [ "${A}" == "${B}" ] ; then
											echo "move: FAIL - If you want move page on position ${A}, which is the same page as target. If you want moved page from position ${2} before actual position, use command without identification of target position." >> /dev/stderr
											exit 1
										fi
										if [ "${MOVE}" == "fore" ] ; then
											if [ "${A}" == "$((${B} - 1))" ] ; then
												echo "move: INFO - page ${ANAME} is on previous position (${A}) in ${FILE} before page with position ${B}." >> /dev/stderr
												return 1
											else
												PAGE="yes"
												exportdjvupage "${SOURCE}" "${ANAME}" "${TEMPDIR}"
												deletepage "${SOURCE}" "${ANAME}"
												if [ "${A}" -gt "${B}" ] ; then
													${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "${B}"
												else
													${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "$((${B} - 1))"
												fi
												return 0
											fi
										elif [ "${MOVE}" == "back" ] ; then
											local TEST=$(lastpage "${SOURCE}")
											if [ "$A" == "${TEST}" ] ; then
												echo "move: INFO - page ${ANAME} is on last position in ${FILE}." >> /dev/stderr
												return 1
											elif [ "$A" == "$((${B} + 1))" ] ; then
												echo "move: INFO - page ${ANAME} is on next position in ${FILE} after page which is target (${B})." >> /dev/stderr
												return 0
											else
												PAGE="yes"
												exportdjvupage "${SOURCE}" "${ANAME}" "${TEMPDIR}"
												deletepage "${SOURCE}" "${ANAME}"
												if [ "${A}" -lt "${B}" ] ; then
													${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "${B}"
												else
													${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "$((${B} - 1))"
												fi
												return 0
											fi
										else
											echo "move: Nedělám nic" >> /dev/stderr
										fi
										return 0
									fi
								else
									local COUNT=${#VSTUP}
									local POS=0
									log warn "move() INFO - page ${ANAME} has order ${A}. What is the identificator of target page from bundle -$VSTUP-?"
								fi
							fi
						elif [ "${ANAME}" == "none" ] ; then
#							# ANAME je none
							local B=$(identifypage "${1}" "${SOUBOR}")
							if [ -z "${B}" ] ; then
								echo "move: ERROR - Chybné jméno stránky před kterou se má stránka přesunout" >> /dev/stderr
								exit 1
							else
								local A=""
								local BNAME="${SOUBOR}"
								log warn "move() Vkládá se konvertovaná stránka ${FROM} před stránu -${BNAME}- na pozici ${B}"
								break
							fi
						else
#							#FINITO### Budu přesouvat..
#							echo "move: ${A} ${TESTORDER}" >> /dev/stderr
							if [ "${A}" == "${TESTORDER}" ] ; then
								echo "move: FAIL - If yu want move page ${ANAME} in ${FILE} about one position. You must for it use action ${MOVE} only with identificator of page to move." >> /dev/stderr
								exit 1
							else
								local B=$(identifypage "${1}" "${SOUBOR}")
								if [ -z "${B}" ] ; then
									echo "move: FAIL - Chybné jméno stránky před kterou se má stránka přesunout" >> /dev/stderr
									exit 1
								else
									local A=$(identifypage "${1}" "${ANAME}")
									if [ -z "${A}" ] ; then
										echo "move: file ${ANAME} je djvu soubor?" >> /dev/stderr
#										exit 1
									else
										echo "move: ANAME je soubor ${ANAME}.." >> /dev/stderr
									local BNAME="${SOUBOR}"
#									#FINITO## Budu přesouvat ####
									if [ "${ANAME}" == "${BNAME}" ] ; then
										echo "move: FAIL - If you want move page on position ${A}, which is the same page as target. If you want moved page from position ${2} before actual position, use command without identification of target position." >> /dev/stderr
										exit 1
									fi
									if [ "${MOVE}" == "fore" ] ; then
										if [ "$A" == "1" ] ; then
											echo "move: INFO - page ${ANAME} is on first position in ${FILE}." >> /dev/stderr
											return 1
										elif [ "$A" == "$((${B} - 1))" ] ; then
											echo "move: INFO - page ${ANAME} is on previous position (${A}) in ${FILE} before page ${BNAME} (position ${B})." >> /dev/stderr
											return 1
										else
											PAGE="yes"
											exportdjvupage "${SOURCE}" "${ANAME}" "${TEMPDIR}"
											deletepage "${SOURCE}" "${ANAME}"
											if [ "${A}" -gt "${B}" ] ; then
												${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "${B}"
											else
												${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "$((${B} - 1))"
											fi
											return 0
										fi
									elif [ "${MOVE}" == "back" ] ; then
										local TEST=$(lastpage "${1}")
										if [ "$A" == "${TEST}" ] ; then
											echo "move: INFO - page ${ANAME} is on last position in ${FILE}." >> /dev/stderr
											return 1
										elif [ "$A" == "$((${B} + 1))" ] ; then
											echo "move: INFO - page ${ANAME} is on next position in ${FILE} after page ${BNAME}." >> /dev/stderr
											return 0
										else
											PAGE="yes"
											exportdjvupage "${SOURCE}" "${ANAME}" "${TEMPDIR}"
											deletepage "${SOURCE}" "${ANAME}"
											if [ "${A}" -lt "${B}" ] ; then
												${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "${B}"
											else
												${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "$((${B} - 1))"
											fi
											return 0
										fi
									else
										echo "move: Nedělám nic" >> /dev/stderr
									fi
									fi
								fi
							fi
						fi
					fi
				else
					if [ -f "${SOUBOR}" ] ; then
						local FROM="${SOUBOR}"
						##### KONVERZE #######
						local ANAME="none"
						local VSTUP="${VSTUP#${SOUBOR}}"
						local COUNT=${#VSTUP}
						local POS=0
						echo "move: INFO file ${SOUBOR} id not DjVu; must be converted" >> /dev/stderr
						local ANAME="${TEMPDIR}/${SOUBOR%.*}.djvu"
						filetodjvu "${SOUBOR}" "${ANAME}"
						if [ ! -f "${ANAME}" ] ; then
							echo "move: ERROR - file ${ANAME} not exists. Probably any problem with conversion." >> /dev/stderr
							exit 1
						fi
					else
						echo "move: ERROR - Soubor ${SOUBOR} neexistuje" >> /dev/stderr
						exit 1
					fi
				fi
			;;
		esac
	done

	if [ -f "${ANAME}" ] ; then
		echo "Sem to propadne je-li ANAME -${ANAME}- již existující soubor" >> /dev/stderr
		if [ -z "${BNAME}" ] ; then
			echo "move: Musím získat pozici ze zbytku ${VSTUP}" >> /dev/stderr
			local TEST="${VSTUP##+([[:blank:]])}"
			if [ "${TEST##+([[:blank:]])}" == "" ] ; then
				## Budu soubor připojovat na konec DjVu svazku...
				# Není třeba nic víc řešit...
				echo "Budu soubor připojovat na konec DjVu svazku. Není třeba řešit nic víc, nežli to zda není nějaká stránka v konfliktu.."
				if comparedjvu "${SOURCE}" "${ANAME}" ; then
					echo "move: APPEND - content of file ${ANAME} to ${MOVE} ${SOURCE}" >> /dev/stderr
					if [ "${MOVE}" == "fore" ] ; then
						${DJVM} -i "${SOURCE}" "${ANAME}" 1
					elif [ "${MOVE}" == "back" ] ; then
						${DJVM} -i "${SOURCE}" "${ANAME}"
					else
						echo "Nedělám nic" >> /dev/stderr
					fi
					return 0
				else
					echo "Stránka je v konfliktu" >> /dev/stderr
					exit 1
				fi
			else
				local B=$(identifypage "${SOURCE}" "${TEST}")
				if [ -z "${B}" ] ; then
					echo "move: identificator -${TEST} is not valid." >> /dev/stderr
					exit 1
				else
					echo "move: APPEND - content of file ${ANAME} to ${SOURCE} ${MOVE} page ${B}" >> /dev/stderr
					if comparedjvu "${SOURCE}" "${ANAME}" ; then
						if [ "${MOVE}" == "fore" ] ; then
							${DJVM} -i "${SOURCE}" "${ANAME}" "${B}"
						elif [ "${MOVE}" == "back" ] ; then
							${DJVM} -i "${SOURCE}" "${ANAME}" "$((${B} + 1))"
						else
							echo "Nedělám nic" >> /dev/stderr
						fi
						return 0
					else
						echo "Stránka je v konfliktu" >> /dev/stderr
						exit 1
					fi
				fi 
			fi
		fi
	else
		if [ -z "${ANAME}" ] ; then
			local TEST=( ${VSTUP} )
			if [ "${#TEST}" -gt "0" ] ; then
				local ANAME=$(identifyname "${SOURCE}" "${TEST[0]}")
				if [ -z "${ANAME}" ] ; then
					echo "move: FAIL - for DjVu file ${FILE} identificator ${TEST[0]} is not valid." >> /dev/stderr
					exit 1
				else
					if [ "${TEST[1]##+([[:blank:]])}" != "" ] ; then
						local BNAME=$(identifyname "${SOURCE}" "${TEST[1]}")
						if [ -z "${BNAME}" ] ; then
							echo "move: FAIL - for DjVu file ${FILE} identificator ${TEST[1]} is not validxxx." >> /dev/stderr
							exit 1
						else
							echo "move: INFO - page ${ANAME} has order ${A}. Do move ${MOVE} ${BNAME}." >> /dev/stderr
							### budu přesouvat stránku na pozici..
						fi
					else
						echo "move: page ${ANAME} move ${MOVE}" >> /dev/stderr
						### budu přesouvat stránku o jednu pozici..
					fi

				fi
			fi 
		fi
	fi

	echo "move - jsem za tim" >> /dev/stderr

	if [ -z "${BNAME}" ] ; then
		if [ -z "{ANAME}" ] ; then
			echo "move: Neplatná cílová stránka ${BNAME}, i stránka ${ANAME} která se má přesouvat" >> /dev/stderr
			exit 1
		else
			local TEST=( ${VSTUP} )
			if [ "${#TEST}" -gt "0" ] ; then
				local BNAME=$(identifyname "${SOURCE}" "${TEST[0]}")
				if [ -z "${BNAME}" ] ; then
					echo "move: FAIL - identificator ${TEST[0]} is not valid for DjVu file ${FILE}" >> /dev/stderr
					exit 1
				else
#					#FINITO## Zpracovávám přesun..
					if [ "${ANAME}" == "${BNAME}" ] ; then
						local A=$(identifypage "${SOURCE}" "${ANAME}")
						if [ "${MOVE}" == "fore" ] ; then
							if [ "$A" == "1" ] ; then
								echo "move: INFO - page ${ANAME} is on first position in ${FILE}." >> /dev/stderr
								return 1
							else
								PAGE="yes"
								exportdjvupage "${SOURCE}" "${ANAME}" "${TEMPDIR}"
								deletepage "${SOURCE}" "${ANAME}"
								${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "$((${A} - 1))"
								return 0
							fi
						elif [ "${MOVE}" == "back" ] ; then
							local TEST=$(lastpage "${1}")
							if [ "$A" == "${TEST}" ] ; then
								echo "move: INFO - page ${ANAME} is on last position in ${FILE}." >> /dev/stderr
								return 1
							else
								PAGE="yes"
								exportdjvupage "${SOURCE}" "${ANAME}" "${TEMPDIR}"
								deletepage "${SOURCE}" "${ANAME}"
								${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "$((${A}+1))"
								return 0
							fi
						else
							echo "move: Nedělám nic" >> /dev/stderr
						fi
					else
#						echo "move: INFO - move page -${ANAME}- -${A}- ${MORE} page -${BNAME}- -${B}-" >> /dev/stderr
#						#FINITO## Zpracovávám přesun..
						local B=$(identifypage "${SOURCE}" "${BNAME}")
						if [ "${ANAME}" == "${BNAME}" ] ; then
							echo "move: FAIL - If you want move page on position ${A}, which is the same page as target. If you want moved page from position ${2} before actual position, use command without identification of target position." >> /dev/stderr
							exit 1
						fi
						if [ "${MOVE}" == "fore" ] ; then
							if [ "$A" == "1" ] ; then
								echo "move: INFO - page ${ANAME} is on first position in ${FILE}." >> /dev/stderr
								return 1
							elif [ "$A" == "$((${B} - 1))" ] ; then
								echo "move: INFO - page ${ANAME} is on previous position (${A}) in ${FILE} before page ${BNAME} (position ${B})." >> /dev/stderr
								return 1
							else
								PAGE="yes"
								exportdjvupage "${SOURCE}" "${ANAME}" "${TEMPDIR}"
								deletepage "${SOURCE}" "${ANAME}"
								if [ "${A}" -gt "${B}" ] ; then
									${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "${B}"
								else
									${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "$((${B} - 1))"
								fi
								return 0
							fi
						elif [ "${MOVE}" == "back" ] ; then
							local TEST=$(lastpage "${SOURCE}")
							if [ "$A" == "${TEST}" ] ; then
								echo "move: INFO - page ${ANAME} is on last position in ${FILE}." >> /dev/stderr
								return 1
							elif [ "$A" == "$((${B} + 1))" ] ; then
								echo "move: INFO - page ${ANAME} is on next position in ${FILE} after page ${BNAME}." >> /dev/stderr
								return 0
							else
								PAGE="yes"
								exportdjvupage "${SOURCE}" "${ANAME}" "${TEMPDIR}"
								deletepage "${SOURCE}" "${ANAME}"
								if [ "${A}" -lt "${B}" ] ; then
									${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "${B}"
								else
									${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "$((${B} - 1))"
								fi
								return 0
							fi
						else
							echo "move: Nedělám nic" >> /dev/stderr
						fi
					fi
				fi
			else
				echo "move: FAIL ANAME -${ANAME}-, VSTUP -${VSTUP}- je buď prázdný, nebo obsahuje pouze číselnou identifikaci cílové pozice" >> /dev/stderr
				exit 1
			fi 
		fi
	else
		if [ -z "${FROM}" ] && [ -z "${ANAME}" ] ; then
			echo "move: Neplatná identifikace stránky se kterou se má pracovat" >> /dev/stderr
			exit 1
		fi
	fi

	echo "FROM - ${FROM}" >> /dev/stderr
	echo "A - ${A}" >> /dev/stderr
	echo "ANAME - ${ANAME}" >> /dev/stderr
	echo "B - ${B}" >> /dev/stderr
	echo "BNAME - ${BNAME}" >> /dev/stderr
	echo "MOVE - ${MOVE}" >> /dev/stderr

# Do tohoto místa probíhá zpracování stejně pro fore i back
# Následuje další zpracování parametrů - především porovnání ..

# 1, je-li ANAME, stejné jako BNAME, přesun A o jednu pozici vřed či vzad..
#
# 2, je-li FROM stejné jako BNAME, vyhodit dotaz: 
#		Nahradit? nebo akci přerušit?
# Pro MOVE=fore...
# 3f, je-li pozice A o 1 větší než B - skončit 
# 4f, je-li pozice A = 1 skončit 
# 
# Pro MOVE=back...
# 3b, je-li pozice A o 1 menší než B - skončit
# 4b, le-li pozice A = lastpage skončit
#
# Má se přesouvat kupředu
}

function range {
	# 1,2,3-9,10-20
	case "${1:0:1}" in
		[[:digit:]]) local INPUTARRAY=( ${1//,/ } )
			for i in ${INPUTARRAY[@]} ; do
				if [[ "$i" =~ "-" ]] ; then
					seq ${i//-/ }
				else
					seq ${i} ${i}
				fi
			done | sort -u
		;;
		*) printf "range: FAIL - range of pages must be set only from order numbers, commas and hyphens.\n" >> /dev/stderr
		exit 1
		;;
	esac
}

function changemeta {
	# Funkce která modifikuje soubor pro vložení meta atributů
	# AUTHOR
	# TITLE
	# SUBJECT
	# NOTE
	# ANNOTATION
	# URL
	# CREATOR
	[ $(grep -c '^CreationDate' ${1}) -eq 0 ] && printf "CreationDate \"%s\"\n" "$(date -u +%FT%T%:z)" >> ${1}
	if [ $(grep -c '^Producer' ${1}) -eq 1 ] ; then
		sed --in-place '/^Producer/,/$/d' ${1}
		printf 'Producer "djvutool 0.1 alpha (http://www.thewoodcraft.org)"\n' >> ${1}
	elif  [ $(grep -c '^Producer' ${1}) -eq 0 ] ; then
		printf 'Producer "djvutool 0.1 alpha (http://www.thewoodcraft.org)"\n' >> ${1}
	fi
	if [ $(grep -c '^ModDate' ${1}) -eq 1 ] ; then
		sed --in-place '/^ModDate/,/$/d' ${1}
		printf "ModDate \"%s\"\n" "$(date -u +%FT%T%:z)" >> ${1}
	elif  [ "$(grep -c ^ModDate $1)" == "0" ] ; then
		printf "ModDate \"%s\"\n" "$(date -u +%FT%T%:z)" >> ${1}
	fi
	printf '##' >> ${1}
	printf '## Toto jsou nejčastěji používané atributy. Budete-li je chtít použít,' >> ${1}
	printf '## stačí zrušit znak # na začátku řádky a doplnit do uvozovek obsah\n' >> ${1}
	printf '## Pokud budete mít nastavenou odpovídající proměnnou, tak se některé doplní.\n' >> ${1}
	[ $(grep -c '^Title' ${1}) -eq 0 ] && printf '#Title "%s"\t# - název zpracovávaného dokumentu\n' "${TITLE}" >> ${1}
	[ $(grep -c '^Author' ${1}) -eq 0 ] && printf '#Author "%s"\t# - jméno autora původního dokumentu, je-li znám\n' "${AUTHOR-unknown}" >> ${1}
	[ $(grep -c '^Subject' ${1}) -eq 0 ] && printf '#Subject "%s"\t# - stručné info o čem to je\n' "${SUBJECT}" >> ${1}
	[ $(grep -c '^Keywords' ${1}) -eq 0 ] && printf '#Keywords " "\t# - klíčová slova, která se vztahují k dokumentu, oddělená čárkou\n' >> ${1}
	[ $(grep -c '^note' ${1}) -eq 0 ] && printf '#note "%s"\t# - poznámka ke stránce\n' "${NOTE}" >> ${1}
	[ $(grep -c '^annote' ${1}) -eq 0 ] && printf '#annote "%s"\t# - stručná anotace obsahu\n' "${ANNOTATION}" >> ${1}
	[ $(grep -c '^url' ${1}) -eq 0 ] && printf '#url "%s"\t# - URL vašeho webu\n' "${URL}" >> ${1}
	[ $(grep -c '^Trapped' ${1}) -eq 0 ] && printf '#Trapped "FALSE"\t# - indikační klíč, který oznamuje zda-li je úprava stránky tímto dokončena (TRUE), nebo ne (FALSE)\n' >> ${1}
	[ $(grep -c '^Creator' ${1}) -eq 0 ] && printf '#Creator "%s"\t# - uvádí se jméno autora, nebo název aplikace ve které vytvořil původní dokument.\n' "${CREATOR}" >> ${1}
	return 0
}

function setmeta {
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .meta)
	local CHARSET="${2}"
	local RANGE="${CHARSET%%\ *}"
	if [ "${RANGE}" == "all" ] ; then
		local ITEM="${CHARSET#* }"
		local KEY=(${ITEM})
		if [ "${#KEY[@]}" -lt "2" ] ; then
			printf "setmeta: FAIL - you must set meta attribute key and any value for it.\n"
			exit 1
		else
			for i in $(seq $(lastpage "${SOURCE}")) ; do
				printf "set meta: Set meta attribute key %s into all pages in DjVu bundle %s\n" "${KEY[0]}" "${FILE}" >> ${LOG}
				printmeta "${SOURCE}" "$i" | grep -v '^[#.]\|^$' > ${TEMPFILE}
				ed ${TEMPFILE} 2>/dev/null <<-EOF
/${KEY}
d
w
q
EOF
				ed ${TEMPFILE} 2>/dev/null <<-EOF
i
${ITEM}
.
w
q
EOF
				${DJVUSED} "${SOURCE}" -e "select $i; set-meta ${TEMPFILE}" -s
			done 1>/dev/null
		fi
	elif [ "${RANGE//+([[:alpha:]])/}" == "" ] ; then
		local ITEM="${CHARSET}"
		printf "set meta: Set global meta attribute key %s into DjVu bundle %s\n" "${RANGE}" "${FILE}" >> ${LOG}
		printmeta "${SOURCE}" global | grep -v '^[#.]\|^$' > ${TEMPFILE}
		ed ${TEMPFILE} 2>/dev/null <<-EOF
/${RANGE}
d
w
q
EOF
		ed ${TEMPFILE} 2>/dev/null <<-EOF
i
${ITEM}
.
w
q
EOF
		${DJVUSED} "${SOURCE}" -e "select; set-meta ${TEMPFILE}" -s
	else
		local IDPAGES=($(range "${RANGE}"))
		local ITEM="${CHARSET#* }"
		local KEY=(${ITEM})
		for i in ${IDPAGES[@]} ; do
			printf "set meta: Set meta attribute key %s into page %s in DjVu bundle %s\n" "${KEY[0]}" "$i" "${FILE}" >> ${LOG}
			printmeta "${SOURCE}" "$i" | grep -v '^[#.]\|^$' > ${TEMPFILE}
			ed ${TEMPFILE} 2>/dev/null <<-EOF
/${KEY}
d
w
q
EOF
			ed ${TEMPFILE} 2>/dev/null <<-EOF
i
${ITEM}
.
w
q
EOF
			${DJVUSED} "${SOURCE}" -e "select $i; set-meta ${TEMPFILE}" -s
		done 1>/dev/null
	fi
	return 0
}


function unsetmeta {
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .meta)
	local CHARSET="${2}"
	local RANGE="${CHARSET%%\ *}"
	if [ "${RANGE}" == "all" ] ; then
		local ITEM="${CHARSET#* }"
		local KEY=(${ITEM})
		printf "unset meta: Remove attribute key %s from all pages DjVu bundle %s\n" "${KEY[0]}" "${FILE}" >> ${LOG}
		for i in $(seq $(lastpage "${SOURCE}")) ; do
			printmeta "${SOURCE}" "$i" | grep -v '^[#.]\|^$' > ${TEMPFILE}
			ed ${TEMPFILE} 2>/dev/null <<-EOF
/${KEY}
d
w
q
EOF
			${DJVUSED} "${SOURCE}" -e "select $i; set-meta ${TEMPFILE}" -s
		done  1>/dev/null
	elif [ "${RANGE//+([[:alpha:]])/}" == "" ] ; then
		printf "unset meta: Remove global attribute key %s from DjVu bundle %s\n" "${RANGE}" "${FILE}" >> ${LOG}
		printmeta "${SOURCE}" global | grep -v '^[#.]\|^$' > ${TEMPFILE}
		ed ${TEMPFILE} 2>/dev/null <<-EOF
/${RANGE}
d
w
q
EOF
		${DJVUSED} "${SOURCE}" -e "select; set-meta ${TEMPFILE}" -s
	else
		local IDPAGES=($(range "${RANGE}"))
		local ITEM="${CHARSET#* }"
		local KEY=(${ITEM})
		for i in ${IDPAGES[@]} ; do
			printf "unset meta: Remove attribute key %s from page %s\n" "${KEY[0]}" "$i" >> ${LOG}
			printmeta "${SOURCE}" "$i" | grep -v '^[#.]\|^$' > ${TEMPFILE}
			ed ${TEMPFILE} 2>/dev/null <<-EOF
/${KEY}
d
w
q
EOF
			${DJVUSED} "${SOURCE}" -e "select $i; set-meta ${TEMPFILE}" -s
		done  1>/dev/null
	fi
	return 0
}

function djvuinfo {
	# $1 - soubor
	# $2 - parametry
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	if $(identifybundle "${SOURCE}") ; then
		local PAGES="none"
	else
		local PAGES=$(lastpage "${SOURCE}")
	fi
	if [ -z "${2}" ] ; then
		case "${PAGES}" in
			none) local INFO="${FILE}"
				echo -n "${INFO}" && printf "%$((31 - ${#INFO}))s : DjVu single-page\n"
			;;
			*) local INFO="${FILE}"
				echo -n "${INFO}" && printf "%$((31 - ${#INFO}))s : DjVu bundle - ${PAGES} pages\n"
			;;
		esac
	else
		case "${2}" in
			exif) ${EXIFTOOL} "${SOURCE}"
			;;
			meta) printmeta "${SOURCE}" all | grep -v '^[#.]\|^$'
			;;
			pages) if identifybundle ${SOURCE} ; then
					${DJVM} -l "${SOURCE}" | grep PAGE\ # | awk '{print " [P"$3"]:"$4}' | sed 's/P#/P/'
				else
					${DJVUSED} "${SOURCE}" -e dump | grep FORM:DJVU | awk -F'[{}]' '{print $3":"$2}'
				fi
				return 0
			;;
			*) case "${2%%\ *}" in
					meta) if [ "${2#* }" == "all" ] ; then
							printmeta "${SOURCE}" all | grep -v '^[#.]\|^$'
							return 0
						elif [ "${2#* }" == "global" ] ; then
							printmeta "${SOURCE}" global | grep -v '^[#.]\|^$'
							return 0
						else
							printf "Meta atributtes for page %s from %s" "${2#* }" "${FILE}" >> ${LOG}
							local NAMEPAGE=$(identifyname "${SOURCE}" "${2#* }")
							if [ -z "${NAMEPAGE}" ] ; then
								echo "info: FAIL - identificator page ${2#* } is not valid for DjVu bundle ${FILE}" >> /dev/stderr
								exit 1
							else
								local IDPAGE=$(identifypage "${SOURCE}" "${NAMEPAGE}")
								printf "Meta attributes from #%s page in DjVu bundle %s" "${IDPAGE}" "${FILE}" >> ${LOG}
								printmeta "${SOURCE}" "${NAMEPAGE}" | grep -v '^[#.]\|^$'
								return 0
							fi
						fi
					;;
					pages) if [ "${2#* }" == "all" ] ; then
							if identifybundle ${SOURCE} ; then
								${DJVM} -l "${SOURCE}" | grep PAGE\ # | awk '{print " [P"$3"]:"$4}' | sed 's/P#/P/'
							else
								${DJVUSED} "${SOURCE}" -e dump | grep FORM:DJVU | awk -F'[{}]' '{print $3":"$2}'
							fi
							return 0
						else
							printf "View %s item from list %s" "${2#* }" "${FILE}" >> ${LOG}
							local NAMEPAGE=$(identifyname "${SOURCE}" "${2#* }")
							if [ -z "${NAMEPAGE}" ] ; then
								echo "info: FAIL - identificator page ${2#* } is not valid for DjVu bundle ${FILE}" >> /dev/stderr
								exit 1
							else
								local IDPAGE=$(identifypage "${SOURCE}" "${NAMEPAGE}")
								printf " [P%d]:%s\n" "${IDPAGE}" "${NAMEPAGE}"
								return 0
							fi
						fi
					;;
					exif) if [ "${2#* }" == "all" ] ; then
							${EXIFTOOL} "${SOURCE}"
							return 0
						else
							printf "Exif atributtes for page %s from %s" "${2#* }" "${FILE}" >> ${LOG}
							local NAMEPAGE=$(identifyname "${SOURCE}" "${2#* }")
							if [ -z "${NAMEPAGE}" ] ; then
								echo "info: FAIL - identificator page ${2#* } is not valid for DjVu bundle ${FILE}" >> /dev/stderr
								exit 1
							else
								local IDPAGE=$(identifypage "${SOURCE}" "${NAMEPAGE}")
								PAGE="yes"
								djvuexport "${1}" "${NAMEPAGE} ${TEMPDIR}"
								local INFO="Page #${IDPAGE} from DjVu bundle"
								echo -n "${INFO}" && printf "%$((31 - ${#INFO}))s : ${FILE}\n"
								${EXIFTOOL} "${TEMPDIR}/${NAMEPAGE}"
								return 0
							fi
						fi
					;;
				esac
			;;
		esac
	fi
}

function help {
	case "$1" in
		algorithm) echo """Nápověda pro algoritmy.. ToDo
		"""
		;;
		bundle) echo """Nápověda pro volbu typu svazku.. ToDo
		"""
		;;
		page) echo """volba [1m-p[0m ([1m--page[0m)

  Extrakce DjVu stránky ze svazku při akci [2mexport[22m

  [1m${0##*/}[0m ... {-p|--page} [yes|no] ...
  
[4mPoznámka:[24m
  * Pokud za volbou není uveden žádný další parametr, tak se automaticky
    předpokládá - yes.
  * Výchozí parametr - no - lze implicitně změnit nastavením proměnné
    PAGE do souboru v adresáři ${HOME}/.config/${NAME}/
  * Exportované stránky se ukládají pod svým původním názvem.
"""
		;;
		image) echo """volba [1m-i[0m ([1m--img[0m)

  [4mExtrakce obrazové vrstvy[24m DjVu stránky do bitmapového souboru

  [1m${0##*/}[0m ... {-i|--img} [yes|no|<layer>] ...

  Je-li parametrem volby [3myes[23m, tak se bude při akci [2mexport[22m generovat z DjVu
  stránky plnobarevný bitmapový obrázek ve formátu PNG.
  V ostatních případech bude ve formátu PNM.

      [1m${0##*/}[0m --img background svazek.djvu export stranka.djvu
 
Použitelné parametry:
                 color - plnobarevná stránka
                 black - černobílá kresba
            foreground - vrstva popředí
            background - vrstva pozadí
                  mask - maska
  Je-li místo [3m'yes'[23m uvedeno [3m'background'[23m, bude při exportu stránky
  strana.djvu uložen obrázek pozadí pod jménem strana.background.pnm
  Výchozí nastavení lze implicitně změnit nastavením proměnné IMGPAGE
"""
		;;
		dsed) echo """Option [1m-d[0m ([1m--dsed[0m)

  Extrakce skryté textové vrstvy DjVu stránky ve formátu pro djvused.
  Parametrem lze zvolit, co se má při akci [2mexport[22m uložit.

  [1m${0##*/}[0m ... {-d|--dsed} [yes|no|all|txt|ant] ...
  
         yes - stejný efekt jako volba all
         no  - textová vrstva se neexportuje (default)
         all - exportuje se celý obsah skryté textové vrstvy
         txt - exportuje se pouze obsah stránky
         ant - exportují se meta atributy stránky, hyperlinky, atp.

[4mPoznámka:[24m
  * Pokud za volbou není uveden žádný další parametr, tak se automaticky
    předpokládá - yes.
  * Výchozí parametr - no - lze implicitně změnit nastavením proměnné
    DSED do souboru v adresáři ${HOME}/.config/${NAME}/
  * Exportovaná data se ukládají do souborů s příponou [3m.dsed[23m.
"""
		;;
		force) echo """volba [1m-f[0m ([1m--force[0m)

  Nastavením této volby si lze vynutit výchozí chování k souborům při
  akci [2mexport[22m. Není-li uvedena, tak se skript před každým
  přepsáním již existujícího souboru zeptá, zda-li má, nebo nemá
  pokračovat.

  [1m${0##*/}[0m ... {-f|--force} [yes|no|skip] ...
  
         yes  - všechny soubory se budou bez keců přepisovat.
         no   - skript se před přepsáním souboru bude dotazovat, zda-li
                má soubor přepsat.
         skip - pokud bude cílový soubor existovat, tak se akce přeskočí.

[4mPoznámka:[24m
  * Pokud za volbou není uveden žádný další parametr, tak se automaticky
    předpokládá - skip.
  * Výchozí parametr hodnotu parametru  (skip) - lze implicitně změnit
    nastavením proměnné FORCE v uživatelském konfiguračním souboru.
"""
		;;
		verbose) echo """volbu [1m-v[0m ([1m--verbose[0m)
  Prostřednictvím této volby si lze přesměrovat výstup doplňujících
  informačních výpisů na konzoli. Díky nim pak lze podrobně sledovat
  postup skriptu při zpracování souboru

  [1m${0##*/}[0m ... {-v|--verbose} ...
"""
		;;
		xml) echo """volba [1m-x[0m ([1m--xml[0m)

  Extrakce skryté textové vrstvy DjVu stránky ve formátu XML.
  Parametrem lze zvolit, co se má při akci [2mexport[22m uložit.

  [1m${0##*/}[0m ... {-d|--dsed} [yes|no|all|txt|ant] ...
  
         yes - stejný efekt jako volba all
         no  - textová vrstva se neexportuje (default)
         all - exportuje se celý obsah skryté textové vrstvy
         txt - exportuje se pouze obsah stránky
         ant - exportují se meta atributy stránky

[4mPoznámka:[24m
  * Pokud za volbou není uveden žádný další parametr, tak se automaticky
    předpokládá - yes.
  * Výchozí parametr - no - lze implicitně změnit nastavením proměnné
    XML do souboru v adresáři ${HOME}/.config/${NAME}/
  * Exportovaná data se ukládají do souborů s příponou [3m.xml[23m.

[1mPozor:[0m  Při exportu do XML nelze podchytit všechny meta atributy!!!
"""
		;;
		exporttometa) echo """volba [1m-m[0m ([1m--meta[0m)

  Extrakce DjVu stránky ze svazku

  [1m${0##*/}[0m ... {-x|--xml} [yes|no] ...
  
  Prostřednictvím této volby lze zvolit zda se má, nebo nemá při akci
  [3mexport[23m z DjVu svazku exportovat i celá DjVu stránka. Pokud za volbou
  nenásleduje parametr, pak se automaticky předpokládá že ano (yes).
  Výchozí nastavení (no), lze implicitně změnit prostřednictvím
  uživatelského konfiguračního souboru umístěného v v adresáři:

    ${HOME}/.config/${NAME}/
"""
		;;
		exporttothumb) echo """volba [1m-t[0m ([1m--thumb[0m)

  Extrakce DjVu stránky ze svazku

  [1m${0##*/}[0m ... {-t|--thumb} [yes|no] ...
  
  Prostřednictvím této volby lze zvolit zda se má, nebo nemá při akci
  [3mexport[23m z DjVu svazku exportovat i celá DjVu stránka. Pokud za volbou
  nenásleduje parametr, pak se automaticky předpokládá že ano (yes).
  Výchozí nastavení (no), lze implicitně změnit prostřednictvím
  uživatelského konfiguračního souboru umístěného v v adresáři:

    ${HOME}/.config/${NAME}/
"""
		;;
		indirect) echo"""
[1mVolba[0m
         --indirect Volba, kterou lze změnit výchozí typ vícestránkového 
                    DjVu svazku (bundeled)

  Volbu je třeba aplikovat pokud chcete rozbalit stvávající DjVu svazek 
  do podoby volného svazku, nebo pokud chcete při konverzi bitmapových
  souborů rovnou sestavit DjVu svazek jako volný

  Výhodou volného svazku je, že lze dodatečně upravovat jednotlivé stránky
  jako samostatné DjVu soubory, aniž by je bylo nutné exportovat.

  Pro finalizaci DjVu svazku je pak lepší svazek překonvertovat na typ
  bundled, kdy je vše zabaleno v jednom souboru
"""
		;;
		existed) echo """
  Soubor $2 existuje. Pokud se má přepsat, musí být
  uveden parametr -f (--force)
"""
		;;
		dpi) echo """
[1mOption:[0m --dpi  <[2mčíslo[22m> Hodnota DPI, která se má použít při zpracování obrázku.
                               při konverzi. Optimální je zjistit hodnotu přímo ze vstupního
                               obrázku. Před nastavením této hodnoty pro finální konverzi. lze vyzkoušet
                               optimální nastavení na některém ze souborů s využitím parametru
                               --test

  Rozsah číselné hodnoty je od 72 do 6000 dpi. Výchozí hodnota 300 se použije 
  v případě, že parametr --dpi není vůbec uveden.
  Vliv dpi na zpracování obrazu..
"""
		;;
		level) echo """
[1mParametr[0m
         -l|--level  <[2mčíslo[22m> Hodnota akceptovatelných ztrát u černobílé kresby
                               při konverzi. Před nastavením této hodnoty vyzkoušejte
                               optimální nastavení na některém ze souborů a s parametrem
                               --test

  Kromě číselné hodnoty, která musí být menší než 200 lze úroveň ztrát
  nastavit i pomocí některého z následujících parametrů - v případě že 
  jich bude uvedeno víc, má prioritu poslední z nich.

        --lossless     0 - žádné ztráty (default)
        --clean        1 - ignorují se body o velikosti 1 pixelu
        --lossy        100 - ignorují se plochy
"""
		;;
		keywords) echo """
Help for actions:

  [1m${0##*/}[0m <DjVu file> {ACTIONS} -h

ACTIONS:

    delete - remove page from bundle
fore, back - move, or insert pages into DjVu bundle
    rotate - change orientation page or all pages DjVu bundle
    export - export from DjVu bundle
    import - import (content, meta attributes, outline) into DjVu bundle 
      edit - edit meta attributes or outline in DjVu bundle
      info - view info about DjVu bundle or selected page
    rename - rename pages in DjVu bundle by pattern

OBSOLETE ACTIONS:
    insert - vložení čehokoliv do DjVu (nahrazuje import)
     print - výpis meta atributů na konzoli (nahrazuje export)
       set - nastavení meta atributu (nahrazuje edit)
     unset - zrušení meta atributu (nahrazuje edit)
      view - otevření DjVu souboru v djview4

[3mNotice:[23m
   For more description about any action or option you set on command line as next parameter option -h (--help)
"""
		;;
		keywords-delete) echo """
  ACTION: [1mdelete[0m

  [4mOdstranění stránky[24m identifikované jménem, nebo pozicí v DjVu svazku

  [1m${0##*/}[0m [volby] <svazek> delete {<num>|<name>}

         num  - pořadové číslo stránky v DjVu svazku
         name - jméno stránky v DjVu svazku

[1mDávejte pozor[0m - akce je nevratná !
  Je doporučeno při odstraňování stránek použít jako identifikátor jméno
  stránky. A to z toho důvodu, že se pozice stránky může v průběhu
  zpracování DjVu svazku změnit, kdežto její jméno zůstává vždy v rámci
  svazku jedinečné.
"""
		;;
		keywords-fore) help move
		;;
		keywords-fore1) echo """
  ACTION [1mfore[0m

  Umístění nové stránky, nebo stránky v rámci DjVu svazku již existující před stránku identifikovanou jménem, nebo aktuální pozicí. o pozici vpřed. [4mPřed stránku, která[24m
  [4mji má následovat[24m. V případě, už přesouvaná stránka je na první pozici,
  se nestane nic.

  [1m${0##*/}[0m [volby] <svazek> fore {<num>|<name>|<file>} [<num>|<name>]

         num  - pořadové číslo stránky v DjVu svazku
         name - jméno stránky v DjVu svazku
         file - DjVu soubor nebo naskenovaná stránka v bitmapovém formátu

  Je doporučeno použít jako identifikátor jména stránek, místo jejich 
  aktuální pozice. A to z toho důvodu, že se pozice stránek mohou v průběhu
  zpracování DjVu svazku měnit, kdežto její jméno stránky je vždy v rámci
  svazku jedinečné.
"""
		;;
		keywords-back) echo """
  ACTION [1mback[0m

  Přesun stránky v rámci DjVu svazku o pozici zpět. [4mZa stránku, která[24m
  [4mji má následovat[24m. V případě, už je přesouvaná stránka na poslední pozici,
  se nestane nic.

  [1m${0##*/}[0m [volby] <svazek> back {<num>|<name>} [<num>|<name>]

         num  - pořadové číslo stránky v DjVu svazku
         name - jméno stránky v DjVu svazku

  Je doporučeno použít jako identifikátor jména stránek, místo jejich 
  aktuální pozice. A to z toho důvodu, že se pozice stránek mohou v průběhu
  zpracování DjVu svazku měnit, kdežto její jméno stránky je vždy v rámci
  svazku jedinečné.
"""
		;;
		keywords-rotate) echo """
  ACTION [1mrotate[0m

  For change of default orientation page in DjVu file.

  [1m${0##*/}[0m [option] <DjVu> rotate {<num>|<name>} <VALUE>

         num   - order of page to change in DjVu bundle
         name  - name of page to change in DjVu bundle

Options:
    -f|--force   Force rotate without any questions

  VALUE:
             0 - normal orientation (0°)
             1 - rotate page 90° to right
             2 - rotate page 180°
             3 - rotate page 90° to left (270°)
          left - rotate page 90° in left direction
         right - rotate page 90° in right direction
           180 - turn the page on the contrary

[3mWarning:[23m
  * If is not any identificator of page, do set global orientation for all DjVu bundle.
"""
		;;
		keywords-export) echo """
  ACTION: [1mexport[0m

  Export pages , meta attributes from DjVu svazku. O tom co bude předmětem exportu rozhodují další 
  volby. Export textové vrstvy zajistí volby [3m-x[23m a [3m-d[23m, náhled obrazové vrstvy
  se generuje při volbě [3m-i[23m, a celá stránka v DjVu formátu se exportuje
  při volbě [3m-p[23m.

  [1m${0##*/}[0m [volby] <svazek> export {<num>|<name>|all|outline|meta [<num>|<name>|all]}  [<dir>]

      num - pořadové číslo stránky v DjVu svazku
     name - jméno stránky v DjVu svazku
      dir - adresář do kterého má být výstup uložen
      all - předmětem exportu bude obsah celého DjVu svazku
  outline - na výstup bude vypsán obsah DjVu svazku ve formátu pro import
     meta - na výstup budou vypsány meta atributy svazku ve formátu pro import

[4mPoznámky:[24m
  * Pro zpracování single-page DjVu stránek je parametr [3mall[23m doporučený
  * Není-li uveden cílový adresář, budou soubory exporované do adresáře,
    kde byl [1m${0##*/}[0m spuštěn.
  * Přepsání již existujících souborů si lze vynutit volbou [3m--force yes[23m
    Výchozí chování je - [3mskip[23m (existující soubory se znovu neexportují)
"""
		;;
		keywords-import) echo """
   ACTION: [1mimport[0m
  [4mImport obsahu textové vrstvy[24m do DjVu souboru

  [1m${0##*/}[0m [volby] <svazek> import [<file>|<dir>]

         file - soubor s obsahem skryté textové vrstvy
         dir  - adresář se soubory s obsahem skryté textové vrstvy

[3mPoznámky:[23m
  * Parametrem akce [2mimport[22m může být buď adresář se soubory, nebo soubor s
    daty k importu
  * Název souboru musí odpovídat názvu svazku (pro gobální metadata), nebo
    názvu stránky, kterou obsahuje, s tím rozdílem, že jeho přípona odpovídá
    typu dat které obsahuje:
          [3m.meta[23m - meta atributy
           [3m.xml[23m - skrytý text obsahu
          [3m.dsed[23m - poznámky, meta atributy a skrytý text obsahu
       [3m.outline[23m - obsah svazku; Pozor! Obsah je součást celého svazku, nemá
                  tedy smysl ho vkládat do single-page DjVu dokumentu.
    K formátu těchto souborů více viz manuál
  * Není-li uveden žádný adresář, ani soubor, tak se předpokládá že se budou
    zpracovávat soubory z aktuálního adresáře
"""
		;;
		keywords-edit) echo """
  ACTION [1medit[0m

  Editace textový informací DjVu svazku - meta informace, bookmarks,outline

  [1m${0##*/}[0m <DjVu> edit outline

  [1m${0##*/}[0m <DjVu> edit ant [<num>|<name>|<RANGE>]

         outline - výpis aktuálního obsahu DjVu svazku ve formátu .outline
         meta  - vygenerování šablony pro .outline formát s adresováním
                 stránek podle jejich názvů

         num  - pořadové číslo stránky v DjVu svazku
         name - jméno stránky v DjVu svazku

[3mPoznámka:[23m
  Vygenerovanou šablonu .outline formátu lze upravit editací v libovolném
  textovém editoru. Řádky s nevyužitými položkami je třeba smazat.
  Do dalších úrovní lze položky obsahu zanořit pomocí odsazení řádku
                   1 úroveň = 1 tabulátor = 8 mezer
  Aktuální obsah lze vyexportovat v .outline formátu parametrem print
  Upravený obsah lze do DjVu svazku naimportovat ze souboru přes akci [2mimport[22m,
[1mPozor:[0m Soubor ve formátu .outline musí mít (až na příponu) stejné jméno,
  jako má DjVu svazek do kterého se má vložit, jinak se nenaimportuje!
"""
		help range
		;;
		keywords-info) echo """
  ACTION [1minfo[0m

  Print informations about DjVu bundle. Without parameters return number of pages.
  If is DjVu file 'single-page', return 'none'.

  [1m${0##*/}[0m <DjVu> info [SUBKEY [<num>|<name>]]

         num  - order number of page in DjVu bundle
         name - name of page in DjVu bundle

  SUBKEYS:
         [3mexif[23m - return exif info about DjVu file
         [3mmeta[23m - return meta attribute keys from DjVu file
        [3mpages[23m - return ordered list pages from DjVu bundle with names

[3mNotice:[23m
  * For [3m'meta'[23m [2minfo[22m different from [2mexport[22m in that output is purified from syntax chars, whose is required for [2mimport[22m.
  * When is passed subkey [3m'exif'[23m with an identificator of page, be export a page into temporary dir and view info only about this page.
  * Subkey [3m'pages'[23m with an identificator of page return only item for this.
"""
		;;
		keywords-convert) echo """
options:
* není-li uvedeno -o tak se OCR nedělá!
* je třeba přidat volbu, která dovolí upravit chování
	c (color) barevná kresba na pozadí
	b (black-white) černobílá kresba na popředí
	n (na výstupu pouze xml soubor s výsledkem OCR)

  ACTION [1mconvert[0m

  Conversion multipage file into DjVu bundle.

  [1m${0##*/}[0m <Multipage file> convert [ALG [<num>|<name>]]

         num  - order or range layers
         name - name of layer in multipage file

  ALG:
         [3mexif[23m - return exif info about DjVu file
         [3mmeta[23m - return meta attribute keys from DjVu file
        [3mpages[23m - return ordered list pages from DjVu bundle with names

[3mNotice:[23m
  * For [3m'meta'[23m [2minfo[22m different from [2mexport[22m in that output is purified from syntax chars, whose is required for [2mimport[22m.
  * When is passed subkey [3m'exif'[23m with an identificator of page, be export a page into temporary dir and view info only about this page.
  * Subkey [3m'pages'[23m with an identificator of page return only item for this.
"""

		;;
		keywords-print) echo """
   Action [1mprint[0m

   Action [2mprint[22m meta attribute keys or outline into stdout

  [1m${0##*/}[0m <DjVu> print outline

  [1m${0##*/}[0m <DjVu> print meta

  [1m${0##*/}[0m <svazek> print <attr>
  [1m${0##*/}[0m <svazek> print {<num>|<name>} [all]
  [1m${0##*/}[0m <svazek> print {<num>|<name>} <attr>

         num  - pořadové číslo stránky v DjVu svazku
         name - jméno stránky v DjVu svazku
         attr - jméno atributu
         all  - klíčové slovo (vypsat vše)

[3mPoznámka:[23m
  Jednotlivé atributy lze nastavovat přes [2mset[22m, více atributů najednou
  lze do DjVu stránky či svazku importovat z externího souboru při
  akci [2mimport[22m. Metadata lze z DjVu souborů také exportovat ([2mexport[22m).
"""
		;;
		keywords-set) echo """
  ACTION [1mset[0m set meta attribute key or outline item from command line

  [1m${0##*/}[0m <DjVu> set outline {<num>[:[+|-]]} <ITEM> <TARGET>
 
  [1m${0##*/}[0m <DjVu> set meta [all|<RANGE>|<name>] <KEY> <VALUE>

Example for set outline item:

  [1m${0##*/}[0m bundle.djvu set outline : 'To page 12' '#12'

Example for set meta attribute:

  [1m${0##*/}[0m bundle.djvu set meta 1,3,7-12 Creator 'Thomas Jefferson'

[3mNotice:[23m
    * If is value of [3mORDER[23m zero or empty, is append ITEM
      to end outline
    * Plus, separed by colon from order num, signalize next level for
      nesting of the item compare to level of a previous item
    * Count of minus, separed by colon, signalize level for emersion of
      the outline item compare to level of a previous item.
    * First item outline can not be nested.
    * If is not page identificator, is [3mKEY[23m set as shared
      into shared_anno.iff

   ITEM - text value of bookmark item
 TARGET - name or order page which is target of item with hash (#)
    num - item order in outline (see action [2mprint[22m)
    all - attributte is set as meta attribute for every page in DjVu bundle
   name - attributte is set to page specified by name"""
		help key
		help value
		help range
		;;
		keywords-unset) echo """
  ACTION [1munset[0m remove item from outline or meta attributes

  [1m${0##*/}[0m <DjVu> unset outline <num>

  [1m${0##*/}[0m <DjVu> unset meta [all|<RANGE>|<name>] <KEY>

Example for remove bookmark item:

    [1m${0##*/}[0m bundle.djvu unset outline 3

Examle for remove meta attribute:

    [1m${0##*/}[0m bundle.djvu unset meta 1,3,7-12 Creator

    all - item is set as meta attribute for every page in DjVu bundle
    num - item order in outline (see action [2mprint[22m)
   name - name page in DjVu bundle"""
		help range
		help key
		help value
		;;
		range) echo """  RANGE - parameter for selection range pages, specified by order of pages
           in DjVu bundle. Separated by comma. Hyphen is for limits from-to.
           Example range: 1,3,7-12"""
		;;
		key) echo """    KEY - name of meta attribute, single word without diacritical chars
          and spaces. Example commonly used keys:
                 [3mTitle[23m - Title of DjVu page or bundle
               [3mCreator[23m - Creator DjVu bundle or DjVu page from scan
          [3mCreationDate[23m - Creation date of DjVu bundle or page
              [3mKeywords[23m - Keywords for indexation DjVu file
                [3mannote[23m - Notes about origin of document & etc."""
		;;
		value) echo """  VALUE - is normal text string in quotes"""
		;;
		keywords-meta) echo """
  ACTION [1mset[0m or [1munset[0m

  Keywords [2mset[22m or [2munset[22m work only with meta attribute key.
  For view meta attribute use keyword [2minfo[22m and [2mexport[22m for output in
  format which is usable to [2mimport[22m. You may [2medit[22m attribute too.

  [1m${0##*/}[0m <DjVu> unset meta [all|<RANGE>] <KEY>

  [1m${0##*/}[0m <DjVu> set meta [all|<RANGE>] <KEY> <VALUE>

          all - item is set as meta attribute for every
                page in DjVu bundle
        RANGE - range specified pages
          KEY - key name of meta attribute
        VALUE - value of meta attribute key

[3mNotice:[23m
  * If is not given key word [3mall[23m or [3mRANGE[23m of pages, is item KEY accepted
    as global meta attribute of DjVu bundle
  * Range is 

RANGE example:

    [1m${0##*/}[0m bundle.djvu set meta 1,3,7-12 Creator 'Thomas Jefferson'

KEY most common attributes:
        [3mTitle[23m - Title of DjVu page or bundle
      [3mCreator[23m - Creator DjVu bundle or DjVu page from scan
 [3mCreationDate[23m - Creation date of DjVu bundle or page
     [3mKeywords[23m - Keywords for indexation DjVu file
       [3mannote[23m - Notes about origin of document & etc.

[3mNotice:[23m
  * KEY is single word without diacritical chars and spaces
  * VALUE is normal text string
"""
		;;
# ODSTRANIT VVVV
		keywords-outline) echo """akce [1moutline[0m

Zrušeno, nahrazeno akcí edit a export

  Pomocná akce pro výpis a export obsahu (bookmarks,outline) Djvu svazku.

  [1m${0##*/}[0m <svazek> outline {dump|print|<order>|<name}

         dump  - dump aktuálního obsahu DjVu svazku v dsed formátu
         print - výpis aktuálního obsahu DjVu svazku ve formátu .outline
         order - vygenerování šablony pro .outline formát s adresováním
                 stránek dle pořadových čísel
         name  - vygenerování šablony pro .outline formát s adresováním
                 stránek podle jejich názvů
         num  - pořadové číslo stránky v DjVu svazku
         name - jméno stránky v DjVu svazku

[3mPoznámka:[23m
  Vygenerovanou šablonu .outline formátu lze upravit editací v libovolném
  textovém editoru. Řádky s nevyužitými položkami je třeba smazat.
  Do dalších úrovní lze položky obsahu zanořit pomocí odsazení řádku
                   1 úroveň = 1 tabulátor = 8 mezer
  Aktuální obsah lze vyexportovat v .outline formátu parametrem print
  Upravený obsah lze do DjVu svazku naimportovat ze souboru přes akci [2mimport[22m,
[1mPozor:[0m Soubor ve formátu .outline musí mít (až na příponu) stejné jméno,
  jako má DjVu svazek do kterého se má vložit, jinak se nenaimportuje!
"""
		;;
# ODSTRANIT VVVV
		meta) echo """
Export meta atributů

  [1m${0##*/}[0m <svazek> export meta [<num>|<name>|all|global]
  
  global - globální meta atributy DjVu svazku
     all - kompletní výpis atributů ke svazku
         - výpis atributů stránky identifikované pořadovým číslem nebo jménem

Syntaxe meta souboru:

 #<num> '<name>'
 key1 <description>
 key2 ...
 .

Při importu stránky má jméno stránky přednost před pořadovým číslem. To se použije pouze tehdy, pokud identifikační jméno stránky chybí
Pokud stránka žádné meta atributy nemá, vypíše se pouze prázdná šablona
"""
		;;
		move) echo """akce [1mfore[0m a [1mback[0m
  [4mUmožňují přesunout stránku v rámci DjVu svazku [24m na jinou pozici, či
  [4mvložit[24m na tuto pozici  [4mstránku novou [24m, je-li prvním parametrem akce
  místo identifikátoru stránky v DjVu svazku soubor.

  [1m${0##*/}[0m [volby] <svazek> {fore|back} {<num>|<name>|<file>} [<num>|<name>]

         num  - pořadové číslo stránky v DjVu svazku
         name - jméno stránky v DjVu svazku
         file - jméno DjVu souboru, nebo skenu

[3mPoznámka:[23m
  * Je-li souborem nekonvertovaný bitmapový obrázek, určí co vše bude
    obnášet konverze předané volby.
  * Není-li určena indentifikátorem cílová pozice, bude stránka přesunuta
    při akci [2mfore[22m o pozici vpřed, nebo vzad - při akci [2mback[22m.
  * Je-li při akci [2mfore[22m vložena ze souboru nová stránka a není uveden
    identifikátor cílové pozice, bude stránka vložena na první pozici
    DjVu svazku. Při akci [2mback[22m) se připojí na konec.
  * Pokud se již v DjVu svazku nalézá stránka se stejným názvem jako má
    vkládaný soubor, vyskytuje, dojde při jeho vložení automaticky k
    přejmenování - za název se přidá podtržítko a pořadové číslo.
"""
		;;
		rename) echo """ volba [1m-r[0m, [1m--rename[0m
 Nastavení vzorku, podle jakého se mají pojmenovat, nebo přejmenovat DjVu soubory v DjVu svazku.

Lze využít parametr %01d pro nastavení počtu znaků v číslování stránky, při konverzi vícestránkových bitmapových souborů (tiff, png, xcf)

[4mPopis:[24m
  Pomocí [2mvzoru[22m lze upravit názvy zkonvertovaných DjVu souborů
  před jejich sestavením do DjVu svazku. [2mVzor[22m může být tvořen:
    1, Pouze jednou, nebo více nulami - 000
    2, Nebo řetězcem, následovaným nulami - soubor_00

[3mPoznámka:[23m
  Je-li uvedena pouze jedna nula, budou stránky očíslovány [4mnumericky[24m,
  t.j. od čísla 1 dále. Je-li nul více, pak bude číslo interpretováno
  jako [4mřetězec[24m. tedy 001 a dále. Pokud by číslování stránek přesáhlo
  nastavený počet čísel, bude upraven dle maximálního čísla.

[3mUkázkové vzory : a výsledný efekt..[23m
   soubor-0000 : soubor-0001.djvu .. soubor-0123.djvu
   soubor_0    : soubor_1.djvu    .. soubor_123.djvu
   soubor000   : soubor0001.djvu  .. soubor1234.djvu
"""
			;;
		suffix) echo """
[1mParametr[0m
         -e|--ext  <[2msuffix[22m>  Přípona souborů, ze kterých se má sestavit 
                                DjVu soubor.
[4mPopis:[24m
  [2mSuffix[22m je nutné uvést pouze v případě, že soubory s názvem odpovídajícím
  vzorku dosud nebyly do DjVu zkonvertovány. Jinak se vždy předpokládá, že
  se bude pracovat s již konvertovanými DjVu soubory.

  Je-li [2msuffix[22m uveden, budou konvertovány soubory vyhovující vzorku.
  Pokud některé z nich již konvertovány byly, tak se se fáze konverze
  přeskočí. Pracuje se pak s již existujícím DjVu souborem.

  Konvertovány jsou pouze soubory, které chybí. Kvalitu konverze lze
  ovlivnit  dalšími parametry. Mají-li být soubory překonvertovány znovu,
  lze si to vynutit parametrem -f (--force) a stávající soubory  přepsat.

  Akceptované sufixy: 
     djvu (default), jpg, gif, png, bmp, pnm, pbm, pgm.
  Vícevrstvé soubory:
     xcf, tiff, pdf 
"""
			;;
		ocr) echo "Nápověda k OCR - ToDo"
		;;
		options) echo """Options:
    -a|--algorithm Algorithm for separating mask of image (fore or back)
xx  -b|--bundle    Setting type of DjVu bundle
    -d|--dsed      Export hiddent text layer in native code for DjVused
       --dpi       DPI input image for import (actions fore or back)
    -f|--force     Force action
       --clean     Params for convert image to DjVu with separate layers
       --lossy
       --lossless
       --level
    -h|--help      Main options for help about option, or action
    -i|--image     Export .png image of page for use with DjVuWebEd
??  -m|--meta      Export meta attributes from DjVu file
    -o|--ocr       Application OCR
    -p|--page      Export single DjVu page from bundle
    -r|--rename    Pattern for action rename 
xx  -t|--thumb     Creating thumbnails in DjVu bundle
    -v|--verbose   
    -x|--xml       Export hiddent text layer (XML) for use with DjVuWebEd"""
		;;
		*) echo """
DJVUTOOL - tool to work with DjVu files & bundles

Use:  [1m${0##*/}[0m [options] { [-h|--help] | <file> {KEYWORDS} [...] }
""" && help options && help keywords
		;;
	esac
}

function filetodjvu {
	echo "filetodjvu: vstupuji sem.." >> /dev/stderr
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	local TARGETPATH=$(${REALPATH} -m -P "${2}")
	local TARGET="${TARGETPATH##*/}"
	case "${FILE##*.}" in
		[jJ][pP][gG]|[pP][nN][gG]|[gG][iI][fF]|[pP][nN][mM]) todjvu "${SOURCE}" "${TARGETPATH}"
			echo "filetodjvu: INFO - DjVu bundle ${TARGETPATH} is prepared" >> /dev/stderr
		;;
		[tT][iI][fF][fF]|[xX][cC][fF]|[nM][nN][gG]|[pP][dD][fF]) if [ "${RENAME}" == "no" ] ; then
				# pojmenování cíle vyjde ze jména souboru
				local COUNT=$(${IDENTIFY} -format "%n" ${SOURCE})
				${CONVERT} "${SOURCE}" "${TEMPDIR}/${FILE%.*}_%0${#COUNT}d.png"
			else
				# pojmenování vyjde ze vzoru
				local COUNT=$(${IDENTIFY} -format "%n" ${SOURCE})
				if [[ ${RENAME} =~ "%" ]] ; then
					echo "Použiju číslování ze vzoru" >> /dev/stderr
					${CONVERT} "${SOURCE}" "${TEMPDIR}/${RENAME}.png"
				else
					echo "Použiju výchozí číslování" >> /dev/stderr
					${CONVERT} "${SOURCE}" "${TEMPDIR}/${RENAME}_%0${#COUNT}d.png"
				fi
			fi
			# Konverze vytažených souborů..
			find "${TEMPDIR}" -type f ! -name '*.djvu' | while read line
			do
				todjvu "${line}" "${line%.*}.djvu"
			done
			# Zabalení vytažených souborů...
			find "${TEMPDIR}" -type f ! -name "${TARGET}" -name "*.djvu" | while read line
			do
				if [ -f "${TARGETPATH}" ] ; then
					${DJVM} -i "${TARGETPATH}" "${line}"
				else
					${DJVM} -c "${TARGETPATH}" "${line}"
				fi
			done
			echo "filetodjvu: INFO - DjVu bundle ${TARGETPATH} is prepared" >> /dev/stderr
		;;
		*) echo "filetodjvu: INFO - Format file ${FILE##*\.} is not supported. Sorry!!" >> /dev/stderr && exit 1
		;;
	esac
}

function todjvu {
	# $1 - soubor ke konverzi
	# $2 - target path to new DjVu file (full path!!)
	#echo "to djvu -${1}- -${2}-" >> /dev/stderr
	#return 0
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	case "${FILE##*.}" in
		[jJ][pP][gG]|[pP][nN][gG]|[gG][iI][fF]|[pP][nN][mM])
		;;
		[tT][iI][fF][fF]|[xX][cC][fF]|[nM][nN][gG]|[pP][dD][fF]) echo "todjvu: INFO - Format file ${FILE##*\.} now is not accepted. Sorry!!" >> /dev/stderr && exit 1
		;;
		*) echo "todjvu: INFO - Format file ${FILE##*\.} is not supported. Sorry!!" >> /dev/stderr && exit 1
		;;
	esac
	local TARGETPATH=$(${REALPATH} -m -P "${2}")
	local TARGET="${TARGETPATH##*/}"
	log warn "todjvu() From input file ${SOURCE} make DjVu file ${TARGET}"
	if [ $(testfile "${SOURCE}") == "djvu" ] ; then
		echo "todjvu: ERROR - ${SOURCE} is DjVu file" >> /dev/stderr
		exit 1
	else
		if [ "${#ALG[@]}" -gt "1" ] ; then
			for i in ${ALG[@]} ; do 
				${DIDJVU} encode -o "${TARGETPATH/.djvu/.$i.djvu}" -d "${DPI-300}" ${LEVEL} -m "$i" "${SOURCE}"
				[ "$?" ] && log info "todjvu() INFO - file ${FILE} was converted into ${TARGETPATH/.djvu/.$i.djvu}"
				getocr "${TARGETPATH/.djvu/.$i.djvu}"
			done
		else
			if [ -f "${TARGETPATH}" ] ; then
				if [ "${FORCE}" == "yes" ] ; then
				log info "todjvu() INFO - rewrite target file ${TARGET}."
					${DIDJVU} encode -o "${TARGETPATH}" -d "${DPI-300}" ${LEVEL} -m "${ALG}" "${SOURCE}"
				[ "$?" ] && log info "todjvu() INFO - file ${FILE} was converted into ${TARGETPATH}"
					getocr "${TARGETPATH}"
				else
					echo "Mám přepsat cílový soubor ${TARGET}?"
					potvrdit && ${DIDJVU} encode -o "${TARGETPATH}" -d "${DPI-300}" ${LEVEL} -m "${ALG}" "${SOURCE}"
					getocr "${TARGETPATH}"
				fi
			else
				${DIDJVU} encode -o "${TARGETPATH}" -d "${DPI-300}" ${LEVEL} -m "${ALG}" "${SOURCE}"
				getocr "${TARGETPATH}"
				[ "$?" ] && log info "todjvu() INFO - file ${FILE} was converted into ${TARGETPATH}"
			fi
		fi
	fi
}

# TODO - test - testovací enkode proces
function todotest {
	for i in ${ALG[@]} ; do 
		${DIDJVU} encode -o "${1%.*}-$i.djvu" -d 300 -m "$i" "$1"
	done
}

# TODO - test - zobrazení testovacích DjVu souborů
function todoview {
	for i in ${ALG[@]} ; do 
		(${DJVIEW} ${1%.*}-$i.djvu &)
	done
}

# TODO - insert
function todjvuclassic {
    RANDOMKEY=$[ 8000 + $[ RANDOM % 1000 ]]
    TEMP_DIR="${TEMPDIR}/$WINDOWID$BASHPID$RANDOMKEY"
    mkdir $TEMP_DIR
    TEMP_IMG="$TEMP_DIR/temp.ppm"
    TEMP_MASK="$TEMP_DIR/mask.pbm"
    DJVU_MASK="$TEMP_DIR/mask.djvu"

    case ${1##*.} in
        tiff|tif) KONVERT="${TIFFTOPNM}";;
        png) KONVERT="${PNGTOPNM}";;
        jpg) KONVERT="${JPEGTOPNM}" ;;
    esac

    $KONVERT $1 | tee $TEMP_IMG | ${PPMTOPGM} | ${PGMTOPBM} -threshold -value 0.${3-5} | ${PNMTOPLAINPNM} > $TEMP_MASK;
    ${CJB2} -lossy -clean $TEMP_MASK $DJVU_MASK;
    ${DJVUMAKE} ${1/.png/.djvu} Sjbz=$DJVU_MASK PPM=$TEMP_IMG;
    getocr ${1/.png/.djvu}
    rm -rf $TEMP_DIR
}

# Zpracování parametrů předaných při startu skriptu
main() {
#	echo "$@" >> /dev/stderr
#	echo "$*" >> /dev/stderr

while [ $# -gt 0 ]
do
#echo $1 >> /dev/stderr
    case ${1} in
        -a|--algorithm) #/ Volba pro akci insert
            #/ Není-li uveden žádný kompresní algoritmus, je aplikováno
            #/ výchozí nastavení proměnné $ALG z konfigurace"
            case ${2} in
                -h|--help) help algorithm
                    exit 0
                    ;;
                *) for i in ${2//,/ } ; do
                    if [[ ${ALGORITHM[@]} =~ (^|[^[:alpha:]])$i([^[:alpha:]]|$) ]] ; then
                        log info "main() Verify algorithm $i –> OK"
                    else
                        printf "Algorithm %s isn't supported\n" "$i" 1>&2
                        exit 0
                    fi
                    done
                    ALG=(${2//,/ })
                    log set "main() Compression algorithm –> ${ALG[@]}"
                    shift && shift
                    ;;
            esac
            ;;
        -d|--dsed) # Volba pro akci export
            case ${2} in
                -h*|--help*) help dsed && exit 0
                    ;;
                yes|no|txt|ant|all) DSED=${2}
                    log info "main() Aplikuji pro DSED parametr - ${DSED}"
                    shift && shift
                    ;;
                *) log warn "main() Nebyl uveden žádný parametr, aplikuji pro DSED parametr - yes"
                    DSED="yes"
                    shift
                    ;;
            esac
            ;;
        --dpi) # Volba pro akci insert
            case ${2} in
                -h*|--help*) help dpi && exit 0
                    ;;
                [[:digit:]])
                    if [ "${2}" -ge "72" ] && [ "${2}" -le "6000" ] ; then
                        DPI="${2}"
                        log info "main() Aplikuji pro DPI parametr - ${DPI}"
                        shift && shift
                    else
                        echo "Hodnota u volby --dpi se musí pohybovat v rozmezí od 72 do 6000" >> /dev/stderr
                        exit 1
                    fi
                    ;;
                *) echo "Nebyla uvedena hodnota dpi. Pokud chcete volbou --dpi změnit výchozí hodnotu (300), musíte ji uvést jako číselný parametr" >> /dev/stderr
                    exit 1
                    ;;
            esac
            ;;
        -f|--force)
            case ${2} in
                -h*|--help*) help force && exit 0
                    ;;
                yes|no|skip) FORCE=${2}
                    log info "main() Aplikuji pro FORCE parametr - ${FORCE}"
                    shift && shift
                    ;;
                *) log warn "main() Nebyl uveden žádný parametr, aplikuji pro FORCE parametr - skip"
                    FORCE="yes"
                    shift
                    ;;
            esac
            ;;
        --clean) LEVEL="--loss-level=1" && shift
            ;;
        --lossy) LEVEL="--loss-level=100" && shift
            ;;
        --lossless) LEVEL="--loss-level=0" && shift
            ;;
        --level) # Volba pro akci insert
            case ${2} in
                -h*|--help*) help force && exit 0
                    ;;
                [[:digit:]])
                    if [ "${2}" -ge "0" ] && [ "${2}" -lt "200" ] ; then
                        LEVEL="--loss-level=${2}"
                        log info "main() Aplikuji pro LEVEL hodnotu - ${LEVEL}"
                        shift && shift
                    else
                        help level && exit 0
                    fi
                    ;;
                *) echo "main() Volba --loss-level musí mít vždy uvedenou číselnou hodnotu v rozmezí 0-199" >> /dev/stderr
                    exit 1
                    ;;
            esac
            log info "main() Úroveň ztrátovosti při kompresi ${LEVEL}"
            ;;
        -i|--image) # Volba pro akci export
            case "${2}" in
                -h*|--help*) help image && exit 0
                    ;;
                yes|no|color|black|foreground|background|mask)
                    IMG="${2}"
                    log info "main)) Aplikuji pro IMG parametr - ${IMG}"
                    shift && shift
                    ;;
                *) log warn "main() Nebyl uveden žádný parametr, aplikuji pro IMG parametr - yes"
                    IMG="yes"
                    shift
                    ;;
            esac
            ;;
        -m|--meta) # Volba pro akci export
            case "${2}" in
                -h*|--help*) help meta && exit 0
                    ;;
                yes|no) META="${2}"
                    log info "main() Aplikuji pro META parametr - ${META}"
                    shift && shift
                    ;;
                *) META="yes"
                    log warn "main() Nebyl uveden žádný parametr, aplikuji pro META parametr - yes"
                    shift
                    ;;
            esac
            ;;
        -o|--ocr) # Volba pro akci insert
            case "${2}" in
                -h*|--help*) help ocr
                    ${TESSERACT} --list-langs 2>&1 | sed -n '1!p'
                    exit 0
                    ;;
                *)
#			echo $(${TESSERACT} --list-langs 2>&1 | sed '1d;x') >> /dev/stderr
                for i in ${2//+/ } ; do
                    local TEST="no"
                    local OCR=(${i//:/\ })
                    if [ "${#OCR[@]}" -eq 2 ] ; then
                        # ${OCR[0]} engine
                        # ${OCR[1]} jazyk
                        case "${OCR[0]:0:1}" in
                            c) CUNEIFORM=$(which cuneiform)
                                [ ! -x "${CUNEIFORM}" ] && exit 31
                                if [ "${OCR[1]}" == "?" ] ; then
                                    ${CUNEIFORM} -l
                                    exit 0
                                else
                                    local LANGUAGES=($(${CUNEIFORM} -l | grep languages | sed 's/^[a-Z ]*://'))
                                    if [[ ${LANGUAGES[@]} =~ (^|[^[:alpha:]])$y([^[:alpha:]]|$) ]] ; then
                                        OCRLANG=$y && local TEST="yes"
                                        log info "main() OCR lang –> $y"
                                    fi
                                fi
                                ;;
                            t) TESSERACT=$(which tesseract)
                                [ ! -x "${TESSERACT}" ] && exit 31
                                if [ "${OCR[1]}" == "?" ] ; then
                                    ${TESSERACT} --list-langs
                                    exit 0
                                else
                                    local LANGUAGES=($(${TESSERACT} --list-langs 2>&1 | sed -n '1!p'))
                                    if [[ ${LANGUAGES[@]} =~ (^|[^[:alpha:]])$y([^[:alpha:]]|$) ]] ; then
                                        OCRLANG=$y && local TEST="yes"
                                        log info "main() OCR lang –> $y"
                                    fi
                                fi
                                ;;
                            *) help keywords-convert-ocr
                                exit 0
                                ;;
                        esac
                    elif [ "${#OCR[@]}" -eq 1 ] ; then
                        # ${OCR[0]} jazyk
                        # výchozí engine je tesseract
                        TESSERACT=$(which tesseract)
                        [ ! -x "${TESSERACT}" ] && exit 31
                        if [ "${OCR[0]}" == "?" ] ; then
                            ${TESSERACT} --list-langs
                            exit 0
                        else
                            local LANGUAGES=($(${TESSERACT} --list-langs 2>&1 | sed -n '1!p'))
                            if [[ ${LANGUAGES[@]} =~ (^|[^[:alpha:]])$y([^[:alpha:]]|$) ]] ; then
                                OCRLANG=$y && local TEST="yes"
                                log info "main() OCR lang –> $y"
                            fi
                        fi
                    else
                        help keywords-convert-ocr
                        exit 0
                    fi
                    echo "OCR ${#OCR[@]}" >> /dev/stderr
                    echo "OCRLANG ${OCRLANG}" >> /dev/stderr
                    echo "TESSERACT ${TESSERACT}" >> /dev/stderr
                    echo "CUNEIFORM ${CUNEIFORM}" >> /dev/stderr
                    if [ "${TEST}" == "no" ] ; then
                        echo "Pro OCR engine $i není nainstalovanájazyková podpora" >> /dev/stderr
#					exit 1
                    fi
                done

                if [ "${TEST}" == "yes" ] ; then
                    OCR="${2%%+([[:blank:]])}"
                    log info "main() Aplikuji pro OCR parametr - ${OCR}"
                    shift && shift
                else
                    OCR="${OCR=ces}"
                    echo "Nebyl uveden žádný parametr, pro OCR použiji výchozí jazyk - ${OCR}" >> /dev/stderr
#				exit 1
                    shift
                fi
                ;;
            esac
            ;;
        -p|--page) # Volba pro akci export
            case "${2}" in
                -h*|--help*) help page && exit 0
                    ;;
                yes|no) PAGE="${2}"
                    log info "main() Aplikuji pro PAGE parametr - ${PAGE}"
                    shift && shift
                    ;;
                *) log warn "main() Nebyl uveden žádný parametr, aplikuji pro PAGE parametr - yes"
                    PAGE="yes"
                    shift
                    ;;
            esac
            ;;
        -r|--rename) # Nastavení vzoru pro pojmenování stránek při akcích rename, fore a back
            case "${2}" in
                -h*|--help*) help rename && exit 0
                ;;
                *) if [ "${2##+([[:alnum:]%_-])}" == "" ] ; then
                    RENAME="${2}"
                    log info "main() Aplikuji pro RENAME parametr - ${RENAME}"
                    shift && shift
                else
                    echo "main() FAIL - pattern '${VALUE}' for rename is is not acceptable." >> /dev/stderr
                    exit 1
                fi
            ;;
            esac
        ;;
        -t|--thumb) # Volba pro akci insert
            case "${2}" in
                -h*|--help*) help thumb && exit 0
                    ;;
                *) if [ "${2//+([[:digit:]])}" == "" ] ; then
                        if [ "${2}" -ge "32" ] && [ "${2}" -le "256" ] ; then
                            THUMB="${2%%+([[:blank:]])}"
                            log info "main() Aplikuji pro THUMB parametr - ${DPI}"
                            shift && shift
                        else
                            echo "Hodnota u volby --thumb se musí pohybovat v rozmezí od 32 do 256" >> /dev/stderr
                            exit 1
                        fi
                    else
                        echo "Nebyla uvedena hodnota velikosti náhledu. Pokud chcete volbou --thumb nastavit výchozí hodnotu, musíte ji uvést jako číselný parametr" >> /dev/stderr
                        exit 1
                    fi
                    ;;
            esac
            ;;
        -v*|--verbose*) #/ Změna výchozí hodnoty proměnné $DEBUG
            case ${1} in
                -v|--verbose)
                    case ${2} in
                        -h|--help|help|\?)
                            help verbose && exit 0
                            ;;
                        [0-9])
                            DEBUG="-d${2}"
                            shift && shift
                            ;;
                        *) DEBUG="-d1"
                            shift
                            ;;
                    esac
                    ;;
                -v[0-9])
                    DEBUG="-d${1:2}"
                    shift
                    ;;
                *=*)
                    case "${1#*=}" in
                        0) shift
                            ;;
                        [1-9]) DEBUG="-d${1#*=}"
                            shift
                            ;;
                        *) help_debug "${1#*=}" && exit 1
                            ;;
                    esac
                    ;;
            esac
            log set "main() DEBUG –> ${DEBUG}"
            ;;
        -x|--xml) # Volba pro akci export
            case "${2}" in
                -h*|--help*) help xml && exit 0
                    ;;
                yes|no|txt|ant|all) XML="${2%%+([[:blank:]])}"
                    log info "main() Aplikuji pro XML parametr - ${XML}"
                    shift && shift
                    ;;
                *) log warn "main() Nebyl uveden žádný parametr, aplikuji pro XML parametr - yes"
                    XML="yes"
                    shift
                    ;;
            esac
            ;;
        *.[dD][jJ][vV][uU]|*.[gG][iI][fF]|*.[jJ][pP][gG]|*.[mM][nN][gG]|*.[pP][dD][fF]|*.[pP][nN][gG]|*.[pP][nN][mM]|*.[tT][iI][fF][fF]|*.[xX][cC][fF])
            local FILE="${1}"
            shift
            ;;
        *) KEYS=(
            delete
            fore
            back
            rotate
            export
            import
            edit
            info
            rename
            insert
            print
            set
            unset
            view
            )
            if [[ ${KEYS[@]} =~ (^|[^[:alpha:]])${1}([^[:alpha:]]|$) ]] ; then
                KEY=${1}
                local CHARSTRING="$@"
                log info "main() ACTION –> ${KEY}"
                break
            else
                break
            fi
            ;;
    esac
done

echo "Zpracované volby" >> /dev/stderr
	case "${CHARSTRING}" in
		*-h|*--help|-h*|--help*) if [ -z "${KEY}" ] ; then
				help
			else
				help "keywords-${KEY}"
			fi
			exit 0
		;;
	esac

	if [ -f "${FILE}" ] ; then
#		log warn "main: Soubor -${FILE}- existuje.."
#		FILE=${FILE//\ /\\ }
		FILETYPE=$(testfile "${FILE}")
		case ${FILETYPE} in
			djvu)
				#echo "AKCE ${KEY}" >> /dev/stderr
				#echo "Parametry #${CHARSTRING}#" >> /dev/stderr
				case "${KEY}" in
					delete) deletepage "${FILE}" "${CHARSTRING}"
						case "$?" in
							2) printf "Page for remove from bundle must by identificated by num order, or name page in bundle. Range can not be use.\n" >> /dev/stderr
							;;
						esac
						exit 0
					;;
					insert) # ToDo - zpracovat ${CHARSTRING}
						exit 1
						if [ -f "${3}" ] ; then
							if [ $(testfile ${3}) == "djvu" ] ; then
								log info "main() - insert: Soubor je typu djvu"
								local INSERTFILE=${3}
							else
								[ "${#ALG[@]}" == "1" ] || exit 32
								local INSERTFILE="$TEMPDIR/${3%.*}.djvu"
								todjvu ${3} ${INSERTFILE}
								if [ $? -gt "0" ] ; then
									echo "main - insert: Soubor ${3} se nepodařilo zkonvertovat do souboru ${INSERTFILE}" >> /dev/stderr
									exit 1
								fi
							fi
							# Určit pozici...
							local P=$(identifypage ${1} ${4})
							log info "main() - insert: Cílová pozice je $P"
							if [ -z "${P}" ] ; then
								if [ -z "${4}" ] ; then
									echo "Připojení souboru ${INSERTFILE} na konec souboru ${1}" >> /dev/stderr
									insertpage ${1} ${INSERTFILE}
								else
									echo "Identifikátor ${4} je pro soubor ${1} neplatný" >> /dev/stderr
									exit 1
								fi
							else
								log info "main() - insert: Vkládám ${INSERTFILE} na pozici $P"
								insertpage ${1} ${INSERTFILE} ${P}
							fi
						else
							echo "Akci insert lze použít pouze ke vložení souboru" >> /dev/stderr
							exit 1
						fi
						exit 0
					;;
					fore) MOVE="fore"
						djvumove "${FILE}" "${CHARSTRING}"
						exit 0
					;;
					back) MOVE="back"
						djvumove "${FILE}" "${CHARSTRING}"
						exit 0
					;;
					rotate) djvurotate "${FILE}" "${CHARSTRING}"
						exit 0
					;;
					export) case "${CHARSTRING%% *}" in
						ant) # Exportuje hyperlinky a meta atributy ve formátu .ant
							#anttodsed "${CHARSTRING#* }"
							echo nil
							;;
						outline) # Exportuje obsah ve fromátu .outline
							printoutline "${FILE}" "${CHARSTRING#* }"
							;;
						bookmark) # Exportuje obsah ve formátu .bookmarks
							outlinetodsed "${CHARSTRING#* }" | encode > "${TARGET/.djvu/.outline}"
							;;
						dsed) # Exportuje obsah textové vrstvy ve formátu .dsed
							echo nil
							;;
						xml) #exportuje obsah textové vrstvy ve formátu .xml
							;;
						djvu) # exportuje celé stránky ve formátu DjVu
							echo nil
							;;
						img) # exportuje náhledy stránek ve formátu PNG
							echo nil
							;;
						*) djvuexport "${FILE}" "${CHARSTRING}"
							;;
						esac
						exit 0
					;;
					convert) # Konvertuje obsah předhozeného souboru
						case "${CHARSTRING%% *}" in
						ant) # Převede obsah .ant souboru do formátu pro dsed
							anttodsed "${CHARSTRING#* }"
							;;
						outline) # Převede obsah .outline souboru do formátu pro dsed
							#outlinetodsed "${CHARSTRING#* }" | encode >> "${TARGET/.djvu/.outline}"
							local OUTLINE="${CHARSTRING#* }"
							outlinetodjvu "${FILE}" "${OUTLINE%%.outline*}.outline" "${OUTLINE#*outline}"
							;;
						bookmark) # Převede obsah .outline souboru do formátu pro import
							outlinetodsed "${CHARSTRING#* }" | encode > "${TARGET/.djvu/.outline}"
							;;
						
						dsed) # Převede obsah .dsed souboru podle obsahu na soubor typu .outline a soubor typu .ant
							;;
						-h) help keyword-import
							;;
						*) djvuimport "${FILE}" "${CHARSTRING}"
							;;
					esac
					;;
					import) case "${CHARSTRING%% *}" in
						ant) # Importuje obsah předhozeného .ant souboru
							local ANT=${CHARSTRING#* }
							if [ -f "${ANT%% *}" ] ; then
								echo "import from ant file ${ANT%% *} to ${FILE} to pages: ${ANT#${ANT%% *}}" >> /dev/stderr
								#anttodsed "${CHARSTRING#* }"
								important "${FILE}" "${ANT%% *}" "${ANT#${ANT%% *}}"
							else
								echo "ERROR: ${ANT%% *} isn't .ant file!"
								exit 1
							fi
							;;
						meta) echo "import from meta file to ${FILE}"
							;;
						outline) if [ -f "${CHARSTRING#* }" ] ; then
								outlinetodjvu "${FILE}" "${CHARSTRING#* }"
							else
								echo "Import bokmarks is only from outline file"
							fi
							;;
						-h) help keyword-import
							;;
						*) djvuimport "${FILE}" "${CHARSTRING}"
							;;
					esac
						exit 33
					;;
					info) djvuinfo "${FILE}" "${CHARSTRING}"
						exit 0
					;;
					print) case "${CHARSTRING%% *}" in
						ant) printant "${FILE}" "${CHARSTRING#* }"
							;;
						outline) printoutline "${FILE}"
							;;
						test) compgen -A "${CHARSTRING#* }"
							;;
						*) help keyword-print
							;;
					esac
					exit 33
					;;
					rename)   # ToDo - zpracovat ${CHARSTRING}
						exit 1
					;;
					set) case "${CHARSTRING%% *}" in
							meta) setmeta "${FILE}" "${CHARSTRING#* }"
							;;
							outline) outlineset "${FILE}" "${CHARSTRING#outline *}"
							;;
							*) help keyword-meta
							;;
						esac
						exit 0
					;;
					unset) case "${CHARSTRING%% *}" in
							meta) unsetmeta "${FILE}" "${CHARSTRING#* }"
							;;
							outline) outlineunset "${FILE}" "${CHARSTRING#outline *}"
							;;
							*) help keyword-meta
							;;
						esac
						exit 0
					;;
					edit) case "${CHARSTRING}" in
							ant) # export všech ant 
								printant "${FILE}" "${CHARSTRING#* }"
								editor "${TEMPFILE}"
								echo "chybí funkce pro vložení.. set.."
							;;
							outline) local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .outline)
								printf '; Pravidla pro obsah souboru .outline :\n' >> "${TEMPFILE}"
								printf '; * Text záložky i její cíl musí být v uvozovkách\n' >> "${TEMPFILE}"
								printf ';  * Cíl může být identifikován buď pořadovým číslem stránky, nebo jejím jménem\n' >> "${TEMPFILE}"
								printf ';  * Identifikátor vždy začíná znakem #\n' >> "${TEMPFILE}"
								printf ';  * Úroveň zanoření záložky je daná odsazením pomocí tabelátoru\n' >> "${TEMPFILE}"
								printf ';  * Veškerý text na řádcích začínajících středníkem je považován za komentář\n' >> "${TEMPFILE}"
								printf ';  * Při importu souboru bude zakomentovaný obsah odfiltrován\n' >> "${TEMPFILE}"
								printf ';  * Soubor nesmí končit prázným řádkem!\n' >> "${TEMPFILE}"
								printf ';  * Pokud se do soubory změny neuloží, tak se vloží zpět původní obsah.\n' >> "${TEMPFILE}"
								printf ';\n' >> "${TEMPFILE}"
								printf ';"Link první úrovně" "#1"\n' >> "${TEMPFILE}"
								printf ';      "Link druhé úrovně" "#strana-001.djvu"\n' >> "${TEMPFILE}"
								printoutline "${FILE}" "${TEMPFILE}"
								editor "${TEMPFILE}"
								outlinetodjvu "${FILE}" "${TEMPFILE}"
							;;
							meta) echo "nahrazuje ant"
#							 local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .meta)
#								printmeta "${FILE}" all > "${TEMPFILE}"
#								# Doplnit vzor meta stránky pro případ, že zatím žádný obsah neexistuje
#								editor "${TEMPFILE}"
##								sed --in-place '/^#/d' "${TEMPFILE}"
#								[ $(grep -c ^ "${TARGET}") -eq "0" ] && return 1
#								djvuimport "${FILE}" "${TEMPFILE}"
							;;
							*) help keywords-edit
#								local NAMEPAGE=$(identifyname "${FILE}" "${CHARSTRING#* }")
#								if [ ! -z "${NAMEPAGE}" ] ; then
#									local TARGET="${TEMPDIR}/${FILE##*/}"
#									local IDPAGE=$(identifypage "${FILE}" "${PAGENAME}") 
#									local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .meta)
#									printmeta "${FILE}" "${NAMEPAGE}" | grep -v '^$' | grep -v '^\.$' >  "${TEMPFILE}"
#									local METAHEAD=$(head -1 ${TEMPFILE})
#									if [ -z "${METAHEAD}" ] ; then
#										METAHEAD="#${IDPAGE} '${NAMEPAGE}'"
#									fi
#									changemeta "${TEMPFILE}"
#									editor "${TEMPFILE}"
#									printf "$METAHEAD\n" > "${TARGET/.djvu/.meta}"
#									sed '/^#/d' "${TEMPFILE}" | sort >> "${TARGET/.djvu/.meta}"
#									printf "\n\n.\n" >> "${TARGET/.djvu/.meta}"
#									djvuimport "${FILE}" "${TARGET/.djvu/.meta}"
#								else
#									printf "You must add valid parameter. Use -h for more info.\n" >> /dev/stderr
#									exit 1
#								fi
							;;
						esac
						exit 33
					;;
					view) djview "${FILE}" &
						exit 1
					;;
					*) help keywords && exit 0
					;;
				esac
			;;
			jpeg|png) echo "Bude se zpracovávat soubor v bitmapovém formátu"
				echo "ToDo"
				exit 1
			;;
			gimp|xcf|tiff|mng|pdf)
				if [ -z "${2}" ] ; then
#					echo ${ACTION} >> /dev/stderr
					ACTION=( ${1#${FILE}} )
					if [ -z "${ACTION[1]:0:1}" ] ; then
						echo "INFO: Konvertuji všechny vrstvy (stránky)" >> /dev/stderr
					else
						case ${ACTION[1]:0:1} in
							[1-9]) # echo "INFO zpracovávám rozsah ${ACTION[1]}" >> /dev/stderr
								RANGE=($(range ${ACTION[1]} | sort -n))
							;;
							0) echo "INFO: zpracuji všechny stránky" >> /dev/stderr
							;;
							*) echo "INFO: aplikuji algoritmus ${ACTION[1]}" >> /dev/stderr
								# mohou následovat další konverzní argumenty...
								#echo ${#ACTION[@]} >> /dev/stderr
								echo ${ACTION[$((${#ACTION[@]}-1))]:0:1} >> /dev/stderr
								case ${ACTION[$((${#ACTION[@]}-1))]:0:1} in
									[1-9]) #echo "INFO zpracovávám rozsah ${ACTION[2]}" >> /dev/stderr
										RANGE=($(range ${ACTION[$((${#ACTION[@]}-1))]} | sort -n))
										ENCODEPARAM=${ACTION[@]:1:$((${#ACTION[@]}-2))}
									;;
									0) # Rozsah začíná nulou... konvertovat vše..
										ENCODEPARAM=${ACTION[@]:1:$((${#ACTION[@]}-2))}
									;;
									*) echo "INFO: zpracuji všechny stránky s algoritmem ${ACTION[1]}" >> /dev/stderr
										ENCODEPARAM=${ACTION[@]:1:$((${#ACTION[@]}-1))}
									;;
								esac
								case ${ACTION[1]} in
									test) if [ "${#RANGE[@]}" -eq "1" ] ; then
											echo "Konvertuji stranu ${RANGE[0]}" >> /dev/stderr
										elif [ "${#RANGE[@]}" -eq "0" ] ; then
											RANGE="1"
										else
											echo "WARNING: U testovací konverze je zpracována pouze první strana uvedeného rozsahu" >> /dev/stderr
										fi
										# vrátí pouze stranu vymezenou přes range
										splitxcf ${FILE}
										;;
									abutaleb) #ok
										;;
									bernsen) # params
										;;
									brink|shading-subtraction) # ok  Gamera ≥ 3.4.0
										;;
									djvu) # params
										;;
									niblack) #params
										;;
									otsu) # ok
										;;
									sauvola) # params
										;;
									shading-subtraction) # params  Gamera ≥ 3.4.0
										;;
									tsai) # ok
										;;
									white-rohrer) # params
										;;
									*) echo -e "${ALGORITHM//\ /\\\n}" >> /dev/stderr
										exit 0
									;;
								esac
							;;
						esac
					fi
					case ${ACTION[0]} in
						info) echo "Info o souboru ${FILETYPE}"
							case ${FILETYPE} in
								pdf) echo -n "PDF "
#									xcfinfo ${FILE} | grep '^[+-]'  | wc -l
									exit 0
								;;
								mng) echo -n "MNG "
#									xcfinfo ${FILE} | grep '^[+-]'  | wc -l
									exit 0
								;;
								xcf|gimp) echo -n "XCF "
									xcfinfo ${FILE} | grep '^[+-]'  | wc -l
									exit 0
								;;
								tiff) echo -n "TIFF "
									tiffinfo ${FILE} | grep TIFF | wc -l
									exit 0
								;;
							esac
						;;
						convert) echo "Konverze souboru do DjVu"
							case ${FILETYPE} in
								pdf) 
#									xcfinfo ${FILE} | grep '^[+-]'  | wc -l
									exit 0
								;;
								mng)
#									xcfinfo ${FILE} | grep '^[+-]'  | wc -l
									exit 0
								;;
								xcf|gimp) splitxcf ${FILE}
									pushd ${TEMPDIR}
									ls -1cr | while read line
										do todjvu "$line" "${line/.pnm/.djvu}"
									done
									popd
									# Rozděleno na pnm soubory to je..
									# konvertovat tam, nebo jinde?
									# použít funkci todjvu? Asi jo..
									# konvertovat po jednom a přesouvat do cílové lokace
									# Zatím je to uloženo v tempdir - který se odstraní..
									potvrdit && echo "ano"
									echo xxxxxxxxxxxxxxxxxxxxx >> /dev/stderr
									exit 0
								;;
								tiff) echo -n "TIFF "
									tiffinfo ${FILE} | grep TIFF | wc -l
									exit 0
								;;
							esac
						# Rozebrání souboru na pnm
						# vytvoření pole s názvy souborů
						# zpracování podle ${RANGE}

						 # Je-li předán rozsah - vytvoření číselné řady..
								#xcf2pnm $SOURCE -o ${TARGETNAME%\.*}-$i.pnm $i

						 # Je-li předán rozsah, tak se provede rekonverze..
								#echo ${${RANGE[@]}//\ /,}
									#tiffcp -c none $FILE,${RANGE//\n/,} temporary.tiff
									#tiffsplit temporary.tiff
									 # není-li předán rozsah...
									#tiffsplit source.tiff

						;;
						*) help keywords-convert
						;;
					esac
						echo "Nápověda pro akci convert"
#						help keywords-convert
#						exit 0
#						echo "Jako druhý parametr je soubor ve vícevrstvém bitmapovém formátu. Zpracování těchto souborů není zatím implementováno" >> /dev/stderr
#						echo "Povolené akce: info, convert, import" >> /dev/stderr
#						echo ${@} >> /dev/stderr
#						convertimg ${FILE} ${2}
					exit 0
				else
					echo "Sem by se neměl dostat v případě že je předaný soubor typu multipage" >> /dev/stderr
					exit 0
				fi
			;;
			xml|XML) echo "má-li první soubor příponu xml"
				echo "ToDo"
				exit 1
			;;
			unknown) echo "Pokud je soubor ${1} typu DjVU, může jít o tzv. SecureDjVu formát, který má kryptované vrstvy. S takovým souborem nelze s opensource nástroji pracovat." >> /dev/stderr
				exit 1
			;;
			*) if [ ! "${2}" ] ; then
					echo '''Není předaný jiný parametr, bude se zpracovávat soubor podle typu ''' >> /dev/stderr
					echo "${FILE} : $(testfile ${FILE})" >> /dev/stderr
				else
					echo "Zpracování souborů jako je $2 zatím není implementováno" >> /dev/stderr
				fi
				echo '''Pokud následuje djvu soubor'''
				echo '''Pokud následuje adresář'''
				echo '''to je existující soubor typu bundle a:
				- nenásleduje žádný další existující soubor typu djvu, nebo adresář
				a zároveň existuje $DIRECTORY, pak to znamená že se má rozbalit
				- pokud následuje další soubor, pak to znamená že se má nějakým způsobem s tímto dalším souborem naložit. Je-li to:
				- djvu soubor, má se připojit
				- xml soubor, má se vložit
				- soubor typu dsed má se zpracovat
				- jiný soubor - obrázek, který se má převést a vložit
				'''
				exit 1
			;;
		esac
	else
		#echo "Tady se dostane pokud ${FILE} neexistuje" >> /dev/stderr
		help
		exit 0
	fi
}

main $@

exit 0
