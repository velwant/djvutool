#!/bin/bash
# -*- mode: sh -*-

# convertor - tool for conversion and work DjVu files
#
# Author: Aleš Kapica <kapica@fel.cvut.cz>, 2015
#
# Použití...
# convertor [test] image
#	provede testovací konverzi pro všechny dostupné separační algoritmy didjvu
shopt -s extglob

# Changelog
# - ošetřena situace, kdy není nainstalován ocrodjvu
# - ošetřit situaci, kdy soubor neobsahuje žádný textový obsah a soubor dsed, ani xml neexistuje
# - mezi klíčové operace přidáno delete a insert
# - OCR zpracované do samostatné funkce
# - výchozí algoritmus djvu; testovací konverze pro všechny algoritmy se
#   provede pouze je-li uveden parametr --test-conversion
# - implementována rotace stránky
# - implementovány přesuny stránek (akce fore a back)
# - implementováno generování náhledů do exportu
# - upraveny funkce pro export náhledů a souborů textové vrstvy
# - implementována akce print pro výpis metadat

# Konvence..
# Hlavní funkce djvu<KEYWORD>
# Vedlejší funkce <KEYWORD>...

# Otestovat
# - export ze single-page dokumentu
#

# ToDo
# Opravit akci edit meta - dočasný soubor je někde v pytli - binec dělá asi realpath nebo co..
# přepracovat použití djvudump na djvm -l (je rychlejší..)
# implementovat kontrolu do funkce todjvu, aby nedocházelo k nekontrolovatelnému vkládání již existujících stránek
# - přidat kontrolu do akce insert na duplicitní soubory při vkládání
#   vícestránkových DjVu souborů. to ovšem bude vyžadovat samostatnou
#   funkci...
# - dopsat nápovědu pro akci keywords-unset 
# - dopsat manuál pro akci set, argumenty, xmp, atp.
# - implementovat import
# doplnit nápovědu k rotaci stránky (akce rotate)
# opravit volby --algoritmus a --view
NAME="djvutool"
[ -d "${HOME}/.config/${NAME}" ] &&	. ${HOME}/.config/${NAME}/* &>>/dev/null

LOG="${LOG=/dev/null}"
XML="${XML=no}"
DPI="${DPI=300}"
DSED="${DSED=no}"
PAGE="${PAGE=no}"
META="${META=no}"
IMG="${IMG=no}"
INDIRECT="${INDIRECT=no}"
FORCE="${FORCE=skip}"
RENAME="no"
EXTENSION=".djvu"
THUMBNAIL="${THUMBNAIL=no}"
INSERTTEXT="${INSERTTEXT=no}"
ALG="${ALG=djvu}"
EXTRACTPAGE="${EXTRACTPAGE=no}"
IMGPAGE="${IMGPAGE=no}"
ALGORITHM="abutaleb bernsen brink djvu niblack otsu sauvola shading-subtraction"
TABS="8"

trap '''CHYBA=$? ;
case $CHYBA in
 20) echo "Není nainstalován balík djvu-tools"
 ;;
 21) echo "ERROR: mimetype - tool for detection type of image"
 ;;
 22) echo "ERROR: readlink - tool for detection absolute path of directory"
 ;;
 23) echo "ERROR: netpbm-sf - pack of utilities for image conversions not installed "
 ;;
 24) echo "ERROR: imagemagick - tool for image convert is not installed"
 ;;
 25) echo "ERROR: xmlstarlet - tool for work with xml not installed"
 ;;
 31) echo "Není nainstalován balík ocrodjvu, na djvu soubory nelze aplikovat OCR. Buďto jej doinstalujte, nebo odstraňte z příkazové řádky parametr -o (--ocr)" >> /dev/stderr
 ;;
 32) echo "Pokud má při operaci zpracovat do DjVu bitmapový soubor, je třeba uvést na příkazové řádce parametrem -a jaký se má použít algoritmus. Jaké parametry lze použít se dozvíte pokud místo jména algoritmu napíšete znak ?" >> /dev/stderr
 ;;
 33) NORMDIR=yes
 ;;
esac
[ $NORMDIR ] || rm -rf -- "$TEMPDIR"
exit $CHYBA
''' EXIT

TEMPDIR=$(mktemp -d -p /tmp ${NAME}-XXX) || exit 1

#=== testy závislostí ===
# Dependencies:
#   * feh      ( http://feh.finalrewind.org/ )
#   * exiftool ( http://www.sno.phy.queensu.ca/~phil/exiftool ) in Debian package: libimage-exiftool-perl 
#   * yad      ( http://sourceforge.net/projects/yad-dialog )
REALPATH=$(which realpath)
[ ! ${REALPATH} ] && exit 1
REALPATH="$REALPATH -e "

DIDJVU=$(which didjvu)
[ ! ${DIDJVU} ] && echo 'Není nainstalován balík didjvu, nebude možné aplikovat pokročilé algoritmy pro separaci popředí při konverzi do DjVu' >> /dev/stderr && DIDJVU=false
OCRODJVU=$(which ocrodjvu)
[ ! ${OCRODJVU} ] && OCRODJVU=31
DJVIEW=$(which djview)
[ ! ${DJVIEW} ] && echo 'Není nainstalován balík djview, nebude fungovat testovací zobrazení djvu.souborů' >> /dev/stderr && DJVIEW=false
DDJVU=$(which ddjvu)
[ ! ${DDJVU} ] && exit 20
DJVUTXT=$(which djvutxt)
[ ! ${DJVUTXT} ] && exit 20
DJVUSED=$(which djvused)
[ ! ${DJVUSED} ] && exit 20
DJVUTOXML=$(which djvutoxml)
[ ! ${DJVUTOXML} ] && exit 20
DJVUXMLPARSER=$(which djvuxmlparser)
[ ! ${DJVUXMLPARSER} ] && exit 20
DJVUDUMP=$(which djvudump)
[ ! ${DJVUDUMP} ] && exit 20
DJVMCVT=$(which djvmcvt)
[ ! ${DJVMCVT} ] && exit 20
DJVM=$(which djvm)
[ ! ${DJVM} ] && exit 20
CJB2=$(which cjb2)
[ ! ${CJB2} ] && exit 20
DJVUMAKE=$(which djvumake)
[ ! ${DJVUMAKE} ] && exit 20
#YAD=$(which yad)
#[ ! ${YAD} ] && echo 'Není nainstalován balík yad' && exit 1
MIME=$(which mimetype)
[ ! -x "${MIME}" ] && exit 21
STAT=$(which readlink)
[ ! -x "${STAT}" ] && exit 22
EXIFTOOL=$(which exiftool)
[ ! -x "${EXIFTOOL}" ] && exit 23
TESSERACT=$(which tesseract)
[ ! -x "${TESSERACT}" ] && exit 31
IDENTIFY=$(which identify)
[ ! -x "${IDENTIFY}" ] && echo exit 24
CONVERT=$(which convert)
[ ! -x "${CONVERT}" ] && echo exit 24


NETPBM=0
PNMSCALE=$(which pnmscale)
[ ! -x "${PNMSCALE}" ] && NETPBM=1
if (( $NETPBM == 0 )); then
    VERSION=($(${PNMSCALE} -version 2>&1 | head -1))
    case ${VERSION[$((${#VERSION[@]} - 1))]} in
	10.0*|9*) echo "WARNING: Version Netpbm pnmacele don't support filters. I must use imagemagick convert" >> /dev/stderr
	    NETPBM=1
	    ;;
	*)  NETPBM=0
	    BMPTOPNM=$(which bmptopnm)
	    [ ! -x "${BMPTOPNM}" ] && exit 23
	    JPEGTOPNM=$(which jpegtopnm)
	    [ ! -x "${JPEGTOPNM}" ] && exit 23
	    GIFTOPNM=$(which giftopnm)
	    [ ! -x "${GIFTOPNM}" ] && exit 23
	    PNGTOPNM=$(which pngtopnm)
	    [ ! -x "${PNGTOPNM}" ] && exit 23
	    PNMTOJPEG=$(which pnmtojpeg)
	    [ ! -x "${PNMTOJPEG}" ] && exit 23
	    TIFFTOPNM=$(which tifftopnm)
	    [ ! -x "${TIFFTOPNM}" ] && exit 23
	    PNMTOPNG=$(which pnmtopng)
	    [ ! -x "${PNMTOPNG}" ] && exit 23
	    PNMTOPLAINPNM=$(which pnmtoplainpnm)
	    [ ! -x "${PNMTOPLAINPNM}" ] && exit 23
	    PPMTOPGM=$(which ppmtopgm)
	    [ ! -x "${PPMTOPGM}" ] && exit 23
	    PGMTOPBM=$(which pgmtopbm)
	    [ ! -x "${PGMTOPBM}" ] && exit 23
	    ;;
    esac
fi
if (( $NETPBM == 1 )) ; then
    CONVERT=$(which convert)
    [ ! -x "${CONVERT}" ] && echo exit 24
fi
#=== konec testu závislostí ===

## Pomocné funkce...
function tabs {
	# $1 - file with tabs
	local TAB=$(printf '%.0s\ ' {0..${TABS}})
	sed "s/\t/${TAB}/g" "${1}"
}

function log {
	# $1 - závažnost hlášky
	# $2 - textový řetězec..
	# $DEBUG úroveň logování
	# $LOG - výstup (default - /dev/null
	case "${1}" in
		1) # Hlášky upřesňující místo ve skriptu
		echo "${@:2}" >> ${LOG}
		;;
		0) # Běžné hlášky
		echo "${1}" >> ${LOG}
		;;
		*)
		;;
	esac
}

function pushd {
    command pushd "$@" > /dev/null
}

function popd {
    command popd "$@" > /dev/null
}

function potvrdit {
    read -r -p "${1:-Opravdu chcete akci provést? [y/N]} " response
    case $response in
        [yY][eE][sS]|[yY]) 
            true
            ;;
        [aA][nN][oO]|[aA]) 
            true
            ;;
        *)
            false
            ;;
    esac
}

function printtext {
	echo "${#1}" >> /dev/stderr
	echo -e "${@}"
}

function escape_path {
# Zatím nepoužitá
	echo "escape_path $*" >> /dev/stderr
	echo "$*" | sed \
  -e 's/\ /\\\ /g'
}

function printmeta {
	# $1 - svazek
	# $2 - identifikátor, klíčové slovo 'all' nebo atribut
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	case "${2}" in
		all) printf "printmeta: All meta attributes for %s\n" "${FILE}" >> ${LOG}
			local META=$(${DJVUSED} "${SOURCE}" -e "select; print-meta" | sed 's/\\/\\0/g')
			if [ ! -z "${META}" ] ; then
				echo "#"
				echo -e "${META}" | tr '\000' '\\'
				echo -e "\n."
			fi
			for i in $(seq $(lastpage ${SOURCE})) ; do
				local PAGENAME=$(identifyname "${SOURCE}" "${i}")
				local META=$(${DJVUSED} "${SOURCE}" -e "select '${PAGENAME}'; print-meta" | sed 's/\\/\\0/g')
				if [ ! -z "${META}" ] ; then
					echo "#$i '${PAGENAME}'"
					echo -e "${META}" | tr '\000' '\\'
					echo -e "\n."
				fi
			done
		;;
		global) printf "printmeta: Global meta attributes from %s\n" "${FILE}" >> ${LOG}
			local META=$(${DJVUSED} "${SOURCE}" -e "select; print-meta" | sed 's/\\/\\0/g')
			if [ ! -z "${META}" ] ; then
				echo "#"
				echo -e "${META}" | tr '\000' '\\'
				echo -e "\n."
			fi
		;;
		+([[:digit:]])|*.djvu) printf "printmeta: Meta attributes for page %s from %s\n" "${2}" "${FILE}" >> ${LOG}
			local PAGENAME=$(identifyname "${SOURCE}" "${2}")
			if [ ! -z "${PAGENAME}" ] ; then
				local IDPAGE=$(identifypage "${SOURCE}" "${PAGENAME}")
				local META=$(${DJVUSED} "${SOURCE}" -e "select '${PAGENAME}'; print-meta" | sed 's/\\/\\0/g')
				if [ ! -z "${META}" ] ; then
					echo "#${IDPAGE} '${PAGENAME}'"
					echo -e "${META}" | tr '\000' '\\'
					echo -e "\n."
				fi
			fi
		;;
		*) printmeta "${SOURCE}" all
		;;
	esac
}

function djvuimport {
	# Import nevkládá nové stránky, ale importuje soubory textové vrstvy
	# $1 - DjVu file
	# $2 - soubor identifikátor + cílový adresář
	#echo "1- ${1}" >> /dev/stderr
	#echo "2- ${2}" >> /dev/stderr
	#echo "3- ${3}" >> /dev/stderr
	local SOURCE=$(${REALPATH} -m -P "${1}")
	echo "djvuimport: SOURCE ${SOURCE}" >> /dev/stderr
	local FILE="${SOURCE##*/}"
	if [ -z "${2}" ] ; then
		local FROM=$(${REALPATH} -m -P "$(pwd)")
		echo "djvuimport: FROM ${FROM}" >> /dev/stderr
	else
		local FROM=$(${REALPATH} -m -P "${2}")
		echo "djvuimport: FROM ${FROM}" >> /dev/stderr
	fi

	if [ -d "${FROM}" ] ; then
		local LIST=$(djvuinfo "${SOURCE}" pages)
		local IFS_BAK=$IFS
		local IFS=$'\n'
		for i in  ${LIST} ; do

			local PAGENAME="${i##*:}"
			log 1 "import: Hledám soubory pro import dat do stránky ${PAGENAME} v souboru ${FILE}"
			if [ -f "${FROM}/${PAGENAME/.djvu/.dsed}" ] ; then
				importdsedpage "${SOURCE}" "${PAGENAME}" "${FROM}/${PAGENAME/.djvu/.dsed}"
			fi
			if [ -f "${FROM}/${PAGENAME/.djvu/.xml}" ] ; then
				importxmlpage "${SOURCE}" "${FROM}/${PAGENAME/.djvu/.xml}"
			fi
			if [ -f "${FROM}/${PAGENAME/.djvu/.meta}" ] ; then
				importmetapage "${SOURCE}" "${PAGENAME}" "${FROM}/${PAGENAME/.djvu/.meta}"
			fi

		done
		local IFS=$IFS_BAK
		log 1 "import: Importuji meta atributy a obsah pro celý soubor ${FILE}"
		# Import obsahu souboru..
		if [ -f "${FROM}/${FILE/.djvu/.meta}" ] ; then
			importmetaall "${SOURCE}" "${FROM}/${FILE/.djvu/.meta}"
		fi
		if [ -f "${FROM}/${FILE/.djvu/.outline}" ] ; then
			importoutline "${SOURCE}" "${FROM}/${FILE/.djvu/.outline}"
		fi
	elif [ -f "${FROM}" ] ; then
		case "$(head -c 1 ${FROM})" in
			\<) echo "import: import XML file" >> /dev/stderr
				XML="yes"
				importxmlpage "${SOURCE}" "${FROM}"
				return 0
			;;
			s) echo "import: import file in dsed format" >> /dev/stderr
				DSED="yes"
				importdsedall "${SOURCE}" "${FROM}"
				return 0
			;;
			\") echo "import: import outline file" >> /dev/stderr
				local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .outline)
				outlinetodsed "${FROM}" | encode > "${TEMPFILE}"
				importoutline "${SOURCE}" "${TEMPFILE}"
				return 0
			;;
			\() echo "import: import outline in dsed format" >> /dev/stderr
				"${SOURCE}" 
				importoutline "${SOURCE}" "${FROM}"
				return 0
			;;
			\#) echo "import: import meta atribute file" >> /dev/stderr
				META="yes"
				importmeta "${SOURCE}" "${FROM}"
				return 0
			;;
			[[:alpha:]]) echo "import: meta TODO atribute file for one page - not implemented" >> /dev/stderr
				echo "může jít i o seznam stránek k importu do souboru.." >> /dev/stderr
				local FROMFILE="${FROM##*/}"
				#echo  "${FILE%.*} ${FROMFILE%.*}" >> /dev/stderr
				log 1 "import: Importuji data do stránky ${FROMFILE}"
				local LIST=$(djvuinfo "${SOURCE}" pages)
				local IFS_BAK=$IFS
				local IFS=$'\n'
				for i in  ${LIST} ; do
					local PAGENAME="${i##*:}"
					if [ "${PAGENAME%.*}" == "${FROMFILE%.*}" ] ; then
						echo "Importuji data ze souboru ${FROM} do stránky ${PAGENAME} v souboru ${FILE}" >> /dev/stderr
						case "${FROMFILE}" in
							*.dsed) DSED="yes"
								importdsedpage "${SOURCE}" "${PAGENAME}" "${FROM}"
							;;
							*.meta) META="yes"
								importmeta "${SOURCE}" "${PAGENAME}" "${FROM}"
							;;
							*.xml) XML="yes"
								importxmlpage "${SOURCE}" "${FROM}"
							;;
							*) echo "import: Při importu textových dat do stránky jsou akceptovány pouze soubory s příponou .dsed, .xml a .meta" >> /dev/stderr
							;;
						esac
					fi
				done
				local IFS=$IFS_BAK
				return 0
			;;
			*) echo "import: FAIL - unknown file" >> /dev/stderr
				exit 1
			;;
		esac
	else
		echo "import: Parametrem akce import může být buď adresář se soubory, nebo soubor s daty k importu" >> /dev/stderr
		exit 1
	fi
}

function djvuexport {
	# $1 - DjVu file
	# $2 - identifikátor + cílový adresář
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"

	# Parsing $2
	local CHARSTRING="$2"
	if [ "${CHARSTRING}" == "" ] ; then
		help keywords-export
		exit 0
	fi

#	echo "${PAGE} ${DSED} ${XML} ${IMG} ${META} ${FORCE} option" >> /dev/stderr
	export EXPORTVALUE=0
	[ "${PAGE}" != "no" ] && export EXPORTVALUE=$(( $EXPORTVALUE + 1 ))
	[ "${IMG}" != "no" ] && export EXPORTVALUE=$(( $EXPORTVALUE + 2 ))
	[ "${XML}" != "no" ] && export EXPORTVALUE=$(( $EXPORTVALUE + 4 ))
	[ "${META}" != "no" ] && export EXPORTVALUE=$(( $EXPORTVALUE + 8 ))
	[ "${DSED}" != "no" ] && export EXPORTVALUE=$(( $EXPORTVALUE + 16 ))
#	if [ "${PAGE}" == "no" ] && [ "${DSED}" == "no" ] && [ "${XML}" == "no" ] && [ "${IMG}" == "no" ] && [ "${META}" == "no" ] ; then

	if  [ "${FORCE}" == "skip" ] ; then
		# Interaktivní mód
		printf "export: For export from DjVu bundle we must use any option\n" >> /dev/stderr
		# Co mám vyexportovat ze svazku?
		# 1) pouze stránky ve formátu DjVu
		# 2) pouze náhledy stránek ve formátu PNG
		# 3) 0+P
		# 4) pouze xml soubory textové vrstvy
		# 5) X+P
		# 6) X+O
		# 7) X+O+P
		# 8) pouze metainformace
		# 9) M+P
		# 10) M+O
		# 11) M+O+P
		# 12) M+X
		# 13) M+X+P
		# 14) M+X+O
		# 15) M+X+O+P
		# 16) pouze dsed soubory
		# 17) D+P
		# 18) D+O
		# 19) D+O+P
		# 20) D+X
		# 21) D+X+P
		# 22) D+X+O
		# 23) D+X+O+P
		# 24) D+M
		# 25) D+M+P
		# 26) D+M+O
		# 27) D+M+O+P
		# 28) D+M+X
		# 29) D+M+X+P
		# 30) D+M+X+O
		# 31) D+M+X+O+P
		printf "Export of DjVu pages from bundle?\n" >> /dev/stderr
		potvrdit && export EXPORTVALUE=$(( $EXPORTVALUE + 1 ))
		printf "Export pages as PNG too?\n" >> /dev/stderr
		potvrdit && export EXPORTVALUE=$(( $EXPORTVALUE + 2 ))
		printf "Export text layer as XML file?\n" >> /dev/stderr
		potvrdit && export EXPORTVALUE=$(( $EXPORTVALUE + 4 ))
		printf "Export meta and outline from bundle?\n" >> /dev/stderr
		potvrdit && export EXPORTVALUE=$(( $EXPORTVALUE + 8 ))
		printf "Export text from bundle in DSED format?\n" >> /dev/stderr
		potvrdit && export EXPORTVALUE=$(( $EXPORTVALUE + 16 ))
#		echo "Budu zpracovávat $EXPORTVALUE"
	fi

	if [ $EXPORTVALUE == 0 ] ; then
		printf "export: Options are necessary for specify of content for export from DjVu bundle.\n" >> /dev/stderr
		return 1
	fi

	local CHARCOUNT=$((${#CHARSTRING} + 1))
	local CHARPOS=0
	local STRPOS=0
	while [ "${CHARCOUNT}" -gt "0" ] ; do
		case "${CHARSTRING:0:$((${CHARPOS} - ${STRPOS}))}" in
			*.[dD][jJ][vV][uU]) local PAGENAME="${CHARSTRING:0:$((${CHARPOS} - ${STRPOS}))}"
				local STRPOS="${CHARPOS}"
				local CHARSTRING="${CHARSTRING#${PAGENAME}}"
				local CHARCOUNT=$((${#CHARSTRING} + 1))
			;;
		esac
		local CHARPOS=$((CHARPOS + 1))
		local CHARCOUNT=$((CHARCOUNT - 1))
	done

	if [  -z "${CHARSTRING}" ] ; then
		if [ -z "${PAGENAME}" ] ; then
			log 1 "export: Export all pages from ${FILE} into aktual directory - do set TARGETDIR"
			local TARGETDIR=$(targetdir $(pwd))
			exportdjvuall "${SOURCE}" "${TARGETDIR}"
			return 0
		else
			log 1 "export: Export page identificated by ${PAGENAME} from ${FILE} into aktual directory - do set TARGETDIR"
			local IDPAGE=$(identifypage "${SOURCE}" "${PAGENAME}")
			if [ -z "${IDPAGE}" ] ; then
				case "${PAGENAME%%\ *}" in
					meta) printmeta "${SOURCE}" "${PAGENAME#* }"
						return 0
					;;
					*) echo "export: In ${FILE} is not any page identificated by ${PAGENAME}"  >> /dev/stderr &&  exit 1
					;;
				esac
			else
				local NAMEPAGE=$(identifyname "${SOURCE}" "${PAGENAME}")
				local TARGETDIR=$(targetdir $(pwd))
			fi
		fi
	else
		if [ -z "${PAGENAME}" ] ; then
			local TEMP=${CHARSTRING##+([[:blank:]])}
			local IDPAGE=${TEMP%%+([[:blank:]])*}
			local CHARSTRING=${TEMP#${IDPAGE}}
			local TARGETDIR=${CHARSTRING##+([[:blank:]])}
			# Tady může být nějaký jiný parametr, než pořadové číslo, a také TARGETDIR může být prázdný.
			case "${IDPAGE}" in
				all) if [ -z "${TARGETDIR}" ] ; then
						log 1 "export: Export all pages from ${FILE} into actual directory - do set TARGETDIR"
						local TARGETDIR=$(targetdir $(pwd))
						exportdjvuall "${SOURCE}" "${TARGETDIR}"
						return 0
					else
						log 1 "export: Export all pages from ${FILE} into ${TARGETDIR}"
						local TARGETDIR=$(targetdir "${TARGETDIR}")
						exportdjvuall "${SOURCE}" "${TARGETDIR}"
						return 0
					fi
				;;
				meta) printmeta "${SOURCE}" "${TARGETDIR}"
					return 0
				;;
				outline) dsedtooutline "${SOURCE}"
					return 0
				;;
				*) log 1 "export: Export page identificated by order -${IDPAGE}- from ${FILE} into -${TARGETDIR}-"
					local NAMEPAGE=$(identifyname "${SOURCE}" "${IDPAGE}")
					if [ -z "${NAMEPAGE}" ] ; then
						# djvutool bundle.djvu export
						if [ -e "${IDPAGE}" ] ; then
							if [ -d "${IDPAGE}" ] ; then
								djvuexport "${SOURCE}" "all ${IDPAGE}"
							else
								echo "export: In ${FILE} is not any page on position ${IDPAGE}"  >> /dev/stderr &&  exit 1
							fi
						else
							djvuexport "${SOURCE}" "all ${IDPAGE}"
						fi
					else
						local TARGETDIR=$(targetdir "${TARGETDIR}")
					fi
				;;
			esac
		else
			local NAMEPAGE=${PAGENAME##+([[:blank:]])}
			local TARGETDIR=${CHARSTRING##+([[:blank:]])}
			log 1 "export: Export page identificated by name -${NAMEPAGE}- from ${FILE} into -${TARGETDIR}-"
			local IDPAGE=$(identifypage "${SOURCE}" "${NAMEPAGE}")
			[ -z "${IDPAGE}" ] && echo "export: In ${FILE} is not any page with name ${NAMEPAGE}" >> /dev/stderr &&  exit 1
			local TARGETDIR=$(targetdir "${TARGETDIR}")
		fi
	fi

#	echo "export: SOURCE ${SOURCE}">> /dev/stderr
#	echo "export: FILE ${FILE}">> /dev/stderr
#	echo "export: IDPAGE ${ODPAGE}">> /dev/stderr
#	echo "export: NAMEPAGE ${NAMEPAGE}">> /dev/stderr
#	echo "export: TARGETDIR ${TARGETDIR}">> /dev/stderr
#	echo "export: FORCE ${FORCE}">> /dev/stderr

	exportdjvupage "${SOURCE}" "${NAMEPAGE}" "${TARGETDIR}"
	exportdsedpage "${SOURCE}" "${NAMEPAGE}" "${TARGETDIR}"
	#echo "export: For export text content from DjVu page in dsed format we must use option -d" >> /dev/stderr
	exportxmlpage "${SOURCE}" "${NAMEPAGE}" "${TARGETDIR}"
	#echo "export: For export hidden text layer of pages from DjVu bundle in XML format we must use option -x" >> /dev/stderr
	exportimgpage "${SOURCE}" "${NAMEPAGE}" "${TARGETDIR}"
	#echo "export: For export image of page from DjVu bundle we must use option -i" >> /dev/stderr
	exportmetapage "${SOURCE}" "${NAMEPAGE}" "${TARGETDIR}"
	# echo "export: For export meta attributes from pages DjVu bundle in we must use option -m" >> /dev/stderr
}

function exportdjvuall {
	# $1 - DjVu file - full path
	# $2 - targetdir - full path
	echo "$EXPORTVALUE" >> /dev/stderr
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	[ "${PAGE}" != "no" ] || echo "exportdjvuall: For export pages in DjVu format we must use option -p" >> /dev/stderr
	[ "${DSED}" != "no" ] || echo "exportdjvuall: For export hidden text layer of pages from DjVu bundle in dsed format we must use option -d" >> /dev/stderr
	[ "${XML}" != "no" ] || echo "exportdjvuall: For export hidden text layer of pages from DjVu bundle in XML format we must use option -x" >> /dev/stderr
	[ "${IMG}" != "no" ] || echo "exportdjvuall: For export image of page from DjVu bundle we must use option -i" >> /dev/stderr
	[ "${META}" != "no" ] || echo "exportdjvuall: For export meta attributes from pages DjVu bundle in we must use option -m" >> /dev/stderr
	local PAGES=$(lastpage "${SOURCE}")
	local NUMPAGE=1
	while [ ${PAGES} -gt "0" ] ; do
		local NAMEPAGE=$(identifyname "${SOURCE}" "${NUMPAGE}")
		log 1 "exportdjvuall: Exportuji stránku ${NAMEPAGE}"
		case $EXPORTVALUE in
			1|3|5|9|11|13|15|17|19|21|23|25|27|29|31) exportdjvupage "${1}" "${NAMEPAGE}" "${2}"
			;;
		esac
		case $EXPORTVALUE in
			2|3|6|7|10|11|14|15|18|19|22|23|26|27|30|31) exportimgpage "${1}" "${NAMEPAGE}" "${2}"
			;;
		esac
		case $EXPORTVALUE in
			4|5|6|7|12|13|14|15|20|21|22|23|28|29|30|31) exportxmlpage "${1}" "${NAMEPAGE}" "${2}"
			;;
		esac
		case $EXPORTVALUE in
			8|9|10|11|12|13|14|15|24|25|26|27|28|29|30|31) exportmetapage "${1}" "${NAMEPAGE}" "${2}"
			;;
		esac
		case  $EXPORTVALUE in
			16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31) exportdsedpage "${1}" "${NAMEPAGE}" "${2}"
			;;
		esac
		local NUMPAGE=$((NUMPAGE + 1))
		local PAGES=$((PAGES - 1))
	done
	case $EXPORTVALUE in
		4|5|6|7|12|13|14|15|20|21|22|23|28|29|30|31)
			exportxmlbundle "${1}" "${2}"
		;;
	esac
	case $EXPORTVALUE in
		8|9|10|11|12|13|14|15|24|25|26|27|28|29|30|31)
			exportmetabundle "${1}" "${2}"
			dsedtooutline "${1}" > "${2}/${FILE/.djvu/.outline}"
		;;
	esac
	case $EXPORTVALUE in
		16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31)
			exportdsedbundle "${1}" "${2}"
		;;
	esac
}

function exportdsedbundle {
	# $1 - DjVu file - full path
	# $2 - targetdir - full path
	local FILE="${1##*/}"
	pushd "${2}"
	case "${DSED}" in
		yes|all) local EXPORT="output-all"
		;;
		txt) local EXPORT="output-txt"
		;;
		ant) local EXPORT="output-ant"
		;;
		no) return 0
		;;
	esac
	if [ "${DSED}" != "no" ] ; then
		local TARGET="${FILE/.djvu/.dsed}"
		if [ -f "${TARGET}" ] ; then
			if [ "${FORCE}" == "yes" ] ; then
				${DJVUSED} "${1}" -e "${EXPORT}" > "${TARGET}"
			elif [ "${FORCE}" == "skip" ] ; then
				log 1 "exportdsedbundle: Soubor ${TARGET} již v adresáři ${3} existuje."
			else
				echo "exportdsedbundle: Soubor ${TARGET} již v adresáři ${3} existuje.." >> /dev/stderr
				potvrdit && ${DJVUSED} "${1}" -e "${EXPORT}" > "${TARGET}"
			fi
		else
			${DJVUSED} "${1}" -e "${EXPORT}" > "${TARGET}"
		fi
	fi
	popd
}

function exportxmlbundle {
	# $1 - DjVu file - full path
	# $2 - targetdir - full path
	local FILE="${1##*/}"
	pushd "${2}"
	case "${XML}" in
		yes|all) local EXPORT="--with-text --with-anno"
		;;
		txt) local EXPORT="--with-text --without-anno"
		;;
		ant) local EXPORT="--without-text --with-anno"
		;;
		no) return 0
		;;
	esac
	if [ "${XML}" != "no" ] ; then
		local TARGET="${FILE/.djvu/.xml}"
		if [ -f "${TARGET}" ] ; then
			if [ "${FORCE}" == "yes" ] ; then
				${DJVUTOXML} "${1}" "${TARGET}"
			elif [ "${FORCE}" == "skip" ] ; then
				log 1 "exportxmlbundle: Soubor ${TARGET} již v adresáři ${3} existuje."
			else
				echo "exportxmlbundle: Soubor ${TARGET} již v adresáři ${3} existuje.." >> /dev/stderr
				potvrdit && ${DJVUTOXML} "${1}" "${TARGET}"
			fi
		else
			${DJVUTOXML} "${1}" "${TARGET}"
		fi
	fi
	popd
}

function exportimgpage {
	# $1 - DjVu file - full path
	# $2 - identificator - page name
	# $3 - targetdir - full path
	pushd "${3}"
	case "${IMG}" in
		yes) local EXPORT="-mode=color"
		;;
		color|black|foreground|background|mask) local EXPORT="-mode=${IMG}"
		;;
		no) return 0
		;;
	esac
	if [ "${IMG}" != "no" ] ; then
		local PAGE=$(identifypage "${1}" "${2}")
		local TARGET="${2/.djvu/.png}"
		if [ -f "${TARGET}" ] ; then
			if [ "${FORCE}" == "yes" ] ; then
				${DDJVU} -format=pnm "${EXPORT}" -page="${PAGE}" "${1}" | ${PNMTOPNG} > "${TARGET}"
			elif [ "${FORCE}" == "skip" ] ; then
				log 1 "exportimgpage: Soubor ${TARGET} již v adresáři ${3} existuje."
			else
				echo "exportimgpage: Soubor ${TARGET} již v adresáři ${3} existuje.." >> /dev/stderr
				potvrdit && ${DDJVU} -format=pnm "${EXPORT}" -page="${PAGE}" "${1}" | ${PNMTOPNG} > "${TARGET}"
			fi
		else
			${DDJVU} -format=pnm "${EXPORT}" -page="${PAGE}" "${1}" | ${PNMTOPNG} > "${TARGET}"
		fi
	fi
	popd
}

function exportxmlpage {
	# $1 - DjVu file - full path
	# $2 - identificator - page name
	# $3 - targetdir - full path
	pushd "${3}"
	case "${XML}" in
		yes|all) local EXPORT="--with-text --with-anno"
		;;
		txt) local EXPORT="--with-text --without-anno"
		;;
		ant) local EXPORT="--without-text --with-anno"
		;;
		no) return 0
		;;
	esac
	if [ "${XML}" != "no" ] ; then
		local PAGE=$(identifypage "${1}" "${2}")
		local TARGET="${2/.djvu/.xml}"
		if [ -f "${TARGET}" ] ; then
			if [ "${FORCE}" == "yes" ] ; then
				${DJVUTOXML} --page "${PAGE}" ${EXPORT} "${1}" "${TARGET}"
			elif [ "${FORCE}" == "skip" ] ; then
				log 1 "Soubor ${TARGET} již v adresáři ${3} existuje."
			else
				echo "Soubor ${TARGET} již v adresáři ${3} existuje.." >> /dev/stderr
				potvrdit && ${DJVUTOXML} --page "${PAGE}" ${EXPORT} "${1}" "${TARGET}"
			fi
		else
			${DJVUTOXML} --page "${PAGE}" ${EXPORT} "${1}" "${TARGET}"
		fi
	fi
	popd
}

function importmetapage {
	# $1 - soubor se stránkou
	# $2 - identifikátor stránky
	# $3 - soubor s meta atributy
	echo "importmetapage: Importuji meta atributy do jedné stránky" >> /dev/stderr
	${DJVUSED} "${1}" -e "select '${2}'; set-meta ${3}; save"
}

function importmetaall {
	# $1 - soubor se stránkou
	# $2 - soubor s meta atributy
	echo "importmetaall: Importuji meta atributy pro celý svazek" >> /dev/stderr
	${DJVUSED} "${1}" -e "select; set-meta ${2}; save"
}

function encode {
	# Funkce průběžně konvertuje unicode znaky do číselné podoby
	while read -n 1 a
	do
	CHAR=($( echo "$a" | od -A n -t c ))
	if [ "${#CHAR[@]}" -gt "2" ] ; then 
		echo -n "\\${CHAR[0]}\\${CHAR[1]}"
	elif [ "${#CHAR[@]}" == "1" ] ; then 
		echo -n " "
	else
		if [ "${#CHAR[0]}" == "0" ] ; then
			echo -n " "
		else
			echo -n "${CHAR[0]}"
		fi
	fi
	done
}

function dsedtooutline {
	local TARGET="$1"
	local BEGIN=""
	local TAB=0
	${DJVUSED} "${1}" -e 'print-outline' | sed -n '
	s|(|\n(\n|g
	s|)|\n)\n|g
	s|\\|\\\\0|g
	p
	' |	while read y
	do
		case "$y" in
			\)) local TAB=$((TAB - 1))
			;;
			\() local TAB=$((TAB + 1))
			;;
			\"*) if [ "${BEGIN}" == "" ] ; then
					local TEXT="$y"
					local BEGIN="yes"
				else
					for i in $(seq $((TAB-2))) ; do echo -en '\t' ; done
					echo -e "${TEXT} ${y}"
					local BEGIN=""
				fi
			;;
		esac
	done
}

function outlinetodsed {
	# $1 - temporary .outline file with TAB syntax
	# Output is txt stream
	local TARGET="$1"
	# Remove comment from .outline file
	sed --in-place '/^#/d' "${TARGET}"
	[ $(grep -c ^ "${TARGET}") -eq "0" ] && return 1
	local LEVEL="1"
	IFS=''
	echo -n "(bookmarks "
	CONTENT=$(sed '
		s/\ \ \ \ /\t/g
		s/^/\t/
		' "${TARGET}" | while read line ; do
		local SPACE="${line%%\"*}"
		if [ "${#SPACE}" -gt "${LEVEL}" ] ; then
			local PREV="${PREV%)} ( ${line} )"
			local LEVEL=$((${LEVEL} + 1))
		elif [ "${#SPACE}" -eq "${LEVEL}" ] ; then
			local PREV="${PREV} ( ${line} )"
		elif [ "${#SPACE}" -lt "${LEVEL}" ] ; then
			local ROZDIL=$((${LEVEL} - ${#SPACE}))
			local ZAV=$(seq  -f "%1.0f" -s '' ${ROZDIL})
			local PREV="${PREV} ${ZAV//[[:digit:]]/)} ( $line )"
			local LEVEL=$((${LEVEL} - ${ROZDIL}))
		fi
		echo "${PREV}"
		echo "-----${LEVEL}"
	done | sed 's/\t/\ /g' | tail -2)
	TEST="${CONTENT##*-----}"
	echo -n "${CONTENT%-----*}"
	local ZAV=$(seq  -f "%1.0f" -s '' ${TEST})
	echo "${ZAV//[[:digit:]]/)}"
	return 0
}


function importdsedall {
	case "${DSED}" in
		# Vytvořit dočasný soubor s následující hlavičkou...
		# -e "select '${2}'; remove-ant; remove-txt"
		# -------------------------
		# time awk '/^set-ant$/{flag=1;next} ; /^.$/{flag=0}; flag' vysledek.dsed 
		all|yes) # nejprve ant, pak text..
		${DJVUSED} "${1}" -f "${2}" -s
		;;
		no)
		;;
	esac
}

function importdsedpage {
	# $1 - DjVu file - full path
	# $2 - identificator - page name
	# $3 - source DSED file - full path
	case "${DSED}" in
		# Vytvořit dočasný soubor s následující hlavičkou...
		# -e "select '${2}'; remove-ant; remove-txt"
		# -------------------------
		# time awk '/^set-ant$/{flag=1;next} ; /^.$/{flag=0}; flag' vysledek.dsed 
		all|yes) awk '/^set-ant$/{flag=1;next} ; /^.$/{flag=0}; flag' "${3}" > ${TEMPDIR}/${2}.ant
			${DJVUSED} "${1}" -e "select '${2}'; set-ant ${TEMPDIR}/${2}.ant ; save"
			awk '/^set-txt$/{flag=1;next} ; /^.$/{flag=0}; flag' "${3}" > ${TEMPDIR}/${2}.txt
			${DJVUSED} "${1}" -e "select '${2}'; set-txt ${TEMPDIR}/${2}.txt ; save"
		;;
		ant) awk '/^set-ant$/{flag=1;next} ; /^.$/{flag=0}; flag' "${3}" > ${TEMPDIR}/${2}.ant
			${DJVUSED} "${1}" -e "select '${2}'; set-ant ${TEMPDIR}/${2}.ant ; save"
		;;
		txt) awk '/^set-txt$/{flag=1;next} ; /^.$/{flag=0}; flag' "${3}" > ${TEMPDIR}/${2}.txt
			${DJVUSED} "${1}" -e "select '${2}'; set-txt ${TEMPDIR}/${2}.txt ; save"
		;;
		no) echo "K importu textových dat ze souboru ${3} se přistoupí pouze bude-li uvedena volba -d" >> /dev/stderr
		;;
	esac
}

function importmeta {
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .meta)
	local FROM=$(${REALPATH} -m -P "${2}")
	local FROMFILE="${FROM##*/}"
	grep '^#' "${FROM}" | while read line ; do
		echo "$line" >> /dev/stderr
		local NAMEPAGE=( $line )
		case "${#NAMEPAGE[@]}" in
			2) local PAGENAME=$(identifyname "${SOURCE}" "${NAMEPAGE[1]//\'/}")
				if [ -z "${PAGENAME}" ] ; then
					echo "importmeta: FAIL - for ${FILE} is identificator ${NAMEPAGE[1]} not valid" >> /dev/stderr
				else
					awk "/.\ '${PAGENAME}'$/{flag=1;next} ; /^.$/{flag=0}; flag" "${FROM}" > ${TEMPFILE}
					${DJVUSED} "${1}" -e "select ${PAGENAME}; set-meta ${TEMPFILE}" -s
				fi
			;;
			1) if [ "${NAMEPAGE[0]}" == "#" ] ; then
					awk "/^#$/{flag=1;next} ; /^.$/{flag=0}; flag" "${FROM}" > ${TEMPFILE}
					${DJVUSED} "${1}" -e "select ; set-meta ${TEMPFILE}" -s
				else
					local PAGENAME=$(identifyname "${SOURCE}" "${NAMEPAGE[0]:1}")
					if [ -z "${PAGENAME}" ] ; then
						echo "importmeta: FAIL - for ${FILE} is identificator ${NAMEPAGE[0]:1} not valid" >> /dev/stderr
					else
						awk "/^#${NAMEPAGE[0]:1}$/{flag=1;next} ; /^.$/{flag=0}; flag" "${FROM}" > ${TEMPFILE}
						${DJVUSED} "${1}" -e "select ${PAGENAME}; set-meta ${TEMPFILE}" -s
					fi
				fi
			;;
		esac
	done
}

function importmeta1 {
	# $1 - DjVu file - full path
	# $2 - identificator - page name
	# $3 - source DSED file - full path
	if [ -f "${2}" ] ; then
		if [ "${3}" ] ; then
			local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .meta)
			# Zpracování gobálních metadat
			awk '/^# select '${i}'$/{flag=1;next} ; /^.$/{flag=0}; flag' "${2}" > ${TEMPFILE}
			${DJVUSED} "${1}" -e "select ${3}; set-meta ${TEMPFILE}" -s
		else
			for i in $(seq $(lastpage ${1})) ; do
				awk '/^# select '${i}'$/{flag=1;next} ; /^.$/{flag=0}; flag' "${2}" > ${TEMPFILE}
				if [ "${TEMPFILE}" ] ; then
					${DJVUSED} "${1}" -e "select ${i}; set-meta ${TEMPFILE}" -s
				fi
			done
		fi
	else
		importmeta "${1}" "${3}" 
	fi
}

function importoutline {
	# Import outline in dsed format
	${DJVUSED}  "${1}" -e "set-outline ${2}" -s
}

function importxmlpage {
	# $1 - DjVu file - full path
	# $2 - source XML file - full path
	# INFO: XML file has name of target page in self.
	case "${XML}" in
		no) echo "K importu textových dat ze souboru ${2} se přistoupí pouze bude-li uvedena volba -x" >> /dev/stderr
		;;
		*) ${DJVUXMLPARSER} -o "${1}" "${2}"
		;;
	esac
}

# TODO - meta - Nepoužitá funkce
function exportmetabundle {
	# $1 - DjVu file - full path
	# $2 - targetdir - full path
	local FILE="${1##*/}"
	pushd "${2}"
	if [ "${META}" != "no" ] ; then
		local TARGET="${FILE/.djvu/.meta}"
		if [ -f "${TARGET}" ] ; then
			if [ "${FORCE}" == "yes" ] ; then
				${DJVUSED} "${1}" -e "print-meta" > "${TARGET}"
			elif [ "${FORCE}" == "skip" ] ; then
				log 1 "Soubor ${TARGET} již v adresáři ${2} existuje."
			else
				echo "Soubor ${TARGET} již v adresáři ${2} existuje.." >> /dev/stderr
				potvrdit && ${DJVUSED} "${1}" -e "print-meta" > "${TARGET}"
			fi
		else
			${DJVUSED} "${1}" -e "print-meta" > "${TARGET}"
		fi
	fi
	popd
}

# TODO - meta - Nepoužitá funkce
function exportmetapage {
	# $1 - DjVu file - full path
	# $2 - identificator - page name
	# $3 - targetdir - full path
	pushd "${3}"
	if [ "${META}" != "no" ] ; then
		local TARGET="${2/.djvu/.meta}"
		if [ -f "${TARGET}" ] ; then
			if [ "${FORCE}" == "yes" ] ; then
				${DJVUSED} "${1}" -e "select '${2}'; print-meta" > "${TARGET}"
			elif [ "${FORCE}" == "skip" ] ; then
				log 1 "Soubor ${TARGET} již v adresáři ${3} existuje."
			else
				echo "Soubor ${TARGET} již v adresáři ${3} existuje.." >> /dev/stderr
				potvrdit && ${DJVUSED} "${1}" -e "select '${2}'; print-meta" > "${TARGET}"
			fi
		else
			${DJVUSED} "${1}" -e "select '${2}'; print-meta" > "${TARGET}"
		fi
	fi
	popd
}

function exportdsedpage {
	# $1 - DjVu file - full path
	# $2 - identificator - page name
	# $3 - targetdir - full path
	pushd "${3}"
	case "${DSED}" in
		yes|all) local EXPORT="output-all"
		;;
		txt) local EXPORT="output-txt"
		;;
		ant) local EXPORT="output-ant"
		;;
		no) return 0
		;;
	esac
	if [ "${DSED}" != "no" ] ; then
		local TARGET="${2/.djvu/.dsed}"
		if [ -f "${TARGET}" ] ; then
			if [ "${FORCE}" == "yes" ] ; then
				${DJVUSED} "${1}" -e "select '${2}'; ${EXPORT}" > "${TARGET}"
			elif [ "${FORCE}" == "skip" ] ; then
				log 1 "Soubor ${TARGET} již v adresáři ${3} existuje."
			else
				echo "Soubor ${TARGET} již v adresáři ${3} existuje.." >> /dev/stderr
				potvrdit && ${DJVUSED} "${1}" -e "select '${2}'; ${EXPORT}" > "${TARGET}"
			fi
		else
			${DJVUSED} "${1}" -e "select '${2}'; ${EXPORT}" > "${TARGET}"
		fi
	fi
	popd
}

function exportdjvupage {
	# $1 - DjVu file - full path
	# $2 - identificator - page name
	# $3 - targetdir - full path
	log 1 "exportdjvupage: -${1}- -${2}- ${3}"
	pushd "${3}"
	if [ "${PAGE}" == "yes" ] ; then
		if [ -f "${2}" ] ; then
			if [ "${FORCE}" == "yes" ] ; then
				${DJVUSED} -e "select '${2}'; save-page-with '${2}'" "${1}"
			elif [ "${FORCE}" == "skip" ] ; then
				log 1 "Soubor ${2} již v adresáři ${3} existuje."
			else
				echo "Soubor ${2} již v adresáři ${3} existuje.." >> /dev/stderr
				potvrdit && ${DJVUSED} -e "select '${2}'; save-page-with '${2}'" "${1}"
			fi
		else
			${DJVUSED} -e "select '${2}'; save-page-with '${2}'" "${1}"
		fi
	fi
	popd
}

function getocr {
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	if [ "${OCR}" ] ; then
		${OCRODJVU} --in-place -l "${OCR}" "${SOURCE}"
		[ "$?" ] && log 1 "getocr: OCR was applicated on ${FILE}" 
	fi
}

function testfile {
	# Function return type file by MIME
	# $1 - file
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	if [ -f "${SOURCE}" ] ; then
		local TYPE=$(${MIME} -dbM "${SOURCE}" | awk '{print $1}')
	else
		log 1 "testfile: File ${1} is NOT valid."
		exit 1
	fi
	echo "${TYPE,,}"
}

function targetdir {
	# Function return path into existing directory
	# $1 - path
	if [ -z "${1}" ] ; then
		log 1 "targetdir: NOT PATH"
		exit 1
	else
		local TARGETDIR=$(${REALPATH} -m -P "${1}")
		if [ -d "${TARGETDIR}" ] ; then
			echo -n "${TARGETDIR}"
		else
			mkdir -p "${TARGETDIR}"
			if [ $? -gt "0" ] ; then
				log 1 "targetdir: Could not create target directory ${TARGETDIR}"
				exit 1
			else
				echo -n "${TARGETDIR}"
			fi
		fi
	fi
}

function identifybundle {
	# Function testing DjVu file if is (0) or not (1) bundle
	# $1 - DjVu file
	# WARNING: Use ${DJVUDUMP} is necessary!
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	if [ -z "${SOURCE}" ] ; then
		log 1 "identifybundle: Path ${1} is not valid."
		exit 1
	else
		if [ $(testfile "${SOURCE}") == "djvu" ] ; then
			local TEST=$(${DJVUDUMP} "${SOURCE}" | grep '^\([[:blank:]]*\)DIRM')
			if [ "${TEST}" == "" ] ; then
				log 1 "identifybundle: ${FILE} is DjVu file"
				return 0
			else
				log 1 "identifybundle: ${FILE} is DjVu bundle"
				return 1
			fi
		else
			log 1 "identifybundle: File ${FILE} is NOT DjVu file."
			exit 1
		fi
	fi
}

function comparedjvu {
	#  Function do test two DjVu files and return (0) if is not any page in conflict or (1)
	# $1 - Djvu full path
	# $2 - Djvu full path
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	local FROMPATH=$(${REALPATH} -m -P "${2}")
	local FROM="${FROMPATH##*/}"
	${DJVUSED} "${SOURCE}" -e dump | grep FORM:DJVU | awk -F'[{}]' '{print $2}' | while read x ; do
		${DJVUSED} "${FROMPATH}" -e dump | grep FORM:DJVU | awk -F'[{}]' '{print $2}' | while read y ; do
			if [ "${x}" == "${y}" ] ; then
				echo "comparedjvu: WARNING Page with name ${x} from file ${FILE} is in ${FROM} too." >> /dev/stderr
				break
			fi
		done
	done
	potvrdit && return 0 || return 1
}

function convertimg {
	# Function for splitting multilayer image format
	# $1 Image in multilayer format (tiff, mng or xcf (gimp)
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	if [ "${2}" ] ; then 
		#cíl bude jinde...
		local TOPATH=$(${REALPATH} -m -P "${2}")
	else
		#cíl bude v adresáři kde jsem teď..
		local TOPATH=$(pwd "${SOURCE}")
	fi
	if [ -d "${TOPATH}/${FILE%.*}" ] ; then
		echo "convertimg: WARNING Dir ${TOPATH}/${FILE%.*} exists. Do rewrite files?" >> /dev/stderr
		potvrdit || return 1
	else
		mkdir "${TOPATH}/${FILE%.*}"
	fi
	convert "${SOURCE}" "${TOPATH}/${FILE%.*}/${FILE%.*}.png"
	pushd "${TOPATH}/${FILE%.*}"
		for i in $(ls -cr -1 *.png) ; do
			filetodjvu "${i}" "${i/.png/.djvu}"
		done
	popd
}

function identifyname {
	# Function return NAME of DjVu page in DjVu bundle
	# $1 DjVu Bundle
	# $2 Page identificator (order or name)
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	local IDENTIFICATOR="${2##+([[:blank:]])}"
	if [ "${IDENTIFICATOR//+([[:digit:]])}" == "" ] ; then
#		log 1 "identifyname: What is name of page on position ${IDENTIFICATOR} in DjVu file ${FILE}?"
		local SEARCH="\[P${IDENTIFICATOR}\]"
	else
#		log 1 "identifyname: Is page with name ${IDENTIFICATOR} in DjVu file ${FILE}?"
		local SEARCH="\{${IDENTIFICATOR}\}"
	fi
	local OUTPUT=$(${DJVUSED} "${SOURCE}" -e dump | grep FORM:DJVU | grep "${SEARCH}" | awk -F'[{}]' '{print $2}')
	if [ -z "${OUTPUT}" ] ; then
		printf "identifyname: FAIL - for DjVu bundle %s identificator %s is NOT VALID.\n" "${FILE}" "${IDENTIFICATOR}" >> ${LOG}
		return 0
	else
		printf "identifyname: OK - name page is %s\n" "${OUTPUT}" >> ${LOG}
		echo -n "${OUTPUT}"
	fi
}

function identifypage {
	# Function return DjVu page actual ORDER in DjVu bundle
	# $1 DjVu Bundle
	# $2 Page identificator (order or name)
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	local IDENTIFICATOR="${2##+([[:blank:]])}"
	if [ "${IDENTIFICATOR//+([[:digit:]])}" == "" ] ; then
#		log 1 "identifypage: Has DjVu file ${FILE} page on position ${IDENTIFICATOR}?"
		local SEARCH="\[P${IDENTIFICATOR}\]"
	else
#		log 1 "identifypage: Has DjVu file ${FILE} page with name ${IDENTIFICATOR}?"
		local SEARCH="\{${IDENTIFICATOR}\}"
	fi
#	echo "${SEARCH}" >> /dev/stderr
	local OUTPUT=$(${DJVUSED} "${SOURCE}" -e dump | grep FORM:DJVU | grep "${SEARCH}" | awk -F'[{}]' '{print $3}')
#	echo "${OUTPUT}" >> /dev/stderr
#	echo "${KEY}" >> /dev/stderr
	if [ -z "${OUTPUT}" ] ; then
		printf "identifypage: FAIL - for DjVu bundle %s identificator %s is NOT VALID.\n" "${FILE}" "${IDENTIFICATOR}" >> ${LOG}
		return 0
	else
		local ORDER="${OUTPUT//+([\]P\[ ])/}"
		log 1 "identifypage: OK order page is %s.\n" "${ORDER}" >> ${LOG}
		echo -n "${ORDER}"
	fi
}

function lastpage {
	# Function return count of all pages in DjVu bundle
	# $1 DjVu file
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	[ "$(testfile ${SOURCE})" == "djvu" ] || exit 1
	log 1 "lastpage: Count of all pages in ${FILE}"
	local OUTPUT=$(${DJVUSED} "${SOURCE}" -e n)
	echo -n "${OUTPUT}"
	
}

function deletepage {
	# $1 - soubor se kterým se pracuje
	# $2 - číslo, nebo název strany co se má odstranit
	local FILE="${1##*/}"
	if $(identifybundle "${1}") ; then
		echo "Soubor ${FILE} je typu single-page"
		return 1
	else
		local PAGE=$(identifypage "${1}" "${2}")
		if [ ! -z "${PAGE}" ] ; then
			${DJVM} -d "${1}" "${PAGE}"
		else
			return 2
		fi
	fi
}

function djvurotate {
	# $1 - soubor se kterým se pracuje
	# $2 - číslo, nebo název strany která se má rotovat
	# $3 - hodnota rotace
#	echo "$*" >> /dev/stderr
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	local INFO="""
Uvedenou hodnotu rotace nelze akceptovat. Rotaci lze nastavit buď 
absolutně, a nebo relativně (pootočit o 90°). AKceptované hodnoty:

      0 - výchozí pozice
      1 - natočení vpravo
      2 - otočení  vzhůru nohama
      3 - natočení vlevo
   left - rotace směrem doleva
  right - rotace směrem doprava).
    180 - přetočení o 180°

Každá jiná hodnota parametru je ignorována."""
	local PARAMS=($2)
	if [ "${#PARAMS[@]}" -gt "1" ] ; then
		case "${PARAMS[$((${#PARAMS[@]} -1))]}" in
			0|1|2|3|180|left|right) # echo "Jak mám otáčet $1" >> /dev/stderr
				local ROTATE="${PARAMS[$((${#PARAMS[@]} -1))]}"
#				echo "rotate: před ořezáním -$2-"
				local TEMP="${2% ${ROTATE}}"
				local IDPAGE=${TEMP##+([[:blank:]])}
#				echo "rotate: po ořezání -${IDPAGE}-"
			;;
			*) printf "%s - is not valid rotate VALUE" "${2}" >> /dev/stderr
				exit 1
			;;
		esac
	else
		case "${PARAMS}" in
			0|1|2|3|180|left|right) local ROTATE="${PARAMS}"
			;;
			*) printf "%s - is not valid rotate VALUE" "${PARAMS}" >> /dev/stderr
				exit 1
			;;
		esac
	fi

	if $(identifybundle "${1}") ; then
		if [ -z "${IDPAGE}" ] ; then
			case "${ROTATE}" in
				0|1|2|3)  ${DJVUSED} -e "set-rotation ${ROTATE}; save" "${SOURCE}"
				;;
				left) ${DJVUSED} -e "set-rotation +1; save" "${SOURCE}"
				;;
				right) ${DJVUSED} -e "set-rotation -1; save" "${SOURCE}"
				;;
				180) ${DJVUSED} -e "set-rotation +2; save" "${SOURCE}"
				;;
				*) echo "${INFO}" >> /dev/stderr
				;;
			esac
		else
			printf "DjVu file is single page. Param %s is non sense, continue in rotate?" "${IDPAGE}" >> /dev/stderr
			if $(potvrdit) ; then
				case "${ROTATE}" in
					0|1|2|3)  ${DJVUSED} -e "set-rotation ${ROTATE}; save" "${SOURCE}"
					;;
					left) ${DJVUSED} -e "set-rotation +1; save" "${SOURCE}"
					;;
					right) ${DJVUSED} -e "set-rotation -1; save" "${SOURCE}"
					;;
					180) ${DJVUSED} -e "set-rotation +2; save" "${SOURCE}"
					;;
					*) echo "${INFO}" >> /dev/stderr
					;;
				esac
			else
				exit 0
			fi
		fi
	else
		if [ -z "${IDPAGE}" ] ; then
			echo "Warning: If you want c a global orientation of pages Při globálním natočení stránek dokumentu dávejte pozor, zda-li nastavujete absolutní hodnotu natočení, nebo, zda-li otáčíte stránky relativně (left/right). Při točení se upravuje natočení všech stránek. Buďte tedy při této operaci opatrní a raději si předem zkontrolujte, zda-li tím neovlivníte i některou ze stránek. Pokud ano, pak zvolte buť relativní parametr natočení, nebo ji pak otočte do správné pozice dodatečně."
			if $(potvrdit) ; then
				case "${ROTATE}" in
					0|1|2|3)  ${DJVUSED} -e "set-rotation ${ROTATE}; save" "${SOURCE}"
					;;
					left) ${DJVUSED} -e "set-rotation +1; save" "${SOURCE}"
					;;
					right) ${DJVUSED} -e "set-rotation -1; save" "${SOURCE}"
					;;
					180) ${DJVUSED} -e "set-rotation +2; save" "${SOURCE}"
					;;
					*) echo "${INFO}" >> /dev/stderr
					;;
				esac
			else
				exit 0
			fi
		else
#			echo "Je třeba provést identifikaci stránky ${IDPAGE}"
			local NAMEPAGE=$(identifyname "${1}" "${IDPAGE}")
			if [ -z "${NAMEPAGE}" ] ; then
				printf "Page %s is not valid for file %s" "${IDPAGE}" "${FILE}" >> /dev/stderr
				exit 1
			else
				printf "Change orientation page %s in %s by %s" "${NAMEPAGE}" "${FILE}" "${ROTATE}" >> ${LOG}
				case "${ROTATE}" in
					0|1|2|3)  ${DJVUSED} -e "select '${NAMEPAGE}'; set-rotation ${ROTATE}; save" "${SOURCE}"
					;;
					left) ${DJVUSED} -e "select '${NAMEPAGE}'; set-rotation +1; save" "${SOURCE}"
					;;
					right) ${DJVUSED} -e "select '${NAMEPAGE}'; set-rotation -1; save" "${SOURCE}"
					;;
					180) ${DJVUSED} -e "select '${NAMEPAGE}'; set-rotation +2; save" "${SOURCE}"
					;;
					*) echo "${INFO}" >> /dev/stderr
					;;
			esac
			fi
		fi
	fi
}

function djvumove {
	# $1 - DjVu file
	# $2 - Parametry
	#	zdroj : identifikátor pozice
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"

	local VSTUP="${2}"
	local COUNT=${#VSTUP}
	local POS=0
	local START=0
	while [ $POS -lt $COUNT ]
	do local POS=$((POS+1))
#		echo "${VSTUP:$START:$POS}" >> /dev/stderr
		case "${VSTUP:$START:$POS}" in
			*.[dD][jJ][vV][uU]|*.[gG][iI][fF]|*.[jJ][pP][gG]|*.[mM][nN][gG]|*.[pP][dD][fF]|*.[pP][nN][gG]|*.[pP][nN][mM]|*.[tT][iI][fF][fF]|*.[xX][cC][fF]) 
				local SOUBOR="${VSTUP:0:$POS}"
				log 1 "move: Zachycen soubor $SOUBOR - ${SOUBOR:$((${#SOUBOR} - 4)):4}"
				if [ "${SOUBOR:$((${#SOUBOR} - 4)):4}" == "djvu" ] ; then
#					echo "Před testem.. '${SOUBOR##+([[:blank:]])}'" >> /dev/stderr
					local TESTORDER=$(identifypage "${SOURCE}" "${SOUBOR##+([[:blank:]])}")
#					echo "Po testu.." >> /dev/stderr
					if [ -z "${TESTORDER}" ] ; then
						if [ -f "${SOUBOR}" ] ; then
							local FROM="${SOUBOR}"
							local VSTUP="${VSTUP#${SOUBOR} }"
							local COUNT=${#VSTUP}
							local POS=0
							echo "move: OK - jde o DjVu soubor ${SOUBOR} co se má vložit" >> /dev/stderr
							local ANAME="${SOUBOR}"
							##### Ve zbytku musí být identifikátor
							# ....
#							echo "Insert djvu file yet not implemented!!!" >> /dev/stderr
#							return 0
						else
							local TEST=( ${SOUBOR} )
							if [ "${#TEST}" -gt "0" ] ; then
								local A="${TEST[0]}"
								if [ "${A%%+([[:digit:]])}" == "" ] ; then
									local BTEST="${SOUBOR##${A}+([[:blank:]])}"
									local B=$(identifypage "${SOURCE}" "${BTEST}")
									if [ -z "${B}" ] ; then
										echo "move: FAIL - for DjVu file ${FILE} identificator target page ${BTEST} is not valid." >> /dev/stderr
										exit 1
									else
										#FINITO### tady budu realizovat přesun...?
										local ANAME=$(identifyname "${SOURCE}" "${A}")
										local BNAME=$(identifyname "${SOURCE}" "${B}")
										if [ "${ANAME}" == "${BNAME}" ] ; then
											echo "move: FAIL - If you want move page on position ${A}, which is the same page as target. If you want moved page from position ${2} before actual position, use command without identification of target position." >> /dev/stderr
											exit 1
										fi
										if [ "${MOVE}" == "fore" ] ; then
											if [ "$A" == "1" ] ; then
												echo "move: INFO - page ${ANAME} is on first position in ${FILE}." >> /dev/stderr
												return 1
											elif [ "$A" == "$((${B} - 1))" ] ; then
												echo "move: INFO - page ${ANAME} is on previous position (${A}) in ${FILE} before page ${BNAME} (position ${B})." >> /dev/stderr
												return 1
											else
												PAGE="yes"
												exportdjvupage "${SOURCE}" "${ANAME}" "${TEMPDIR}"
												deletepage "${SOURCE}" "${ANAME}"
												if [ "${A}" -gt "${B}" ] ; then
													${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "${B}"
												else
													${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "$((${B} - 1))"
												fi
												return 0
											fi
										elif [ "${MOVE}" == "back" ] ; then
											local TEST=$(lastpage "${1}")
											if [ "$A" == "${TEST}" ] ; then
												echo "move: INFO - page ${ANAME} is on last position in ${FILE}." >> /dev/stderr
												return 1
											elif [ "$A" == "$((${B} + 1))" ] ; then
												echo "move: INFO - page ${ANAME} is on next position in ${FILE} after page ${BNAME}." >> /dev/stderr
												return 0
											else
												PAGE="yes"
												exportdjvupage "${SOURCE}" "${ANAME}" "${TEMPDIR}"
												deletepage "${SOURCE}" "${ANAME}"
												if [ "${A}" -lt "${B}" ] ; then
													${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "${B}"
												else
													${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "$((${B} - 1))"
												fi
												return 0
											fi
										else
											echo "move: Nedělám nic" >> /dev/stderr
										fi
									fi
								else
									echo "move: FAIL - identificator '${SOUBOR##+([[:blank:]])}' for file ${FILE} is not valid. Pay attention to the gap - are treacherous!" >> /dev/stderr
									exit 1
								fi
							else
								echo "move: S názvem souboru není něco v pořádku" >> /dev/stderr
							fi
						fi
					else
						if [ -z "${ANAME}" ] ; then
							# Nenastavené ANAME 
							local ANAME="${SOUBOR}"
							local A="${TESTORDER}"
							local VSTUP="${VSTUP#${SOUBOR}}"
							if [ "${VSTUP##+([[:blank:]])}" == "" ] ; then
								#FINITO### tady budu realizovat přesun...?
								if [ "${MOVE}" == "fore" ] ; then
									if [ "$A" == "1" ] ; then
										echo "move: INFO - page ${ANAME} is on first position in ${FILE}." >> /dev/stderr
										return 1
									else
										PAGE="yes"
										exportdjvupage "${SOURCE}" "${ANAME}" "${TEMPDIR}"
										deletepage "${SOURCE}" "${ANAME}"
										${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "$((${A} - 1))"
										return 0
									fi
								elif [ "${MOVE}" == "back" ] ; then
									local TEST=$(lastpage "${1}")
									if [ "$A" == "${TEST}" ] ; then
										echo "move: INFO - page ${ANAME} is on last position in ${FILE}." >> /dev/stderr
										return 1
									else
										PAGE="yes"
										exportdjvupage "${SOURCE}" "${ANAME}" "${TEMPDIR}"
										deletepage "${SOURCE}" "${ANAME}"
										${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "$((${A}+1))"
										return 0
									fi
								else
									echo "move: Nedělám nic" >> /dev/stderr
								fi
							else
								local TEST="${VSTUP##+([[:blank:]])}"
								if [ "${TEST##+([[:digit:]])}" == "" ] ; then
#									# Pořadové číslo - budu přesouvat..
									local B=$(identifypage "${SOURCE}" "${TEST}")
									if [ -z "${B}" ] ; then
										echo "move: ERROR - target position is not valid for file ${FILE}" >> /dev/stderr
										exit 1
									else
										#FINITO## Budu přesouvat
										if [ "${A}" == "${B}" ] ; then
											echo "move: FAIL - If you want move page on position ${A}, which is the same page as target. If you want moved page from position ${2} before actual position, use command without identification of target position." >> /dev/stderr
											exit 1
										fi
										if [ "${MOVE}" == "fore" ] ; then
											if [ "${A}" == "$((${B} - 1))" ] ; then
												echo "move: INFO - page ${ANAME} is on previous position (${A}) in ${FILE} before page with position ${B}." >> /dev/stderr
												return 1
											else
												PAGE="yes"
												exportdjvupage "${SOURCE}" "${ANAME}" "${TEMPDIR}"
												deletepage "${SOURCE}" "${ANAME}"
												if [ "${A}" -gt "${B}" ] ; then
													${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "${B}"
												else
													${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "$((${B} - 1))"
												fi
												return 0
											fi
										elif [ "${MOVE}" == "back" ] ; then
											local TEST=$(lastpage "${SOURCE}")
											if [ "$A" == "${TEST}" ] ; then
												echo "move: INFO - page ${ANAME} is on last position in ${FILE}." >> /dev/stderr
												return 1
											elif [ "$A" == "$((${B} + 1))" ] ; then
												echo "move: INFO - page ${ANAME} is on next position in ${FILE} after page which is target (${B})." >> /dev/stderr
												return 0
											else
												PAGE="yes"
												exportdjvupage "${SOURCE}" "${ANAME}" "${TEMPDIR}"
												deletepage "${SOURCE}" "${ANAME}"
												if [ "${A}" -lt "${B}" ] ; then
													${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "${B}"
												else
													${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "$((${B} - 1))"
												fi
												return 0
											fi
										else
											echo "move: Nedělám nic" >> /dev/stderr
										fi
										return 0
									fi
								else
									local COUNT=${#VSTUP}
									local POS=0
									log 1 "move: INFO - page ${ANAME} has order ${A}. What is the identificator of target page from bundle -$VSTUP-?"
								fi
							fi
						elif [ "${ANAME}" == "none" ] ; then
#							# ANAME je none
							local B=$(identifypage "${1}" "${SOUBOR}")
							if [ -z "${B}" ] ; then
								echo "move: ERROR - Chybné jméno stránky před kterou se má stránka přesunout" >> /dev/stderr
								exit 1
							else
								local A=""
								local BNAME="${SOUBOR}"
								log 1 "move: Vkládá se konvertovaná stránka ${FROM} před stránu -${BNAME}- na pozici ${B}"
								break
							fi
						else
#							#FINITO### Budu přesouvat..
#							echo "move: ${A} ${TESTORDER}" >> /dev/stderr
							if [ "${A}" == "${TESTORDER}" ] ; then
								echo "move: FAIL - If yu want move page ${ANAME} in ${FILE} about one position. You must for it use action ${MOVE} only with identificator of page to move." >> /dev/stderr
								exit 1
							else
								local B=$(identifypage "${1}" "${SOUBOR}")
								if [ -z "${B}" ] ; then
									echo "move: FAIL - Chybné jméno stránky před kterou se má stránka přesunout" >> /dev/stderr
									exit 1
								else
									local A=$(identifypage "${1}" "${ANAME}")
									if [ -z "${A}" ] ; then
										echo "move: file ${ANAME} je djvu soubor?" >> /dev/stderr
#										exit 1
									else
										echo "move: ANAME je soubor ${ANAME}.." >> /dev/stderr
									local BNAME="${SOUBOR}"
#									#FINITO## Budu přesouvat ####
									if [ "${ANAME}" == "${BNAME}" ] ; then
										echo "move: FAIL - If you want move page on position ${A}, which is the same page as target. If you want moved page from position ${2} before actual position, use command without identification of target position." >> /dev/stderr
										exit 1
									fi
									if [ "${MOVE}" == "fore" ] ; then
										if [ "$A" == "1" ] ; then
											echo "move: INFO - page ${ANAME} is on first position in ${FILE}." >> /dev/stderr
											return 1
										elif [ "$A" == "$((${B} - 1))" ] ; then
											echo "move: INFO - page ${ANAME} is on previous position (${A}) in ${FILE} before page ${BNAME} (position ${B})." >> /dev/stderr
											return 1
										else
											PAGE="yes"
											exportdjvupage "${SOURCE}" "${ANAME}" "${TEMPDIR}"
											deletepage "${SOURCE}" "${ANAME}"
											if [ "${A}" -gt "${B}" ] ; then
												${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "${B}"
											else
												${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "$((${B} - 1))"
											fi
											return 0
										fi
									elif [ "${MOVE}" == "back" ] ; then
										local TEST=$(lastpage "${1}")
										if [ "$A" == "${TEST}" ] ; then
											echo "move: INFO - page ${ANAME} is on last position in ${FILE}." >> /dev/stderr
											return 1
										elif [ "$A" == "$((${B} + 1))" ] ; then
											echo "move: INFO - page ${ANAME} is on next position in ${FILE} after page ${BNAME}." >> /dev/stderr
											return 0
										else
											PAGE="yes"
											exportdjvupage "${SOURCE}" "${ANAME}" "${TEMPDIR}"
											deletepage "${SOURCE}" "${ANAME}"
											if [ "${A}" -lt "${B}" ] ; then
												${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "${B}"
											else
												${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "$((${B} - 1))"
											fi
											return 0
										fi
									else
										echo "move: Nedělám nic" >> /dev/stderr
									fi
									fi
								fi
							fi
						fi
					fi
				else
					if [ -f "${SOUBOR}" ] ; then
						local FROM="${SOUBOR}"
						##### KONVERZE #######
						local ANAME="none"
						local VSTUP="${VSTUP#${SOUBOR}}"
						local COUNT=${#VSTUP}
						local POS=0
						echo "move: INFO file ${SOUBOR} id not DjVu; must be converted" >> /dev/stderr
						local ANAME="${TEMPDIR}/${SOUBOR%.*}.djvu"
						filetodjvu "${SOUBOR}" "${ANAME}"
						if [ ! -f "${ANAME}" ] ; then
							echo "move: ERROR - file ${ANAME} not exists. Probably any problem with conversion." >> /dev/stderr
							exit 1
						fi
					else
						echo "move: ERROR - Soubor ${SOUBOR} neexistuje" >> /dev/stderr
						exit 1
					fi
				fi
			;;
		esac
	done

	if [ -f "${ANAME}" ] ; then
		echo "Sem to propadne je-li ANAME -${ANAME}- již existující soubor" >> /dev/stderr
		if [ -z "${BNAME}" ] ; then
			echo "move: Musím získat pozici ze zbytku ${VSTUP}" >> /dev/stderr
			local TEST="${VSTUP##+([[:blank:]])}"
			if [ "${TEST##+([[:blank:]])}" == "" ] ; then
				## Budu soubor připojovat na konec DjVu svazku...
				# Není třeba nic víc řešit...
				echo "Budu soubor připojovat na konec DjVu svazku. Není třeba řešit nic víc, nežli to zda není nějaká stránka v konfliktu.."
				if comparedjvu "${SOURCE}" "${ANAME}" ; then
					echo "move: APPEND - content of file ${ANAME} to ${MOVE} ${SOURCE}" >> /dev/stderr
					if [ "${MOVE}" == "fore" ] ; then
						${DJVM} -i "${SOURCE}" "${ANAME}" 1
					elif [ "${MOVE}" == "back" ] ; then
						${DJVM} -i "${SOURCE}" "${ANAME}"
					else
						echo "Nedělám nic" >> /dev/stderr
					fi
					return 0
				else
					echo "Stránka je v konfliktu" >> /dev/stderr
					exit 1
				fi
			else
				local B=$(identifypage "${SOURCE}" "${TEST}")
				if [ -z "${B}" ] ; then
					echo "move: identificator -${TEST} is not valid." >> /dev/stderr
					exit 1
				else
					echo "move: APPEND - content of file ${ANAME} to ${SOURCE} ${MOVE} page ${B}" >> /dev/stderr
					if comparedjvu "${SOURCE}" "${ANAME}" ; then
						if [ "${MOVE}" == "fore" ] ; then
							${DJVM} -i "${SOURCE}" "${ANAME}" "${B}"
						elif [ "${MOVE}" == "back" ] ; then
							${DJVM} -i "${SOURCE}" "${ANAME}" "$((${B} + 1))"
						else
							echo "Nedělám nic" >> /dev/stderr
						fi
						return 0
					else
						echo "Stránka je v konfliktu" >> /dev/stderr
						exit 1
					fi
				fi 
			fi
		fi
	else
		if [ -z "${ANAME}" ] ; then
			local TEST=( ${VSTUP} )
			if [ "${#TEST}" -gt "0" ] ; then
				local ANAME=$(identifyname "${SOURCE}" "${TEST[0]}")
				if [ -z "${ANAME}" ] ; then
					echo "move: FAIL - for DjVu file ${FILE} identificator ${TEST[0]} is not valid." >> /dev/stderr
					exit 1
				else
					if [ "${TEST[1]##+([[:blank:]])}" != "" ] ; then
						local BNAME=$(identifyname "${SOURCE}" "${TEST[1]}")
						if [ -z "${BNAME}" ] ; then
							echo "move: FAIL - for DjVu file ${FILE} identificator ${TEST[1]} is not validxxx." >> /dev/stderr
							exit 1
						else
							echo "move: INFO - page ${ANAME} has order ${A}. Do move ${MOVE} ${BNAME}." >> /dev/stderr
							### budu přesouvat stránku na pozici..
						fi
					else
						echo "move: page ${ANAME} move ${MOVE}" >> /dev/stderr
						### budu přesouvat stránku o jednu pozici..
					fi

				fi
			fi 
		fi
	fi

	echo "move - jsem za tim" >> /dev/stderr

	if [ -z "${BNAME}" ] ; then
		if [ -z "{ANAME}" ] ; then
			echo "move: Neplatná cílová stránka ${BNAME}, i stránka ${ANAME} která se má přesouvat" >> /dev/stderr
			exit 1
		else
			local TEST=( ${VSTUP} )
			if [ "${#TEST}" -gt "0" ] ; then
				local BNAME=$(identifyname "${SOURCE}" "${TEST[0]}")
				if [ -z "${BNAME}" ] ; then
					echo "move: FAIL - identificator ${TEST[0]} is not valid for DjVu file ${FILE}" >> /dev/stderr
					exit 1
				else
#					#FINITO## Zpracovávám přesun..
					if [ "${ANAME}" == "${BNAME}" ] ; then
						local A=$(identifypage "${SOURCE}" "${ANAME}")
						if [ "${MOVE}" == "fore" ] ; then
							if [ "$A" == "1" ] ; then
								echo "move: INFO - page ${ANAME} is on first position in ${FILE}." >> /dev/stderr
								return 1
							else
								PAGE="yes"
								exportdjvupage "${SOURCE}" "${ANAME}" "${TEMPDIR}"
								deletepage "${SOURCE}" "${ANAME}"
								${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "$((${A} - 1))"
								return 0
							fi
						elif [ "${MOVE}" == "back" ] ; then
							local TEST=$(lastpage "${1}")
							if [ "$A" == "${TEST}" ] ; then
								echo "move: INFO - page ${ANAME} is on last position in ${FILE}." >> /dev/stderr
								return 1
							else
								PAGE="yes"
								exportdjvupage "${SOURCE}" "${ANAME}" "${TEMPDIR}"
								deletepage "${SOURCE}" "${ANAME}"
								${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "$((${A}+1))"
								return 0
							fi
						else
							echo "move: Nedělám nic" >> /dev/stderr
						fi
					else
#						echo "move: INFO - move page -${ANAME}- -${A}- ${MORE} page -${BNAME}- -${B}-" >> /dev/stderr
#						#FINITO## Zpracovávám přesun..
						local B=$(identifypage "${SOURCE}" "${BNAME}")
						if [ "${ANAME}" == "${BNAME}" ] ; then
							echo "move: FAIL - If you want move page on position ${A}, which is the same page as target. If you want moved page from position ${2} before actual position, use command without identification of target position." >> /dev/stderr
							exit 1
						fi
						if [ "${MOVE}" == "fore" ] ; then
							if [ "$A" == "1" ] ; then
								echo "move: INFO - page ${ANAME} is on first position in ${FILE}." >> /dev/stderr
								return 1
							elif [ "$A" == "$((${B} - 1))" ] ; then
								echo "move: INFO - page ${ANAME} is on previous position (${A}) in ${FILE} before page ${BNAME} (position ${B})." >> /dev/stderr
								return 1
							else
								PAGE="yes"
								exportdjvupage "${SOURCE}" "${ANAME}" "${TEMPDIR}"
								deletepage "${SOURCE}" "${ANAME}"
								if [ "${A}" -gt "${B}" ] ; then
									${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "${B}"
								else
									${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "$((${B} - 1))"
								fi
								return 0
							fi
						elif [ "${MOVE}" == "back" ] ; then
							local TEST=$(lastpage "${SOURCE}")
							if [ "$A" == "${TEST}" ] ; then
								echo "move: INFO - page ${ANAME} is on last position in ${FILE}." >> /dev/stderr
								return 1
							elif [ "$A" == "$((${B} + 1))" ] ; then
								echo "move: INFO - page ${ANAME} is on next position in ${FILE} after page ${BNAME}." >> /dev/stderr
								return 0
							else
								PAGE="yes"
								exportdjvupage "${SOURCE}" "${ANAME}" "${TEMPDIR}"
								deletepage "${SOURCE}" "${ANAME}"
								if [ "${A}" -lt "${B}" ] ; then
									${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "${B}"
								else
									${DJVM} -i "${SOURCE}" "${TEMPDIR}/${ANAME}" "$((${B} - 1))"
								fi
								return 0
							fi
						else
							echo "move: Nedělám nic" >> /dev/stderr
						fi
					fi
				fi
			else
				echo "move: FAIL ANAME -${ANAME}-, VSTUP -${VSTUP}- je buď prázdný, nebo obsahuje pouze číselnou identifikaci cílové pozice" >> /dev/stderr
				exit 1
			fi 
		fi
	else
		if [ -z "${FROM}" ] && [ -z "${ANAME}" ] ; then
			echo "move: Neplatná identifikace stránky se kterou se má pracovat" >> /dev/stderr
			exit 1
		fi
	fi

	echo "FROM - ${FROM}" >> /dev/stderr
	echo "A - ${A}" >> /dev/stderr
	echo "ANAME - ${ANAME}" >> /dev/stderr
	echo "B - ${B}" >> /dev/stderr
	echo "BNAME - ${BNAME}" >> /dev/stderr
	echo "MOVE - ${MOVE}" >> /dev/stderr

# Do tohoto místa probíhá zpracování stejně pro fore i back
# Následuje další zpracování parametrů - především porovnání ..

# 1, je-li ANAME, stejné jako BNAME, přesun A o jednu pozici vřed či vzad..
#
# 2, je-li FROM stejné jako BNAME, vyhodit dotaz: 
#		Nahradit? nebo akci přerušit?
# Pro MOVE=fore...
# 3f, je-li pozice A o 1 větší než B - skončit 
# 4f, je-li pozice A = 1 skončit 
# 
# Pro MOVE=back...
# 3b, je-li pozice A o 1 menší než B - skončit
# 4b, le-li pozice A = lastpage skončit
#
# Má se přesouvat kupředu
}

function range {
	# 1,2,3-9,10-20
	case "${1:0:1}" in
		[[:digit:]]) local INPUTARRAY=( ${1//,/ } )
			for i in ${INPUTARRAY[@]} ; do
				if [[ "$i" =~ "-" ]] ; then
					seq ${i//-/ }
				else
					seq ${i} ${i}
				fi
			done | sort -u
		;;
		*) printf "range: FAIL - range of pages must be set only from order numbers, commas and hyphens.\n" >> /dev/stderr
		exit 1
		;;
	esac
}

function setmeta {
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .meta)
	local CHARSET="${2}"
	local RANGE="${CHARSET%%\ *}"
	if [ "${RANGE}" == "all" ] ; then
		local ITEM="${CHARSET#* }"
		local KEY=(${ITEM})
		if [ "${#KEY[@]}" -lt "2" ] ; then
			printf "setmeta: FAIL - you must set meta attribute key and any value for it.\n"
			exit 1
		else
			for i in $(seq $(lastpage "${SOURCE}")) ; do
				printf "set meta: Set meta attribute key %s into all pages in DjVu bundle %s\n" "${KEY[0]}" "${FILE}" >> ${LOG}
				printmeta "${SOURCE}" "$i" | grep -v '^[#.]\|^$' > ${TEMPFILE}
				ed ${TEMPFILE} 2>/dev/null <<-EOF
/${KEY}
d
w
q
EOF
				ed ${TEMPFILE} 2>/dev/null <<-EOF
i
${ITEM}
.
w
q
EOF
				${DJVUSED} "${SOURCE}" -e "select $i; set-meta ${TEMPFILE}" -s
			done 1>/dev/null
		fi
	elif [ "${RANGE//+([[:alpha:]])/}" == "" ] ; then
		local ITEM="${CHARSET}"
		printf "set meta: Set global meta attribute key %s into DjVu bundle %s\n" "${RANGE}" "${FILE}" >> ${LOG}
		printmeta "${SOURCE}" global | grep -v '^[#.]\|^$' > ${TEMPFILE}
		ed ${TEMPFILE} 2>/dev/null <<-EOF
/${RANGE}
d
w
q
EOF
		ed ${TEMPFILE} 2>/dev/null <<-EOF
i
${ITEM}
.
w
q
EOF
		${DJVUSED} "${SOURCE}" -e "select; set-meta ${TEMPFILE}" -s
	else
		local IDPAGES=($(range "${RANGE}"))
		local ITEM="${CHARSET#* }"
		local KEY=(${ITEM})
		for i in ${IDPAGES[@]} ; do
			printf "set meta: Set meta attribute key %s into page %s in DjVu bundle %s\n" "${KEY[0]}" "$i" "${FILE}" >> ${LOG}
			printmeta "${SOURCE}" "$i" | grep -v '^[#.]\|^$' > ${TEMPFILE}
			ed ${TEMPFILE} 2>/dev/null <<-EOF
/${KEY}
d
w
q
EOF
			ed ${TEMPFILE} 2>/dev/null <<-EOF
i
${ITEM}
.
w
q
EOF
			${DJVUSED} "${SOURCE}" -e "select $i; set-meta ${TEMPFILE}" -s
		done 1>/dev/null
	fi
	return 0
}


function unsetmeta {
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .meta)
	local CHARSET="${2}"
	local RANGE="${CHARSET%%\ *}"
	if [ "${RANGE}" == "all" ] ; then
		local ITEM="${CHARSET#* }"
		local KEY=(${ITEM})
		printf "unset meta: Remove attribute key %s from all pages DjVu bundle %s\n" "${KEY[0]}" "${FILE}" >> ${LOG}
		for i in $(seq $(lastpage "${SOURCE}")) ; do
			printmeta "${SOURCE}" "$i" | grep -v '^[#.]\|^$' > ${TEMPFILE}
			ed ${TEMPFILE} 2>/dev/null <<-EOF
/${KEY}
d
w
q
EOF
			${DJVUSED} "${SOURCE}" -e "select $i; set-meta ${TEMPFILE}" -s
		done  1>/dev/null
	elif [ "${RANGE//+([[:alpha:]])/}" == "" ] ; then
		printf "unset meta: Remove global attribute key %s from DjVu bundle %s\n" "${RANGE}" "${FILE}" >> ${LOG}
		printmeta "${SOURCE}" global | grep -v '^[#.]\|^$' > ${TEMPFILE}
		ed ${TEMPFILE} 2>/dev/null <<-EOF
/${RANGE}
d
w
q
EOF
		${DJVUSED} "${SOURCE}" -e "select; set-meta ${TEMPFILE}" -s
	else
		local IDPAGES=($(range "${RANGE}"))
		local ITEM="${CHARSET#* }"
		local KEY=(${ITEM})
		for i in ${IDPAGES[@]} ; do
			printf "unset meta: Remove attribute key %s from page %s\n" "${KEY[0]}" "$i" >> ${LOG}
			printmeta "${SOURCE}" "$i" | grep -v '^[#.]\|^$' > ${TEMPFILE}
			ed ${TEMPFILE} 2>/dev/null <<-EOF
/${KEY}
d
w
q
EOF
			${DJVUSED} "${SOURCE}" -e "select $i; set-meta ${TEMPFILE}" -s
		done  1>/dev/null
	fi
	return 0
}

function djvuinfo {
	# $1 - soubor
	# $2 - parametry
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	if $(identifybundle "${SOURCE}") ; then
		local PAGES="none"
	else
		local PAGES=$(lastpage "${SOURCE}")
	fi
	if [ -z "${2}" ] ; then
		case "${PAGES}" in
			none) local INFO="${FILE}"
				echo -n "${INFO}" && printf "%$((31 - ${#INFO}))s : DjVu single-page\n"
			;;
			*) local INFO="${FILE}"
				echo -n "${INFO}" && printf "%$((31 - ${#INFO}))s : DjVu bundle - ${PAGES} pages\n"
			;;
		esac
	else
		case "${2}" in
			exif) ${EXIFTOOL} "${SOURCE}"
			;;
			meta) printmeta "${SOURCE}" all | grep -v '^[#.]\|^$'
			;;
			pages) 	${DJVUSED} "${SOURCE}" -e dump | grep FORM:DJVU | awk -F'[{}]' '{print $3":"$2}'
				return 0
			;;
			*) case "${2%%\ *}" in
					meta) if [ "${2#* }" == "all" ] ; then
							printmeta "${SOURCE}" all | grep -v '^[#.]\|^$'
							return 0
						elif [ "${2#* }" == "global" ] ; then
							printmeta "${SOURCE}" global | grep -v '^[#.]\|^$'
							return 0
						else
							printf "Meta atributtes for page %s from %s" "${2#* }" "${FILE}" >> ${LOG}
							local NAMEPAGE=$(identifyname "${SOURCE}" "${2#* }")
							if [ -z "${NAMEPAGE}" ] ; then
								echo "info: FAIL - identificator page ${2#* } is not valid for DjVu bundle ${FILE}" >> /dev/stderr
								exit 1
							else
								local IDPAGE=$(identifypage "${SOURCE}" "${NAMEPAGE}")
								printf "Meta attributes from #%s page in DjVu bundle %s" "${IDPAGE}" "${FILE}" >> ${LOG}
								printmeta "${SOURCE}" "${NAMEPAGE}" | grep -v '^[#.]\|^$'
								return 0
							fi
						fi
					;;
					pages) if [ "${2#* }" == "all" ] ; then
							${DJVUSED} "${SOURCE}" -e dump | grep FORM:DJVU | awk -F'[{}]' '{print $3":"$2}'
							return 0
						else
							printf "View %s item from list %s" "${2#* }" "${FILE}" >> ${LOG}
							local NAMEPAGE=$(identifyname "${SOURCE}" "${2#* }")
							if [ -z "${NAMEPAGE}" ] ; then
								echo "info: FAIL - identificator page ${2#* } is not valid for DjVu bundle ${FILE}" >> /dev/stderr
								exit 1
							else
								local IDPAGE=$(identifypage "${SOURCE}" "${NAMEPAGE}")
								printf " [P%d]:%s\n" "${IDPAGE}" "${NAMEPAGE}"
								return 0
							fi
						fi
					;;
					exif) if [ "${2#* }" == "all" ] ; then
							${EXIFTOOL} "${SOURCE}"
							return 0
						else
							printf "Exif atributtes for page %s from %s" "${2#* }" "${FILE}" >> ${LOG}
							local NAMEPAGE=$(identifyname "${SOURCE}" "${2#* }")
							if [ -z "${NAMEPAGE}" ] ; then
								echo "info: FAIL - identificator page ${2#* } is not valid for DjVu bundle ${FILE}" >> /dev/stderr
								exit 1
							else
								local IDPAGE=$(identifypage "${SOURCE}" "${NAMEPAGE}")
								PAGE="yes"
								djvuexport "${1}" "${NAMEPAGE} ${TEMPDIR}"
								local INFO="Page #${IDPAGE} from DjVu bundle"
								echo -n "${INFO}" && printf "%$((31 - ${#INFO}))s : ${FILE}\n"
								${EXIFTOOL} "${TEMPDIR}/${NAMEPAGE}"
								return 0
							fi
						fi
					;;
				esac
			;;
		esac
	fi
}

function help {
	case "$1" in
		algorithm) echo """Nápověda pro algoritmy.. ToDo
		"""
		;;
		bundle) echo """Nápověda pro volbu typu svazku.. ToDo
		"""
		;;
		page) echo """volba [1m-p[0m ([1m--page[0m)

  Extrakce DjVu stránky ze svazku při akci [2mexport[22m

  [1m${0##*/}[0m ... {-p|--page} [yes|no] ...
  
[4mPoznámka:[24m
  * Pokud za volbou není uveden žádný další parametr, tak se automaticky
    předpokládá - yes.
  * Výchozí parametr - no - lze implicitně změnit nastavením proměnné
    PAGE do souboru v adresáři ${HOME}/.config/${NAME}/
  * Exportované stránky se ukládají pod svým původním názvem.
"""
		;;
		image) echo """volba [1m-i[0m ([1m--img[0m)

  [4mExtrakce obrazové vrstvy[24m DjVu stránky do bitmapového souboru

  [1m${0##*/}[0m ... {-i|--img} [yes|no|<layer>] ...

  Je-li parametrem volby [3myes[23m, tak se bude při akci [2mexport[22m generovat z DjVu
  stránky plnobarevný bitmapový obrázek ve formátu PNG.
  V ostatních případech bude ve formátu PNM.

      [1m${0##*/}[0m --img background svazek.djvu export stranka.djvu
 
Použitelné parametry:
                 color - plnobarevná stránka
                 black - černobílá kresba
            foreground - vrstva popředí
            background - vrstva pozadí
                  mask - maska
  Je-li místo [3m'yes'[23m uvedeno [3m'background'[23m, bude při exportu stránky
  strana.djvu uložen obrázek pozadí pod jménem strana.background.pnm
  Výchozí nastavení lze implicitně změnit nastavením proměnné IMGPAGE
"""
		;;
		dsed) echo """Option [1m-d[0m ([1m--dsed[0m)

  Extrakce skryté textové vrstvy DjVu stránky ve formátu pro djvused.
  Parametrem lze zvolit, co se má při akci [2mexport[22m uložit.

  [1m${0##*/}[0m ... {-d|--dsed} [yes|no|all|txt|ant] ...
  
         yes - stejný efekt jako volba all
         no  - textová vrstva se neexportuje (default)
         all - exportuje se celý obsah skryté textové vrstvy
         txt - exportuje se pouze obsah stránky
         ant - exportují se meta atributy stránky, hyperlinky, atp.

[4mPoznámka:[24m
  * Pokud za volbou není uveden žádný další parametr, tak se automaticky
    předpokládá - yes.
  * Výchozí parametr - no - lze implicitně změnit nastavením proměnné
    DSED do souboru v adresáři ${HOME}/.config/${NAME}/
  * Exportovaná data se ukládají do souborů s příponou [3m.dsed[23m.
"""
		;;
		force) echo """volba [1m-f[0m ([1m--force[0m)

  Nastavením této volby si lze vynutit výchozí chování k souborům při
  akci [2mexport[22m. Není-li uvedena, tak se skript před každým
  přepsáním již existujícího souboru zeptá, zda-li má, nebo nemá
  pokračovat.

  [1m${0##*/}[0m ... {-f|--force} [yes|no|skip] ...
  
         yes  - všechny soubory se budou bez keců přepisovat.
         no   - skript se před přepsáním souboru bude dotazovat, zda-li
                má soubor přepsat.
         skip - pokud bude cílový soubor existovat, tak se akce přeskočí.

[4mPoznámka:[24m
  * Pokud za volbou není uveden žádný další parametr, tak se automaticky
    předpokládá - skip.
  * Výchozí parametr hodnotu parametru  (skip) - lze implicitně změnit
    nastavením proměnné FORCE v uživatelském konfiguračním souboru.
"""
		;;
		verbose) echo """volbu [1m-v[0m ([1m--verbose[0m)
  Prostřednictvím této volby si lze přesměrovat výstup doplňujících
  informačních výpisů na konzoli. Díky nim pak lze podrobně sledovat
  postup skriptu při zpracování souboru

  [1m${0##*/}[0m ... {-v|--verbose} ...
"""
		;;
		xml) echo """volba [1m-x[0m ([1m--xml[0m)

  Extrakce skryté textové vrstvy DjVu stránky ve formátu XML.
  Parametrem lze zvolit, co se má při akci [2mexport[22m uložit.

  [1m${0##*/}[0m ... {-d|--dsed} [yes|no|all|txt|ant] ...
  
         yes - stejný efekt jako volba all
         no  - textová vrstva se neexportuje (default)
         all - exportuje se celý obsah skryté textové vrstvy
         txt - exportuje se pouze obsah stránky
         ant - exportují se meta atributy stránky

[4mPoznámka:[24m
  * Pokud za volbou není uveden žádný další parametr, tak se automaticky
    předpokládá - yes.
  * Výchozí parametr - no - lze implicitně změnit nastavením proměnné
    XML do souboru v adresáři ${HOME}/.config/${NAME}/
  * Exportovaná data se ukládají do souborů s příponou [3m.xml[23m.

[1mPozor:[0m  Při exportu do XML nelze podchytit všechny meta atributy!!!
"""
		;;
		exporttometa) echo """volba [1m-m[0m ([1m--meta[0m)

  Extrakce DjVu stránky ze svazku

  [1m${0##*/}[0m ... {-x|--xml} [yes|no] ...
  
  Prostřednictvím této volby lze zvolit zda se má, nebo nemá při akci
  [3mexport[23m z DjVu svazku exportovat i celá DjVu stránka. Pokud za volbou
  nenásleduje parametr, pak se automaticky předpokládá že ano (yes).
  Výchozí nastavení (no), lze implicitně změnit prostřednictvím
  uživatelského konfiguračního souboru umístěného v v adresáři:

    ${HOME}/.config/${NAME}/
"""
		;;
		exporttothumb) echo """volba [1m-t[0m ([1m--thumb[0m)

  Extrakce DjVu stránky ze svazku

  [1m${0##*/}[0m ... {-t|--thumb} [yes|no] ...
  
  Prostřednictvím této volby lze zvolit zda se má, nebo nemá při akci
  [3mexport[23m z DjVu svazku exportovat i celá DjVu stránka. Pokud za volbou
  nenásleduje parametr, pak se automaticky předpokládá že ano (yes).
  Výchozí nastavení (no), lze implicitně změnit prostřednictvím
  uživatelského konfiguračního souboru umístěného v v adresáři:

    ${HOME}/.config/${NAME}/
"""
		;;
		indirect) echo"""
[1mVolba[0m
         --indirect Volba, kterou lze změnit výchozí typ vícestránkového 
                    DjVu svazku (bundeled)

  Volbu je třeba aplikovat pokud chcete rozbalit stvávající DjVu svazek 
  do podoby volného svazku, nebo pokud chcete při konverzi bitmapových
  souborů rovnou sestavit DjVu svazek jako volný

  Výhodou volného svazku je, že lze dodatečně upravovat jednotlivé stránky
  jako samostatné DjVu soubory, aniž by je bylo nutné exportovat.

  Pro finalizaci DjVu svazku je pak lepší svazek překonvertovat na typ
  bundled, kdy je vše zabaleno v jednom souboru
"""
		;;
		existed) echo """
  Soubor $2 existuje. Pokud se má přepsat, musí být
  uveden parametr -f (--force)
"""
		;;
		dpi) echo """
[1mOption:[0m --dpi  <[2mčíslo[22m> Hodnota DPI, která se má použít při zpracování obrázku.
                               při konverzi. Optimální je zjistit hodnotu přímo ze vstupního
                               obrázku. Před nastavením této hodnoty pro finální konverzi. lze vyzkoušet
                               optimální nastavení na některém ze souborů s využitím parametru
                               --test

  Rozsah číselné hodnoty je od 72 do 6000 dpi. Výchozí hodnota 300 se použije 
  v případě, že parametr --dpi není vůbec uveden.
  Vliv dpi na zpracování obrazu..
"""
		;;
		level) echo """
[1mParametr[0m
         -l|--level  <[2mčíslo[22m> Hodnota akceptovatelných ztrát u černobílé kresby
                               při konverzi. Před nastavením této hodnoty vyzkoušejte
                               optimální nastavení na některém ze souborů a s parametrem
                               --test

  Kromě číselné hodnoty, která musí být menší než 200 lze úroveň ztrát
  nastavit i pomocí některého z následujících parametrů - v případě že 
  jich bude uvedeno víc, má prioritu poslední z nich.

        --lossless     0 - žádné ztráty (default)
        --clean        1 - ignorují se body o velikosti 1 pixelu
        --lossy        100 - ignorují se plochy
"""
		;;
		keywords-export) echo """KEYWORD: [1mexport[0m

  Export pages , meta attributes from DjVu svazku. O tom co bude předmětem exportu rozhodují další 
  volby. Export textové vrstvy zajistí volby [3m-x[23m a [3m-d[23m, náhled obrazové vrstvy
  se generuje při volbě [3m-i[23m, a celá stránka v DjVu formátu se exportuje
  při volbě [3m-p[23m.

  [1m${0##*/}[0m [volby] <svazek> export {<num>|<name>|all|outline|meta [<num>|<name>|all]}  [<dir>]

      num - pořadové číslo stránky v DjVu svazku
     name - jméno stránky v DjVu svazku
      dir - adresář do kterého má být výstup uložen
      all - předmětem exportu bude obsah celého DjVu svazku
  outline - na výstup bude vypsán obsah DjVu svazku ve formátu pro import
     meta - na výstup budou vypsány meta atributy svazku ve formátu pro import

[4mPoznámky:[24m
  * Pro zpracování single-page DjVu stránek je parametr [3mall[23m doporučený
  * Není-li uveden cílový adresář, budou soubory exporované do adresáře,
    kde byl [1m${0##*/}[0m spuštěn.
  * Přepsání již existujících souborů si lze vynutit volbou [3m--force yes[23m
    Výchozí chování je - [3mskip[23m (existující soubory se znovu neexportují)
"""
		;;
		keywords-import) echo """akce [1mimport[0m
  [4mImport obsahu textové vrstvy[24m do DjVu souboru

  [1m${0##*/}[0m [volby] <svazek> import [<file>|<dir>]

         file - soubor s obsahem skryté textové vrstvy
         dir  - adresář se soubory s obsahem skryté textové vrstvy

[3mPoznámky:[23m
  * Parametrem akce [2mimport[22m může být buď adresář se soubory, nebo soubor s
    daty k importu
  * Název souboru musí odpovídat názvu svazku (pro gobální metadata), nebo
    názvu stránky, kterou obsahuje, s tím rozdílem, že jeho přípona odpovídá
    typu dat které obsahuje:
          [3m.meta[23m - meta atributy
           [3m.xml[23m - skrytý text obsahu
          [3m.dsed[23m - poznámky, meta atributy a skrytý text obsahu
       [3m.outline[23m - obsah svazku; Pozor! Obsah je součást celého svazku, nemá
                  tedy smysl ho vkládat do single-page DjVu dokumentu.
    K formátu těchto souborů více viz manuál
  * Není-li uveden žádný adresář, ani soubor, tak se předpokládá že se budou
    zpracovávat soubory z aktuálního adresáře
"""
		;;
		keywords-delete) echo """akce [1mdelete[0m

  [4mOdstranění stránky[24m identifikované jménem, nebo pozicí v DjVu svazku

  [1m${0##*/}[0m [volby] <svazek> delete {<num>|<name>}

         num  - pořadové číslo stránky v DjVu svazku
         name - jméno stránky v DjVu svazku

[1mDávejte pozor[0m - akce je nevratná !
  Je doporučeno při odstraňování stránek použít jako identifikátor jméno
  stránky. A to z toho důvodu, že se pozice stránky může v průběhu
  zpracování DjVu svazku změnit, kdežto její jméno zůstává vždy v rámci
  svazku jedinečné.
"""
		;;
		keywords-info) echo """
  KEYWORD [1minfo[0m

  Print informations about DjVu bundle. Without parameters return number of pages.
  If is DjVu file 'single-page', return 'none'.

  [1m${0##*/}[0m <DjVu> info [SUBKEY [<num>|<name>]]

         num  - order number of page in DjVu bundle
         name - name of page in DjVu bundle

  SUBKEYS:
         [3mexif[23m - return exif info about DjVu file
         [3mmeta[23m - return meta attribute keys from DjVu file
        [3mpages[23m - return ordered list pages from DjVu bundle with names

[3mNotice:[23m
  * For [3m'meta'[23m [2minfo[22m different from [2mexport[22m in that output is purified from syntax chars, whose is required for [2mimport[22m.
  * When is passed subkey [3m'exif'[23m with an identificator of page, be export a page into temporary dir and view info only about this page.
  * Subkey [3m'pages'[23m with an identificator of page return only item for this.
"""
		;;
		move) echo """akce [1mfore[0m a [1mback[0m
  [4mUmožňují přesunout stránku v rámci DjVu svazku [24m na jinou pozici, či
  [4mvložit[24m na tuto pozici  [4mstránku novou [24m, je-li prvním parametrem akce
  místo identifikátoru stránky v DjVu svazku soubor.

  [1m${0##*/}[0m [volby] <svazek> {fore|back} {<num>|<name>|<file>} [<num>|<name>]

         num  - pořadové číslo stránky v DjVu svazku
         name - jméno stránky v DjVu svazku
         file - jméno DjVu souboru, nebo skenu

[3mPoznámka:[23m
  * Je-li souborem nekonvertovaný bitmapový obrázek, určí co vše bude
    obnášet konverze předané volby.
  * Není-li určena indentifikátorem cílová pozice, bude stránka přesunuta
    při akci [2mfore[22m o pozici vpřed, nebo vzad - při akci [2mback[22m.
  * Je-li při akci [2mfore[22m vložena ze souboru nová stránka a není uveden
    identifikátor cílové pozice, bude stránka vložena na první pozici
    DjVu svazku. Při akci [2mback[22m) se připojí na konec.
  * Pokud se již v DjVu svazku nalézá stránka se stejným názvem jako má
    vkládaný soubor, vyskytuje, dojde při jeho vložení automaticky k
    přejmenování - za název se přidá podtržítko a pořadové číslo.
"""
		;;
		keywords-fore) help move
		;;
		keywords-fore1) echo """akce [1mfore[0m

  Umístění nové stránky, nebo stránky v rámci DjVu svazku již existující před stránku identifikovanou jménem, nebo aktuální pozicí. o pozici vpřed. [4mPřed stránku, která[24m
  [4mji má následovat[24m. V případě, už přesouvaná stránka je na první pozici,
  se nestane nic.

  [1m${0##*/}[0m [volby] <svazek> fore {<num>|<name>|<file>} [<num>|<name>]

         num  - pořadové číslo stránky v DjVu svazku
         name - jméno stránky v DjVu svazku
         file - DjVu soubor nebo naskenovaná stránka v bitmapovém formátu

  Je doporučeno použít jako identifikátor jména stránek, místo jejich 
  aktuální pozice. A to z toho důvodu, že se pozice stránek mohou v průběhu
  zpracování DjVu svazku měnit, kdežto její jméno stránky je vždy v rámci
  svazku jedinečné.
"""
		;;
		keywords-back) echo """akce [1mback[0m

  Přesun stránky v rámci DjVu svazku o pozici zpět. [4mZa stránku, která[24m
  [4mji má následovat[24m. V případě, už je přesouvaná stránka na poslední pozici,
  se nestane nic.

  [1m${0##*/}[0m [volby] <svazek> back {<num>|<name>} [<num>|<name>]

         num  - pořadové číslo stránky v DjVu svazku
         name - jméno stránky v DjVu svazku

  Je doporučeno použít jako identifikátor jména stránek, místo jejich 
  aktuální pozice. A to z toho důvodu, že se pozice stránek mohou v průběhu
  zpracování DjVu svazku měnit, kdežto její jméno stránky je vždy v rámci
  svazku jedinečné.
"""
		;;
		keywords-rotate) echo """
  KEYWORD [1mrotate[0m

  For change of default orientation page in DjVu file.

  [1m${0##*/}[0m [option] <DjVu> rotate {<num>|<name>} <VALUE>

         num   - order of page to change in DjVu bundle
         name  - name of page to change in DjVu bundle

Options:
    -f|--force   Force rotate without any questions

  VALUE:
             0 - normal orientation (0°)
             1 - rotate page 90° to right
             2 - rotate page 180°
             3 - rotate page 90° to left (270°)
          left - rotate page 90° in left direction
         right - rotate page 90° in right direction
           180 - turn the page on the contrary

[3mWarning:[23m
  * If is not any identificator of page, do set global orientation for all DjVu bundle.
"""
		;;
		keywords-set) help keywords-meta
		;;
		keywords-unset) help keywords-meta
		;;
		keywords-meta) echo """
  KEYWORD [1mset[0m or [1munset[0m

  Keywords [2mset[22m or [2munset[22m work only with meta attribute key.
  For view meta attribute use keyword [2minfo[22m and [2mexport[22m for output in
  format which is usable to [2mimport[22m. You may [2medit[22m attribute too.

  [1m${0##*/}[0m <DjVu> unset meta [all|<RANGE>] <KEY>

  [1m${0##*/}[0m <DjVu> set meta [all|<RANGE>] <KEY> <VALUE>

          all - item is set as meta attribute for every
                page in DjVu bundle
        RANGE - range specified pages
          KEY - key name of meta attribute
        VALUE - value of meta attribute key

[3mNotice:[23m
  * If is not given key word [3mall[23m or [3mRANGE[23m of pages, is item KEY accepted
    as global meta attribute of DjVu bundle
  * Range is specified by order of pages in DjVu bundle. Separated by comma.
    Hyphen is for limits from-to.

RANGE example:

    [1m${0##*/}[0m bundle.djvu set meta 1,3,7-12 Creator 'Thomas Jefferson'

KEY most common attributes:
        [3mTitle[23m - Title of DjVu page or bundle
      [3mCreator[23m - Creator DjVu bundle or DjVu page from scan
 [3mCreationDate[23m - Creation date of DjVu bundle or page
     [3mKeywords[23m - Keywords for indexation DjVu file
       [3mannote[23m - Notes about origin of document & etc.

[3mNotice:[23m
  * KEY is single word without diacritical chars and spaces
  * VALUE is normal text string
"""
		;;
		keywords-edit) echo """akce [1medit[0m

  Editace textový informací DjVu svazku - meta informace, bookmarks,outline

  [1m${0##*/}[0m <svazek> edit {outline|meta [<num>|<name>]}

         outline - výpis aktuálního obsahu DjVu svazku ve formátu .outline
         meta  - vygenerování šablony pro .outline formát s adresováním
                 stránek podle jejich názvů

         num  - pořadové číslo stránky v DjVu svazku
         name - jméno stránky v DjVu svazku

[3mPoznámka:[23m
  Vygenerovanou šablonu .outline formátu lze upravit editací v libovolném
  textovém editoru. Řádky s nevyužitými položkami je třeba smazat.
  Do dalších úrovní lze položky obsahu zanořit pomocí odsazení řádku
                   1 úroveň = 1 tabulátor = 8 mezer
  Aktuální obsah lze vyexportovat v .outline formátu parametrem print
  Upravený obsah lze do DjVu svazku naimportovat ze souboru přes akci [2mimport[22m,
[1mPozor:[0m Soubor ve formátu .outline musí mít (až na příponu) stejné jméno,
  jako má DjVu svazek do kterého se má vložit, jinak se nenaimportuje!
"""
		;;
# ODSTRANIT VVVV
		keywords-outline) echo """akce [1moutline[0m

Zrušeno, nahrazeno akcí edit a export

  Pomocná akce pro výpis a export obsahu (bookmarks,outline) Djvu svazku.

  [1m${0##*/}[0m <svazek> outline {dump|print|<order>|<name}

         dump  - dump aktuálního obsahu DjVu svazku v dsed formátu
         print - výpis aktuálního obsahu DjVu svazku ve formátu .outline
         order - vygenerování šablony pro .outline formát s adresováním
                 stránek dle pořadových čísel
         name  - vygenerování šablony pro .outline formát s adresováním
                 stránek podle jejich názvů
         num  - pořadové číslo stránky v DjVu svazku
         name - jméno stránky v DjVu svazku

[3mPoznámka:[23m
  Vygenerovanou šablonu .outline formátu lze upravit editací v libovolném
  textovém editoru. Řádky s nevyužitými položkami je třeba smazat.
  Do dalších úrovní lze položky obsahu zanořit pomocí odsazení řádku
                   1 úroveň = 1 tabulátor = 8 mezer
  Aktuální obsah lze vyexportovat v .outline formátu parametrem print
  Upravený obsah lze do DjVu svazku naimportovat ze souboru přes akci [2mimport[22m,
[1mPozor:[0m Soubor ve formátu .outline musí mít (až na příponu) stejné jméno,
  jako má DjVu svazek do kterého se má vložit, jinak se nenaimportuje!
"""
		;;
# ODSTRANIT VVVV
		keywords-print) echo """akce [1mprint[0m

Zrušeno nahrazeno akcí export a info

  [4mVýpis klíčů a jejich obsahu[24m z metainformací uložených v Djvu svazku.

  [1m${0##*/}[0m <svazek> print [all]
  [1m${0##*/}[0m <svazek> print <attr>
  [1m${0##*/}[0m <svazek> print {<num>|<name>} [all]
  [1m${0##*/}[0m <svazek> print {<num>|<name>} <attr>

         num  - pořadové číslo stránky v DjVu svazku
         name - jméno stránky v DjVu svazku
         attr - jméno atributu
         all  - klíčové slovo (vypsat vše)

[3mPoznámka:[23m
  Jednotlivé atributy lze nastavovat přes [2mset[22m, více atributů najednou
  lze do DjVu stránky či svazku importovat z externího souboru při
  akci [2mimport[22m. Metadata lze z DjVu souborů také exportovat ([2mexport[22m).
"""
		;;
		keywords) echo """
KEYWORDS:

    delete - remove page from bundle
fore, back - move, or insert pages into DjVu bundle
    rotate - change orientation page or all pages DjVu bundle
    export - export from DjVu bundle
    import - import (content, meta attributes, outline) into DjVu bundle 
      edit - edit meta attributes or outline in DjVu bundle
      info - view info about DjVu bundle or selected page
    rename - rename pages in DjVu bundle by pattern

[3mNotice:[23m
   For more description about any action or option you set on command line as next parameter option -h (--help)
"""
		;;
		meta) echo """
Export meta atrributů

  [1m${0##*/}[0m <svazek> export meta [<num>|<name>|all|global]
  
  global - globální meta atributy DjVu svazku
     all - kompletní výpis atributů ke svazku
         - výpis atributů stránky identifikované pořadovým číslem nebo jménem

Syntaxe meta souboru:

 #<num> '<name>'
 key1 <description>
 key2 ...
 .

Při importu stránky má jméno stránky přednost před pořadovým číslem. To se použije pouze tehdy, pokud identifikační jméno stránky chybí
Pokud stránka žádné meta atributy nemá, vypíše se pouze prázdná šablona
"""
		;;
		rename) echo """ volba [1m-r[0m, [1m--rename[0m
 Nastavení vzorku, podle jakého se mají pojmenovat, nebo přejmenovat DjVu soubory v DjVu svazku.

Lze využít parametr %01d pro nastavení počtu znaků v číslování stránky, při konverzi vícestránkových bitmapových souborů (tiff, png, xcf)

[4mPopis:[24m
  Pomocí [2mvzoru[22m lze upravit názvy zkonvertovaných DjVu souborů
  před jejich sestavením do DjVu svazku. [2mVzor[22m může být tvořen:
    1, Pouze jednou, nebo více nulami - 000
    2, Nebo řetězcem, následovaným nulami - soubor_00

[3mPoznámka:[23m
  Je-li uvedena pouze jedna nula, budou stránky očíslovány [4mnumericky[24m,
  t.j. od čísla 1 dále. Je-li nul více, pak bude číslo interpretováno
  jako [4mřetězec[24m. tedy 001 a dále. Pokud by číslování stránek přesáhlo
  nastavený počet čísel, bude upraven dle maximálního čísla.

[3mUkázkové vzory : a výsledný efekt..[23m
   soubor-0000 : soubor-0001.djvu .. soubor-0123.djvu
   soubor_0    : soubor_1.djvu    .. soubor_123.djvu
   soubor000   : soubor0001.djvu  .. soubor1234.djvu
"""
			;;
		suffix) echo """
[1mParametr[0m
         -e|--ext  <[2msuffix[22m>  Přípona souborů, ze kterých se má sestavit 
                                DjVu soubor.
[4mPopis:[24m
  [2mSuffix[22m je nutné uvést pouze v případě, že soubory s názvem odpovídajícím
  vzorku dosud nebyly do DjVu zkonvertovány. Jinak se vždy předpokládá, že
  se bude pracovat s již konvertovanými DjVu soubory.

  Je-li [2msuffix[22m uveden, budou konvertovány soubory vyhovující vzorku.
  Pokud některé z nich již konvertovány byly, tak se se fáze konverze
  přeskočí. Pracuje se pak s již existujícím DjVu souborem.

  Konvertovány jsou pouze soubory, které chybí. Kvalitu konverze lze
  ovlivnit  dalšími parametry. Mají-li být soubory překonvertovány znovu,
  lze si to vynutit parametrem -f (--force) a stávající soubory  přepsat.

  Akceptované sufixy: 
     djvu (default), jpg, gif, png, bmp, pnm, pbm, pgm.
  Vícevrstvé soubory:
     xcf, tiff, pdf 
"""
			;;
		ocr) echo "Nápověda k OCR - ToDo"
		;;
		options) echo """Options:
    -a|--algorithm Algorithm for separating mask of image (fore or back)
xx  -b|--bundle    Setting type of DjVu bundle
    -d|--dsed      Export hiddent text layer in native code for DjVused
       --dpi       DPI input image for import (actions fore or back)
    -f|--force     Force action
       --clean     Params for convert image to DjVu with separate layers
       --lossy
       --lossless
       --level
    -h|--help      Main options for help about option, or action
    -i|--image     Export .png image of page for use with DjVuWebEd
??  -m|--meta      Export meta attributes from DjVu file
    -o|--ocr       Application OCR
    -p|--page      Export single DjVu page from bundle
    -r|--rename    Pattern for action rename 
xx  -t|--thumb     Creating thumbnails in DjVu bundle
    -v|--verbose   
    -x|--xml       Export hiddent text layer (XML) for use with DjVuWebEd"""
		;;
		*) echo """
DJVUTOOL - tool to work with DjVu files & bundles

Use:  [1m${0##*/}[0m [options] { [-h|--help] | <file> {KEYWORDS} [...] }
""" && help options && help keywords
		;;
	esac
}

function filetodjvu {
	echo "filetodjvu: vstupuji sem.." >> /dev/stderr
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	local TARGETPATH=$(${REALPATH} -m -P "${2}")
	local TARGET="${TARGETPATH##*/}"
	case "${FILE##*.}" in
		[jJ][pP][gG]|[pP][nN][gG]|[gG][iI][fF]|[pP][nN][mM]) todjvu "${SOURCE}" "${TARGETPATH}"
			echo "filetodjvu: INFO - DjVu bundle ${TARGETPATH} is prepared" >> /dev/stderr
		;;
		[tT][iI][fF][fF]|[xX][cC][fF]|[nM][nN][gG]|[pP][dD][fF]) if [ "${RENAME}" == "no" ] ; then
				# pojmenování cíle vyjde ze jména souboru
				local COUNT=$(${IDENTIFY} -format "%n" ${SOURCE})
				${CONVERT} "${SOURCE}" "${TEMPDIR}/${FILE%.*}_%0${#COUNT}d.png"
			else
				# pojmenování vyjde ze vzoru
				local COUNT=$(${IDENTIFY} -format "%n" ${SOURCE})
				if [[ ${RENAME} =~ "%" ]] ; then
					echo "Použiju číslování ze vzoru" >> /dev/stderr
					${CONVERT} "${SOURCE}" "${TEMPDIR}/${RENAME}.png"
				else
					echo "Použiju výchozí číslování" >> /dev/stderr
					${CONVERT} "${SOURCE}" "${TEMPDIR}/${RENAME}_%0${#COUNT}d.png"
				fi
			fi
			# Konverze vytažených souborů..
			find "${TEMPDIR}" -type f ! -name '*.djvu' | while read line
			do
				todjvu "${line}" "${line%.*}.djvu"
			done
			# Zabalení vytažených souborů...
			find "${TEMPDIR}" -type f ! -name "${TARGET}" -name "*.djvu" | while read line
			do
				if [ -f "${TARGETPATH}" ] ; then
					${DJVM} -i "${TARGETPATH}" "${line}"
				else
					${DJVM} -c "${TARGETPATH}" "${line}"
				fi
			done
			echo "filetodjvu: INFO - DjVu bundle ${TARGETPATH} is prepared" >> /dev/stderr
		;;
		*) echo "filetodjvu: INFO - Format file ${FILE##*\.} is not supported. Sorry!!" >> /dev/stderr && exit 1
		;;
	esac
}

function todjvu {
	# $1 - soubor ke konverzi
	# $2 - target path to new DjVu file (full path!!)
	#echo "to djvu -${1}- -${2}-" >> /dev/stderr
	#return 0
	local SOURCE=$(${REALPATH} -m -P "${1}")
	local FILE="${SOURCE##*/}"
	case "${FILE##*.}" in
		[jJ][pP][gG]|[pP][nN][gG]|[gG][iI][fF]|[pP][nN][mM])
		;;
		[tT][iI][fF][fF]|[xX][cC][fF]|[nM][nN][gG]|[pP][dD][fF]) echo "todjvu: INFO - Format file ${FILE##*\.} now is not accepted. Sorry!!" >> /dev/stderr && exit 1
		;;
		*) echo "todjvu: INFO - Format file ${FILE##*\.} is not supported. Sorry!!" >> /dev/stderr && exit 1
		;;
	esac
	local TARGETPATH=$(${REALPATH} -m -P "${2}")
	local TARGET="${TARGETPATH##*/}"
	log 1 "todjvu: From input file ${SOURCE} make DjVu file ${TARGET}" >> /dev/stderr
	if [ $(testfile "${SOURCE}") == "djvu" ] ; then
		echo "todjvu: ERROR - ${SOURCE} is DjVu file" >> /dev/stderr
		exit 1
	else
		if [ "${#ALG[@]}" -gt "1" ] ; then
			for i in ${ALG[@]} ; do 
				${DIDJVU} encode -o "${TARGETPATH/.djvu/.$i.djvu}" -d "${DPI-300}" ${LEVEL} -m "$i" "${SOURCE}"
				[ "$?" ] && log 1 "todjvu: INFO - file ${FILE} was converted into ${TARGETPATH/.djvu/.$i.djvu}"
				getocr "${TARGETPATH/.djvu/.$i.djvu}"
			done
		else
			if [ -f "${TARGETPATH}" ] ; then
				if [ "${FORCE}" == "yes" ] ; then
				log 1 "todjvu: INFO - rewrite target file ${TARGET}."
					${DIDJVU} encode -o "${TARGETPATH}" -d "${DPI-300}" ${LEVEL} -m "${ALG}" "${SOURCE}"
				[ "$?" ] && log 1 "todjvu: INFO - file ${FILE} was converted into ${TARGETPATH}"
					getocr "${TARGETPATH}"
				else
					echo "Mám přepsat cílový soubor ${TARGET}?"
					potvrdit && ${DIDJVU} encode -o "${TARGETPATH}" -d "${DPI-300}" ${LEVEL} -m "${ALG}" "${SOURCE}"
					getocr "${TARGETPATH}"
				fi
			else
				${DIDJVU} encode -o "${TARGETPATH}" -d "${DPI-300}" ${LEVEL} -m "${ALG}" "${SOURCE}"
				getocr "${TARGETPATH}"
				[ "$?" ] && log 1 "todjvu: INFO - file ${FILE} was converted into ${TARGETPATH}"
			fi
		fi
	fi
}

# TODO - test - testovací enkode proces
function todotest {
	for i in ${ALG[@]} ; do 
		${DIDJVU} encode -o "${1%.*}-$i.djvu" -d 300 -m "$i" "$1"
	done
}

# TODO - test - zobrazení testovacích DjVu souborů
function todoview {
	for i in ${ALG[@]} ; do 
		(${DJVIEW} ${1%.*}-$i.djvu &)
	done
}

# TODO - insert
function todjvuclassic {
    RANDOMKEY=$[ 8000 + $[ RANDOM % 1000 ]]
    TEMP_DIR="${TEMPDIR}/$WINDOWID$BASHPID$RANDOMKEY"
    mkdir $TEMP_DIR
    TEMP_IMG="$TEMP_DIR/temp.ppm"
    TEMP_MASK="$TEMP_DIR/mask.pbm"
    DJVU_MASK="$TEMP_DIR/mask.djvu"

    case ${1##*.} in
        tiff|tif) KONVERT="${TIFFTOPNM}";;
        png) KONVERT="${PNGTOPNM}";;
        jpg) KONVERT="${JPEGTOPNM}" ;;
    esac

    $KONVERT $1 | tee $TEMP_IMG | ${PPMTOPGM} | ${PGMTOPBM} -threshold -value 0.${3-5} | ${PNMTOPLAINPNM} > $TEMP_MASK;
    ${CJB2} -lossy -clean $TEMP_MASK $DJVU_MASK;
    ${DJVUMAKE} ${1/.png/.djvu} Sjbz=$DJVU_MASK PPM=$TEMP_IMG;
    getocr ${1/.png/.djvu}
    rm -rf $TEMP_DIR
}

# Zpracování parametrů předaných při startu skriptu
function main {
#	echo "$@" >> /dev/stderr
#	echo "$*" >> /dev/stderr

local VSTUP="$*"
local COUNT=${#VSTUP}
local POS=0
local START=0
while [ $POS -lt $COUNT ]
do local POS=$((POS+1))
	case "${VSTUP:$START:$POS}" in
		-a|--algorithm) # Volba pro akci insert
			local POS=$((POS+1))
			local TEMP=${VSTUP:$POS}
			case "$TEMP" in
				-h*|--help*) help algorithm && exit 0
				;;
				*) echo "Seru na tebe? $TEMP"
				;;
			esac
			local NEXT="${TEMP#* }"
			local VALUE="${TEMP%${NEXT}}"
#			echo "$VALUE" >> /dev/stderr
			if [ "${VALUE:0:1}" == "-" ] ; then
				local VSTUP="${TEMP}"
				local POS=0
				local COUNT=${#VSTUP}
				log 1 "Nebyl uveden žádný kompresní algoritmus, aplikuji výchozí - $ALG"
			else
				for i in ${VALUE//,/ } ; do
#					echo "$i" >> /dev/stderr
					local TEST="no"
					for y in ${ALGORITHM[@]} ; do
						[ "$i" == "$y" ] && local TEST="yes"
					done
					[ "${TEST}" == "no" ] && echo "Algoritmus $i nelze použít" >> /dev/stderr && exit 0
				done
				ALG=(${VALUE//,/ })
				local VSTUP="${NEXT}"
				local POS=0
				local COUNT=${#VSTUP}
				log 1 "main: Kompresní algoritmy jsou ověřeny, použiji - ${ALG[@]}"
			fi
		;;
		-d|--dsed) # Volba pro akci export
			local POS=$((POS+1))
			local TEMP=${VSTUP:$POS}
			case "$TEMP" in
				-h*|--help*) help dsed && exit 0
				;;
			esac
			local NEXT="${TEMP#* }"
			local VALUE="${TEMP%${NEXT}}"
			case "${VALUE%%+([[:blank:]])}" in
				yes|no|txt|ant|all) DSED="${VALUE%%+([[:blank:]])}"
				local VSTUP="${NEXT}"
				local POS=0
				local COUNT=${#VSTUP}
				log 1 "main: Aplikuji pro DSED parametr - ${DSED}"
				;;
				*) log 1 "Nebyl uveden žádný parametr, aplikuji pro DSED parametr - yes"
				DSED="yes"
				local VSTUP="${TEMP}"
				local POS=0
				local COUNT=${#VSTUP}
			esac
		;;
		--dpi) # Volba pro akci insert
			local POS=$((POS+1))
			local TEMP=${VSTUP:$POS}
			case "$TEMP" in
				-h*|--help*) help dpi && exit 0
				;;
			esac
			local NEXT="${TEMP#* }"
			local VALUE="${TEMP% ${NEXT}}"
#			echo "${VALUE//+([[:digit:]])}" >> /dev/stderr
			if [ "${VALUE//+([[:digit:]])}" == "" ] ; then
				if [ "${VALUE}" -ge "72" ] && [ "${VALUE}" -le "6000" ] ; then
					DPI="${VALUE%%+([[:blank:]])}"
					local VSTUP="${NEXT}"
					local POS=0
					local COUNT=${#VSTUP}
					log 1 "main: Aplikuji pro DPI parametr - ${DPI}"
				else
					echo "Hodnota u volby --dpi se musí pohybovat v rozmezí od 72 do 6000" >> /dev/stderr
					exit 1
				fi
			else
				echo "Nebyla uvedena hodnota dpi. Pokud chcete volbou --dpi změnit výchozí hodnotu (300), musíte ji uvést jako číselný parametr" >> /dev/stderr
				exit 1
			fi
		;;
		-f|--force) local POS=$((POS+1))
			local TEMP=${VSTUP:$POS}
			case "$TEMP" in
				-h*|--help*) help force && exit 0
				;;
			esac
			local NEXT="${TEMP#* }"
			local VALUE="${TEMP%${NEXT}}"
			case "${VALUE%%+([[:blank:]])}" in
				yes|no|skip) FORCE="${VALUE%%+([[:blank:]])}"
				local VSTUP="${NEXT}"
				local POS=0
				local COUNT=${#VSTUP}
				log 1 "main: Aplikuji pro FORCE parametr - ${FORCE}"
				;;
				*) log 1 "Nebyl uveden žádný parametr, aplikuji pro FORCE parametr - skip"
				FORCE="skip"
				local VSTUP="${TEMP}"
				local POS=0
				local COUNT=${#VSTUP}
			esac
		;;
		--clean|--lossy|--lossless|--level) # Volba pro akci insert
			local PARAM=${VSTUP:0:$POS}
			local POS=$((POS+1))
			local TEMP=${VSTUP:$POS}
			case "$TEMP" in
				-h*|--help*) help force && exit 0
				;;
			esac
			case "${PARAM}" in
				--lossy) LEVEL="--loss-level=100"
					local VSTUP="${TEMP}"
					local POS=0
				;;
				--lossless) LEVEL="--loss-level=0"
					local VSTUP="${TEMP}"
					local POS=0
				;;
				--clean) LEVEL="--loss-level=1"
					local VSTUP="${TEMP}"
					local POS=0
				;;
				--level)
							local NEXT="${TEMP#* }"
						local VALUE="${TEMP%${NEXT}}"
						local XXX=${VALUE%%+([[:blank:]])}
						if [ "${XXX//+([[:digit:]])}" == "" ] ; then
						local VSTUP="${NEXT}"
						local POS=0
						local COUNT=${#VSTUP}
						if [ "${XXX}" -ge "0" ] && [ "${XXX}" -lt "200" ] ; then
							LEVEL="--loss-level=${XXX}"
							log 1 "main: Aplikuji pro LEVEL hodnotu - ${LEVEL}"
						else
							help level && exit 0
						fi
					else
						echo "main: Volba --loss-level musí mít vždy uvedenou číselnou hodnotu v rozmezí 0-199" >> /dev/stderr
						exit 1
					fi
				;;
				*) echo "Sem se nikdy neměl dostat"
				;;
			esac
			log 1 "Úroveň ztrátovosti při kompresi ${LEVEL}"
		;;
		-i|--image) # Volba pro akci export
			local POS=$((POS+1))
			local TEMP=${VSTUP:$POS}
			case "$TEMP" in
				-h*|--help*) help image && exit 0
				;;
			esac
			local NEXT="${TEMP#* }"
			local VALUE="${TEMP%${NEXT}}"
			case "${VALUE%%+([[:blank:]])}" in
				yes|no|color|black|foreground|background|mask) IMG="${VALUE%%+([[:blank:]])}"
				local VSTUP="${NEXT}"
				local POS=0
				local COUNT=${#VSTUP}
				log 1 "main: Aplikuji pro IMG parametr - ${IMG}"
				;;
				*) log 1 "Nebyl uveden žádný parametr, aplikuji pro IMG parametr - yes"
				IMG="yes"
				local VSTUP="${TEMP}"
				local POS=0
				local COUNT=${#VSTUP}
			esac
		;;
		-m|--meta) # Volba pro akci export
			local POS=$((POS+1))
			local TEMP=${VSTUP:$POS}
			case "$TEMP" in
				-h*|--help*) help meta && exit 0
				;;
			esac
			local NEXT="${TEMP#* }"
			local VALUE="${TEMP%${NEXT}}"
			if [ "${VALUE%%+([[:blank:]])}" == "yes" ] || [ "${VALUE%%+([[:blank:]])}" == "no" ] ; then
				META="${VALUE%%+([[:blank:]])}"
				local VSTUP="${NEXT}"
				local POS=0
				local COUNT=${#VSTUP}
				log 1 "main: Aplikuji pro META parametr - ${META}"
			else
				META="yes"
				local VSTUP="${TEMP}"
				local POS=0
				local COUNT=${#VSTUP}
				log 1 "Nebyl uveden žádný parametr, aplikuji pro META parametr - yes"
			fi
		;;
		-o|--ocr) # Volba pro akci insert
			local POS=$((POS+1))
			local TEMP=${VSTUP:$POS}
			case "$TEMP" in
				-h*|--help*) help ocr
					${TESSERACT} --list-langs 2>&1 | sed -n '1!p'
					exit 0
				;;
			esac
			local NEXT="${TEMP#* }"
			local VALUE="${TEMP% ${NEXT}}"
#			echo "$VALUE" >> /dev/stderr
#			echo $(${TESSERACT} --list-langs 2>&1 | sed '1d;x') >> /dev/stderr
			for i in ${VALUE//+/ } ; do
				local TEST="no"
				for y in $(${TESSERACT} --list-langs 2>&1 | sed -n '1!p') ; do
					[ "$i" == "$y" ] && local TEST="yes"
#					echo "$i - $y" >> /dev/stderr
				done
				[ "${TEST}" == "no" ] && echo "Pro jazyk $i nemá tesseract nainstalovanou jazykovou podporu" >> /dev/stderr && exit 0
			done
			if [ "${TEST}" == "yes" ] ; then
				OCR="${VALUE%%+([[:blank:]])}"
				local VSTUP="${NEXT}"
				local POS=0
				local COUNT=${#VSTUP}
				log 1 "main: Aplikuji pro OCR parametr - ${OCR}"
			else
				OCR="${OCR=ces}"
				local VSTUP="${TEMP}"
				local POS=0
				local COUNT=${#VSTUP}
				echo "Nebyl uveden žádný parametr, pro OCR použiji výchozí jazyk - ${OCR}" >> /dev/stderr
			fi
		;;
		-p|--page) # Volba pro akci export
			local POS=$((POS+1))
			local TEMP=${VSTUP:$POS}
			case "$TEMP" in
				-h*|--help*) help page && exit 0
				;;
			esac
			local NEXT="${TEMP#* }"
			local VALUE="${TEMP%${NEXT}}"
			if [ "${VALUE%%+([[:blank:]])}" == "yes" ] || [ "${VALUE%%+([[:blank:]])}" == "no" ] ; then
				PAGE="${VALUE%%+([[:blank:]])}"
				local VSTUP="${NEXT}"
				local POS=0
				local COUNT=${#VSTUP}
				log 1 "main: Aplikuji pro PAGE parametr - ${PAGE}"
			else
				log 1 "Nebyl uveden žádný parametr, aplikuji pro PAGE parametr - yes"
				PAGE="yes"
				local VSTUP="${TEMP}"
				local POS=0
				local COUNT=${#VSTUP}
			fi
		;;
		-r|--rename) # Nastavení vzoru pro pojmenování stránek při akcích rename, fore a back
			local POS=$((POS+1))
			local TEMP=${VSTUP:$POS}
			case "$TEMP" in
				-h*|--help*) help rename && exit 0
				;;
			esac
			local NEXT="${TEMP#* }"
			local VALUE="${TEMP% ${NEXT}}"
			if [ "${VALUE##+([[:alnum:]%_-])}" == "" ] ; then
				RENAME="${VALUE}"
				local VSTUP="${NEXT}"
				local POS=0
				local COUNT=${#VSTUP}
				log 1 "main: Aplikuji pro RENAME parametr - ${RENAME}"
			else
				echo "main: FAIL - pattern '${VALUE}' for rename is is not acceptable." >> /dev/stderr
				exit 1
			fi
		;;
		-t|--thumb) # Volba pro akci insert
			local POS=$((POS+1))
			local TEMP=${VSTUP:$POS}
			case "$TEMP" in
				-h*|--help*) help thumb && exit 0
				;;
			esac
			local NEXT="${TEMP#* }"
			local VALUE="${TEMP% ${NEXT}}"
#			echo "${VALUE//+([[:digit:]])}" >> /dev/stderr
			if [ "${VALUE//+([[:digit:]])}" == "" ] ; then
				if [ "${VALUE}" -ge "32" ] && [ "${VALUE}" -le "256" ] ; then
					THUMB="${VALUE%%+([[:blank:]])}"
					local VSTUP="${NEXT}"
					local POS=0
					local COUNT=${#VSTUP}
					log 1 "main: Aplikuji pro THUMB parametr - ${DPI}"
				else
					echo "Hodnota u volby --thumb se musí pohybovat v rozmezí od 32 do 256" >> /dev/stderr
					exit 1
				fi
			else
				echo "Nebyla uvedena hodnota velikosti náhledu. Pokud chcete volbou --thumb nastavit výchozí hodnotu, musíte ji uvést jako číselný parametr" >> /dev/stderr
				exit 1
			fi
		;;
		-v|--verbose) # Volba pro ukecaný výstup
			local PARAM=${VSTUP:0:$POS}
			local POS=$((POS+1))
			local TEMP=${VSTUP:$POS}
			case "$TEMP" in
				-h*|--help*) help verbose && exit 0
				;;
			esac
			case "${PARAM}" in
				-v|--verbose) LOG="/dev/stderr"
					local VSTUP="${TEMP}"
					local POS=0
				;;
			esac
#			log 1 "Nastavuji ukecaný výstup"
		;;
		-x|--xml) # Volba pro akci export
			local POS=$((POS+1))
			local TEMP=${VSTUP:$POS}
			case "$TEMP" in
				-h*|--help*) help xml && exit 0
				;;
			esac
			local NEXT="${TEMP#* }"
			local VALUE="${TEMP%${NEXT}}"
			case "${VALUE%%+([[:blank:]])}" in
				yes|no|txt|ant|all) XML="${VALUE%%+([[:blank:]])}"
				local VSTUP="${NEXT}"
				local POS=0
				local COUNT=${#VSTUP}
				log 1 "main: Aplikuji pro XML parametr - ${XML}"
				;;
				*) log 1 "Nebyl uveden žádný parametr, aplikuji pro XML parametr - yes"
				XML="yes"
				local VSTUP="${TEMP}"
				local POS=0
				local COUNT=${#VSTUP}
			esac
		;;
		*.[dD][jJ][vV][uU]|*.[gG][iI][fF]|*.[jJ][pP][gG]|*.[mM][nN][gG]|*.[pP][dD][fF]|*.[pP][nN][gG]|*.[pP][nN][mM]|*.[tT][iI][fF][fF]|*.[xX][cC][fF]) 
# tady vzniká problém, pokud akce nemá žádné další parametry...
			local FILE="${VSTUP:0:$POS}"
			local TEMP=${VSTUP#${FILE}}
#			echo "Délka řetězce ${#TEMP} -${TEMP}-" >> /dev/stderr
			local OREZ=${TEMP##+([[:blank:]])}
#			echo "Délka řetězce ${#OREZ} -${OREZ}-" >> /dev/stderr
			local CHARSTRING="${OREZ#* }"
#			echo "CHARSTRING Délka řetězce ${#CHARSTRING} -${CHARSTRING}-" >> /dev/stderr
			if [ "${#CHARSTRING}" -eq "${#OREZ}" ] ; then
				local KEY="${CHARSTRING}"
				local CHARSTRING=""
			else
				local TEMP="${OREZ%${CHARSTRING}}"
				local KEY="${TEMP%%+([[:blank:]])}"
			fi
#			log 1 "KEY -${KEY}-"
#			log 1 "FILE -${FILE}-"
#			log 1 "CHARSTRING -${CHARSTRING}-"
		break
		;;
	esac
done

	case "${CHARSTRING}" in
		*-h|*--help|-h*|--help*) if [ -z "${KEY}" ] ; then
				help
			else
				help "keywords-${KEY}"
			fi
			exit 0
		;;
	esac

	if [ -f "${FILE}" ] ; then
#		log 1 "main: Soubor -${FILE}- existuje.."
#		FILE=${FILE//\ /\\ }
		case $(testfile "${FILE}") in
			djvu)
				#echo "AKCE ${KEY}" >> /dev/stderr
				#echo "Parametry #${CHARSTRING}#" >> /dev/stderr
				case "${KEY}" in
					delete) deletepage "${FILE}" "${CHARSTRING}"
						case "$?" in
							2) printf "Page for remove from bundle must by identificated by num order, or name page in bundle. Range can not be use.\n" >> /dev/stderr
							;;
						esac
						exit 0
					;;
					insert) # ToDo - zpracovat ${CHARSTRING}
						exit 1
						if [ -f "${3}" ] ; then
							if [ $(testfile ${3}) == "djvu" ] ; then
								log 1 "main - insert: Soubor je typu djvu"
								local INSERTFILE=${3}
							else
								[ "${#ALG[@]}" == "1" ] || exit 32
								local INSERTFILE="$TEMPDIR/${3%.*}.djvu"
								todjvu ${3} ${INSERTFILE}
								if [ $? -gt "0" ] ; then
									echo "main - insert: Soubor ${3} se nepodařilo zkonvertovat do souboru ${INSERTFILE}" >> /dev/stderr
									exit 1
								fi
							fi
							# Určit pozici...
							local P=$(identifypage ${1} ${4})
							log 1 "main - insert: Cílová pozice je $P"
							if [ -z "${P}" ] ; then
								if [ -z "${4}" ] ; then
									echo "Připojení souboru ${INSERTFILE} na konec souboru ${1}" >> /dev/stderr
									insertpage ${1} ${INSERTFILE}
								else
									echo "Identifikátor ${4} je pro soubor ${1} neplatný" >> /dev/stderr
									exit 1
								fi
							else
								log 1 "main - insert: Vkládám ${INSERTFILE} na pozici $P"
								insertpage ${1} ${INSERTFILE} ${P}
							fi
						else
							echo "Akci insert lze použít pouze ke vložení souboru" >> /dev/stderr
							exit 1
						fi
						exit 0
					;;
					print) # Nahrazeno akcí export
						printmeta ${FILE} "${CHARSTRING}"
						exit 0
					;;
					fore) MOVE="fore"
						djvumove "${FILE}" "${CHARSTRING}"
						exit 0
					;;
					back) MOVE="back"
						djvumove "${FILE}" "${CHARSTRING}"
						exit 0
					;;
					rotate) djvurotate "${FILE}" "${CHARSTRING}"
						exit 0
					;;
					edit) case "${CHARSTRING}" in
							outline) local TARGET="${TEMPDIR}/${FILE##*/}"
								local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .outline)
								printf '# Pravidla pro obsah souboru .outline :\n' >> "${TEMPFILE}"
								printf '#  * Text záložky i její cíl musí být v uvozovkách\n' >> "${TEMPFILE}"
								printf '#  * Cíl může být identifikován buď pořadovým číslem stránky, nebo jejím jménem\n' >> "${TEMPFILE}"
								printf '#  * Identifikátor vždy začíná znakem #\n' >> "${TEMPFILE}"
								printf '#  * Úroveň zanoření záložky je daná odsazením pomocí tabelátoru\n' >> "${TEMPFILE}"
								printf '#  * Veškerý text na řádcích začínajícím znakem # je považován za komentář\n' >> "${TEMPFILE}"
								printf '#  * Při importu souboru bude zakomentovaný obsah odfiltrován\n' >> "${TEMPFILE}"
								printf '#  * Soubor nesmí končit prázným řádkem!\n' >> "${TEMPFILE}"
								printf '#  * Pokud se do soubory změny neuloží, tak se vloží zpět původní obsah.\n' >> "${TEMPFILE}"
								printf '#\n' >> "${TEMPFILE}"
								printf '#"Link první úrovně" "#1"\n' >> "${TEMPFILE}"
								printf '#      "Link druhé úrovně" "#strana-001.djvu"\n' >> "${TEMPFILE}"
								dsedtooutline "${FILE}" >> "${TEMPFILE}"
								editor "${TEMPFILE}"
								outlinetodsed "${TEMPFILE}" | encode > "${TARGET/.djvu/.outline}"
								${DJVUSED}  "${FILE}" -e "set-outline ${TARGET/.djvu/.outline}; save"
							;;
							meta) local TEMPFILE=$(tempfile -d ${TEMPDIR} -s .meta)
								printmeta "${FILE}" all > "${TEMPFILE}"
								# Doplnit vzor meta stránky pro případ, že zatím žádný obsah neexistuje
								editor "${TEMPFILE}"
								djvuimport "${FILE}" "${TEMPFILE}"
							;;
							*) echo "meta stránky.. ${CHARSTRING}"
								local NAMEPAGE=$(identifyname "${FILE}" "${CHARSTRING#* }")
								if [ ! -z "${NAMEPAGE}" ] ; then
									local TARGET="${TEMPDIR}/${FILE##*/}"
									local IDPAGE=$(identifypage "${FILE}" "${PAGENAME}") 
									printmeta "${FILE}" "${NAMEPAGE}" >  "${TARGET/.djvu/.meta}"
									if [ ! -z "$(head -c 1 ${TEMPFILE})" ] ; then
										editor "${TARGET/.djvu/.meta}"
									else
										echo "#${IDPAGE} '${NAMEPAGE}'" > "${TARGET/.djvu/.meta}"
										echo -e "\n\n." >> "${TARGET/.djvu/.meta}"
										editor "${TARGET/.djvu/.meta}"
									fi
									djvuimport "${FILE}" "${TARGET/.djvu/.meta}"
								else
									printf "You must add valid parameter. Use -h for more info.\n" >> /dev/stderr
									exit 1
								fi
							;;
						esac
						exit 33
					;;
					export) djvuexport "${FILE}" "${CHARSTRING}"
						case "$?" in
							2) printf "What have been exported?\n" >> /dev/stderr
							;;
						esac
						exit 0
					;;
					import) djvuimport "${FILE}" "${CHARSTRING}"
						exit 0
					;;
					info) djvuinfo "${FILE}" "${CHARSTRING}"
						exit 0
					;;
					rename)   # ToDo - zpracovat ${CHARSTRING}
						exit 1
					;;
					set) case "${CHARSTRING%% *}" in
							meta) setmeta "${FILE}" "${CHARSTRING#* }"
							;;
							*) help keyword-meta
							;;
						esac
						exit 0
					;;
					unset) case "${CHARSTRING%% *}" in
							meta) unsetmeta "${FILE}" "${CHARSTRING#* }"
							;;
							*) help keyword-meta
							;;
						esac
						exit 0
					;;
					view) djview "${FILE}" &
						exit 1
					;;
					*) help keywords && exit 0
					;;
				esac
			;;
			jpeg|png) echo "Bude se zpracovávat soubor v bitmapovém formátu"
				echo "ToDo"
				exit 1
			;;
			gimp|xcf|tiff|mng)
			if [ "${2}" == "-h" ] || [ "${2}" == "--help" ] ; then
					echo "Nápověda?"
#					exit 0
				else
					echo "Jako druhý parametr je soubor ve vícevrstvém bitmapovém formátu. Zpracování těchto souborů není zatím implementováno" >> /dev/stderr
#					exit 0
					convertimg ${FILE} ${2}
					exit 0
				fi
			;;
			xml|XML) echo "má-li první soubor příponu xml"
				echo "ToDo"
				exit 1
			;;
			unknown) echo "Pokud je soubor ${1} typu DjVU, může jít o tzv. SecureDjVu formát, který má kryptované vrstvy. S takovým souborem nelze s opensource nástroji pracovat." >> /dev/stderr
				exit 1
			;;
			*) if [ ! "${2}" ] ; then
					echo '''Není předaný jiný parametr, bude se zpracovávat soubor podle typu ''' >> /dev/stderr
					echo "${FILE} : $(testfile ${FILE})" >> /dev/stderr
				else
					echo "Zpracování souborů jako je $2 zatím není implementováno" >> /dev/stderr
				fi
				echo '''Pokud následuje djvu soubor'''
				echo '''Pokud následuje adresář'''
				echo '''to je existující soubor typu bundle a:
				- nenásleduje žádný další existující soubor typu djvu, nebo adresář
				a zároveň existuje $DIRECTORY, pak to znamená že se má rozbalit
				- pokud následuje další soubor, pak to znamená že se má nějakým způsobem s tímto dalším souborem naložit. Je-li to:
				- djvu soubor, má se připojit
				- xml soubor, má se vložit
				- soubor typu dsed má se zpracovat
				- jiný soubor - obrázek, který se má převést a vložit
				'''
				exit 1
			;;
		esac
	else
		#echo "Tady se dostane pokud ${FILE} neexistuje" >> /dev/stderr
		help
		exit 0
	fi
}

main "$*"

exit 0
